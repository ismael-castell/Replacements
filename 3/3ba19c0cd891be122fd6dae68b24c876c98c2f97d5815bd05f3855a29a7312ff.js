/*!
 * Bootstrap v3.3.7 (http://getbootstrap.com)
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under the MIT license
 */

if (typeof jQuery === "undefined") {
  throw new Error("Bootstrap's JavaScript requires jQuery");
}

+(function ($) {
  "use strict";
  var version = $.fn.jquery.split(" ")[0].split(".");
  if (
    (version[0] < 2 && version[1] < 9) ||
    (version[0] == 1 && version[1] == 9 && version[2] < 1) ||
    version[0] > 3
  ) {
    throw new Error(
      "Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4"
    );
  }
})(jQuery);

/* ========================================================================
 * Bootstrap: transition.js v3.3.7
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+(function ($) {
  "use strict";

  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================

  function transitionEnd() {
    var el = document.createElement("bootstrap");

    var transEndEventNames = {
      WebkitTransition: "webkitTransitionEnd",
      MozTransition: "transitionend",
      OTransition: "oTransitionEnd otransitionend",
      transition: "transitionend",
    };

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] };
      }
    }

    return false; // explicit for ie8 (  ._.)
  }

  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false;
    var $el = this;
    $(this).one("bsTransitionEnd", function () {
      called = true;
    });
    var callback = function () {
      if (!called) $($el).trigger($.support.transition.end);
    };
    setTimeout(callback, duration);
    return this;
  };

  $(function () {
    $.support.transition = transitionEnd();

    if (!$.support.transition) return;

    $.event.special.bsTransitionEnd = {
      bindType: $.support.transition.end,
      delegateType: $.support.transition.end,
      handle: function (e) {
        if ($(e.target).is(this))
          return e.handleObj.handler.apply(this, arguments);
      },
    };
  });
})(jQuery);

/* ========================================================================
 * Bootstrap: alert.js v3.3.7
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+(function ($) {
  "use strict";

  // ALERT CLASS DEFINITION
  // ======================

  var dismiss = '[data-dismiss="alert"]';
  var Alert = function (el) {
    $(el).on("click", dismiss, this.close);
  };

  Alert.VERSION = "3.3.7";

  Alert.TRANSITION_DURATION = 150;

  Alert.prototype.close = function (e) {
    var $this = $(this);
    var selector = $this.attr("data-target");

    if (!selector) {
      selector = $this.attr("href");
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, ""); // strip for ie7
    }

    var $parent = $(selector === "#" ? [] : selector);

    if (e) e.preventDefault();

    if (!$parent.length) {
      $parent = $this.closest(".alert");
    }

    $parent.trigger((e = $.Event("close.bs.alert")));

    if (e.isDefaultPrevented()) return;

    $parent.removeClass("in");

    function removeElement() {
      // detach from parent, fire event then clean up data
      $parent.detach().trigger("closed.bs.alert").remove();
    }

    $.support.transition && $parent.hasClass("fade")
      ? $parent
          .one("bsTransitionEnd", removeElement)
          .emulateTransitionEnd(Alert.TRANSITION_DURATION)
      : removeElement();
  };

  // ALERT PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data("bs.alert");

      if (!data) $this.data("bs.alert", (data = new Alert(this)));
      if (typeof option == "string") data[option].call($this);
    });
  }

  var old = $.fn.alert;

  $.fn.alert = Plugin;
  $.fn.alert.Constructor = Alert;

  // ALERT NO CONFLICT
  // =================

  $.fn.alert.noConflict = function () {
    $.fn.alert = old;
    return this;
  };

  // ALERT DATA-API
  // ==============

  $(document).on("click.bs.alert.data-api", dismiss, Alert.prototype.close);
})(jQuery);

/* ========================================================================
 * Bootstrap: button.js v3.3.7
 * http://getbootstrap.com/javascript/#buttons
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+(function ($) {
  "use strict";

  // BUTTON PUBLIC CLASS DEFINITION
  // ==============================

  var Button = function (element, options) {
    this.$element = $(element);
    this.options = $.extend({}, Button.DEFAULTS, options);
    this.isLoading = false;
  };

  Button.VERSION = "3.3.7";

  Button.DEFAULTS = {
    loadingText: "loading...",
  };

  Button.prototype.setState = function (state) {
    var d = "disabled";
    var $el = this.$element;
    var val = $el.is("input") ? "val" : "html";
    var data = $el.data();

    state += "Text";

    if (data.resetText == null) $el.data("resetText", $el[val]());

    // push to event loop to allow forms to submit
    setTimeout(
      $.proxy(function () {
        $el[val](data[state] == null ? this.options[state] : data[state]);

        if (state == "loadingText") {
          this.isLoading = true;
          $el.addClass(d).attr(d, d).prop(d, true);
        } else if (this.isLoading) {
          this.isLoading = false;
          $el.removeClass(d).removeAttr(d).prop(d, false);
        }
      }, this),
      0
    );
  };

  Button.prototype.toggle = function () {
    var changed = true;
    var $parent = this.$element.closest('[data-toggle="buttons"]');

    if ($parent.length) {
      var $input = this.$element.find("input");
      if ($input.prop("type") == "radio") {
        if ($input.prop("checked")) changed = false;
        $parent.find(".active").removeClass("active");
        this.$element.addClass("active");
      } else if ($input.prop("type") == "checkbox") {
        if ($input.prop("checked") !== this.$element.hasClass("active"))
          changed = false;
        this.$element.toggleClass("active");
      }
      $input.prop("checked", this.$element.hasClass("active"));
      if (changed) $input.trigger("change");
    } else {
      this.$element.attr("aria-pressed", !this.$element.hasClass("active"));
      this.$element.toggleClass("active");
    }
  };

  // BUTTON PLUGIN DEFINITION
  // ========================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data("bs.button");
      var options = typeof option == "object" && option;

      if (!data) $this.data("bs.button", (data = new Button(this, options)));

      if (option == "toggle") data.toggle();
      else if (option) data.setState(option);
    });
  }

  var old = $.fn.button;

  $.fn.button = Plugin;
  $.fn.button.Constructor = Button;

  // BUTTON NO CONFLICT
  // ==================

  $.fn.button.noConflict = function () {
    $.fn.button = old;
    return this;
  };

  // BUTTON DATA-API
  // ===============

  $(document)
    .on("click.bs.button.data-api", '[data-toggle^="button"]', function (e) {
      var $btn = $(e.target).closest(".btn");
      Plugin.call($btn, "toggle");
      if (!$(e.target).is('input[type="radio"], input[type="checkbox"]')) {
        // Prevent double click on radios, and the double selections (so cancellation) on checkboxes
        e.preventDefault();
        // The target component still receive the focus
        if ($btn.is("input,button")) $btn.trigger("focus");
        else $btn.find("input:visible,button:visible").first().trigger("focus");
      }
    })
    .on(
      "focus.bs.button.data-api blur.bs.button.data-api",
      '[data-toggle^="button"]',
      function (e) {
        $(e.target)
          .closest(".btn")
          .toggleClass("focus", /^focus(in)?$/.test(e.type));
      }
    );
})(jQuery);

/* ========================================================================
 * Bootstrap: carousel.js v3.3.7
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+(function ($) {
  "use strict";

  // CAROUSEL CLASS DEFINITION
  // =========================

  var Carousel = function (element, options) {
    this.$element = $(element);
    this.$indicators = this.$element.find(".carousel-indicators");
    this.options = options;
    this.paused = null;
    this.sliding = null;
    this.interval = null;
    this.$active = null;
    this.$items = null;

    this.options.keyboard &&
      this.$element.on("keydown.bs.carousel", $.proxy(this.keydown, this));

    this.options.pause == "hover" &&
      !("ontouchstart" in document.documentElement) &&
      this.$element
        .on("mouseenter.bs.carousel", $.proxy(this.pause, this))
        .on("mouseleave.bs.carousel", $.proxy(this.cycle, this));
  };

  Carousel.VERSION = "3.3.7";

  Carousel.TRANSITION_DURATION = 600;

  Carousel.DEFAULTS = {
    interval: 5000,
    pause: "hover",
    wrap: true,
    keyboard: true,
  };

  Carousel.prototype.keydown = function (e) {
    if (/input|textarea/i.test(e.target.tagName)) return;
    switch (e.which) {
      case 37:
        this.prev();
        break;
      case 39:
        this.next();
        break;
      default:
        return;
    }

    e.preventDefault();
  };

  Carousel.prototype.cycle = function (e) {
    e || (this.paused = false);

    this.interval && clearInterval(this.interval);

    this.options.interval &&
      !this.paused &&
      (this.interval = setInterval(
        $.proxy(this.next, this),
        this.options.interval
      ));

    return this;
  };

  Carousel.prototype.getItemIndex = function (item) {
    this.$items = item.parent().children(".item");
    return this.$items.index(item || this.$active);
  };

  Carousel.prototype.getItemForDirection = function (direction, active) {
    var activeIndex = this.getItemIndex(active);
    var willWrap =
      (direction == "prev" && activeIndex === 0) ||
      (direction == "next" && activeIndex == this.$items.length - 1);
    if (willWrap && !this.options.wrap) return active;
    var delta = direction == "prev" ? -1 : 1;
    var itemIndex = (activeIndex + delta) % this.$items.length;
    return this.$items.eq(itemIndex);
  };

  Carousel.prototype.to = function (pos) {
    var that = this;
    var activeIndex = this.getItemIndex(
      (this.$active = this.$element.find(".item.active"))
    );

    if (pos > this.$items.length - 1 || pos < 0) return;

    if (this.sliding)
      return this.$element.one("slid.bs.carousel", function () {
        that.to(pos);
      }); // yes, "slid"
    if (activeIndex == pos) return this.pause().cycle();

    return this.slide(pos > activeIndex ? "next" : "prev", this.$items.eq(pos));
  };

  Carousel.prototype.pause = function (e) {
    e || (this.paused = true);

    if (this.$element.find(".next, .prev").length && $.support.transition) {
      this.$element.trigger($.support.transition.end);
      this.cycle(true);
    }

    this.interval = clearInterval(this.interval);

    return this;
  };

  Carousel.prototype.next = function () {
    if (this.sliding) return;
    return this.slide("next");
  };

  Carousel.prototype.prev = function () {
    if (this.sliding) return;
    return this.slide("prev");
  };

  Carousel.prototype.slide = function (type, next) {
    var $active = this.$element.find(".item.active");
    var $next = next || this.getItemForDirection(type, $active);
    var isCycling = this.interval;
    var direction = type == "next" ? "left" : "right";
    var that = this;

    if ($next.hasClass("active")) return (this.sliding = false);

    var relatedTarget = $next[0];
    var slideEvent = $.Event("slide.bs.carousel", {
      relatedTarget: relatedTarget,
      direction: direction,
    });
    this.$element.trigger(slideEvent);
    if (slideEvent.isDefaultPrevented()) return;

    this.sliding = true;

    isCycling && this.pause();

    if (this.$indicators.length) {
      this.$indicators.find(".active").removeClass("active");
      var $nextIndicator = $(
        this.$indicators.children()[this.getItemIndex($next)]
      );
      $nextIndicator && $nextIndicator.addClass("active");
    }

    var slidEvent = $.Event("slid.bs.carousel", {
      relatedTarget: relatedTarget,
      direction: direction,
    }); // yes, "slid"
    if ($.support.transition && this.$element.hasClass("slide")) {
      $next.addClass(type);
      $next[0].offsetWidth; // force reflow
      $active.addClass(direction);
      $next.addClass(direction);
      $active
        .one("bsTransitionEnd", function () {
          $next.removeClass([type, direction].join(" ")).addClass("active");
          $active.removeClass(["active", direction].join(" "));
          that.sliding = false;
          setTimeout(function () {
            that.$element.trigger(slidEvent);
          }, 0);
        })
        .emulateTransitionEnd(Carousel.TRANSITION_DURATION);
    } else {
      $active.removeClass("active");
      $next.addClass("active");
      this.sliding = false;
      this.$element.trigger(slidEvent);
    }

    isCycling && this.cycle();

    return this;
  };

  // CAROUSEL PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data("bs.carousel");
      var options = $.extend(
        {},
        Carousel.DEFAULTS,
        $this.data(),
        typeof option == "object" && option
      );
      var action = typeof option == "string" ? option : options.slide;

      if (!data)
        $this.data("bs.carousel", (data = new Carousel(this, options)));
      if (typeof option == "number") data.to(option);
      else if (action) data[action]();
      else if (options.interval) data.pause().cycle();
    });
  }

  var old = $.fn.carousel;

  $.fn.carousel = Plugin;
  $.fn.carousel.Constructor = Carousel;

  // CAROUSEL NO CONFLICT
  // ====================

  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old;
    return this;
  };

  // CAROUSEL DATA-API
  // =================

  var clickHandler = function (e) {
    var href;
    var $this = $(this);
    var $target = $(
      $this.attr("data-target") ||
        ((href = $this.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, ""))
    ); // strip for ie7
    if (!$target.hasClass("carousel")) return;
    var options = $.extend({}, $target.data(), $this.data());
    var slideIndex = $this.attr("data-slide-to");
    if (slideIndex) options.interval = false;

    Plugin.call($target, options);

    if (slideIndex) {
      $target.data("bs.carousel").to(slideIndex);
    }

    e.preventDefault();
  };

  $(document)
    .on("click.bs.carousel.data-api", "[data-slide]", clickHandler)
    .on("click.bs.carousel.data-api", "[data-slide-to]", clickHandler);

  $(window).on("load", function () {
    $('[data-ride="carousel"]').each(function () {
      var $carousel = $(this);
      Plugin.call($carousel, $carousel.data());
    });
  });
})(jQuery);

/* ========================================================================
 * Bootstrap: collapse.js v3.3.7
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

/* jshint latedef: false */

+(function ($) {
  "use strict";

  // COLLAPSE PUBLIC CLASS DEFINITION
  // ================================

  var Collapse = function (element, options) {
    this.$element = $(element);
    this.options = $.extend({}, Collapse.DEFAULTS, options);
    this.$trigger = $(
      '[data-toggle="collapse"][href="#' +
        element.id +
        '"],' +
        '[data-toggle="collapse"][data-target="#' +
        element.id +
        '"]'
    );
    this.transitioning = null;

    if (this.options.parent) {
      this.$parent = this.getParent();
    } else {
      this.addAriaAndCollapsedClass(this.$element, this.$trigger);
    }

    if (this.options.toggle) this.toggle();
  };

  Collapse.VERSION = "3.3.7";

  Collapse.TRANSITION_DURATION = 350;

  Collapse.DEFAULTS = {
    toggle: true,
  };

  Collapse.prototype.dimension = function () {
    var hasWidth = this.$element.hasClass("width");
    return hasWidth ? "width" : "height";
  };

  Collapse.prototype.show = function () {
    if (this.transitioning || this.$element.hasClass("in")) return;

    var activesData;
    var actives =
      this.$parent &&
      this.$parent.children(".panel").children(".in, .collapsing");

    if (actives && actives.length) {
      activesData = actives.data("bs.collapse");
      if (activesData && activesData.transitioning) return;
    }

    var startEvent = $.Event("show.bs.collapse");
    this.$element.trigger(startEvent);
    if (startEvent.isDefaultPrevented()) return;

    if (actives && actives.length) {
      Plugin.call(actives, "hide");
      activesData || actives.data("bs.collapse", null);
    }

    var dimension = this.dimension();

    this.$element
      .removeClass("collapse")
      .addClass("collapsing")
      [dimension](0)
      .attr("aria-expanded", true);

    this.$trigger.removeClass("collapsed").attr("aria-expanded", true);

    this.transitioning = 1;

    var complete = function () {
      this.$element
        .removeClass("collapsing")
        .addClass("collapse in")
        [dimension]("");
      this.transitioning = 0;
      this.$element.trigger("shown.bs.collapse");
    };

    if (!$.support.transition) return complete.call(this);

    var scrollSize = $.camelCase(["scroll", dimension].join("-"));

    this.$element
      .one("bsTransitionEnd", $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
      [dimension](this.$element[0][scrollSize]);
  };

  Collapse.prototype.hide = function () {
    if (this.transitioning || !this.$element.hasClass("in")) return;

    var startEvent = $.Event("hide.bs.collapse");
    this.$element.trigger(startEvent);
    if (startEvent.isDefaultPrevented()) return;

    var dimension = this.dimension();

    this.$element[dimension](this.$element[dimension]())[0].offsetHeight;

    this.$element
      .addClass("collapsing")
      .removeClass("collapse in")
      .attr("aria-expanded", false);

    this.$trigger.addClass("collapsed").attr("aria-expanded", false);

    this.transitioning = 1;

    var complete = function () {
      this.transitioning = 0;
      this.$element
        .removeClass("collapsing")
        .addClass("collapse")
        .trigger("hidden.bs.collapse");
    };

    if (!$.support.transition) return complete.call(this);

    this.$element[dimension](0)
      .one("bsTransitionEnd", $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION);
  };

  Collapse.prototype.toggle = function () {
    this[this.$element.hasClass("in") ? "hide" : "show"]();
  };

  Collapse.prototype.getParent = function () {
    return $(this.options.parent)
      .find(
        '[data-toggle="collapse"][data-parent="' + this.options.parent + '"]'
      )
      .each(
        $.proxy(function (i, element) {
          var $element = $(element);
          this.addAriaAndCollapsedClass(
            getTargetFromTrigger($element),
            $element
          );
        }, this)
      )
      .end();
  };

  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
    var isOpen = $element.hasClass("in");

    $element.attr("aria-expanded", isOpen);
    $trigger.toggleClass("collapsed", !isOpen).attr("aria-expanded", isOpen);
  };

  function getTargetFromTrigger($trigger) {
    var href;
    var target =
      $trigger.attr("data-target") ||
      ((href = $trigger.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, "")); // strip for ie7

    return $(target);
  }

  // COLLAPSE PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data("bs.collapse");
      var options = $.extend(
        {},
        Collapse.DEFAULTS,
        $this.data(),
        typeof option == "object" && option
      );

      if (!data && options.toggle && /show|hide/.test(option))
        options.toggle = false;
      if (!data)
        $this.data("bs.collapse", (data = new Collapse(this, options)));
      if (typeof option == "string") data[option]();
    });
  }

  var old = $.fn.collapse;

  $.fn.collapse = Plugin;
  $.fn.collapse.Constructor = Collapse;

  // COLLAPSE NO CONFLICT
  // ====================

  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old;
    return this;
  };

  // COLLAPSE DATA-API
  // =================

  $(document).on(
    "click.bs.collapse.data-api",
    '[data-toggle="collapse"]',
    function (e) {
      var $this = $(this);

      if (!$this.attr("data-target")) e.preventDefault();

      var $target = getTargetFromTrigger($this);
      var data = $target.data("bs.collapse");
      var option = data ? "toggle" : $this.data();

      Plugin.call($target, option);
    }
  );
})(jQuery);

/* ========================================================================
 * Bootstrap: dropdown.js v3.3.7
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+(function ($) {
  "use strict";

  // DROPDOWN CLASS DEFINITION
  // =========================

  var backdrop = ".dropdown-backdrop";
  var toggle = '[data-toggle="dropdown"]';
  var Dropdown = function (element) {
    $(element).on("click.bs.dropdown", this.toggle);
  };

  Dropdown.VERSION = "3.3.7";

  function getParent($this) {
    var selector = $this.attr("data-target");

    if (!selector) {
      selector = $this.attr("href");
      selector =
        selector &&
        /#[A-Za-z]/.test(selector) &&
        selector.replace(/.*(?=#[^\s]*$)/, ""); // strip for ie7
    }

    var $parent = selector && $(selector);

    return $parent && $parent.length ? $parent : $this.parent();
  }

  function clearMenus(e) {
    if (e && e.which === 3) return;
    $(backdrop).remove();
    $(toggle).each(function () {
      var $this = $(this);
      var $parent = getParent($this);
      var relatedTarget = { relatedTarget: this };

      if (!$parent.hasClass("open")) return;

      if (
        e &&
        e.type == "click" &&
        /input|textarea/i.test(e.target.tagName) &&
        $.contains($parent[0], e.target)
      )
        return;

      $parent.trigger((e = $.Event("hide.bs.dropdown", relatedTarget)));

      if (e.isDefaultPrevented()) return;

      $this.attr("aria-expanded", "false");
      $parent
        .removeClass("open")
        .trigger($.Event("hidden.bs.dropdown", relatedTarget));
    });
  }

  Dropdown.prototype.toggle = function (e) {
    var $this = $(this);

    if ($this.is(".disabled, :disabled")) return;

    var $parent = getParent($this);
    var isActive = $parent.hasClass("open");

    clearMenus();

    if (!isActive) {
      if (
        "ontouchstart" in document.documentElement &&
        !$parent.closest(".navbar-nav").length
      ) {
        // if mobile we use a backdrop because click events don't delegate
        $(document.createElement("div"))
          .addClass("dropdown-backdrop")
          .insertAfter($(this))
          .on("click", clearMenus);
      }

      var relatedTarget = { relatedTarget: this };
      $parent.trigger((e = $.Event("show.bs.dropdown", relatedTarget)));

      if (e.isDefaultPrevented()) return;

      $this.trigger("focus").attr("aria-expanded", "true");

      $parent
        .toggleClass("open")
        .trigger($.Event("shown.bs.dropdown", relatedTarget));
    }

    return false;
  };

  Dropdown.prototype.keydown = function (e) {
    if (
      !/(38|40|27|32)/.test(e.which) ||
      /input|textarea/i.test(e.target.tagName)
    )
      return;

    var $this = $(this);

    e.preventDefault();
    e.stopPropagation();

    if ($this.is(".disabled, :disabled")) return;

    var $parent = getParent($this);
    var isActive = $parent.hasClass("open");

    if ((!isActive && e.which != 27) || (isActive && e.which == 27)) {
      if (e.which == 27) $parent.find(toggle).trigger("focus");
      return $this.trigger("click");
    }

    var desc = " li:not(.disabled):visible a";
    var $items = $parent.find(".dropdown-menu" + desc);

    if (!$items.length) return;

    var index = $items.index(e.target);

    if (e.which == 38 && index > 0) index--; // up
    if (e.which == 40 && index < $items.length - 1) index++; // down
    if (!~index) index = 0;

    $items.eq(index).trigger("focus");
  };

  // DROPDOWN PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data("bs.dropdown");

      if (!data) $this.data("bs.dropdown", (data = new Dropdown(this)));
      if (typeof option == "string") data[option].call($this);
    });
  }

  var old = $.fn.dropdown;

  $.fn.dropdown = Plugin;
  $.fn.dropdown.Constructor = Dropdown;

  // DROPDOWN NO CONFLICT
  // ====================

  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old;
    return this;
  };

  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================

  $(document)
    .on("click.bs.dropdown.data-api", clearMenus)
    .on("click.bs.dropdown.data-api", ".dropdown form", function (e) {
      e.stopPropagation();
    })
    .on("click.bs.dropdown.data-api", toggle, Dropdown.prototype.toggle)
    .on("keydown.bs.dropdown.data-api", toggle, Dropdown.prototype.keydown)
    .on(
      "keydown.bs.dropdown.data-api",
      ".dropdown-menu",
      Dropdown.prototype.keydown
    );
})(jQuery);

/* ========================================================================
 * Bootstrap: modal.js v3.3.7
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+(function ($) {
  "use strict";

  // MODAL CLASS DEFINITION
  // ======================

  var Modal = function (element, options) {
    this.options = options;
    this.$body = $(document.body);
    this.$element = $(element);
    this.$dialog = this.$element.find(".modal-dialog");
    this.$backdrop = null;
    this.isShown = null;
    this.originalBodyPad = null;
    this.scrollbarWidth = 0;
    this.ignoreBackdropClick = false;

    if (this.options.remote) {
      this.$element.find(".modal-content").load(
        this.options.remote,
        $.proxy(function () {
          this.$element.trigger("loaded.bs.modal");
        }, this)
      );
    }
  };

  Modal.VERSION = "3.3.7";

  Modal.TRANSITION_DURATION = 300;
  Modal.BACKDROP_TRANSITION_DURATION = 150;

  Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true,
  };

  Modal.prototype.toggle = function (_relatedTarget) {
    return this.isShown ? this.hide() : this.show(_relatedTarget);
  };

  Modal.prototype.show = function (_relatedTarget) {
    var that = this;
    var e = $.Event("show.bs.modal", { relatedTarget: _relatedTarget });

    this.$element.trigger(e);

    if (this.isShown || e.isDefaultPrevented()) return;

    this.isShown = true;

    this.checkScrollbar();
    this.setScrollbar();
    this.$body.addClass("modal-open");

    this.escape();
    this.resize();

    this.$element.on(
      "click.dismiss.bs.modal",
      '[data-dismiss="modal"]',
      $.proxy(this.hide, this)
    );

    this.$dialog.on("mousedown.dismiss.bs.modal", function () {
      that.$element.one("mouseup.dismiss.bs.modal", function (e) {
        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true;
      });
    });

    this.backdrop(function () {
      var transition = $.support.transition && that.$element.hasClass("fade");

      if (!that.$element.parent().length) {
        that.$element.appendTo(that.$body); // don't move modals dom position
      }

      that.$element.show().scrollTop(0);

      that.adjustDialog();

      if (transition) {
        that.$element[0].offsetWidth; // force reflow
      }

      that.$element.addClass("in");

      that.enforceFocus();

      var e = $.Event("shown.bs.modal", { relatedTarget: _relatedTarget });

      transition
        ? that.$dialog // wait for modal to slide in
            .one("bsTransitionEnd", function () {
              that.$element.trigger("focus").trigger(e);
            })
            .emulateTransitionEnd(Modal.TRANSITION_DURATION)
        : that.$element.trigger("focus").trigger(e);
    });
  };

  Modal.prototype.hide = function (e) {
    if (e) e.preventDefault();

    e = $.Event("hide.bs.modal");

    this.$element.trigger(e);

    if (!this.isShown || e.isDefaultPrevented()) return;

    this.isShown = false;

    this.escape();
    this.resize();

    $(document).off("focusin.bs.modal");

    this.$element
      .removeClass("in")
      .off("click.dismiss.bs.modal")
      .off("mouseup.dismiss.bs.modal");

    this.$dialog.off("mousedown.dismiss.bs.modal");

    $.support.transition && this.$element.hasClass("fade")
      ? this.$element
          .one("bsTransitionEnd", $.proxy(this.hideModal, this))
          .emulateTransitionEnd(Modal.TRANSITION_DURATION)
      : this.hideModal();
  };

  Modal.prototype.enforceFocus = function () {
    $(document)
      .off("focusin.bs.modal") // guard against infinite focus loop
      .on(
        "focusin.bs.modal",
        $.proxy(function (e) {
          if (
            document !== e.target &&
            this.$element[0] !== e.target &&
            !this.$element.has(e.target).length
          ) {
            this.$element.trigger("focus");
          }
        }, this)
      );
  };

  Modal.prototype.escape = function () {
    if (this.isShown && this.options.keyboard) {
      this.$element.on(
        "keydown.dismiss.bs.modal",
        $.proxy(function (e) {
          e.which == 27 && this.hide();
        }, this)
      );
    } else if (!this.isShown) {
      this.$element.off("keydown.dismiss.bs.modal");
    }
  };

  Modal.prototype.resize = function () {
    if (this.isShown) {
      $(window).on("resize.bs.modal", $.proxy(this.handleUpdate, this));
    } else {
      $(window).off("resize.bs.modal");
    }
  };

  Modal.prototype.hideModal = function () {
    var that = this;
    this.$element.hide();
    this.backdrop(function () {
      that.$body.removeClass("modal-open");
      that.resetAdjustments();
      that.resetScrollbar();
      that.$element.trigger("hidden.bs.modal");
    });
  };

  Modal.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove();
    this.$backdrop = null;
  };

  Modal.prototype.backdrop = function (callback) {
    var that = this;
    var animate = this.$element.hasClass("fade") ? "fade" : "";

    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate;

      this.$backdrop = $(document.createElement("div"))
        .addClass("modal-backdrop " + animate)
        .appendTo(this.$body);

      this.$element.on(
        "click.dismiss.bs.modal",
        $.proxy(function (e) {
          if (this.ignoreBackdropClick) {
            this.ignoreBackdropClick = false;
            return;
          }
          if (e.target !== e.currentTarget) return;
          this.options.backdrop == "static"
            ? this.$element[0].focus()
            : this.hide();
        }, this)
      );

      if (doAnimate) this.$backdrop[0].offsetWidth; // force reflow

      this.$backdrop.addClass("in");

      if (!callback) return;

      doAnimate
        ? this.$backdrop
            .one("bsTransitionEnd", callback)
            .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION)
        : callback();
    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass("in");

      var callbackRemove = function () {
        that.removeBackdrop();
        callback && callback();
      };
      $.support.transition && this.$element.hasClass("fade")
        ? this.$backdrop
            .one("bsTransitionEnd", callbackRemove)
            .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION)
        : callbackRemove();
    } else if (callback) {
      callback();
    }
  };

  // these following methods are used to handle overflowing modals

  Modal.prototype.handleUpdate = function () {
    this.adjustDialog();
  };

  Modal.prototype.adjustDialog = function () {
    var modalIsOverflowing =
      this.$element[0].scrollHeight > document.documentElement.clientHeight;

    this.$element.css({
      paddingLeft:
        !this.bodyIsOverflowing && modalIsOverflowing
          ? this.scrollbarWidth
          : "",
      paddingRight:
        this.bodyIsOverflowing && !modalIsOverflowing
          ? this.scrollbarWidth
          : "",
    });
  };

  Modal.prototype.resetAdjustments = function () {
    this.$element.css({
      paddingLeft: "",
      paddingRight: "",
    });
  };

  Modal.prototype.checkScrollbar = function () {
    var fullWindowWidth = window.innerWidth;
    if (!fullWindowWidth) {
      // workaround for missing window.innerWidth in IE8
      var documentElementRect =
        document.documentElement.getBoundingClientRect();
      fullWindowWidth =
        documentElementRect.right - Math.abs(documentElementRect.left);
    }
    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth;
    this.scrollbarWidth = this.measureScrollbar();
  };

  Modal.prototype.setScrollbar = function () {
    var bodyPad = parseInt(this.$body.css("padding-right") || 0, 10);
    this.originalBodyPad = document.body.style.paddingRight || "";
    if (this.bodyIsOverflowing)
      this.$body.css("padding-right", bodyPad + this.scrollbarWidth);
  };

  Modal.prototype.resetScrollbar = function () {
    this.$body.css("padding-right", this.originalBodyPad);
  };

  Modal.prototype.measureScrollbar = function () {
    // thx walsh
    var scrollDiv = document.createElement("div");
    scrollDiv.className = "modal-scrollbar-measure";
    this.$body.append(scrollDiv);
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    this.$body[0].removeChild(scrollDiv);
    return scrollbarWidth;
  };

  // MODAL PLUGIN DEFINITION
  // =======================

  function Plugin(option, _relatedTarget) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data("bs.modal");
      var options = $.extend(
        {},
        Modal.DEFAULTS,
        $this.data(),
        typeof option == "object" && option
      );

      if (!data) $this.data("bs.modal", (data = new Modal(this, options)));
      if (typeof option == "string") data[option](_relatedTarget);
      else if (options.show) data.show(_relatedTarget);
    });
  }

  var old = $.fn.modal;

  $.fn.modal = Plugin;
  $.fn.modal.Constructor = Modal;

  // MODAL NO CONFLICT
  // =================

  $.fn.modal.noConflict = function () {
    $.fn.modal = old;
    return this;
  };

  // MODAL DATA-API
  // ==============

  $(document).on(
    "click.bs.modal.data-api",
    '[data-toggle="modal"]',
    function (e) {
      var $this = $(this);
      var href = $this.attr("href");
      var $target = $(
        $this.attr("data-target") ||
          (href && href.replace(/.*(?=#[^\s]+$)/, ""))
      ); // strip for ie7
      var option = $target.data("bs.modal")
        ? "toggle"
        : $.extend(
            { remote: !/#/.test(href) && href },
            $target.data(),
            $this.data()
          );

      if ($this.is("a")) e.preventDefault();

      $target.one("show.bs.modal", function (showEvent) {
        if (showEvent.isDefaultPrevented()) return; // only register focus restorer if modal will actually get shown
        $target.one("hidden.bs.modal", function () {
          $this.is(":visible") && $this.trigger("focus");
        });
      });
      Plugin.call($target, option, this);
    }
  );
})(jQuery);

/* ========================================================================
 * Bootstrap: tooltip.js v3.3.7
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+(function ($) {
  "use strict";

  // TOOLTIP PUBLIC CLASS DEFINITION
  // ===============================

  var Tooltip = function (element, options) {
    this.type = null;
    this.options = null;
    this.enabled = null;
    this.timeout = null;
    this.hoverState = null;
    this.$element = null;
    this.inState = null;

    this.init("tooltip", element, options);
  };

  Tooltip.VERSION = "3.3.7";

  Tooltip.TRANSITION_DURATION = 150;

  Tooltip.DEFAULTS = {
    animation: true,
    placement: "top",
    selector: false,
    template:
      '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: "hover focus",
    title: "",
    delay: 0,
    html: false,
    container: false,
    viewport: {
      selector: "body",
      padding: 0,
    },
  };

  Tooltip.prototype.init = function (type, element, options) {
    this.enabled = true;
    this.type = type;
    this.$element = $(element);
    this.options = this.getOptions(options);
    this.$viewport =
      this.options.viewport &&
      $(
        $.isFunction(this.options.viewport)
          ? this.options.viewport.call(this, this.$element)
          : this.options.viewport.selector || this.options.viewport
      );
    this.inState = { click: false, hover: false, focus: false };

    if (
      this.$element[0] instanceof document.constructor &&
      !this.options.selector
    ) {
      throw new Error(
        "`selector` option must be specified when initializing " +
          this.type +
          " on the window.document object!"
      );
    }

    var triggers = this.options.trigger.split(" ");

    for (var i = triggers.length; i--; ) {
      var trigger = triggers[i];

      if (trigger == "click") {
        this.$element.on(
          "click." + this.type,
          this.options.selector,
          $.proxy(this.toggle, this)
        );
      } else if (trigger != "manual") {
        var eventIn = trigger == "hover" ? "mouseenter" : "focusin";
        var eventOut = trigger == "hover" ? "mouseleave" : "focusout";

        this.$element.on(
          eventIn + "." + this.type,
          this.options.selector,
          $.proxy(this.enter, this)
        );
        this.$element.on(
          eventOut + "." + this.type,
          this.options.selector,
          $.proxy(this.leave, this)
        );
      }
    }

    this.options.selector
      ? (this._options = $.extend({}, this.options, {
          trigger: "manual",
          selector: "",
        }))
      : this.fixTitle();
  };

  Tooltip.prototype.getDefaults = function () {
    return Tooltip.DEFAULTS;
  };

  Tooltip.prototype.getOptions = function (options) {
    options = $.extend({}, this.getDefaults(), this.$element.data(), options);

    if (options.delay && typeof options.delay == "number") {
      options.delay = {
        show: options.delay,
        hide: options.delay,
      };
    }

    return options;
  };

  Tooltip.prototype.getDelegateOptions = function () {
    var options = {};
    var defaults = this.getDefaults();

    this._options &&
      $.each(this._options, function (key, value) {
        if (defaults[key] != value) options[key] = value;
      });

    return options;
  };

  Tooltip.prototype.enter = function (obj) {
    var self =
      obj instanceof this.constructor
        ? obj
        : $(obj.currentTarget).data("bs." + this.type);

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
      $(obj.currentTarget).data("bs." + this.type, self);
    }

    if (obj instanceof $.Event) {
      self.inState[obj.type == "focusin" ? "focus" : "hover"] = true;
    }

    if (self.tip().hasClass("in") || self.hoverState == "in") {
      self.hoverState = "in";
      return;
    }

    clearTimeout(self.timeout);

    self.hoverState = "in";

    if (!self.options.delay || !self.options.delay.show) return self.show();

    self.timeout = setTimeout(function () {
      if (self.hoverState == "in") self.show();
    }, self.options.delay.show);
  };

  Tooltip.prototype.isInStateTrue = function () {
    for (var key in this.inState) {
      if (this.inState[key]) return true;
    }

    return false;
  };

  Tooltip.prototype.leave = function (obj) {
    var self =
      obj instanceof this.constructor
        ? obj
        : $(obj.currentTarget).data("bs." + this.type);

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
      $(obj.currentTarget).data("bs." + this.type, self);
    }

    if (obj instanceof $.Event) {
      self.inState[obj.type == "focusout" ? "focus" : "hover"] = false;
    }

    if (self.isInStateTrue()) return;

    clearTimeout(self.timeout);

    self.hoverState = "out";

    if (!self.options.delay || !self.options.delay.hide) return self.hide();

    self.timeout = setTimeout(function () {
      if (self.hoverState == "out") self.hide();
    }, self.options.delay.hide);
  };

  Tooltip.prototype.show = function () {
    var e = $.Event("show.bs." + this.type);

    if (this.hasContent() && this.enabled) {
      this.$element.trigger(e);

      var inDom = $.contains(
        this.$element[0].ownerDocument.documentElement,
        this.$element[0]
      );
      if (e.isDefaultPrevented() || !inDom) return;
      var that = this;

      var $tip = this.tip();

      var tipId = this.getUID(this.type);

      this.setContent();
      $tip.attr("id", tipId);
      this.$element.attr("aria-describedby", tipId);

      if (this.options.animation) $tip.addClass("fade");

      var placement =
        typeof this.options.placement == "function"
          ? this.options.placement.call(this, $tip[0], this.$element[0])
          : this.options.placement;

      var autoToken = /\s?auto?\s?/i;
      var autoPlace = autoToken.test(placement);
      if (autoPlace) placement = placement.replace(autoToken, "") || "top";

      $tip
        .detach()
        .css({ top: 0, left: 0, display: "block" })
        .addClass(placement)
        .data("bs." + this.type, this);

      this.options.container
        ? $tip.appendTo(this.options.container)
        : $tip.insertAfter(this.$element);
      this.$element.trigger("inserted.bs." + this.type);

      var pos = this.getPosition();
      var actualWidth = $tip[0].offsetWidth;
      var actualHeight = $tip[0].offsetHeight;

      if (autoPlace) {
        var orgPlacement = placement;
        var viewportDim = this.getPosition(this.$viewport);

        placement =
          placement == "bottom" &&
          pos.bottom + actualHeight > viewportDim.bottom
            ? "top"
            : placement == "top" && pos.top - actualHeight < viewportDim.top
            ? "bottom"
            : placement == "right" &&
              pos.right + actualWidth > viewportDim.width
            ? "left"
            : placement == "left" && pos.left - actualWidth < viewportDim.left
            ? "right"
            : placement;

        $tip.removeClass(orgPlacement).addClass(placement);
      }

      var calculatedOffset = this.getCalculatedOffset(
        placement,
        pos,
        actualWidth,
        actualHeight
      );

      this.applyPlacement(calculatedOffset, placement);

      var complete = function () {
        var prevHoverState = that.hoverState;
        that.$element.trigger("shown.bs." + that.type);
        that.hoverState = null;

        if (prevHoverState == "out") that.leave(that);
      };

      $.support.transition && this.$tip.hasClass("fade")
        ? $tip
            .one("bsTransitionEnd", complete)
            .emulateTransitionEnd(Tooltip.TRANSITION_DURATION)
        : complete();
    }
  };

  Tooltip.prototype.applyPlacement = function (offset, placement) {
    var $tip = this.tip();
    var width = $tip[0].offsetWidth;
    var height = $tip[0].offsetHeight;

    // manually read margins because getBoundingClientRect includes difference
    var marginTop = parseInt($tip.css("margin-top"), 10);
    var marginLeft = parseInt($tip.css("margin-left"), 10);

    // we must check for NaN for ie 8/9
    if (isNaN(marginTop)) marginTop = 0;
    if (isNaN(marginLeft)) marginLeft = 0;

    offset.top += marginTop;
    offset.left += marginLeft;

    // $.fn.offset doesn't round pixel values
    // so we use setOffset directly with our own function B-0
    $.offset.setOffset(
      $tip[0],
      $.extend(
        {
          using: function (props) {
            $tip.css({
              top: Math.round(props.top),
              left: Math.round(props.left),
            });
          },
        },
        offset
      ),
      0
    );

    $tip.addClass("in");

    // check to see if placing tip in new offset caused the tip to resize itself
    var actualWidth = $tip[0].offsetWidth;
    var actualHeight = $tip[0].offsetHeight;

    if (placement == "top" && actualHeight != height) {
      offset.top = offset.top + height - actualHeight;
    }

    var delta = this.getViewportAdjustedDelta(
      placement,
      offset,
      actualWidth,
      actualHeight
    );

    if (delta.left) offset.left += delta.left;
    else offset.top += delta.top;

    var isVertical = /top|bottom/.test(placement);
    var arrowDelta = isVertical
      ? delta.left * 2 - width + actualWidth
      : delta.top * 2 - height + actualHeight;
    var arrowOffsetPosition = isVertical ? "offsetWidth" : "offsetHeight";

    $tip.offset(offset);
    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical);
  };

  Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {
    this.arrow()
      .css(isVertical ? "left" : "top", 50 * (1 - delta / dimension) + "%")
      .css(isVertical ? "top" : "left", "");
  };

  Tooltip.prototype.setContent = function () {
    var $tip = this.tip();
    var title = this.getTitle();

    $tip.find(".tooltip-inner")[this.options.html ? "html" : "text"](title);
    $tip.removeClass("fade in top bottom left right");
  };

  Tooltip.prototype.hide = function (callback) {
    var that = this;
    var $tip = $(this.$tip);
    var e = $.Event("hide.bs." + this.type);

    function complete() {
      if (that.hoverState != "in") $tip.detach();
      if (that.$element) {
        // TODO: Check whether guarding this code with this `if` is really necessary.
        that.$element
          .removeAttr("aria-describedby")
          .trigger("hidden.bs." + that.type);
      }
      callback && callback();
    }

    this.$element.trigger(e);

    if (e.isDefaultPrevented()) return;

    $tip.removeClass("in");

    $.support.transition && $tip.hasClass("fade")
      ? $tip
          .one("bsTransitionEnd", complete)
          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION)
      : complete();

    this.hoverState = null;

    return this;
  };

  Tooltip.prototype.fixTitle = function () {
    var $e = this.$element;
    if ($e.attr("title") || typeof $e.attr("data-original-title") != "string") {
      $e.attr("data-original-title", $e.attr("title") || "").attr("title", "");
    }
  };

  Tooltip.prototype.hasContent = function () {
    return this.getTitle();
  };

  Tooltip.prototype.getPosition = function ($element) {
    $element = $element || this.$element;

    var el = $element[0];
    var isBody = el.tagName == "BODY";

    var elRect = el.getBoundingClientRect();
    if (elRect.width == null) {
      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
      elRect = $.extend({}, elRect, {
        width: elRect.right - elRect.left,
        height: elRect.bottom - elRect.top,
      });
    }
    var isSvg = window.SVGElement && el instanceof window.SVGElement;
    // Avoid using $.offset() on SVGs since it gives incorrect results in jQuery 3.
    // See https://github.com/twbs/bootstrap/issues/20280
    var elOffset = isBody
      ? { top: 0, left: 0 }
      : isSvg
      ? null
      : $element.offset();
    var scroll = {
      scroll: isBody
        ? document.documentElement.scrollTop || document.body.scrollTop
        : $element.scrollTop(),
    };
    var outerDims = isBody
      ? { width: $(window).width(), height: $(window).height() }
      : null;

    return $.extend({}, elRect, scroll, outerDims, elOffset);
  };

  Tooltip.prototype.getCalculatedOffset = function (
    placement,
    pos,
    actualWidth,
    actualHeight
  ) {
    return placement == "bottom"
      ? {
          top: pos.top + pos.height,
          left: pos.left + pos.width / 2 - actualWidth / 2,
        }
      : placement == "top"
      ? {
          top: pos.top - actualHeight,
          left: pos.left + pos.width / 2 - actualWidth / 2,
        }
      : placement == "left"
      ? {
          top: pos.top + pos.height / 2 - actualHeight / 2,
          left: pos.left - actualWidth,
        }
      : /* placement == 'right' */ {
          top: pos.top + pos.height / 2 - actualHeight / 2,
          left: pos.left + pos.width,
        };
  };

  Tooltip.prototype.getViewportAdjustedDelta = function (
    placement,
    pos,
    actualWidth,
    actualHeight
  ) {
    var delta = { top: 0, left: 0 };
    if (!this.$viewport) return delta;

    var viewportPadding =
      (this.options.viewport && this.options.viewport.padding) || 0;
    var viewportDimensions = this.getPosition(this.$viewport);

    if (/right|left/.test(placement)) {
      var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll;
      var bottomEdgeOffset =
        pos.top + viewportPadding - viewportDimensions.scroll + actualHeight;
      if (topEdgeOffset < viewportDimensions.top) {
        // top overflow
        delta.top = viewportDimensions.top - topEdgeOffset;
      } else if (
        bottomEdgeOffset >
        viewportDimensions.top + viewportDimensions.height
      ) {
        // bottom overflow
        delta.top =
          viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;
      }
    } else {
      var leftEdgeOffset = pos.left - viewportPadding;
      var rightEdgeOffset = pos.left + viewportPadding + actualWidth;
      if (leftEdgeOffset < viewportDimensions.left) {
        // left overflow
        delta.left = viewportDimensions.left - leftEdgeOffset;
      } else if (rightEdgeOffset > viewportDimensions.right) {
        // right overflow
        delta.left =
          viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;
      }
    }

    return delta;
  };

  Tooltip.prototype.getTitle = function () {
    var title;
    var $e = this.$element;
    var o = this.options;

    title =
      $e.attr("data-original-title") ||
      (typeof o.title == "function" ? o.title.call($e[0]) : o.title);

    return title;
  };

  Tooltip.prototype.getUID = function (prefix) {
    do prefix += ~~(Math.random() * 1000000);
    while (document.getElementById(prefix));
    return prefix;
  };

  Tooltip.prototype.tip = function () {
    if (!this.$tip) {
      this.$tip = $(this.options.template);
      if (this.$tip.length != 1) {
        throw new Error(
          this.type +
            " `template` option must consist of exactly 1 top-level element!"
        );
      }
    }
    return this.$tip;
  };

  Tooltip.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow"));
  };

  Tooltip.prototype.enable = function () {
    this.enabled = true;
  };

  Tooltip.prototype.disable = function () {
    this.enabled = false;
  };

  Tooltip.prototype.toggleEnabled = function () {
    this.enabled = !this.enabled;
  };

  Tooltip.prototype.toggle = function (e) {
    var self = this;
    if (e) {
      self = $(e.currentTarget).data("bs." + this.type);
      if (!self) {
        self = new this.constructor(e.currentTarget, this.getDelegateOptions());
        $(e.currentTarget).data("bs." + this.type, self);
      }
    }

    if (e) {
      self.inState.click = !self.inState.click;
      if (self.isInStateTrue()) self.enter(self);
      else self.leave(self);
    } else {
      self.tip().hasClass("in") ? self.leave(self) : self.enter(self);
    }
  };

  Tooltip.prototype.destroy = function () {
    var that = this;
    clearTimeout(this.timeout);
    this.hide(function () {
      that.$element.off("." + that.type).removeData("bs." + that.type);
      if (that.$tip) {
        that.$tip.detach();
      }
      that.$tip = null;
      that.$arrow = null;
      that.$viewport = null;
      that.$element = null;
    });
  };

  // TOOLTIP PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data("bs.tooltip");
      var options = typeof option == "object" && option;

      if (!data && /destroy|hide/.test(option)) return;
      if (!data) $this.data("bs.tooltip", (data = new Tooltip(this, options)));
      if (typeof option == "string") data[option]();
    });
  }

  var old = $.fn.tooltip;

  $.fn.tooltip = Plugin;
  $.fn.tooltip.Constructor = Tooltip;

  // TOOLTIP NO CONFLICT
  // ===================

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old;
    return this;
  };
})(jQuery);

/* ========================================================================
 * Bootstrap: popover.js v3.3.7
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+(function ($) {
  "use strict";

  // POPOVER PUBLIC CLASS DEFINITION
  // ===============================

  var Popover = function (element, options) {
    this.init("popover", element, options);
  };

  if (!$.fn.tooltip) throw new Error("Popover requires tooltip.js");

  Popover.VERSION = "3.3.7";

  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    placement: "right",
    trigger: "click",
    content: "",
    template:
      '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>',
  });

  // NOTE: POPOVER EXTENDS tooltip.js
  // ================================

  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype);

  Popover.prototype.constructor = Popover;

  Popover.prototype.getDefaults = function () {
    return Popover.DEFAULTS;
  };

  Popover.prototype.setContent = function () {
    var $tip = this.tip();
    var title = this.getTitle();
    var content = this.getContent();

    $tip.find(".popover-title")[this.options.html ? "html" : "text"](title);
    $tip
      .find(".popover-content")
      .children()
      .detach()
      .end() // we use append for html objects to maintain js events
      [
        this.options.html
          ? typeof content == "string"
            ? "html"
            : "append"
          : "text"
      ](content);

    $tip.removeClass("fade top bottom left right in");

    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
    // this manually by checking the contents.
    if (!$tip.find(".popover-title").html()) $tip.find(".popover-title").hide();
  };

  Popover.prototype.hasContent = function () {
    return this.getTitle() || this.getContent();
  };

  Popover.prototype.getContent = function () {
    var $e = this.$element;
    var o = this.options;

    return (
      $e.attr("data-content") ||
      (typeof o.content == "function" ? o.content.call($e[0]) : o.content)
    );
  };

  Popover.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find(".arrow"));
  };

  // POPOVER PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data("bs.popover");
      var options = typeof option == "object" && option;

      if (!data && /destroy|hide/.test(option)) return;
      if (!data) $this.data("bs.popover", (data = new Popover(this, options)));
      if (typeof option == "string") data[option]();
    });
  }

  var old = $.fn.popover;

  $.fn.popover = Plugin;
  $.fn.popover.Constructor = Popover;

  // POPOVER NO CONFLICT
  // ===================

  $.fn.popover.noConflict = function () {
    $.fn.popover = old;
    return this;
  };
})(jQuery);

/* ========================================================================
 * Bootstrap: scrollspy.js v3.3.7
 * http://getbootstrap.com/javascript/#scrollspy
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+(function ($) {
  "use strict";

  // SCROLLSPY CLASS DEFINITION
  // ==========================

  function ScrollSpy(element, options) {
    this.$body = $(document.body);
    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element);
    this.options = $.extend({}, ScrollSpy.DEFAULTS, options);
    this.selector = (this.options.target || "") + " .nav li > a";
    this.offsets = [];
    this.targets = [];
    this.activeTarget = null;
    this.scrollHeight = 0;

    this.$scrollElement.on("scroll.bs.scrollspy", $.proxy(this.process, this));
    this.refresh();
    this.process();
  }

  ScrollSpy.VERSION = "3.3.7";

  ScrollSpy.DEFAULTS = {
    offset: 10,
  };

  ScrollSpy.prototype.getScrollHeight = function () {
    return (
      this.$scrollElement[0].scrollHeight ||
      Math.max(
        this.$body[0].scrollHeight,
        document.documentElement.scrollHeight
      )
    );
  };

  ScrollSpy.prototype.refresh = function () {
    var that = this;
    var offsetMethod = "offset";
    var offsetBase = 0;

    this.offsets = [];
    this.targets = [];
    this.scrollHeight = this.getScrollHeight();

    if (!$.isWindow(this.$scrollElement[0])) {
      offsetMethod = "position";
      offsetBase = this.$scrollElement.scrollTop();
    }

    this.$body
      .find(this.selector)
      .map(function () {
        var $el = $(this);
        var href = $el.data("target") || $el.attr("href");
        var $href = /^#./.test(href) && $(href);

        return (
          ($href &&
            $href.length &&
            $href.is(":visible") && [
              [$href[offsetMethod]().top + offsetBase, href],
            ]) ||
          null
        );
      })
      .sort(function (a, b) {
        return a[0] - b[0];
      })
      .each(function () {
        that.offsets.push(this[0]);
        that.targets.push(this[1]);
      });
  };

  ScrollSpy.prototype.process = function () {
    var scrollTop = this.$scrollElement.scrollTop() + this.options.offset;
    var scrollHeight = this.getScrollHeight();
    var maxScroll =
      this.options.offset + scrollHeight - this.$scrollElement.height();
    var offsets = this.offsets;
    var targets = this.targets;
    var activeTarget = this.activeTarget;
    var i;

    if (this.scrollHeight != scrollHeight) {
      this.refresh();
    }

    if (scrollTop >= maxScroll) {
      return (
        activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
      );
    }

    if (activeTarget && scrollTop < offsets[0]) {
      this.activeTarget = null;
      return this.clear();
    }

    for (i = offsets.length; i--; ) {
      activeTarget != targets[i] &&
        scrollTop >= offsets[i] &&
        (offsets[i + 1] === undefined || scrollTop < offsets[i + 1]) &&
        this.activate(targets[i]);
    }
  };

  ScrollSpy.prototype.activate = function (target) {
    this.activeTarget = target;

    this.clear();

    var selector =
      this.selector +
      '[data-target="' +
      target +
      '"],' +
      this.selector +
      '[href="' +
      target +
      '"]';

    var active = $(selector).parents("li").addClass("active");

    if (active.parent(".dropdown-menu").length) {
      active = active.closest("li.dropdown").addClass("active");
    }

    active.trigger("activate.bs.scrollspy");
  };

  ScrollSpy.prototype.clear = function () {
    $(this.selector)
      .parentsUntil(this.options.target, ".active")
      .removeClass("active");
  };

  // SCROLLSPY PLUGIN DEFINITION
  // ===========================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data("bs.scrollspy");
      var options = typeof option == "object" && option;

      if (!data)
        $this.data("bs.scrollspy", (data = new ScrollSpy(this, options)));
      if (typeof option == "string") data[option]();
    });
  }

  var old = $.fn.scrollspy;

  $.fn.scrollspy = Plugin;
  $.fn.scrollspy.Constructor = ScrollSpy;

  // SCROLLSPY NO CONFLICT
  // =====================

  $.fn.scrollspy.noConflict = function () {
    $.fn.scrollspy = old;
    return this;
  };

  // SCROLLSPY DATA-API
  // ==================

  $(window).on("load.bs.scrollspy.data-api", function () {
    $('[data-spy="scroll"]').each(function () {
      var $spy = $(this);
      Plugin.call($spy, $spy.data());
    });
  });
})(jQuery);

/* ========================================================================
 * Bootstrap: tab.js v3.3.7
 * http://getbootstrap.com/javascript/#tabs
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+(function ($) {
  "use strict";

  // TAB CLASS DEFINITION
  // ====================

  var Tab = function (element) {
    // jscs:disable requireDollarBeforejQueryAssignment
    this.element = $(element);
    // jscs:enable requireDollarBeforejQueryAssignment
  };

  Tab.VERSION = "3.3.7";

  Tab.TRANSITION_DURATION = 150;

  Tab.prototype.show = function () {
    var $this = this.element;
    var $ul = $this.closest("ul:not(.dropdown-menu)");
    var selector = $this.data("target");

    if (!selector) {
      selector = $this.attr("href");
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, ""); // strip for ie7
    }

    if ($this.parent("li").hasClass("active")) return;

    var $previous = $ul.find(".active:last a");
    var hideEvent = $.Event("hide.bs.tab", {
      relatedTarget: $this[0],
    });
    var showEvent = $.Event("show.bs.tab", {
      relatedTarget: $previous[0],
    });

    $previous.trigger(hideEvent);
    $this.trigger(showEvent);

    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented())
      return;

    var $target = $(selector);

    this.activate($this.closest("li"), $ul);
    this.activate($target, $target.parent(), function () {
      $previous.trigger({
        type: "hidden.bs.tab",
        relatedTarget: $this[0],
      });
      $this.trigger({
        type: "shown.bs.tab",
        relatedTarget: $previous[0],
      });
    });
  };

  Tab.prototype.activate = function (element, container, callback) {
    var $active = container.find("> .active");
    var transition =
      callback &&
      $.support.transition &&
      (($active.length && $active.hasClass("fade")) ||
        !!container.find("> .fade").length);

    function next() {
      $active
        .removeClass("active")
        .find("> .dropdown-menu > .active")
        .removeClass("active")
        .end()
        .find('[data-toggle="tab"]')
        .attr("aria-expanded", false);

      element
        .addClass("active")
        .find('[data-toggle="tab"]')
        .attr("aria-expanded", true);

      if (transition) {
        element[0].offsetWidth; // reflow for transition
        element.addClass("in");
      } else {
        element.removeClass("fade");
      }

      if (element.parent(".dropdown-menu").length) {
        element
          .closest("li.dropdown")
          .addClass("active")
          .end()
          .find('[data-toggle="tab"]')
          .attr("aria-expanded", true);
      }

      callback && callback();
    }

    $active.length && transition
      ? $active
          .one("bsTransitionEnd", next)
          .emulateTransitionEnd(Tab.TRANSITION_DURATION)
      : next();

    $active.removeClass("in");
  };

  // TAB PLUGIN DEFINITION
  // =====================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data("bs.tab");

      if (!data) $this.data("bs.tab", (data = new Tab(this)));
      if (typeof option == "string") data[option]();
    });
  }

  var old = $.fn.tab;

  $.fn.tab = Plugin;
  $.fn.tab.Constructor = Tab;

  // TAB NO CONFLICT
  // ===============

  $.fn.tab.noConflict = function () {
    $.fn.tab = old;
    return this;
  };

  // TAB DATA-API
  // ============

  var clickHandler = function (e) {
    e.preventDefault();
    Plugin.call($(this), "show");
  };

  $(document)
    .on("click.bs.tab.data-api", '[data-toggle="tab"]', clickHandler)
    .on("click.bs.tab.data-api", '[data-toggle="pill"]', clickHandler);
})(jQuery);

/* ========================================================================
 * Bootstrap: affix.js v3.3.7
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+(function ($) {
  "use strict";

  // AFFIX CLASS DEFINITION
  // ======================

  var Affix = function (element, options) {
    this.options = $.extend({}, Affix.DEFAULTS, options);

    this.$target = $(this.options.target)
      .on("scroll.bs.affix.data-api", $.proxy(this.checkPosition, this))
      .on(
        "click.bs.affix.data-api",
        $.proxy(this.checkPositionWithEventLoop, this)
      );

    this.$element = $(element);
    this.affixed = null;
    this.unpin = null;
    this.pinnedOffset = null;

    this.checkPosition();
  };

  Affix.VERSION = "3.3.7";

  Affix.RESET = "affix affix-top affix-bottom";

  Affix.DEFAULTS = {
    offset: 0,
    target: window,
  };

  Affix.prototype.getState = function (
    scrollHeight,
    height,
    offsetTop,
    offsetBottom
  ) {
    var scrollTop = this.$target.scrollTop();
    var position = this.$element.offset();
    var targetHeight = this.$target.height();

    if (offsetTop != null && this.affixed == "top")
      return scrollTop < offsetTop ? "top" : false;

    if (this.affixed == "bottom") {
      if (offsetTop != null)
        return scrollTop + this.unpin <= position.top ? false : "bottom";
      return scrollTop + targetHeight <= scrollHeight - offsetBottom
        ? false
        : "bottom";
    }

    var initializing = this.affixed == null;
    var colliderTop = initializing ? scrollTop : position.top;
    var colliderHeight = initializing ? targetHeight : height;

    if (offsetTop != null && scrollTop <= offsetTop) return "top";
    if (
      offsetBottom != null &&
      colliderTop + colliderHeight >= scrollHeight - offsetBottom
    )
      return "bottom";

    return false;
  };

  Affix.prototype.getPinnedOffset = function () {
    if (this.pinnedOffset) return this.pinnedOffset;
    this.$element.removeClass(Affix.RESET).addClass("affix");
    var scrollTop = this.$target.scrollTop();
    var position = this.$element.offset();
    return (this.pinnedOffset = position.top - scrollTop);
  };

  Affix.prototype.checkPositionWithEventLoop = function () {
    setTimeout($.proxy(this.checkPosition, this), 1);
  };

  Affix.prototype.checkPosition = function () {
    if (!this.$element.is(":visible")) return;

    var height = this.$element.height();
    var offset = this.options.offset;
    var offsetTop = offset.top;
    var offsetBottom = offset.bottom;
    var scrollHeight = Math.max(
      $(document).height(),
      $(document.body).height()
    );

    if (typeof offset != "object") offsetBottom = offsetTop = offset;
    if (typeof offsetTop == "function") offsetTop = offset.top(this.$element);
    if (typeof offsetBottom == "function")
      offsetBottom = offset.bottom(this.$element);

    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom);

    if (this.affixed != affix) {
      if (this.unpin != null) this.$element.css("top", "");

      var affixType = "affix" + (affix ? "-" + affix : "");
      var e = $.Event(affixType + ".bs.affix");

      this.$element.trigger(e);

      if (e.isDefaultPrevented()) return;

      this.affixed = affix;
      this.unpin = affix == "bottom" ? this.getPinnedOffset() : null;

      this.$element
        .removeClass(Affix.RESET)
        .addClass(affixType)
        .trigger(affixType.replace("affix", "affixed") + ".bs.affix");
    }

    if (affix == "bottom") {
      this.$element.offset({
        top: scrollHeight - height - offsetBottom,
      });
    }
  };

  // AFFIX PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data("bs.affix");
      var options = typeof option == "object" && option;

      if (!data) $this.data("bs.affix", (data = new Affix(this, options)));
      if (typeof option == "string") data[option]();
    });
  }

  var old = $.fn.affix;

  $.fn.affix = Plugin;
  $.fn.affix.Constructor = Affix;

  // AFFIX NO CONFLICT
  // =================

  $.fn.affix.noConflict = function () {
    $.fn.affix = old;
    return this;
  };

  // AFFIX DATA-API
  // ==============

  $(window).on("load", function () {
    $('[data-spy="affix"]').each(function () {
      var $spy = $(this);
      var data = $spy.data();

      data.offset = data.offset || {};

      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom;
      if (data.offsetTop != null) data.offset.top = data.offsetTop;

      Plugin.call($spy, data);
    });
  });
})(jQuery);

/*!
 * jQuery Typeahead
 * Copyright (C) 2017 RunningCoder.org
 * Licensed under the MIT license
 *
 * @author Tom Bertrand
 * @version 2.10.4 (2017-10-17)
 * @link http://www.runningcoder.org/jquerytypeahead/
 */
(function (factory) {
  if (typeof define === "function" && define.amd) {
    define("jquery-typeahead", ["jquery"], function (jQuery) {
      return factory(jQuery);
    });
  } else if (typeof module === "object" && module.exports) {
    module.exports = (function (jQuery, root) {
      if (jQuery === undefined) {
        if (typeof window !== "undefined") {
          jQuery = require("jquery");
        } else {
          jQuery = require("jquery")(root);
        }
      }
      return factory(jQuery);
    })();
  } else {
    factory(jQuery);
  }
})(function ($) {
  "use strict";

  window.Typeahead = {
    version: "2.10.4",
  };

  /**
   * @private
   * Default options
   * @link http://www.runningcoder.org/jquerytypeahead/documentation/
   */
  var _options = {
    input: null, // *RECOMMENDED*, jQuery selector to reach Typeahead's input for initialization
    minLength: 2, // Accepts 0 to search on focus, minimum character length to perform a search
    maxLength: false, // False as "Infinity" will not put character length restriction for searching results
    maxItem: 8, // Accepts 0 / false as "Infinity" meaning all the results will be displayed
    dynamic: false, // When true, Typeahead will get a new dataset from the source option on every key press
    delay: 300, // delay in ms when dynamic option is set to true
    order: null, // "asc" or "desc" to sort results
    offset: false, // Set to true to match items starting from their first character
    hint: false, // Added support for excessive "space" characters
    accent: false, // Will allow to type accent and give letter equivalent results, also can define a custom replacement object
    highlight: true, // Added "any" to highlight any word in the template, by default true will only highlight display keys
    multiselect: null, // Multiselect configuration object, see documentation for all options
    group: false, // Improved feature, Boolean,string,object(key, template (string, function))
    groupOrder: null, // New feature, order groups "asc", "desc", Array, Function
    maxItemPerGroup: null, // Maximum number of result per Group
    dropdownFilter: false, // Take group options string and create a dropdown filter
    dynamicFilter: null, // Filter the typeahead results based on dynamic value, Ex: Players based on TeamID
    backdrop: false, // Add a backdrop behind Typeahead results
    backdropOnFocus: false, // Display the backdrop option as the Typeahead input is :focused
    cache: false, // Improved option, true OR 'localStorage' OR 'sessionStorage'
    ttl: 3600000, // Cache time to live in ms
    compression: false, // Requires LZString library
    searchOnFocus: false, // Display search results on input focus
    blurOnTab: true, // Blur Typeahead when Tab key is pressed, if false Tab will go though search results
    resultContainer: null, // List the results inside any container string or jQuery object
    generateOnLoad: null, // Forces the source to be generated on page load even if the input is not focused!
    mustSelectItem: false, // The submit function only gets called if an item is selected
    href: null, // String or Function to format the url for right-click & open in new tab on link results
    display: ["display"], // Allows search in multiple item keys ["display1", "display2"]
    template: null, // Display template of each of the result list
    templateValue: null, // Set the input value template when an item is clicked
    groupTemplate: null, // Set a custom template for the groups
    correlativeTemplate: false, // Compile display keys, enables multiple key search from the template string
    emptyTemplate: false, // Display an empty template if no result
    cancelButton: true, // If text is detected in the input, a cancel button will be available to reset the input (pressing ESC also cancels)
    loadingAnimation: true, // Display a loading animation when typeahead is doing request / searching for results
    filter: true, // Set to false or function to bypass Typeahead filtering. WARNING: accent, correlativeTemplate, offset & matcher will not be interpreted
    matcher: null, // Add an extra filtering function after the typeahead functions
    source: null, // Source of data for Typeahead to filter
    callback: {
      onInit: null, // When Typeahead is first initialized (happens only once)
      onReady: null, // When the Typeahead initial preparation is completed
      onShowLayout: null, // Called when the layout is shown
      onHideLayout: null, // Called when the layout is hidden
      onSearch: null, // When data is being fetched & analyzed to give search results
      onResult: null, // When the result container is displayed
      onLayoutBuiltBefore: null, // When the result HTML is build, modify it before it get showed
      onLayoutBuiltAfter: null, // Modify the dom right after the results gets inserted in the result container
      onNavigateBefore: null, // When a key is pressed to navigate the results, before the navigation happens
      onNavigateAfter: null, // When a key is pressed to navigate the results
      onEnter: null, // When an item in the result list is focused
      onLeave: null, // When an item in the result list is blurred
      onClickBefore: null, // Possibility to e.preventDefault() to prevent the Typeahead behaviors
      onClickAfter: null, // Happens after the default clicked behaviors has been executed
      onDropdownFilter: null, // When the dropdownFilter is changed, trigger this callback
      onSendRequest: null, // Gets called when the Ajax request(s) are sent
      onReceiveRequest: null, // Gets called when the Ajax request(s) are all received
      onPopulateSource: null, // Perform operation on the source data before it gets in Typeahead data
      onCacheSave: null, // Perform operation on the source data before it gets in Typeahead cache
      onSubmit: null, // When Typeahead form is submitted
      onCancel: null, // Triggered if the typeahead had text inside and is cleared
    },
    selector: {
      container: "typeahead__container",
      result: "typeahead__result",
      list: "typeahead__list",
      group: "typeahead__group",
      item: "typeahead__item",
      empty: "typeahead__empty",
      display: "typeahead__display",
      query: "typeahead__query",
      filter: "typeahead__filter",
      filterButton: "typeahead__filter-button",
      dropdown: "typeahead__dropdown",
      dropdownItem: "typeahead__dropdown-item",
      labelContainer: "typeahead__label-container",
      label: "typeahead__label",
      button: "typeahead__button",
      backdrop: "typeahead__backdrop",
      hint: "typeahead__hint",
      cancelButton: "typeahead__cancel-button",
    },
    debug: false, // Display debug information (RECOMMENDED for dev environment)
  };

  /**
   * @private
   * Event namespace
   */
  var _namespace = ".typeahead";

  /**
   * @private
   * Accent equivalents
   */
  var _accent = {
    from: "ãàáäâẽèéëêìíïîõòóöôùúüûñç",
    to: "aaaaaeeeeeiiiiooooouuuunc",
  };

  /**
   * #62 IE9 doesn't trigger "input" event when text gets removed (backspace, ctrl+x, etc)
   * @private
   */
  var _isIE9 = ~window.navigator.appVersion.indexOf("MSIE 9.");

  /**
   * #193 Clicking on a suggested option does not select it on IE10/11
   * @private
   */
  var _isIE10 = ~window.navigator.appVersion.indexOf("MSIE 10");
  var _isIE11 = ~window.navigator.userAgent.indexOf("Trident")
    ? ~window.navigator.userAgent.indexOf("rv:11")
    : false;

  // SOURCE GROUP RESERVED WORDS: ajax, data, url
  // SOURCE ITEMS RESERVED KEYS: group, display, data, matchedKey, compiled, href

  /**
   * @constructor
   * Typeahead Class
   *
   * @param {object} node jQuery input object
   * @param {object} options User defined options
   */
  var Typeahead = function (node, options) {
    this.rawQuery = node.val() || ""; // Unmodified input query
    this.query = node.val() || ""; // Input query
    this.selector = node[0].selector; // Typeahead instance selector (to reach from window.Typeahead[SELECTOR])
    this.deferred = null; // Promise when "input" event in triggered, this.node.triggerHandler('input').then(() => {})
    this.tmpSource = {}; // Temp var to preserve the source order for the searchResult function
    this.source = {}; // The generated source kept in memory
    this.dynamicGroups = []; // Store the source groups that are defined as dynamic
    this.hasDynamicGroups = false; // Boolean if at least one of the groups has a dynamic source
    this.generatedGroupCount = 0; // Number of groups generated, if limit reached the search can be done
    this.groupBy = "group"; // This option will change according to filtering or custom grouping
    this.groups = []; // Array of all the available groups, used to build the groupTemplate
    this.searchGroups = []; // Array of groups to generate when Typeahead searches data
    this.generateGroups = []; // Array of groups to generate when Typeahead requests data
    this.requestGroups = []; // Array of groups to request via Ajax
    this.result = []; // Results based on Source-query match (only contains the displayed elements)
    this.tmpResult = {}; // Temporary object of results, before they get passed to the buildLayout function
    this.groupTemplate = ""; // Result template at the {{group}} level
    this.resultHtml = null; // HTML Results (displayed elements)
    this.resultCount = 0; // Total results based on Source-query match
    this.resultCountPerGroup = {}; // Total results based on Source-query match per group
    this.options = options; // Typeahead options (Merged default & user defined)
    this.node = node; // jQuery object of the Typeahead <input>
    this.namespace =
      "." + this.helper.slugify.call(this, this.selector) + _namespace; // Every Typeahead instance gets its own namespace for events
    this.isContentEditable =
      typeof this.node.attr("contenteditable") !== "undefined" &&
      this.node.attr("contenteditable") !== "false";
    this.container = null; // Typeahead container, usually right after <form>
    this.resultContainer = null; // Typeahead result container (html)
    this.item = null; // Selected item
    this.items = null; // Multiselect selected items
    this.comparedItems = null; // Multiselect items stored for comparison
    this.xhr = {}; // Ajax request(s) stack
    this.hintIndex = null; // Numeric value of the hint index in the result list
    this.filters = {
      // Filter list for searching, dropdown and dynamic(s)
      dropdown: {}, // Dropdown menu if options.dropdownFilter is set
      dynamic: {}, // Checkbox / Radio / Select to filter the source data
    };
    this.dropdownFilter = {
      static: [], // Objects that has a value
      dynamic: [],
    };
    this.dropdownFilterAll = null; // The last "all" definition
    this.isDropdownEvent = false; // If a dropdownFilter is clicked, this will be true to trigger the callback

    this.requests = {}; // Store the group:request instead of generating them every time

    this.backdrop = {}; // The backdrop object
    this.hint = {}; // The hint object
    this.label = {}; // The label object
    this.hasDragged = false; // Will cancel mouseend events if true
    this.focusOnly = false; // Focus the input preventing any operations

    this.__construct();
  };

  Typeahead.prototype = {
    _validateCacheMethod: function (cache) {
      var supportedCache = ["localStorage", "sessionStorage"],
        supported;

      if (cache === true) {
        cache = "localStorage";
      } else if (typeof cache === "string" && !~supportedCache.indexOf(cache)) {
        // {debug}
        if (this.options.debug) {
          _debug.log({
            node: this.selector,
            function: "extendOptions()",
            message:
              'Invalid options.cache, possible options are "localStorage" or "sessionStorage"',
          });

          _debug.print();
        }
        // {/debug}
        return false;
      }

      supported = typeof window[cache] !== "undefined";

      try {
        window[cache].setItem("typeahead", "typeahead");
        window[cache].removeItem("typeahead");
      } catch (e) {
        supported = false;
      }

      return (supported && cache) || false;
    },

    extendOptions: function () {
      this.options.cache = this._validateCacheMethod(this.options.cache);

      if (this.options.compression) {
        if (typeof LZString !== "object" || !this.options.cache) {
          // {debug}
          if (this.options.debug) {
            _debug.log({
              node: this.selector,
              function: "extendOptions()",
              message:
                "Missing LZString Library or options.cache, no compression will occur.",
            });

            _debug.print();
          }
          // {/debug}
          this.options.compression = false;
        }
      }

      if (!this.options.maxLength || isNaN(this.options.maxLength)) {
        this.options.maxLength = Infinity;
      }

      if (
        typeof this.options.maxItem !== "undefined" &&
        ~[0, false].indexOf(this.options.maxItem)
      ) {
        this.options.maxItem = Infinity;
      }

      if (
        this.options.maxItemPerGroup &&
        !/^\d+$/.test(this.options.maxItemPerGroup)
      ) {
        this.options.maxItemPerGroup = null;
      }

      if (this.options.display && !Array.isArray(this.options.display)) {
        this.options.display = [this.options.display];
      }

      if (this.options.multiselect) {
        this.items = [];
        this.comparedItems = [];
        if (typeof this.options.multiselect.matchOn === "string") {
          this.options.multiselect.matchOn = [this.options.multiselect.matchOn];
        }
      }

      if (this.options.group) {
        if (!Array.isArray(this.options.group)) {
          if (typeof this.options.group === "string") {
            this.options.group = {
              key: this.options.group,
            };
          } else if (typeof this.options.group === "boolean") {
            this.options.group = {
              key: "group",
            };
          }

          this.options.group.key = this.options.group.key || "group";
        } else {
          // {debug}
          if (this.options.debug) {
            _debug.log({
              node: this.selector,
              function: "extendOptions()",
              message:
                "options.group must be a boolean|string|object as of 2.5.0",
            });

            _debug.print();
          }
          // {/debug}
        }
      }

      if (
        this.options.highlight &&
        !~["any", true].indexOf(this.options.highlight)
      ) {
        this.options.highlight = false;
      }

      if (
        this.options.dropdownFilter &&
        this.options.dropdownFilter instanceof Object
      ) {
        if (!Array.isArray(this.options.dropdownFilter)) {
          this.options.dropdownFilter = [this.options.dropdownFilter];
        }
        for (var i = 0, ii = this.options.dropdownFilter.length; i < ii; ++i) {
          this.dropdownFilter[
            this.options.dropdownFilter[i].value ? "static" : "dynamic"
          ].push(this.options.dropdownFilter[i]);
        }
      }

      if (
        this.options.dynamicFilter &&
        !Array.isArray(this.options.dynamicFilter)
      ) {
        this.options.dynamicFilter = [this.options.dynamicFilter];
      }

      if (this.options.accent) {
        if (typeof this.options.accent === "object") {
          if (
            this.options.accent.from &&
            this.options.accent.to &&
            this.options.accent.from.length !== this.options.accent.to.length
          ) {
            // {debug}
            if (this.options.debug) {
              _debug.log({
                node: this.selector,
                function: "extendOptions()",
                message:
                  'Invalid "options.accent", from and to must be defined and same length.',
              });

              _debug.print();
            }
            // {/debug}
          }
        } else {
          this.options.accent = _accent;
        }
      }

      if (this.options.groupTemplate) {
        this.groupTemplate = this.options.groupTemplate;
      }

      if (this.options.resultContainer) {
        if (typeof this.options.resultContainer === "string") {
          this.options.resultContainer = $(this.options.resultContainer);
        }

        if (
          !(this.options.resultContainer instanceof $) ||
          !this.options.resultContainer[0]
        ) {
          // {debug}
          if (this.options.debug) {
            _debug.log({
              node: this.selector,
              function: "extendOptions()",
              message:
                'Invalid jQuery selector or jQuery Object for "options.resultContainer".',
            });

            _debug.print();
          }
          // {/debug}
        } else {
          this.resultContainer = this.options.resultContainer;
        }
      }

      if (
        this.options.maxItemPerGroup &&
        this.options.group &&
        this.options.group.key
      ) {
        this.groupBy = this.options.group.key;
      }

      // Compatibility onClick callback
      if (this.options.callback && this.options.callback.onClick) {
        this.options.callback.onClickBefore = this.options.callback.onClick;
        delete this.options.callback.onClick;
      }

      // Compatibility onNavigate callback
      if (this.options.callback && this.options.callback.onNavigate) {
        this.options.callback.onNavigateBefore =
          this.options.callback.onNavigate;
        delete this.options.callback.onNavigate;
      }

      this.options = $.extend(true, {}, _options, this.options);
    },

    unifySourceFormat: function () {
      this.dynamicGroups = [];

      // source: ['item1', 'item2', 'item3']
      if (Array.isArray(this.options.source)) {
        this.options.source = {
          group: {
            data: this.options.source,
          },
        };
      }

      // source: "http://www.test.com/url.json"
      if (typeof this.options.source === "string") {
        this.options.source = {
          group: {
            ajax: {
              url: this.options.source,
            },
          },
        };
      }

      if (this.options.source.ajax) {
        this.options.source = {
          group: {
            ajax: this.options.source.ajax,
          },
        };
      }

      // source: {data: ['item1', 'item2'], url: "http://www.test.com/url.json"}
      if (this.options.source.url || this.options.source.data) {
        this.options.source = {
          group: this.options.source,
        };
      }

      var group, groupSource, tmpAjax;

      for (group in this.options.source) {
        if (!this.options.source.hasOwnProperty(group)) continue;

        groupSource = this.options.source[group];

        // source: {group: "http://www.test.com/url.json"}
        if (typeof groupSource === "string") {
          groupSource = {
            ajax: {
              url: groupSource,
            },
          };
        }

        // source: {group: {url: ["http://www.test.com/url.json", "json.path"]}}
        tmpAjax = groupSource.url || groupSource.ajax;
        if (Array.isArray(tmpAjax)) {
          groupSource.ajax =
            typeof tmpAjax[0] === "string"
              ? {
                  url: tmpAjax[0],
                }
              : tmpAjax[0];
          groupSource.ajax.path = groupSource.ajax.path || tmpAjax[1] || null;
          delete groupSource.url;
        } else {
          // source: {group: {url: {url: "http://www.test.com/url.json", method: "GET"}}}
          // source: {group: {url: "http://www.test.com/url.json", dataType: "jsonp"}}
          if (typeof groupSource.url === "object") {
            groupSource.ajax = groupSource.url;
          } else if (typeof groupSource.url === "string") {
            groupSource.ajax = {
              url: groupSource.url,
            };
          }
          delete groupSource.url;
        }

        if (!groupSource.data && !groupSource.ajax) {
          // {debug}
          if (this.options.debug) {
            _debug.log({
              node: this.selector,
              function: "unifySourceFormat()",
              arguments: JSON.stringify(this.options.source),
              message:
                'Undefined "options.source.' +
                group +
                '.[data|ajax]" is Missing - Typeahead dropped',
            });

            _debug.print();
          }
          // {/debug}

          return false;
        }

        if (groupSource.display && !Array.isArray(groupSource.display)) {
          groupSource.display = [groupSource.display];
        }

        groupSource.minLength =
          typeof groupSource.minLength === "number"
            ? groupSource.minLength
            : this.options.minLength;
        groupSource.maxLength =
          typeof groupSource.maxLength === "number"
            ? groupSource.maxLength
            : this.options.maxLength;
        groupSource.dynamic =
          typeof groupSource.dynamic === "boolean" || this.options.dynamic;

        if (groupSource.minLength > groupSource.maxLength) {
          groupSource.minLength = groupSource.maxLength;
        }
        this.options.source[group] = groupSource;

        if (this.options.source[group].dynamic) {
          this.dynamicGroups.push(group);
        }

        groupSource.cache =
          typeof groupSource.cache !== "undefined"
            ? this._validateCacheMethod(groupSource.cache)
            : this.options.cache;

        if (groupSource.compression) {
          if (typeof LZString !== "object" || !groupSource.cache) {
            // {debug}
            if (this.options.debug) {
              _debug.log({
                node: this.selector,
                function: "unifySourceFormat()",
                message:
                  "Missing LZString Library or group.cache, no compression will occur on group: " +
                  group,
              });

              _debug.print();
            }
            // {/debug}
            groupSource.compression = false;
          }
        }
      }

      this.hasDynamicGroups =
        this.options.dynamic || !!this.dynamicGroups.length;

      return true;
    },

    init: function () {
      this.helper.executeCallback.call(this, this.options.callback.onInit, [
        this.node,
      ]);

      this.container = this.node.closest("." + this.options.selector.container);

      // {debug}
      if (this.options.debug) {
        _debug.log({
          node: this.selector,
          function: "init()",
          //'arguments': JSON.stringify(this.options),
          message: "OK - Typeahead activated on " + this.selector,
        });

        _debug.print();
      }
      // {/debug}
    },

    delegateEvents: function () {
      var scope = this,
        events = [
          "focus" + this.namespace,
          "input" + this.namespace,
          "propertychange" + this.namespace, // IE8 Fix
          "keydown" + this.namespace,
          "keyup" + this.namespace, // IE9 Fix
          "search" + this.namespace,
          "generate" + this.namespace,
        ];

      // #149 - Adding support for Mobiles
      $("html")
        .on("touchmove", function () {
          scope.hasDragged = true;
        })
        .on("touchstart", function () {
          scope.hasDragged = false;
        });

      this.node
        .closest("form")
        .on("submit", function (e) {
          if (
            scope.options.mustSelectItem &&
            scope.helper.isEmpty(scope.item)
          ) {
            e.preventDefault();
            return;
          }

          if (!scope.options.backdropOnFocus) {
            scope.hideLayout();
          }

          if (scope.options.callback.onSubmit) {
            return scope.helper.executeCallback.call(
              scope,
              scope.options.callback.onSubmit,
              [scope.node, this, scope.item || scope.items, e]
            );
          }
        })
        .on("reset", function () {
          // #221 - Reset Typeahead on form reset.
          // setTimeout to re-queue the `input.typeahead` event at the end
          setTimeout(function () {
            scope.node.trigger("input" + scope.namespace);
            // #243 - minLength: 0 opens the Typeahead results
            scope.hideLayout();
          });
        });

      // IE8 fix
      var preventNextEvent = false;

      // IE10/11 fix
      if (this.node.attr("placeholder") && (_isIE10 || _isIE11)) {
        var preventInputEvent = true;

        this.node.on("focusin focusout", function () {
          preventInputEvent = !!(!this.value && this.placeholder);
        });

        this.node.on("input", function (e) {
          if (preventInputEvent) {
            e.stopImmediatePropagation();
            preventInputEvent = false;
          }
        });
      }

      this.node.off(this.namespace).on(events.join(" "), function (e, data) {
        switch (e.type) {
          case "generate":
            scope.generateSource(Object.keys(scope.options.source));
            break;
          case "focus":
            if (scope.focusOnly) {
              scope.focusOnly = false;
              break;
            }
            if (scope.options.backdropOnFocus) {
              scope.buildBackdropLayout();
              scope.showLayout();
            }
            if (scope.options.searchOnFocus && !scope.item) {
              scope.deferred = $.Deferred();
              scope.assignQuery();
              scope.generateSource();
            }
            break;
          case "keydown":
            if (
              e.keyCode === 8 &&
              scope.options.multiselect &&
              scope.options.multiselect.cancelOnBackspace &&
              scope.query === "" &&
              scope.items.length
            ) {
              scope.cancelMultiselectItem(scope.items.length - 1, null, e);
            } else if (
              e.keyCode &&
              ~[9, 13, 27, 38, 39, 40].indexOf(e.keyCode)
            ) {
              preventNextEvent = true;
              scope.navigate(e);
            }
            break;
          case "keyup":
            if (
              _isIE9 &&
              scope.node[0].value.replace(/^\s+/, "").toString().length <
                scope.query.length
            ) {
              scope.node.trigger("input" + scope.namespace);
            }
            break;
          case "propertychange":
            if (preventNextEvent) {
              preventNextEvent = false;
              break;
            }
          case "input":
            scope.deferred = $.Deferred();
            scope.assignQuery();

            // #195 Trigger an onCancel event if the Typeahead is cleared
            if (scope.rawQuery === "" && scope.query === "") {
              e.originalEvent = data || {};
              scope.helper.executeCallback.call(
                scope,
                scope.options.callback.onCancel,
                [scope.node, e]
              );
            }

            scope.options.cancelButton && scope.toggleCancelButtonVisibility();

            if (
              scope.options.hint &&
              scope.hint.container &&
              scope.hint.container.val() !== ""
            ) {
              if (scope.hint.container.val().indexOf(scope.rawQuery) !== 0) {
                scope.hint.container.val("");
                if (scope.isContentEditable) {
                  scope.hint.container.text("");
                }
              }
            }

            if (scope.hasDynamicGroups) {
              scope.helper.typeWatch(function () {
                scope.generateSource();
              }, scope.options.delay);
            } else {
              scope.generateSource();
            }
            break;
          case "search":
            scope.searchResult();
            scope.buildLayout();

            if (
              scope.result.length ||
              (scope.searchGroups.length &&
                scope.options.emptyTemplate &&
                scope.query.length)
            ) {
              scope.showLayout();
            } else {
              scope.hideLayout();
            }

            scope.deferred && scope.deferred.resolve();
            break;
        }

        return scope.deferred && scope.deferred.promise();
      });

      if (this.options.generateOnLoad) {
        this.node.trigger("generate" + this.namespace);
      }
    },

    assignQuery: function () {
      if (this.isContentEditable) {
        this.rawQuery = this.node.text();
      } else {
        this.rawQuery = this.node.val().toString();
      }
      this.rawQuery = this.rawQuery.replace(/^\s+/, "");

      if (this.rawQuery !== this.query) {
        this.item = null;
        this.query = this.rawQuery;
      }
    },

    filterGenerateSource: function () {
      this.searchGroups = [];
      this.generateGroups = [];

      if (this.focusOnly && !this.options.multiselect) return;

      for (var group in this.options.source) {
        if (!this.options.source.hasOwnProperty(group)) continue;
        if (
          this.query.length >= this.options.source[group].minLength &&
          this.query.length <= this.options.source[group].maxLength
        ) {
          this.searchGroups.push(group);
          if (!this.options.source[group].dynamic && this.source[group]) {
            continue;
          }
          this.generateGroups.push(group);
        }
      }
    },

    generateSource: function (generateGroups) {
      this.filterGenerateSource();
      if (Array.isArray(generateGroups) && generateGroups.length) {
        this.generateGroups = generateGroups;
      } else if (!this.generateGroups.length) {
        this.node.trigger("search" + this.namespace);
        return;
      }

      this.requestGroups = [];
      this.generatedGroupCount = 0;
      this.options.loadingAnimation && this.container.addClass("loading");

      if (!this.helper.isEmpty(this.xhr)) {
        for (var i in this.xhr) {
          if (!this.xhr.hasOwnProperty(i)) continue;
          this.xhr[i].abort();
        }
        this.xhr = {};
      }

      var scope = this,
        group,
        groupData,
        groupSource,
        cache,
        compression,
        dataInStorage,
        isValidStorage;

      for (var i = 0, ii = this.generateGroups.length; i < ii; ++i) {
        group = this.generateGroups[i];
        groupSource = this.options.source[group];
        cache = groupSource.cache;
        compression = groupSource.compression;

        if (cache) {
          dataInStorage = window[cache].getItem(
            "TYPEAHEAD_" + this.selector + ":" + group
          );
          if (dataInStorage) {
            if (compression) {
              dataInStorage = LZString.decompressFromUTF16(dataInStorage);
            }

            isValidStorage = false;
            try {
              dataInStorage = JSON.parse(dataInStorage + "");

              if (
                dataInStorage.data &&
                dataInStorage.ttl > new Date().getTime()
              ) {
                this.populateSource(dataInStorage.data, group);
                isValidStorage = true;

                // {debug}
                if (this.options.debug) {
                  _debug.log({
                    node: this.selector,
                    function: "generateSource()",
                    message:
                      'Source for group "' + group + '" found in ' + cache,
                  });
                  _debug.print();
                }
                // {/debug}
              } else {
                window[cache].removeItem(
                  "TYPEAHEAD_" + this.selector + ":" + group
                );
              }
            } catch (error) {}

            if (isValidStorage) continue;
          }
        }

        if (groupSource.data && !groupSource.ajax) {
          // #198 Add support for async data source
          if (typeof groupSource.data === "function") {
            groupData = groupSource.data.call(this);
            if (Array.isArray(groupData)) {
              scope.populateSource(groupData, group);
            } else if (typeof groupData.promise === "function") {
              (function (group) {
                $.when(groupData).then(function (deferredData) {
                  if (deferredData && Array.isArray(deferredData)) {
                    scope.populateSource(deferredData, group);
                  }
                });
              })(group);
            }
          } else {
            this.populateSource($.extend(true, [], groupSource.data), group);
          }
          continue;
        }

        if (groupSource.ajax) {
          if (!this.requests[group]) {
            this.requests[group] = this.generateRequestObject(group);
          }
          this.requestGroups.push(group);
        }
      }

      if (this.requestGroups.length) {
        this.handleRequests();
      }

      return !!this.generateGroups.length;
    },

    generateRequestObject: function (group) {
      var scope = this,
        groupSource = this.options.source[group];

      var xhrObject = {
        request: {
          url: groupSource.ajax.url || null,
          dataType: "json",
          beforeSend: function (jqXHR, options) {
            // Important to call .abort() in case of dynamic requests
            scope.xhr[group] = jqXHR;

            var beforeSend =
              scope.requests[group].callback.beforeSend ||
              groupSource.ajax.beforeSend;
            typeof beforeSend === "function" &&
              beforeSend.apply(null, arguments);
          },
        },
        callback: {
          beforeSend: null,
          done: null,
          fail: null,
          then: null,
          always: null,
        },
        extra: {
          path: groupSource.ajax.path || null,
          group: group,
        },
        validForGroup: [group],
      };

      if (typeof groupSource.ajax !== "function") {
        if (groupSource.ajax instanceof Object) {
          xhrObject = this.extendXhrObject(xhrObject, groupSource.ajax);
        }

        if (Object.keys(this.options.source).length > 1) {
          for (var _group in this.requests) {
            if (!this.requests.hasOwnProperty(_group)) continue;
            if (this.requests[_group].isDuplicated) continue;

            if (
              xhrObject.request.url &&
              xhrObject.request.url === this.requests[_group].request.url
            ) {
              this.requests[_group].validForGroup.push(group);
              xhrObject.isDuplicated = true;
              delete xhrObject.validForGroup;
            }
          }
        }
      }

      return xhrObject;
    },

    extendXhrObject: function (xhrObject, groupRequest) {
      if (typeof groupRequest.callback === "object") {
        xhrObject.callback = groupRequest.callback;
        delete groupRequest.callback;
      }

      // #132 Fixed beforeSend when using a function as the request object
      if (typeof groupRequest.beforeSend === "function") {
        xhrObject.callback.beforeSend = groupRequest.beforeSend;
        delete groupRequest.beforeSend;
      }

      // Fixes #105 Allow user to define their beforeSend function.
      // Fixes #181 IE8 incompatibility
      xhrObject.request = $.extend(true, xhrObject.request, groupRequest);

      // JSONP needs a unique jsonpCallback to run concurrently
      if (
        xhrObject.request.dataType.toLowerCase() === "jsonp" &&
        !xhrObject.request.jsonpCallback
      ) {
        xhrObject.request.jsonpCallback = "callback_" + xhrObject.extra.group;
      }

      return xhrObject;
    },

    handleRequests: function () {
      var scope = this,
        group,
        requestsCount = this.requestGroups.length;

      if (
        this.helper.executeCallback.call(
          this,
          this.options.callback.onSendRequest,
          [this.node, this.query]
        ) === false
      ) {
        return;
      }

      for (var i = 0, ii = this.requestGroups.length; i < ii; ++i) {
        group = this.requestGroups[i];
        if (this.requests[group].isDuplicated) continue;

        (function (group, xhrObject) {
          if (typeof scope.options.source[group].ajax === "function") {
            var _groupRequest = scope.options.source[group].ajax.call(
              scope,
              scope.query
            );

            // Fixes #271 Data is cached inside the xhrObject
            xhrObject = scope.extendXhrObject(
              scope.generateRequestObject(group),
              typeof _groupRequest === "object" ? _groupRequest : {}
            );

            if (
              typeof xhrObject.request !== "object" ||
              !xhrObject.request.url
            ) {
              // {debug}
              if (scope.options.debug) {
                _debug.log({
                  node: scope.selector,
                  function: "handleRequests",
                  message:
                    'Source function must return an object containing ".url" key for group "' +
                    group +
                    '"',
                });
                _debug.print();
              }
              // {/debug}
              scope.populateSource([], group);
              return;
            }
            scope.requests[group] = xhrObject;
          }

          var _request,
            _isExtended = false, // Prevent the main request from being changed
            _groupData = {};

          if (~xhrObject.request.url.indexOf("{{query}}")) {
            if (!_isExtended) {
              xhrObject = $.extend(true, {}, xhrObject);
              _isExtended = true;
            }
            // #184 Invalid encoded characters on dynamic requests for `{{query}}`
            xhrObject.request.url = xhrObject.request.url.replace(
              "{{query}}",
              encodeURIComponent(scope.query)
            );
          }

          if (xhrObject.request.data) {
            for (var i in xhrObject.request.data) {
              if (!xhrObject.request.data.hasOwnProperty(i)) continue;
              if (~String(xhrObject.request.data[i]).indexOf("{{query}}")) {
                if (!_isExtended) {
                  xhrObject = $.extend(true, {}, xhrObject);
                  _isExtended = true;
                }
                // jQuery handles encodeURIComponent when the query is inside the data object
                xhrObject.request.data[i] = xhrObject.request.data[i].replace(
                  "{{query}}",
                  scope.query
                );
                break;
              }
            }
          }

          $.ajax(xhrObject.request)
            .done(function (data, textStatus, jqXHR) {
              var _group;

              for (
                var i = 0, ii = xhrObject.validForGroup.length;
                i < ii;
                i++
              ) {
                _group = xhrObject.validForGroup[i];
                _request = scope.requests[_group];

                if (_request.callback.done instanceof Function) {
                  _groupData[_group] = _request.callback.done.call(
                    scope,
                    data,
                    textStatus,
                    jqXHR
                  );

                  // {debug}
                  if (
                    !Array.isArray(_groupData[_group]) ||
                    typeof _groupData[_group] !== "object"
                  ) {
                    if (scope.options.debug) {
                      _debug.log({
                        node: scope.selector,
                        function: "Ajax.callback.done()",
                        message: "Invalid returned data has to be an Array",
                      });
                      _debug.print();
                    }
                  }
                  // {/debug}
                }
              }
            })
            .fail(function (jqXHR, textStatus, errorThrown) {
              for (
                var i = 0, ii = xhrObject.validForGroup.length;
                i < ii;
                i++
              ) {
                _request = scope.requests[xhrObject.validForGroup[i]];
                _request.callback.fail instanceof Function &&
                  _request.callback.fail.call(
                    scope,
                    jqXHR,
                    textStatus,
                    errorThrown
                  );
              }

              // {debug}
              if (scope.options.debug) {
                _debug.log({
                  node: scope.selector,
                  function: "Ajax.callback.fail()",
                  arguments: JSON.stringify(xhrObject.request),
                  message: textStatus,
                });

                console.log(errorThrown);

                _debug.print();
              }
              // {/debug}
            })
            .always(function (data, textStatus, jqXHR) {
              var _group;
              for (
                var i = 0, ii = xhrObject.validForGroup.length;
                i < ii;
                i++
              ) {
                _group = xhrObject.validForGroup[i];
                _request = scope.requests[_group];
                _request.callback.always instanceof Function &&
                  _request.callback.always.call(scope, data, textStatus, jqXHR);

                // #248, #303 Aborted requests would call populate with invalid data
                if (typeof jqXHR !== "object") return;

                // #265 Modified data from ajax.callback.done is not being registered (use of _groupData[_group])
                scope.populateSource(
                  (data !== null && typeof data.promise === "function" && []) ||
                    _groupData[_group] ||
                    data,
                  _request.extra.group,
                  _request.extra.path || _request.request.path
                );

                requestsCount -= 1;
                if (requestsCount === 0) {
                  scope.helper.executeCallback.call(
                    scope,
                    scope.options.callback.onReceiveRequest,
                    [scope.node, scope.query]
                  );
                }
              }
            })
            .then(function (jqXHR, textStatus) {
              for (
                var i = 0, ii = xhrObject.validForGroup.length;
                i < ii;
                i++
              ) {
                _request = scope.requests[xhrObject.validForGroup[i]];
                _request.callback.then instanceof Function &&
                  _request.callback.then.call(scope, jqXHR, textStatus);
              }
            });
        })(group, this.requests[group]);
      }
    },

    /**
     * Build the source groups to be cycled for matched results
     *
     * @param {Array} data Array of Strings or Array of Objects
     * @param {String} group
     * @param {String} [path]
     * @return {*}
     */
    populateSource: function (data, group, path) {
      var scope = this,
        groupSource = this.options.source[group],
        extraData = groupSource.ajax && groupSource.data;

      if (path && typeof path === "string") {
        data = this.helper.namespace.call(this, path, data);
      }

      if (typeof data === "undefined") {
        // {debug}
        if (this.options.debug) {
          _debug.log({
            node: this.selector,
            function: "populateSource()",
            arguments: path,
            message: "Invalid data path.",
          });

          _debug.print();
        }
        // {/debug}
      }

      if (!Array.isArray(data)) {
        // {debug}
        if (this.options.debug) {
          _debug.log({
            node: this.selector,
            function: "populateSource()",
            arguments: JSON.stringify({ group: group }),
            message: "Invalid data type, must be Array type.",
          });
          _debug.print();
        }
        // {/debug}
        data = [];
      }

      if (extraData) {
        if (typeof extraData === "function") {
          extraData = extraData();
        }

        if (Array.isArray(extraData)) {
          data = data.concat(extraData);
        } else {
          // {debug}
          if (this.options.debug) {
            _debug.log({
              node: this.selector,
              function: "populateSource()",
              arguments: JSON.stringify(extraData),
              message:
                "WARNING - this.options.source." +
                group +
                ".data Must be an Array or a function that returns an Array.",
            });

            _debug.print();
          }
          // {/debug}
        }
      }

      var tmpObj,
        display = groupSource.display
          ? groupSource.display[0] === "compiled"
            ? groupSource.display[1]
            : groupSource.display[0]
          : this.options.display[0] === "compiled"
          ? this.options.display[1]
          : this.options.display[0];

      for (var i = 0, ii = data.length; i < ii; i++) {
        if (data[i] === null || typeof data[i] === "boolean") {
          // {debug}
          if (this.options.debug) {
            _debug.log({
              node: this.selector,
              function: "populateSource()",
              message:
                "WARNING - NULL/BOOLEAN value inside " +
                group +
                "! The data was skipped.",
            });

            _debug.print();
          }
          // {/debug}
          continue;
        }
        if (typeof data[i] === "string") {
          tmpObj = {};
          tmpObj[display] = data[i];
          data[i] = tmpObj;
        }
        data[i].group = group;
      }

      if (!this.hasDynamicGroups && this.dropdownFilter.dynamic.length) {
        var key,
          value,
          tmpValues = {};

        for (var i = 0, ii = data.length; i < ii; i++) {
          for (
            var k = 0, kk = this.dropdownFilter.dynamic.length;
            k < kk;
            k++
          ) {
            key = this.dropdownFilter.dynamic[k].key;

            value = data[i][key];
            if (!value) continue;
            if (!this.dropdownFilter.dynamic[k].value) {
              this.dropdownFilter.dynamic[k].value = [];
            }
            if (!tmpValues[key]) {
              tmpValues[key] = [];
            }
            if (!~tmpValues[key].indexOf(value.toLowerCase())) {
              tmpValues[key].push(value.toLowerCase());
              this.dropdownFilter.dynamic[k].value.push(value);
            }
          }
        }
      }

      if (this.options.correlativeTemplate) {
        var template = groupSource.template || this.options.template,
          compiledTemplate = "";

        if (typeof template === "function") {
          template = template.call(this, "", {});
        }

        if (!template) {
          // {debug}
          if (this.options.debug) {
            _debug.log({
              node: this.selector,
              function: "populateSource()",
              arguments: String(group),
              message:
                "WARNING - this.options.correlativeTemplate is enabled but no template was found.",
            });

            _debug.print();
          }
          // {/debug}
        } else {
          // #109 correlativeTemplate can be an array of display keys instead of the complete template
          if (Array.isArray(this.options.correlativeTemplate)) {
            for (
              var i = 0, ii = this.options.correlativeTemplate.length;
              i < ii;
              i++
            ) {
              compiledTemplate +=
                "{{" + this.options.correlativeTemplate[i] + "}} ";
            }
          } else {
            // Strip down the html tags, #351 if the template needs "<>" use html entities instead &#60;{{email}}&#62;
            compiledTemplate = template
              .replace(/<.+?>/g, " ")
              .replace(/\s{2,}/, " ")
              .trim();
          }

          for (var i = 0, ii = data.length; i < ii; i++) {
            // Fix #351, convert htmlEntities from the template string
            data[i].compiled = $("<textarea />")
              .html(
                compiledTemplate
                  .replace(
                    /\{\{([\w\-\.]+)(?:\|(\w+))?}}/g,
                    function (match, index) {
                      return scope.helper.namespace.call(
                        scope,
                        index,
                        data[i],
                        "get",
                        ""
                      );
                    }
                  )
                  .trim()
              )
              .text();
          }

          if (groupSource.display) {
            if (!~groupSource.display.indexOf("compiled")) {
              groupSource.display.unshift("compiled");
            }
          } else if (!~this.options.display.indexOf("compiled")) {
            this.options.display.unshift("compiled");
          }
        }
      }

      if (this.options.callback.onPopulateSource) {
        data = this.helper.executeCallback.call(
          this,
          this.options.callback.onPopulateSource,
          [this.node, data, group, path]
        );

        // {debug}
        if (this.options.debug) {
          if (!data || !Array.isArray(data)) {
            _debug.log({
              node: this.selector,
              function: "callback.populateSource()",
              message:
                'callback.onPopulateSource must return the "data" parameter',
            });

            _debug.print();
          }
        }
        // {/debug}
      }

      // Save the data inside tmpSource to re-order once every requests are completed
      this.tmpSource[group] = (Array.isArray(data) && data) || [];

      var cache = this.options.source[group].cache,
        compression = this.options.source[group].compression,
        ttl = this.options.source[group].ttl || this.options.ttl;

      if (
        cache &&
        !window[cache].getItem("TYPEAHEAD_" + this.selector + ":" + group)
      ) {
        if (this.options.callback.onCacheSave) {
          data = this.helper.executeCallback.call(
            this,
            this.options.callback.onCacheSave,
            [this.node, data, group, path]
          );

          // {debug}
          if (this.options.debug) {
            if (!data || !Array.isArray(data)) {
              _debug.log({
                node: this.selector,
                function: "callback.populateSource()",
                message:
                  'callback.onCacheSave must return the "data" parameter',
              });

              _debug.print();
            }
          }
          // {/debug}
        }

        var storage = JSON.stringify({
          data: data,
          ttl: new Date().getTime() + ttl,
        });

        if (compression) {
          storage = LZString.compressToUTF16(storage);
        }

        window[cache].setItem(
          "TYPEAHEAD_" + this.selector + ":" + group,
          storage
        );
      }

      this.incrementGeneratedGroup();
    },

    incrementGeneratedGroup: function () {
      this.generatedGroupCount++;
      if (this.generatedGroupCount !== this.generateGroups.length) {
        return;
      }

      this.xhr = {};

      for (var i = 0, ii = this.generateGroups.length; i < ii; i++) {
        this.source[this.generateGroups[i]] =
          this.tmpSource[this.generateGroups[i]];
      }

      if (!this.hasDynamicGroups) {
        this.buildDropdownItemLayout("dynamic");
      }

      this.options.loadingAnimation && this.container.removeClass("loading");
      this.node.trigger("search" + this.namespace);
    },

    /**
     * Key Navigation
     * tab 9: if option is enabled, blur Typeahead
     * Up 38: select previous item, skip "group" item
     * Down 40: select next item, skip "group" item
     * Right 39: change charAt, if last char fill hint (if options is true)
     * Esc 27: clears input (is not empty) / blur (if empty)
     * Enter 13: Select item + submit search
     *
     * @param {Object} e Event object
     * @returns {*}
     */
    navigate: function (e) {
      this.helper.executeCallback.call(
        this,
        this.options.callback.onNavigateBefore,
        [this.node, this.query, e]
      );

      if (e.keyCode === 27) {
        // #166 Different browsers do not have the same behaviors by default, lets enforce what we want instead
        e.preventDefault();
        if (this.query.length) {
          this.resetInput();
          this.node.trigger("input" + this.namespace, [e]);
        } else {
          this.node.blur();
          this.hideLayout();
        }
        return;
      }

      if (!this.result.length) return;

      var itemList = this.resultContainer
          .find("." + this.options.selector.item)
          .not("[disabled]"),
        activeItem = itemList.filter(".active"),
        activeItemIndex = activeItem[0] ? itemList.index(activeItem) : null,
        activeDataIndex = activeItem[0] ? activeItem.attr("data-index") : null,
        newActiveItemIndex = null,
        newActiveDataIndex = null;

      this.clearActiveItem();

      this.helper.executeCallback.call(this, this.options.callback.onLeave, [
        this.node,
        (activeItemIndex !== null && itemList.eq(activeItemIndex)) || undefined,
        (activeDataIndex !== null && this.result[activeDataIndex]) || undefined,
        e,
      ]);

      if (e.keyCode === 13) {
        // Chrome needs preventDefault else the input search event is triggered
        e.preventDefault();
        if (activeItem.length > 0) {
          // #311 When href is defined and "enter" is pressed, it needs to act as a "clicked" link
          if (activeItem.find("a:first")[0].href === "javascript:;") {
            activeItem.find("a:first").trigger("click", e);
          } else {
            activeItem.find("a:first")[0].click();
          }
        } else {
          this.node.closest("form").trigger("submit");
        }
        return;
      }

      if (e.keyCode === 39) {
        if (activeItemIndex !== null) {
          itemList.eq(activeItemIndex).find("a:first")[0].click();
        } else if (
          this.options.hint &&
          this.hint.container.val() !== "" &&
          this.helper.getCaret(this.node[0]) >= this.query.length
        ) {
          itemList
            .filter('[data-index="' + this.hintIndex + '"]')
            .find("a:first")[0]
            .click();
        }
        return;
      }

      // #284 Blur Typeahead when "Tab" key is pressed
      // #326 Improve Up / Down / Tab navigation to have only 1 "selected" item
      if (e.keyCode === 9) {
        if (this.options.blurOnTab) {
          this.hideLayout();
        } else {
          if (activeItem.length > 0) {
            if (activeItemIndex + 1 < itemList.length) {
              e.preventDefault();
              newActiveItemIndex = activeItemIndex + 1;
              this.addActiveItem(itemList.eq(newActiveItemIndex));
            } else {
              this.hideLayout();
            }
          } else {
            if (itemList.length) {
              e.preventDefault();
              newActiveItemIndex = 0;
              this.addActiveItem(itemList.first());
            } else {
              this.hideLayout();
            }
          }
        }
      } else if (e.keyCode === 38) {
        e.preventDefault();

        if (activeItem.length > 0) {
          if (activeItemIndex - 1 >= 0) {
            newActiveItemIndex = activeItemIndex - 1;
            this.addActiveItem(itemList.eq(newActiveItemIndex));
          }
        } else if (itemList.length) {
          newActiveItemIndex = itemList.length - 1;
          this.addActiveItem(itemList.last());
        }
      } else if (e.keyCode === 40) {
        e.preventDefault();

        if (activeItem.length > 0) {
          if (activeItemIndex + 1 < itemList.length) {
            newActiveItemIndex = activeItemIndex + 1;
            this.addActiveItem(itemList.eq(newActiveItemIndex));
          }
        } else if (itemList.length) {
          newActiveItemIndex = 0;
          this.addActiveItem(itemList.first());
        }
      }

      newActiveDataIndex =
        newActiveItemIndex !== null
          ? itemList.eq(newActiveItemIndex).attr("data-index")
          : null;

      this.helper.executeCallback.call(this, this.options.callback.onEnter, [
        this.node,
        (newActiveItemIndex !== null && itemList.eq(newActiveItemIndex)) ||
          undefined,
        (newActiveDataIndex !== null && this.result[newActiveDataIndex]) ||
          undefined,
        e,
      ]);

      // #115 Prevent the input from changing when navigating (arrow up / down) the results
      if (e.preventInputChange && ~[38, 40].indexOf(e.keyCode)) {
        this.buildHintLayout(
          newActiveDataIndex !== null && newActiveDataIndex < this.result.length
            ? [this.result[newActiveDataIndex]]
            : null
        );
      }

      if (this.options.hint && this.hint.container) {
        this.hint.container.css(
          "color",
          e.preventInputChange
            ? this.hint.css.color
            : (newActiveDataIndex === null && this.hint.css.color) ||
                this.hint.container.css("background-color") ||
                "fff"
        );
      }

      var nodeValue =
        newActiveDataIndex === null || e.preventInputChange
          ? this.rawQuery
          : this.getTemplateValue.call(this, this.result[newActiveDataIndex]);

      this.node.val(nodeValue);
      if (this.isContentEditable) {
        this.node.text(nodeValue);
      }

      this.helper.executeCallback.call(
        this,
        this.options.callback.onNavigateAfter,
        [
          this.node,
          itemList,
          (newActiveItemIndex !== null &&
            itemList.eq(newActiveItemIndex).find("a:first")) ||
            undefined,
          (newActiveDataIndex !== null && this.result[newActiveDataIndex]) ||
            undefined,
          this.query,
          e,
        ]
      );
    },

    getTemplateValue: function (item) {
      if (!item) return;
      var templateValue =
        (item.group && this.options.source[item.group].templateValue) ||
        this.options.templateValue;
      if (typeof templateValue === "function") {
        templateValue = templateValue.call(this);
      }
      if (!templateValue) {
        return this.helper.namespace
          .call(this, item.matchedKey, item)
          .toString();
      }
      var scope = this;

      return templateValue.replace(
        /\{\{([\w\-.]+)}}/gi,
        function (match, index) {
          return scope.helper.namespace.call(scope, index, item, "get", "");
        }
      );
    },

    clearActiveItem: function () {
      this.resultContainer
        .find("." + this.options.selector.item)
        .removeClass("active");
    },

    addActiveItem: function (item) {
      item.addClass("active");
    },

    searchResult: function () {
      this.resetLayout();

      if (
        this.helper.executeCallback.call(this, this.options.callback.onSearch, [
          this.node,
          this.query,
        ]) === false
      )
        return;

      if (
        this.searchGroups.length &&
        !(
          this.options.multiselect &&
          this.options.multiselect.limit &&
          this.items.length >= this.options.multiselect.limit
        )
      ) {
        this.searchResultData();
      }

      this.helper.executeCallback.call(this, this.options.callback.onResult, [
        this.node,
        this.query,
        this.result,
        this.resultCount,
        this.resultCountPerGroup,
      ]);

      if (this.isDropdownEvent) {
        this.helper.executeCallback.call(
          this,
          this.options.callback.onDropdownFilter,
          [this.node, this.query, this.filters.dropdown, this.result]
        );
        this.isDropdownEvent = false;
      }
    },

    searchResultData: function () {
      var scope = this,
        group,
        groupBy = this.groupBy,
        groupReference = null,
        item,
        match,
        comparedDisplay,
        comparedQuery = this.query.toLowerCase(),
        maxItem = this.options.maxItem,
        maxItemPerGroup = this.options.maxItemPerGroup,
        hasDynamicFilters =
          this.filters.dynamic && !this.helper.isEmpty(this.filters.dynamic),
        displayKeys,
        displayValue,
        missingDisplayKey = {},
        groupFilter,
        groupFilterResult,
        groupMatcher,
        groupMatcherResult,
        matcher =
          typeof this.options.matcher === "function" && this.options.matcher,
        correlativeMatch,
        correlativeQuery,
        correlativeDisplay;

      if (this.options.accent) {
        comparedQuery = this.helper.removeAccent.call(this, comparedQuery);
      }

      for (var i = 0, ii = this.searchGroups.length; i < ii; ++i) {
        group = this.searchGroups[i];

        if (
          this.filters.dropdown &&
          this.filters.dropdown.key === "group" &&
          this.filters.dropdown.value !== group
        )
          continue;

        groupFilter =
          typeof this.options.source[group].filter !== "undefined"
            ? this.options.source[group].filter
            : this.options.filter;
        groupMatcher =
          (typeof this.options.source[group].matcher === "function" &&
            this.options.source[group].matcher) ||
          matcher;

        for (var k = 0, kk = this.source[group].length; k < kk; k++) {
          if (
            this.resultItemCount >= maxItem &&
            !this.options.callback.onResult
          )
            break;
          if (
            hasDynamicFilters &&
            !this.dynamicFilter.validate.apply(this, [this.source[group][k]])
          )
            continue;

          item = this.source[group][k];
          // Validation over null item
          if (item === null || typeof item === "boolean") continue;
          if (this.options.multiselect && !this.isMultiselectUniqueData(item))
            continue;

          // dropdownFilter by custom groups
          if (
            this.filters.dropdown &&
            (item[this.filters.dropdown.key] || "").toLowerCase() !==
              (this.filters.dropdown.value || "").toLowerCase()
          ) {
            continue;
          }

          groupReference =
            groupBy === "group"
              ? group
              : item[groupBy]
              ? item[groupBy]
              : item.group;

          if (groupReference && !this.tmpResult[groupReference]) {
            this.tmpResult[groupReference] = [];
            this.resultCountPerGroup[groupReference] = 0;
          }

          if (maxItemPerGroup) {
            if (
              groupBy === "group" &&
              this.tmpResult[groupReference].length >= maxItemPerGroup &&
              !this.options.callback.onResult
            ) {
              break;
            }
          }

          displayKeys =
            this.options.source[group].display || this.options.display;
          for (var v = 0, vv = displayKeys.length; v < vv; ++v) {
            // #286 option.filter: false shouldn't bother about the option.display keys
            if (groupFilter !== false) {
              // #183 Allow searching for deep source object keys
              displayValue = /\./.test(displayKeys[v])
                ? this.helper.namespace.call(this, displayKeys[v], item)
                : item[displayKeys[v]];

              // #182 Continue looping if empty or undefined key
              if (typeof displayValue === "undefined" || displayValue === "") {
                // {debug}
                if (this.options.debug) {
                  missingDisplayKey[v] = {
                    display: displayKeys[v],
                    data: item,
                  };
                }
                // {/debug}
                continue;
              }

              displayValue = this.helper.cleanStringFromScript(displayValue);
            }

            if (typeof groupFilter === "function") {
              groupFilterResult = groupFilter.call(this, item, displayValue);

              // return undefined to skip to next item
              // return false to attempt the matching function on the next displayKey
              // return true to add the item to the result list
              // return item object to modify the item and add it to the result list

              if (groupFilterResult === undefined) break;
              if (!groupFilterResult) continue;
              if (typeof groupFilterResult === "object") {
                item = groupFilterResult;
              }
            }

            if (~[undefined, true].indexOf(groupFilter)) {
              comparedDisplay = displayValue;
              comparedDisplay = comparedDisplay.toString().toLowerCase();

              if (this.options.accent) {
                comparedDisplay = this.helper.removeAccent.call(
                  this,
                  comparedDisplay
                );
              }

              match = comparedDisplay.indexOf(comparedQuery);

              if (
                this.options.correlativeTemplate &&
                displayKeys[v] === "compiled" &&
                match < 0 &&
                /\s/.test(comparedQuery)
              ) {
                correlativeMatch = true;
                correlativeQuery = comparedQuery.split(" ");
                correlativeDisplay = comparedDisplay;
                for (var x = 0, xx = correlativeQuery.length; x < xx; x++) {
                  if (correlativeQuery[x] === "") continue;
                  if (!~correlativeDisplay.indexOf(correlativeQuery[x])) {
                    correlativeMatch = false;
                    break;
                  }
                  correlativeDisplay = correlativeDisplay.replace(
                    correlativeQuery[x],
                    ""
                  );
                }
              }

              if (match < 0 && !correlativeMatch) continue;
              if (this.options.offset && match !== 0) continue;

              if (groupMatcher) {
                groupMatcherResult = groupMatcher.call(
                  this,
                  item,
                  displayValue
                );

                // return undefined to skip to next item
                // return false to attempt the matching function on the next displayKey
                // return true to add the item to the result list
                // return item object to modify the item and add it to the result list

                if (groupMatcherResult === undefined) break;
                if (!groupMatcherResult) continue;
                if (typeof groupMatcherResult === "object") {
                  item = groupMatcherResult;
                }
              }
            }

            this.resultCount++;
            this.resultCountPerGroup[groupReference]++;

            if (this.resultItemCount < maxItem) {
              if (
                maxItemPerGroup &&
                this.tmpResult[groupReference].length >= maxItemPerGroup
              ) {
                break;
              }

              this.tmpResult[groupReference].push(
                $.extend(true, { matchedKey: displayKeys[v] }, item)
              );
              this.resultItemCount++;
            }
            break;
          }

          if (!this.options.callback.onResult) {
            if (this.resultItemCount >= maxItem) {
              break;
            }
            if (
              maxItemPerGroup &&
              this.tmpResult[groupReference].length >= maxItemPerGroup
            ) {
              if (groupBy === "group") {
                break;
              }
            }
          }
        }
      }

      // {debug}
      if (this.options.debug) {
        if (!this.helper.isEmpty(missingDisplayKey)) {
          _debug.log({
            node: this.selector,
            function: "searchResult()",
            arguments: JSON.stringify(missingDisplayKey),
            message:
              "Missing keys for display, make sure options.display is set properly.",
          });

          _debug.print();
        }
      }
      // {/debug}

      if (this.options.order) {
        var displayKeys = [],
          displayKey;

        for (var group in this.tmpResult) {
          if (!this.tmpResult.hasOwnProperty(group)) continue;
          for (var i = 0, ii = this.tmpResult[group].length; i < ii; i++) {
            displayKey =
              this.options.source[this.tmpResult[group][i].group].display ||
              this.options.display;
            if (!~displayKeys.indexOf(displayKey[0])) {
              displayKeys.push(displayKey[0]);
            }
          }
          this.tmpResult[group].sort(
            scope.helper.sort(
              displayKeys,
              scope.options.order === "asc",
              function (a) {
                return a.toString().toUpperCase();
              }
            )
          );
        }
      }

      var concatResults = [],
        groupOrder = [];

      if (typeof this.options.groupOrder === "function") {
        groupOrder = this.options.groupOrder.apply(this, [
          this.node,
          this.query,
          this.tmpResult,
          this.resultCount,
          this.resultCountPerGroup,
        ]);
      } else if (Array.isArray(this.options.groupOrder)) {
        groupOrder = this.options.groupOrder;
      } else if (
        typeof this.options.groupOrder === "string" &&
        ~["asc", "desc"].indexOf(this.options.groupOrder)
      ) {
        groupOrder = Object.keys(this.tmpResult).sort(
          scope.helper.sort(
            [],
            scope.options.groupOrder === "asc",
            function (a) {
              return a.toString().toUpperCase();
            }
          )
        );
      } else {
        groupOrder = Object.keys(this.tmpResult);
      }

      for (var i = 0, ii = groupOrder.length; i < ii; i++) {
        concatResults = concatResults.concat(
          this.tmpResult[groupOrder[i]] || []
        );
      }

      // #286 groupTemplate option was deleting group reference Array
      this.groups = JSON.parse(JSON.stringify(groupOrder));

      this.result = concatResults;
    },

    buildLayout: function () {
      this.buildHtmlLayout();

      this.buildBackdropLayout();

      this.buildHintLayout();

      if (this.options.callback.onLayoutBuiltBefore) {
        this.helper.executeCallback.call(
          this,
          this.options.callback.onLayoutBuiltBefore,
          [this.node, this.query, this.result, this.resultHtml]
        );
      }

      if (this.resultHtml instanceof $) {
        this.resultContainer.html(this.resultHtml);
      }

      if (this.options.callback.onLayoutBuiltAfter) {
        this.helper.executeCallback.call(
          this,
          this.options.callback.onLayoutBuiltAfter,
          [this.node, this.query, this.result]
        );
      }
    },

    buildHtmlLayout: function () {
      // #150 Add the option to have no resultList but still perform the search and trigger the callbacks
      if (this.options.resultContainer === false) return;

      if (!this.resultContainer) {
        this.resultContainer = $("<div/>", {
          class: this.options.selector.result,
        });

        this.container.append(this.resultContainer);
      }

      var emptyTemplate;
      if (!this.result.length) {
        if (
          this.options.multiselect &&
          this.options.multiselect.limit &&
          this.items.length >= this.options.multiselect.limit
        ) {
          if (this.options.multiselect.limitTemplate) {
            emptyTemplate =
              typeof this.options.multiselect.limitTemplate === "function"
                ? this.options.multiselect.limitTemplate.call(this, this.query)
                : this.options.multiselect.limitTemplate.replace(
                    /\{\{query}}/gi,
                    $("<div>")
                      .text(this.helper.cleanStringFromScript(this.query))
                      .html()
                  );
          } else {
            emptyTemplate =
              "Can't select more than " + this.items.length + " items.";
          }
        } else if (this.options.emptyTemplate && this.query !== "") {
          emptyTemplate =
            typeof this.options.emptyTemplate === "function"
              ? this.options.emptyTemplate.call(this, this.query)
              : this.options.emptyTemplate.replace(
                  /\{\{query}}/gi,
                  $("<div>")
                    .text(this.helper.cleanStringFromScript(this.query))
                    .html()
                );
        } else {
          return;
        }
      }

      var _query = this.query.toLowerCase();
      if (this.options.accent) {
        _query = this.helper.removeAccent.call(this, _query);
      }

      var scope = this,
        groupTemplate = this.groupTemplate || "<ul></ul>",
        hasEmptyTemplate = false;

      if (this.groupTemplate) {
        groupTemplate = $(
          groupTemplate.replace(
            /<([^>]+)>\{\{(.+?)}}<\/[^>]+>/g,
            function (match, tag, group, offset, string) {
              var template = "",
                groups = group === "group" ? scope.groups : [group];

              if (!scope.result.length) {
                if (hasEmptyTemplate === true) return "";
                hasEmptyTemplate = true;

                return (
                  "<" +
                  tag +
                  ' class="' +
                  scope.options.selector.empty +
                  '">' +
                  emptyTemplate +
                  "</" +
                  tag +
                  ">"
                );
              }

              for (var i = 0, ii = groups.length; i < ii; ++i) {
                template +=
                  "<" +
                  tag +
                  ' data-group-template="' +
                  groups[i] +
                  '"><ul></ul></' +
                  tag +
                  ">";
              }

              return template;
            }
          )
        );
      } else {
        groupTemplate = $(groupTemplate);
        if (!this.result.length) {
          groupTemplate.append(
            emptyTemplate instanceof $
              ? emptyTemplate
              : '<li class="' +
                  scope.options.selector.empty +
                  '">' +
                  emptyTemplate +
                  "</li>"
          );
        }
      }

      groupTemplate.addClass(
        this.options.selector.list +
          (this.helper.isEmpty(this.result) ? " empty" : "")
      );

      var _group,
        _groupTemplate,
        _item,
        _href,
        _liHtml,
        _template,
        _aHtml,
        _display,
        _displayKeys,
        _displayValue,
        _unusedGroups =
          (this.groupTemplate && this.result.length && scope.groups) || [],
        _tmpIndexOf;

      for (var i = 0, ii = this.result.length; i < ii; ++i) {
        _item = this.result[i];
        _group = _item.group;
        _href =
          (!this.options.multiselect &&
            this.options.source[_item.group].href) ||
          this.options.href;
        _display = [];
        _displayKeys =
          this.options.source[_item.group].display || this.options.display;

        if (this.options.group) {
          _group = _item[this.options.group.key];
          if (this.options.group.template) {
            if (typeof this.options.group.template === "function") {
              _groupTemplate = this.options.group.template.call(this, _item);
            } else if (typeof this.options.group.template === "string") {
              _groupTemplate = this.options.group.template.replace(
                /\{\{([\w\-\.]+)}}/gi,
                function (match, index) {
                  return scope.helper.namespace.call(
                    scope,
                    index,
                    _item,
                    "get",
                    ""
                  );
                }
              );
            }
          }

          if (!groupTemplate.find('[data-search-group="' + _group + '"]')[0]) {
            (this.groupTemplate
              ? groupTemplate.find('[data-group-template="' + _group + '"] ul')
              : groupTemplate
            ).append(
              $("<li/>", {
                class: scope.options.selector.group,
                html: $("<a/>", {
                  href: "javascript:;",
                  html: _groupTemplate || _group,
                  tabindex: -1,
                }),
                "data-search-group": _group,
              })
            );
          }
        }

        if (this.groupTemplate && _unusedGroups.length) {
          _tmpIndexOf = _unusedGroups.indexOf(_group || _item.group);
          if (~_tmpIndexOf) {
            _unusedGroups.splice(_tmpIndexOf, 1);
          }
        }

        _liHtml = $("<li/>", {
          class:
            scope.options.selector.item +
            " " +
            scope.options.selector.group +
            "-" +
            this.helper.slugify.call(this, _group),
          disabled: _item.disabled ? true : false,
          "data-group": _group,
          "data-index": i,
          html: $("<a/>", {
            href:
              _href && !_item.disabled
                ? (function (href, item) {
                    return (item.href = scope.generateHref.call(
                      scope,
                      href,
                      item
                    ));
                  })(_href, _item)
                : "javascript:;",
            html: function () {
              _template =
                (_item.group && scope.options.source[_item.group].template) ||
                scope.options.template;

              if (_template) {
                if (typeof _template === "function") {
                  _template = _template.call(scope, scope.query, _item);
                }

                _aHtml = _template.replace(
                  /\{\{([^\|}]+)(?:\|([^}]+))*}}/gi,
                  function (match, index, options) {
                    var value = scope.helper.cleanStringFromScript(
                      String(
                        scope.helper.namespace.call(
                          scope,
                          index,
                          _item,
                          "get",
                          ""
                        )
                      )
                    );

                    // #151 Slugify should be an option, not enforced
                    options = (options && options.split("|")) || [];
                    if (~options.indexOf("slugify")) {
                      value = scope.helper.slugify.call(scope, value);
                    }

                    if (!~options.indexOf("raw")) {
                      if (
                        scope.options.highlight === true &&
                        _query &&
                        ~_displayKeys.indexOf(index)
                      ) {
                        value = scope.helper.highlight.call(
                          scope,
                          value,
                          _query.split(" "),
                          scope.options.accent
                        );
                      }
                    }
                    return value;
                  }
                );
              } else {
                for (var i = 0, ii = _displayKeys.length; i < ii; i++) {
                  _displayValue = /\./.test(_displayKeys[i])
                    ? scope.helper.namespace.call(
                        scope,
                        _displayKeys[i],
                        _item,
                        "get",
                        ""
                      )
                    : _item[_displayKeys[i]];

                  if (
                    typeof _displayValue === "undefined" ||
                    _displayValue === ""
                  )
                    continue;

                  _display.push(_displayValue);
                }

                _aHtml =
                  '<span class="' +
                  scope.options.selector.display +
                  '">' +
                  scope.helper.cleanStringFromScript(
                    String(_display.join(" "))
                  ) +
                  "</span>";
              }

              if (
                (scope.options.highlight === true && _query && !_template) ||
                scope.options.highlight === "any"
              ) {
                _aHtml = scope.helper.highlight.call(
                  scope,
                  _aHtml,
                  _query.split(" "),
                  scope.options.accent
                );
              }

              $(this).append(_aHtml);
            },
          }),
        });

        (function (i, item, liHtml) {
          liHtml.on("click", function (e, originalEvent) {
            if (item.disabled) {
              e.preventDefault();
              return;
            }

            // #208 - Attach "keyboard Enter" original event
            if (originalEvent && typeof originalEvent === "object") {
              e.originalEvent = originalEvent;
            }

            if (scope.options.mustSelectItem && scope.helper.isEmpty(item)) {
              e.preventDefault();
              return;
            }

            if (scope.options.multiselect) {
              scope.items.push(item);
              scope.comparedItems.push(scope.getMultiselectComparedData(item));
            } else {
              scope.item = item;
            }

            if (
              scope.helper.executeCallback.call(
                scope,
                scope.options.callback.onClickBefore,
                [scope.node, $(this), item, e]
              ) === false
            )
              return;

            if (
              (e.originalEvent && e.originalEvent.defaultPrevented) ||
              e.isDefaultPrevented()
            )
              return;

            var templateValue = scope.getTemplateValue.call(scope, item);

            if (scope.options.multiselect) {
              scope.query = scope.rawQuery = "";
              scope.addMultiselectItemLayout(templateValue);
            } else {
              scope.focusOnly = true;
              scope.query = scope.rawQuery = templateValue;
              if (scope.isContentEditable) {
                scope.node.text(scope.query);
                scope.helper.setCaretAtEnd(scope.node[0]);
              }
            }

            scope.hideLayout();

            scope.node.val(scope.query).focus();

            scope.helper.executeCallback.call(
              scope,
              scope.options.callback.onClickAfter,
              [scope.node, $(this), item, e]
            );
          });
          liHtml.on("mouseenter", function (e) {
            if (!item.disabled) {
              scope.clearActiveItem();
              scope.addActiveItem($(this));
            }
            scope.helper.executeCallback.call(
              scope,
              scope.options.callback.onEnter,
              [scope.node, $(this), item, e]
            );
          });
          liHtml.on("mouseleave", function (e) {
            if (!item.disabled) {
              scope.clearActiveItem();
            }
            scope.helper.executeCallback.call(
              scope,
              scope.options.callback.onLeave,
              [scope.node, $(this), item, e]
            );
          });
        })(i, _item, _liHtml);

        (this.groupTemplate
          ? groupTemplate.find('[data-group-template="' + _group + '"] ul')
          : groupTemplate
        ).append(_liHtml);
      }

      if (this.result.length && _unusedGroups.length) {
        for (var i = 0, ii = _unusedGroups.length; i < ii; ++i) {
          groupTemplate
            .find('[data-group-template="' + _unusedGroups[i] + '"]')
            .remove();
        }
      }

      this.resultHtml = groupTemplate;
    },

    generateHref: function (href, item) {
      var scope = this;

      if (typeof href === "string") {
        href = href.replace(
          /\{\{([^\|}]+)(?:\|([^}]+))*}}/gi,
          function (match, index, options) {
            var value = scope.helper.namespace.call(
              scope,
              index,
              item,
              "get",
              ""
            );

            // #151 Slugify should be an option, not enforced
            options = (options && options.split("|")) || [];
            if (~options.indexOf("slugify")) {
              value = scope.helper.slugify.call(scope, value);
            }

            return value;
          }
        );
      } else if (typeof href === "function") {
        href = href.call(this, item);
      }

      return href;
    },

    getMultiselectComparedData: function (item) {
      var uniqueComparedItem = "";
      if (Array.isArray(this.options.multiselect.matchOn)) {
        for (
          var i = 0, ii = this.options.multiselect.matchOn.length;
          i < ii;
          ++i
        ) {
          uniqueComparedItem +=
            typeof item[this.options.multiselect.matchOn[i]] !== "undefined"
              ? item[this.options.multiselect.matchOn[i]]
              : "";
        }
      } else {
        var tmpItem = JSON.parse(JSON.stringify(item)),
          extraKeys = ["group", "matchedKey", "compiled", "href"];

        for (var i = 0, ii = extraKeys.length; i < ii; ++i) {
          delete tmpItem[extraKeys[i]];
        }
        uniqueComparedItem = JSON.stringify(tmpItem);
      }
      return uniqueComparedItem;
    },

    buildBackdropLayout: function () {
      if (!this.options.backdrop) return;

      if (!this.backdrop.container) {
        this.backdrop.css = $.extend(
          {
            opacity: 0.6,
            filter: "alpha(opacity=60)",
            position: "fixed",
            top: 0,
            right: 0,
            bottom: 0,
            left: 0,
            "z-index": 1040,
            "background-color": "#000",
          },
          this.options.backdrop
        );

        this.backdrop.container = $("<div/>", {
          class: this.options.selector.backdrop,
          css: this.backdrop.css,
        }).insertAfter(this.container);
      }
      this.container.addClass("backdrop").css({
        "z-index": this.backdrop.css["z-index"] + 1,
        position: "relative",
      });
    },

    buildHintLayout: function (result) {
      if (!this.options.hint) return;
      // #144 hint doesn't overlap with the input when the query is too long
      if (this.node[0].scrollWidth > Math.ceil(this.node.innerWidth())) {
        this.hint.container && this.hint.container.val("");
        return;
      }

      var scope = this,
        hint = "",
        result = result || this.result,
        query = this.query.toLowerCase();

      if (this.options.accent) {
        query = this.helper.removeAccent.call(this, query);
      }

      this.hintIndex = null;

      if (this.searchGroups.length) {
        if (!this.hint.container) {
          this.hint.css = $.extend(
            {
              "border-color": "transparent",
              position: "absolute",
              top: 0,
              display: "inline",
              "z-index": -1,
              float: "none",
              color: "silver",
              "box-shadow": "none",
              cursor: "default",
              "-webkit-user-select": "none",
              "-moz-user-select": "none",
              "-ms-user-select": "none",
              "user-select": "none",
            },
            this.options.hint
          );

          this.hint.container = $("<" + this.node[0].nodeName + "/>", {
            type: this.node.attr("type"),
            class: this.node.attr("class"),
            readonly: true,
            unselectable: "on",
            "aria-hidden": "true",
            tabindex: -1,
            click: function () {
              // IE8 Fix
              scope.node.focus();
            },
          })
            .addClass(this.options.selector.hint)
            .css(this.hint.css)
            .insertAfter(this.node);

          this.node.parent().css({
            position: "relative",
          });
        }

        this.hint.container.css("color", this.hint.css.color);

        // Do not display hint for empty query
        if (query) {
          var _displayKeys, _group, _comparedValue;

          for (var i = 0, ii = result.length; i < ii; i++) {
            if (result[i].disabled) continue;

            _group = result[i].group;
            _displayKeys =
              this.options.source[_group].display || this.options.display;

            for (var k = 0, kk = _displayKeys.length; k < kk; k++) {
              _comparedValue = String(result[i][_displayKeys[k]]).toLowerCase();
              if (this.options.accent) {
                _comparedValue = this.helper.removeAccent.call(
                  this,
                  _comparedValue
                );
              }

              if (_comparedValue.indexOf(query) === 0) {
                hint = String(result[i][_displayKeys[k]]);
                this.hintIndex = i;
                break;
              }
            }
            if (this.hintIndex !== null) {
              break;
            }
          }
        }

        var hintValue =
          (hint.length > 0 &&
            this.rawQuery + hint.substring(this.query.length)) ||
          "";
        this.hint.container.val(hintValue);

        if (this.isContentEditable) {
          this.hint.container.text(hintValue);
        }
      }
    },

    buildDropdownLayout: function () {
      if (!this.options.dropdownFilter) return;

      var scope = this;

      $("<span/>", {
        class: this.options.selector.filter,
        html: function () {
          $(this).append(
            $("<button/>", {
              type: "button",
              class: scope.options.selector.filterButton,
              style: "display: none;",
              click: function () {
                scope.container.toggleClass("filter");

                var _ns = scope.namespace + "-dropdown-filter";

                $("html").off(_ns);

                if (scope.container.hasClass("filter")) {
                  $("html").on("click" + _ns + " touchend" + _ns, function (e) {
                    if (
                      ($(e.target).closest(
                        "." + scope.options.selector.filter
                      )[0] &&
                        $(e.target).closest(scope.container)[0]) ||
                      scope.hasDragged
                    )
                      return;
                    scope.container.removeClass("filter");

                    $("html").off(_ns);
                  });
                }
              },
            })
          );

          $(this).append(
            $("<ul/>", {
              class: scope.options.selector.dropdown,
            })
          );
        },
      }).insertAfter(scope.container.find("." + scope.options.selector.query));
    },

    buildDropdownItemLayout: function (type) {
      if (!this.options.dropdownFilter) return;

      var scope = this,
        template,
        all =
          (typeof this.options.dropdownFilter === "string" &&
            this.options.dropdownFilter) ||
          "All",
        ulScope = this.container.find("." + this.options.selector.dropdown),
        filter;

      // Use regular groups defined in options.source
      if (
        type === "static" &&
        (this.options.dropdownFilter === true ||
          typeof this.options.dropdownFilter === "string")
      ) {
        this.dropdownFilter.static.push({
          key: "group",
          template: "{{group}}",
          all: all,
          value: Object.keys(this.options.source),
        });
      }

      for (var i = 0, ii = this.dropdownFilter[type].length; i < ii; i++) {
        filter = this.dropdownFilter[type][i];

        if (!Array.isArray(filter.value)) {
          filter.value = [filter.value];
        }

        if (filter.all) {
          this.dropdownFilterAll = filter.all;
        }

        for (var k = 0, kk = filter.value.length; k <= kk; k++) {
          // Only add "all" at the last filter iteration
          if (k === kk && i !== ii - 1) {
            continue;
          } else if (k === kk && i === ii - 1) {
            if (type === "static" && this.dropdownFilter.dynamic.length) {
              continue;
            }
          }

          template = this.dropdownFilterAll || all;
          if (filter.value[k]) {
            if (filter.template) {
              template = filter.template.replace(
                new RegExp("{{" + filter.key + "}}", "gi"),
                filter.value[k]
              );
            } else {
              template = filter.value[k];
            }
          } else {
            this.container
              .find("." + scope.options.selector.filterButton)
              .html(template);
          }

          (function (k, filter, template) {
            ulScope.append(
              $("<li/>", {
                class:
                  scope.options.selector.dropdownItem +
                  " " +
                  scope.helper.slugify.call(
                    scope,
                    filter.key + "-" + (filter.value[k] || all)
                  ),
                html: $("<a/>", {
                  href: "javascript:;",
                  html: template,
                  click: function (e) {
                    e.preventDefault();
                    _selectFilter.call(scope, {
                      key: filter.key,
                      value: filter.value[k] || "*",
                      template: template,
                    });
                  },
                }),
              })
            );
          })(k, filter, template);
        }
      }

      if (this.dropdownFilter[type].length) {
        this.container
          .find("." + scope.options.selector.filterButton)
          .removeAttr("style");
      }

      /**
       * @private
       * Select the filter and rebuild the result group
       *
       * @param {object} item
       */
      function _selectFilter(item) {
        if (item.value === "*") {
          delete this.filters.dropdown;
        } else {
          this.filters.dropdown = item;
        }

        this.container
          .removeClass("filter")
          .find("." + this.options.selector.filterButton)
          .html(item.template);

        this.isDropdownEvent = true;
        this.node.trigger("search" + this.namespace);

        if (this.options.multiselect) {
          this.adjustInputSize();
        }

        this.node.focus();
      }
    },

    dynamicFilter: {
      isEnabled: false,
      init: function () {
        if (!this.options.dynamicFilter) return;

        this.dynamicFilter.bind.call(this);
        this.dynamicFilter.isEnabled = true;
      },

      validate: function (item) {
        var isValid,
          softValid = null,
          hardValid = null,
          itemValue;

        for (var key in this.filters.dynamic) {
          if (!this.filters.dynamic.hasOwnProperty(key)) continue;
          if (!!~key.indexOf(".")) {
            itemValue = this.helper.namespace.call(this, key, item, "get");
          } else {
            itemValue = item[key];
          }

          if (this.filters.dynamic[key].modifier === "|" && !softValid) {
            softValid = itemValue == this.filters.dynamic[key].value || false;
          }

          if (this.filters.dynamic[key].modifier === "&") {
            // Leaving "==" in case of comparing number with string
            if (itemValue == this.filters.dynamic[key].value) {
              hardValid = true;
            } else {
              hardValid = false;
              break;
            }
          }
        }

        isValid = softValid;
        if (hardValid !== null) {
          isValid = hardValid;
          if (hardValid === true && softValid !== null) {
            isValid = softValid;
          }
        }

        return !!isValid;
      },

      set: function (key, value) {
        var matches = key.match(/^([|&])?(.+)/);

        if (!value) {
          delete this.filters.dynamic[matches[2]];
        } else {
          this.filters.dynamic[matches[2]] = {
            modifier: matches[1] || "|",
            value: value,
          };
        }

        if (this.dynamicFilter.isEnabled) {
          this.generateSource();
        }
      },
      bind: function () {
        var scope = this,
          filter;

        for (var i = 0, ii = this.options.dynamicFilter.length; i < ii; i++) {
          filter = this.options.dynamicFilter[i];

          if (typeof filter.selector === "string") {
            filter.selector = $(filter.selector);
          }

          if (
            !(filter.selector instanceof $) ||
            !filter.selector[0] ||
            !filter.key
          ) {
            // {debug}
            if (this.options.debug) {
              _debug.log({
                node: this.selector,
                function: "buildDynamicLayout()",
                message:
                  'Invalid jQuery selector or jQuery Object for "filter.selector" or missing filter.key',
              });

              _debug.print();
            }
            // {/debug}
            continue;
          }

          (function (filter) {
            filter.selector
              .off(scope.namespace)
              .on("change" + scope.namespace, function () {
                scope.dynamicFilter.set.apply(scope, [
                  filter.key,
                  scope.dynamicFilter.getValue(this),
                ]);
              })
              .trigger("change" + scope.namespace);
          })(filter);
        }
      },

      getValue: function (tag) {
        var value;
        if (tag.tagName === "SELECT") {
          value = tag.value;
        } else if (tag.tagName === "INPUT") {
          if (tag.type === "checkbox") {
            value =
              (tag.checked && tag.getAttribute("value")) || tag.checked || null;
          } else if (tag.type === "radio" && tag.checked) {
            value = tag.value;
          }
        }
        return value;
      },
    },

    buildMultiselectLayout: function () {
      if (!this.options.multiselect) return;
      var scope = this;
      var multiselectData;

      this.label.container = $("<span/>", {
        class: this.options.selector.labelContainer,
        "data-padding-left": parseFloat(this.node.css("padding-left")) || 0,
        "data-padding-right": parseFloat(this.node.css("padding-right")) || 0,
        "data-padding-top": parseFloat(this.node.css("padding-top")) || 0,
        click: function (e) {
          if ($(e.target).hasClass(scope.options.selector.labelContainer)) {
            scope.node.focus();
          }
        },
      });

      this.node
        .closest("." + this.options.selector.query)
        .prepend(this.label.container);

      if (!this.options.multiselect.data) return;

      if (Array.isArray(this.options.multiselect.data)) {
        this.populateMultiselectData(this.options.multiselect.data);
      } else if (typeof this.options.multiselect.data === "function") {
        multiselectData = this.options.multiselect.data.call(this);
        if (Array.isArray(multiselectData)) {
          this.populateMultiselectData(multiselectData);
        } else if (typeof multiselectData.promise === "function") {
          $.when(multiselectData).then(function (deferredData) {
            if (deferredData && Array.isArray(deferredData)) {
              scope.populateMultiselectData(deferredData);
            }
          });
        }
      }
    },

    isMultiselectUniqueData: function (data) {
      var isUniqueData = true;
      for (var x = 0, xx = this.comparedItems.length; x < xx; ++x) {
        if (this.comparedItems[x] === this.getMultiselectComparedData(data)) {
          isUniqueData = false;
          break;
        }
      }
      return isUniqueData;
    },

    populateMultiselectData: function (data) {
      for (var i = 0, ii = data.length; i < ii; ++i) {
        if (!this.isMultiselectUniqueData(data[i])) continue;

        this.items.push(data[i]);
        this.comparedItems.push(this.getMultiselectComparedData(data[i]));
        this.addMultiselectItemLayout(this.getTemplateValue(data[i]));
      }

      this.node.trigger("search" + this.namespace, {
        origin: "populateMultiselectData",
      });
    },

    addMultiselectItemLayout: function (templateValue) {
      var scope = this,
        htmlTag = this.options.multiselect.href ? "a" : "span";

      var label = $("<span/>", {
        class: this.options.selector.label,
        html: $("<" + htmlTag + "/>", {
          text: templateValue,
          click: function (e) {
            var currentLabel = $(this).closest(
                "." + scope.options.selector.label
              ),
              index = scope.label.container
                .find("." + scope.options.selector.label)
                .index(currentLabel);

            scope.options.multiselect.callback &&
              scope.helper.executeCallback.call(
                scope,
                scope.options.multiselect.callback.onClick,
                [scope.node, scope.items[index], e]
              );
          },
          href: this.options.multiselect.href
            ? (function (item) {
                return scope.generateHref.call(
                  scope,
                  scope.options.multiselect.href,
                  item
                );
              })(scope.items[scope.items.length - 1])
            : null,
        }),
      });

      label.append(
        $("<span/>", {
          class: this.options.selector.cancelButton,
          html: "×",
          click: function (e) {
            var label = $(this).closest("." + scope.options.selector.label),
              index = scope.label.container
                .find("." + scope.options.selector.label)
                .index(label);

            scope.cancelMultiselectItem(index, label, e);
          },
        })
      );

      this.label.container.append(label);
      this.adjustInputSize();
    },

    cancelMultiselectItem: function (index, label, e) {
      var item = this.items[index];

      label =
        label ||
        this.label.container.find("." + this.options.selector.label).eq(index);

      label.remove();

      this.items.splice(index, 1);
      this.comparedItems.splice(index, 1);

      this.options.multiselect.callback &&
        this.helper.executeCallback.call(
          this,
          this.options.multiselect.callback.onCancel,
          [this.node, item, e]
        );

      this.adjustInputSize();

      this.focusOnly = true;
      this.node
        .focus()
        .trigger("input" + this.namespace, { origin: "cancelMultiselectItem" });
    },

    adjustInputSize: function () {
      var nodeWidth =
        this.node[0].getBoundingClientRect().width -
        (parseFloat(this.label.container.data("padding-right")) || 0) -
        (parseFloat(this.label.container.css("padding-left")) || 0);

      var labelOuterWidth = 0,
        numberOfRows = 0,
        currentRowWidth = 0,
        isRowAdded = false,
        labelOuterHeight = 0;

      this.label.container
        .find("." + this.options.selector.label)
        .filter(function (i, v) {
          if (i === 0) {
            labelOuterHeight =
              $(v)[0].getBoundingClientRect().height +
              parseFloat($(v).css("margin-bottom") || 0);
          }

          // labelOuterWidth = Math.round($(v)[0].getBoundingClientRect().width * 100) / 100 + parseFloat($(v).css('margin-right'));
          labelOuterWidth =
            $(v)[0].getBoundingClientRect().width +
            parseFloat($(v).css("margin-right") || 0);

          if (
            currentRowWidth + labelOuterWidth > nodeWidth * 0.7 &&
            !isRowAdded
          ) {
            numberOfRows++;
            isRowAdded = true;
          }

          if (currentRowWidth + labelOuterWidth < nodeWidth) {
            currentRowWidth += labelOuterWidth;
          } else {
            isRowAdded = false;
            currentRowWidth = labelOuterWidth;
          }
        });

      var paddingLeft =
        parseFloat(this.label.container.data("padding-left") || 0) +
        (isRowAdded ? 0 : currentRowWidth);
      var paddingTop =
        numberOfRows * labelOuterHeight +
        parseFloat(this.label.container.data("padding-top") || 0);

      this.container
        .find("." + this.options.selector.query)
        .find("input, textarea, [contenteditable], .typeahead__hint")
        .css({
          paddingLeft: paddingLeft,
          paddingTop: paddingTop,
        });
    },

    showLayout: function () {
      if (
        this.container.hasClass("result") ||
        (!this.result.length &&
          !this.options.emptyTemplate &&
          !this.options.backdropOnFocus)
      )
        return;

      _addHtmlListeners.call(this);

      this.container.addClass(
        [
          this.result.length ||
          (this.searchGroups.length &&
            this.options.emptyTemplate &&
            this.query.length)
            ? "result "
            : "",
          this.options.hint && this.searchGroups.length ? "hint" : "",
          this.options.backdrop || this.options.backdropOnFocus
            ? "backdrop"
            : "",
        ].join(" ")
      );

      this.helper.executeCallback.call(
        this,
        this.options.callback.onShowLayout,
        [this.node, this.query]
      );

      function _addHtmlListeners() {
        var scope = this;

        // If Typeahead is blured by pressing the "Tab" Key, hide the results
        $("html")
          .off("keydown" + this.namespace)
          .on("keydown" + this.namespace, function (e) {
            if (!e.keyCode || e.keyCode !== 9) return;
            setTimeout(function () {
              if (!$(":focus").closest(scope.container).find(scope.node)[0]) {
                scope.hideLayout();
              }
            }, 0);
          });

        // If Typeahead is blured by clicking outside, hide the results
        $("html")
          .off("click" + this.namespace + " touchend" + this.namespace)
          .on(
            "click" + this.namespace + " touchend" + this.namespace,
            function (e) {
              if (
                $(e.target).closest(scope.container)[0] ||
                $(e.target).closest("." + scope.options.selector.item)[0] ||
                e.target.className === scope.options.selector.cancelButton ||
                scope.hasDragged
              )
                return;

              scope.hideLayout();
            }
          );
      }
    },

    hideLayout: function () {
      // Means the container is already hidden
      if (
        !this.container.hasClass("result") &&
        !this.container.hasClass("backdrop")
      )
        return;

      this.container.removeClass(
        "result hint filter" +
          (this.options.backdropOnFocus && $(this.node).is(":focus")
            ? ""
            : " backdrop")
      );

      if (this.options.backdropOnFocus && this.container.hasClass("backdrop"))
        return;

      // Make sure the event HTML gets cleared
      $("html").off(this.namespace);

      this.helper.executeCallback.call(
        this,
        this.options.callback.onHideLayout,
        [this.node, this.query]
      );
    },

    resetLayout: function () {
      this.result = [];
      this.tmpResult = {};
      this.groups = [];
      this.resultCount = 0;
      this.resultCountPerGroup = {};
      this.resultItemCount = 0;
      this.resultHtml = null;

      if (this.options.hint && this.hint.container) {
        this.hint.container.val("");
        if (this.isContentEditable) {
          this.hint.container.text("");
        }
      }
    },

    resetInput: function () {
      this.node.val("");
      if (this.isContentEditable) {
        this.node.text("");
      }
      this.item = null;
      this.query = "";
      this.rawQuery = "";
    },

    buildCancelButtonLayout: function () {
      if (!this.options.cancelButton) return;
      var scope = this;

      $("<span/>", {
        class: this.options.selector.cancelButton,
        html: "×",
        mousedown: function (e) {
          // Don't blur the input
          e.stopImmediatePropagation();
          e.preventDefault();

          scope.resetInput();
          scope.node.trigger("input" + scope.namespace, [e]);
        },
      }).insertBefore(this.node);
    },

    toggleCancelButtonVisibility: function () {
      this.container.toggleClass("cancel", !!this.query.length);
    },

    __construct: function () {
      this.extendOptions();

      if (!this.unifySourceFormat()) {
        return;
      }

      this.dynamicFilter.init.apply(this);

      this.init();
      this.buildDropdownLayout();
      this.buildDropdownItemLayout("static");

      this.buildMultiselectLayout();

      this.delegateEvents();
      this.buildCancelButtonLayout();

      this.helper.executeCallback.call(this, this.options.callback.onReady, [
        this.node,
      ]);
    },

    helper: {
      isEmpty: function (obj) {
        for (var prop in obj) {
          if (obj.hasOwnProperty(prop)) return false;
        }

        return true;
      },

      /**
       * Remove every accent(s) from a string
       *
       * @param {String} string
       * @returns {*}
       */
      removeAccent: function (string) {
        if (typeof string !== "string") {
          return;
        }

        var accent = _accent;

        if (typeof this.options.accent === "object") {
          accent = this.options.accent;
        }

        string = string
          .toLowerCase()
          .replace(new RegExp("[" + accent.from + "]", "g"), function (match) {
            return accent.to[accent.from.indexOf(match)];
          });

        return string;
      },

      /**
       * Creates a valid url from string
       *
       * @param {String} string
       * @returns {string}
       */
      slugify: function (string) {
        string = String(string);

        if (string !== "") {
          string = this.helper.removeAccent.call(this, string);
          string = string
            .replace(/[^-a-z0-9]+/g, "-")
            .replace(/-+/g, "-")
            .replace(/^-|-$/g, "");
        }

        return string;
      },

      /**
       * Sort list of object by key
       *
       * @param {String|Array} field
       * @param {Boolean} reverse
       * @param {Function} primer
       * @returns {Function}
       */
      sort: function (field, reverse, primer) {
        var key = function (x) {
          for (var i = 0, ii = field.length; i < ii; i++) {
            if (typeof x[field[i]] !== "undefined") {
              return primer(x[field[i]]);
            }
          }
          return x;
        };

        reverse = [-1, 1][+!!reverse];

        return function (a, b) {
          return (a = key(a)), (b = key(b)), reverse * ((a > b) - (b > a));
        };
      },

      /**
       * Replace a string from-to index
       *
       * @param {String} string The complete string to replace into
       * @param {Number} offset The cursor position to start replacing from
       * @param {Number} length The length of the replacing string
       * @param {String} replace The replacing string
       * @returns {String}
       */
      replaceAt: function (string, offset, length, replace) {
        return (
          string.substring(0, offset) +
          replace +
          string.substring(offset + length)
        );
      },

      /**
       * Adds <strong> html around a matched string
       *
       * @param {String} string The complete string to match from
       * @param {String} key
       * @param {Boolean} [accents]
       * @returns {*}
       */
      highlight: function (string, keys, accents) {
        string = String(string);

        var searchString =
            (accents && this.helper.removeAccent.call(this, string)) || string,
          matches = [];

        if (!Array.isArray(keys)) {
          keys = [keys];
        }

        keys.sort(function (a, b) {
          return b.length - a.length;
        });

        // Make sure the '|' join will be safe!
        for (var i = keys.length - 1; i >= 0; i--) {
          if (keys[i].trim() === "") {
            keys.splice(i, 1);
            continue;
          }
          keys[i] = keys[i].replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
        }

        searchString.replace(
          new RegExp("(?:" + keys.join("|") + ")(?!([^<]+)?>)", "gi"),
          function (match, index, offset) {
            matches.push({
              offset: offset,
              length: match.length,
            });
          }
        );

        for (var i = matches.length - 1; i >= 0; i--) {
          string = this.helper.replaceAt(
            string,
            matches[i].offset,
            matches[i].length,
            "<strong>" +
              string.substr(matches[i].offset, matches[i].length) +
              "</strong>"
          );
        }

        return string;
      },

      /**
       * Get caret position, used for right arrow navigation
       * when hint option is enabled
       * @param {Node} element
       * @returns {Number} Caret position
       */
      getCaret: function (element) {
        var caretPos = 0;

        if (element.selectionStart) {
          // Input & Textarea
          return element.selectionStart;
        } else if (document.selection) {
          var r = document.selection.createRange();
          if (r === null) {
            return caretPos;
          }

          var re = element.createTextRange(),
            rc = re.duplicate();
          re.moveToBookmark(r.getBookmark());
          rc.setEndPoint("EndToStart", re);

          caretPos = rc.text.length;
        } else if (window.getSelection) {
          // Contenteditable
          var sel = window.getSelection();
          if (sel.rangeCount) {
            var range = sel.getRangeAt(0);
            if (range.commonAncestorContainer.parentNode == element) {
              caretPos = range.endOffset;
            }
          }
        }
        return caretPos;
      },

      /**
       * For [contenteditable] typeahead node only,
       * when an item is clicked set the cursor at the end
       * @param {Node} element
       */
      setCaretAtEnd: function (element) {
        if (
          typeof window.getSelection !== "undefined" &&
          typeof document.createRange !== "undefined"
        ) {
          var range = document.createRange();
          range.selectNodeContents(element);
          range.collapse(false);
          var sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);
        } else if (typeof document.body.createTextRange !== "undefined") {
          var textRange = document.body.createTextRange();
          textRange.moveToElementText(element);
          textRange.collapse(false);
          textRange.select();
        }
      },

      /**
       * Clean strings from possible XSS (script and iframe tags)
       * @param string
       * @returns {string}
       */
      cleanStringFromScript: function (string) {
        return (
          (typeof string === "string" &&
            string.replace(/<\/?(?:script|iframe)\b[^>]*>/gm, "")) ||
          string
        );
      },

      /**
       * Executes an anonymous function or a string reached from the window scope.
       *
       * @example
       * Note: These examples works with every configuration callbacks
       *
       * // An anonymous function inside the "onInit" option
       * onInit: function() { console.log(':D'); };
       *
       * // myFunction() located on window.coucou scope
       * onInit: 'window.coucou.myFunction'
       *
       * // myFunction(a,b) located on window.coucou scope passing 2 parameters
       * onInit: ['window.coucou.myFunction', [':D', ':)']];
       *
       * // Anonymous function to execute a local function
       * onInit: function () { myFunction(':D'); }
       *
       * @param {String|Array} callback The function to be called
       * @param {Array} [extraParams] In some cases the function can be called with Extra parameters (onError)
       * @returns {*}
       */
      executeCallback: function (callback, extraParams) {
        if (!callback) {
          return;
        }

        var _callback;

        if (typeof callback === "function") {
          _callback = callback;
        } else if (typeof callback === "string" || Array.isArray(callback)) {
          if (typeof callback === "string") {
            callback = [callback, []];
          }

          _callback = this.helper.namespace.call(this, callback[0], window);

          if (typeof _callback !== "function") {
            // {debug}
            if (this.options.debug) {
              _debug.log({
                node: this.selector,
                function: "executeCallback()",
                arguments: JSON.stringify(callback),
                message: 'WARNING - Invalid callback function"',
              });

              _debug.print();
            }
            // {/debug}
            return;
          }
        }

        return _callback.apply(
          this,
          (callback[1] || []).concat(extraParams ? extraParams : [])
        );
      },

      namespace: function (string, object, method, defaultValue) {
        if (typeof string !== "string" || string === "") {
          // {debug}
          if (this.options.debug) {
            _debug.log({
              node: this.options.input || this.selector,
              function: "helper.namespace()",
              arguments: string,
              message: 'ERROR - Missing string"',
            });

            _debug.print();
          }
          // {/debug}
          return false;
        }

        var value =
          typeof defaultValue !== "undefined" ? defaultValue : undefined;

        // Exit before looping if the string doesn't contain an object reference
        if (!~string.indexOf(".")) {
          return object[string] || value;
        }

        var parts = string.split("."),
          parent = object || window,
          method = method || "get",
          currentPart = "";

        for (var i = 0, length = parts.length; i < length; i++) {
          currentPart = parts[i];

          if (typeof parent[currentPart] === "undefined") {
            if (~["get", "delete"].indexOf(method)) {
              return typeof defaultValue !== "undefined"
                ? defaultValue
                : undefined;
            }
            parent[currentPart] = {};
          }

          if (~["set", "create", "delete"].indexOf(method)) {
            if (i === length - 1) {
              if (method === "set" || method === "create") {
                parent[currentPart] = value;
              } else {
                delete parent[currentPart];
                return true;
              }
            }
          }

          parent = parent[currentPart];
        }
        return parent;
      },

      typeWatch: (function () {
        var timer = 0;
        return function (callback, ms) {
          clearTimeout(timer);
          timer = setTimeout(callback, ms);
        };
      })(),
    },
  };

  /**
   * @public
   * Implement Typeahead on the selected input node.
   *
   * @param {Object} options
   * @return {Object} Modified DOM element
   */
  $.fn.typeahead = $.typeahead = function (options) {
    return _api.typeahead(this, options);
  };

  /**
   * @private
   * API to handles Typeahead methods via jQuery.
   */
  var _api = {
    /**
     * Enable Typeahead
     *
     * @param {Object} node
     * @param {Object} options
     * @returns {*}
     */
    typeahead: function (node, options) {
      if (!options || !options.source || typeof options.source !== "object") {
        // {debug}
        _debug.log({
          node: node.selector || (options && options.input),
          function: "$.typeahead()",
          arguments: JSON.stringify((options && options.source) || ""),
          message:
            'Undefined "options" or "options.source" or invalid source type - Typeahead dropped',
        });

        _debug.print();
        // {/debug}

        return;
      }

      if (typeof node === "function") {
        if (!options.input) {
          // {debug}
          _debug.log({
            node: node.selector,
            function: "$.typeahead()",
            //'arguments': JSON.stringify(options),
            message: 'Undefined "options.input" - Typeahead dropped',
          });

          _debug.print();
          // {/debug}

          return;
        }

        node = $(options.input);
      }
      if (typeof node[0].value === "undefined") {
        node[0].value = node.text();
      }
      if (!node.length) {
        // {debug}
        _debug.log({
          node: node.selector,
          function: "$.typeahead()",
          arguments: JSON.stringify(options.input),
          message: "Unable to find jQuery input element - Typeahead dropped",
        });

        _debug.print();
        // {/debug}

        return;
      }

      // #270 Forcing node.selector, the property was deleted from jQuery3
      // In case of multiple init, each of the instances needs it's own selector!
      if (node.length === 1) {
        node[0].selector =
          node.selector || options.input || node[0].nodeName.toLowerCase();

        /*jshint boss:true */
        return (window.Typeahead[node[0].selector] = new Typeahead(
          node,
          options
        ));
      } else {
        var instances = {},
          instanceName;

        for (var i = 0, ii = node.length; i < ii; ++i) {
          instanceName = node[i].nodeName.toLowerCase();
          if (typeof instances[instanceName] !== "undefined") {
            instanceName += i;
          }
          node[i].selector = instanceName;

          window.Typeahead[instanceName] = instances[instanceName] =
            new Typeahead(node.eq(i), options);
        }

        return instances;
      }
    },
  };

  // {debug}
  var _debug = {
    table: {},
    log: function (debugObject) {
      if (!debugObject.message || typeof debugObject.message !== "string") {
        return;
      }

      this.table[debugObject.message] = $.extend(
        {
          node: "",
          function: "",
          arguments: "",
        },
        debugObject
      );
    },
    print: function () {
      if (
        Typeahead.prototype.helper.isEmpty(this.table) ||
        !console ||
        !console.table
      ) {
        return;
      }

      if (console.group !== undefined || console.table !== undefined) {
        console.groupCollapsed("--- jQuery Typeahead Debug ---");
        console.table(this.table);
        console.groupEnd();
      }

      this.table = {};
    },
  };
  _debug.log({
    message:
      "WARNING - You are using the DEBUG version. Use /dist/jquery.typeahead.min.js in production.",
  });

  _debug.print();
  // {/debug}

  // IE8 Shims
  window.console = window.console || {
    log: function () {},
  };

  if (!Array.isArray) {
    Array.isArray = function (arg) {
      return Object.prototype.toString.call(arg) === "[object Array]";
    };
  }

  if (!("trim" in String.prototype)) {
    String.prototype.trim = function () {
      return this.replace(/^\s+/, "").replace(/\s+$/, "");
    };
  }
  if (!("indexOf" in Array.prototype)) {
    Array.prototype.indexOf = function (find, i /*opt*/) {
      if (i === undefined) i = 0;
      if (i < 0) i += this.length;
      if (i < 0) i = 0;
      for (var n = this.length; i < n; i++)
        if (i in this && this[i] === find) return i;
      return -1;
    };
  }
  if (!Object.keys) {
    Object.keys = function (obj) {
      var keys = [],
        k;
      for (k in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, k)) {
          keys.push(k);
        }
      }
      return keys;
    };
  }

  return Typeahead;
});

/*!
 * FormValidation (http://formvalidation.io)
 * The best jQuery plugin to validate form fields. Support Bootstrap, Foundation, Pure, SemanticUI, UIKit and custom frameworks
 *
 * @version     v0.8.1, built on 2016-07-29 1:10:54 AM
 * @author      https://twitter.com/formvalidation
 * @copyright   (c) 2013 - 2016 Nguyen Huu Phuoc
 * @license     http://formvalidation.io/license/
 */
// Register the namespace
window.FormValidation = {
  AddOn: {}, // Add-ons
  Framework: {}, // Supported frameworks
  I18n: {}, // i18n
  Validator: {}, // Available validators
};

if (typeof jQuery === "undefined") {
  throw new Error("FormValidation requires jQuery");
}

(function ($) {
  var version = $.fn.jquery.split(" ")[0].split(".");
  if (
    (+version[0] < 2 && +version[1] < 9) ||
    (+version[0] === 1 && +version[1] === 9 && +version[2] < 1)
  ) {
    throw new Error("FormValidation requires jQuery version 1.9.1 or higher");
  }
})(jQuery);

(function ($) {
  // TODO: Remove backward compatibility
  /**
   * Constructor
   *
   * @param {jQuery|String} form The form element or selector
   * @param {Object} options The options
   * @param {String} [namespace] The optional namespace which is used for data-{namespace}-xxx attributes and internal data.
   * Currently, it's used to support backward version
   * @constructor
   */
  FormValidation.Base = function (form, options, namespace) {
    this.$form = $(form);
    this.options = $.extend({}, $.fn.formValidation.DEFAULT_OPTIONS, options);
    this._namespace = namespace || "fv";

    this.$invalidFields = $([]); // Array of invalid fields
    this.$submitButton = null; // The submit button which is clicked to submit form
    this.$hiddenButton = null;

    // Validating status
    this.STATUS_NOT_VALIDATED = "NOT_VALIDATED";
    this.STATUS_VALIDATING = "VALIDATING";
    this.STATUS_INVALID = "INVALID";
    this.STATUS_VALID = "VALID";
    this.STATUS_IGNORED = "IGNORED";

    // Default message
    this.DEFAULT_MESSAGE = $.fn.formValidation.DEFAULT_MESSAGE;

    // Determine the event that is fired when user change the field value
    // Most modern browsers supports input event except IE 7, 8.
    // IE 9 supports input event but the event is still not fired if I press the backspace key.
    // Get IE version
    // https://gist.github.com/padolsey/527683/#comment-7595
    this._ieVersion = (function () {
      var v = 3,
        div = document.createElement("div"),
        a = div.all || [];
      while (
        ((div.innerHTML = "<!--[if gt IE " + ++v + "]><br><![endif]-->"), a[0])
      ) {}
      return v > 4 ? v : document.documentMode;
    })();

    var el = document.createElement("div");
    this._changeEvent =
      this._ieVersion === 9 || !("oninput" in el) ? "keyup" : "input";

    // The flag to indicate that the form is ready to submit when a remote/callback validator returns
    this._submitIfValid = null;

    // Field elements
    this._cacheFields = {};

    this._init();
  };

  FormValidation.Base.prototype = {
    constructor: FormValidation.Base,

    /**
     * Check if the number of characters of field value exceed the threshold or not
     *
     * @param {jQuery} $field The field element
     * @returns {Boolean}
     */
    _exceedThreshold: function ($field) {
      var ns = this._namespace,
        field = $field.attr("data-" + ns + "-field"),
        threshold =
          this.options.fields[field].threshold || this.options.threshold;
      if (!threshold) {
        return true;
      }
      var cannotType =
        $.inArray($field.attr("type"), [
          "button",
          "checkbox",
          "file",
          "hidden",
          "image",
          "radio",
          "reset",
          "submit",
        ]) !== -1;
      return cannotType || $field.val().length >= threshold;
    },

    /**
     * Init form
     */
    _init: function () {
      var that = this,
        ns = this._namespace,
        options = {
          addOns: {},
          autoFocus: this.$form.attr("data-" + ns + "-autofocus"),
          button: {
            selector:
              this.$form.attr("data-" + ns + "-button-selector") ||
              this.$form.attr("data-" + ns + "-submitbuttons"), // Support backward
            disabled: this.$form.attr("data-" + ns + "-button-disabled"),
          },
          control: {
            valid: this.$form.attr("data-" + ns + "-control-valid"),
            invalid: this.$form.attr("data-" + ns + "-control-invalid"),
          },
          err: {
            clazz: this.$form.attr("data-" + ns + "-err-clazz"),
            container:
              this.$form.attr("data-" + ns + "-err-container") ||
              this.$form.attr("data-" + ns + "-container"), // Support backward
            parent: this.$form.attr("data-" + ns + "-err-parent"),
          },
          events: {
            formInit: this.$form.attr("data-" + ns + "-events-form-init"),
            formPreValidate: this.$form.attr(
              "data-" + ns + "-events-form-prevalidate"
            ),
            formError: this.$form.attr("data-" + ns + "-events-form-error"),
            formReset: this.$form.attr("data-" + ns + "-events-form-reset"),
            formSuccess: this.$form.attr("data-" + ns + "-events-form-success"),
            fieldAdded: this.$form.attr("data-" + ns + "-events-field-added"),
            fieldRemoved: this.$form.attr(
              "data-" + ns + "-events-field-removed"
            ),
            fieldInit: this.$form.attr("data-" + ns + "-events-field-init"),
            fieldError: this.$form.attr("data-" + ns + "-events-field-error"),
            fieldReset: this.$form.attr("data-" + ns + "-events-field-reset"),
            fieldSuccess: this.$form.attr(
              "data-" + ns + "-events-field-success"
            ),
            fieldStatus: this.$form.attr("data-" + ns + "-events-field-status"),
            localeChanged: this.$form.attr(
              "data-" + ns + "-events-locale-changed"
            ),
            validatorError: this.$form.attr(
              "data-" + ns + "-events-validator-error"
            ),
            validatorSuccess: this.$form.attr(
              "data-" + ns + "-events-validator-success"
            ),
            validatorIgnored: this.$form.attr(
              "data-" + ns + "-events-validator-ignored"
            ),
          },
          excluded: this.$form.attr("data-" + ns + "-excluded"),
          icon: {
            valid:
              this.$form.attr("data-" + ns + "-icon-valid") ||
              this.$form.attr("data-" + ns + "-feedbackicons-valid"), // Support backward
            invalid:
              this.$form.attr("data-" + ns + "-icon-invalid") ||
              this.$form.attr("data-" + ns + "-feedbackicons-invalid"), // Support backward
            validating:
              this.$form.attr("data-" + ns + "-icon-validating") ||
              this.$form.attr("data-" + ns + "-feedbackicons-validating"), // Support backward
            feedback: this.$form.attr("data-" + ns + "-icon-feedback"),
          },
          live: this.$form.attr("data-" + ns + "-live"),
          locale: this.$form.attr("data-" + ns + "-locale"),
          message: this.$form.attr("data-" + ns + "-message"),
          onPreValidate: this.$form.attr("data-" + ns + "-onprevalidate"),
          onError: this.$form.attr("data-" + ns + "-onerror"),
          onReset: this.$form.attr("data-" + ns + "-onreset"),
          onSuccess: this.$form.attr("data-" + ns + "-onsuccess"),
          row: {
            selector:
              this.$form.attr("data-" + ns + "-row-selector") ||
              this.$form.attr("data-" + ns + "-group"), // Support backward
            valid: this.$form.attr("data-" + ns + "-row-valid"),
            invalid: this.$form.attr("data-" + ns + "-row-invalid"),
            feedback: this.$form.attr("data-" + ns + "-row-feedback"),
          },
          threshold: this.$form.attr("data-" + ns + "-threshold"),
          trigger: this.$form.attr("data-" + ns + "-trigger"),
          verbose: this.$form.attr("data-" + ns + "-verbose"),
          fields: {},
        };

      this.$form
        // Disable client side validation in HTML 5
        .attr("novalidate", "novalidate")
        .addClass(this.options.elementClass)
        // Disable the default submission first
        .on("submit." + ns, function (e) {
          e.preventDefault();
          that.validate();
        })
        .on("click." + ns, this.options.button.selector, function () {
          that.$submitButton = $(this);
          // The user just click the submit button
          that._submitIfValid = true;
        });

      if (
        this.options.declarative === true ||
        this.options.declarative === "true"
      ) {
        // Find all fields which have either "name" or "data-{namespace}-field" attribute
        this.$form.find("[name], [data-" + ns + "-field]").each(function () {
          var $field = $(this),
            field = $field.attr("name") || $field.attr("data-" + ns + "-field"),
            opts = that._parseOptions($field);
          if (opts) {
            $field.attr("data-" + ns + "-field", field);
            options.fields[field] = $.extend({}, opts, options.fields[field]);
          }
        });
      }

      this.options = $.extend(true, this.options, options);

      // Normalize the err.parent option
      if ("string" === typeof this.options.err.parent) {
        this.options.err.parent = new RegExp(this.options.err.parent);
      }

      // Support backward
      if (this.options.container) {
        this.options.err.container = this.options.container;
        delete this.options.container;
      }
      if (this.options.feedbackIcons) {
        this.options.icon = $.extend(
          true,
          this.options.icon,
          this.options.feedbackIcons
        );
        delete this.options.feedbackIcons;
      }
      if (this.options.group) {
        this.options.row.selector = this.options.group;
        delete this.options.group;
      }
      if (this.options.submitButtons) {
        this.options.button.selector = this.options.submitButtons;
        delete this.options.submitButtons;
      }

      // If the locale is not found, reset it to default one
      if (!FormValidation.I18n[this.options.locale]) {
        this.options.locale = $.fn.formValidation.DEFAULT_OPTIONS.locale;
      }

      // Parse the add-on options from HTML attributes
      if (
        this.options.declarative === true ||
        this.options.declarative === "true"
      ) {
        this.options = $.extend(true, this.options, {
          addOns: this._parseAddOnOptions(),
        });
      }

      // When pressing Enter on any field in the form, the first submit button will do its job.
      // The form then will be submitted.
      // I create a first hidden submit button
      this.$hiddenButton = $("<button/>")
        .attr("type", "submit")
        .prependTo(this.$form)
        .addClass("fv-hidden-submit")
        .css({ display: "none", width: 0, height: 0 });

      this.$form.on(
        "click." + this._namespace,
        '[type="submit"]',
        function (e) {
          // #746: Check if the button click handler returns false
          if (!e.isDefaultPrevented()) {
            var $target = $(e.target),
              // The button might contain HTML tag
              $button = $target.is('[type="submit"]')
                ? $target.eq(0)
                : $target.parent('[type="submit"]').eq(0);

            // Don't perform validation when clicking on the submit button/input which
            // aren't defined by the 'button.selector' option
            if (
              that.options.button.selector &&
              !$button.is(that.options.button.selector) &&
              !$button.is(that.$hiddenButton)
            ) {
              that.$form.off("submit." + that._namespace).submit();
              // Fix the issue where 'formnovalidate' causes IE to send two postbacks to server
              return false;
            }
          }
        }
      );

      for (var field in this.options.fields) {
        this._initField(field);
      }

      // Init the add-ons
      for (var addOn in this.options.addOns) {
        if ("function" === typeof FormValidation.AddOn[addOn].init) {
          FormValidation.AddOn[addOn].init(this, this.options.addOns[addOn]);
        }
      }

      this.$form.trigger($.Event(this.options.events.formInit), {
        bv: this, // Support backward
        fv: this,
        options: this.options,
      });

      // Prepare the events
      if (this.options.onPreValidate) {
        this.$form.on(this.options.events.formPreValidate, function (e) {
          FormValidation.Helper.call(that.options.onPreValidate, [e]);
        });
      }
      if (this.options.onSuccess) {
        this.$form.on(this.options.events.formSuccess, function (e) {
          FormValidation.Helper.call(that.options.onSuccess, [e]);
        });
      }
      if (this.options.onError) {
        this.$form.on(this.options.events.formError, function (e) {
          FormValidation.Helper.call(that.options.onError, [e]);
        });
      }
      if (this.options.onReset) {
        this.$form.on(this.options.events.formReset, function (e) {
          FormValidation.Helper.call(that.options.onReset, [e]);
        });
      }
    },

    /**
     * Init field
     *
     * @param {String|jQuery} field The field name or field element
     */
    _initField: function (field) {
      var ns = this._namespace,
        fields = $([]);
      switch (typeof field) {
        case "object":
          fields = field;
          field = field.attr("data-" + ns + "-field");
          break;
        case "string":
          fields = this.getFieldElements(field);
          fields.attr("data-" + ns + "-field", field);
          break;
        default:
          break;
      }

      // We don't need to validate non-existing fields
      if (fields.length === 0) {
        return;
      }

      if (
        this.options.fields[field] === null ||
        this.options.fields[field].validators === null
      ) {
        return;
      }

      var validators = this.options.fields[field].validators,
        validatorName,
        alias;
      for (validatorName in validators) {
        alias = validators[validatorName].alias || validatorName;
        if (!FormValidation.Validator[alias]) {
          delete this.options.fields[field].validators[validatorName];
        }
      }
      if (this.options.fields[field].enabled === null) {
        this.options.fields[field].enabled = true;
      }

      var that = this,
        total = fields.length,
        type = fields.attr("type"),
        updateAll = total === 1 || "radio" === type || "checkbox" === type,
        trigger = this._getFieldTrigger(fields.eq(0)),
        clazz = this.options.err.clazz.split(" ").join("."),
        events = $.map(trigger, function (item) {
          return item + ".update." + ns;
        }).join(" ");

      for (var i = 0; i < total; i++) {
        var $field = fields.eq(i),
          row = this.options.fields[field].row || this.options.row.selector,
          $parent = $field.closest(row),
          // Allow user to indicate where the error messages are shown
          // Support backward
          container =
            "function" ===
            typeof (
              this.options.fields[field].container ||
              this.options.fields[field].err ||
              this.options.err.container
            )
              ? (
                  this.options.fields[field].container ||
                  this.options.fields[field].err ||
                  this.options.err.container
                ).call(this, $field, this)
              : this.options.fields[field].container ||
                this.options.fields[field].err ||
                this.options.err.container,
          $message =
            container && container !== "tooltip" && container !== "popover"
              ? $(container)
              : this._getMessageContainer($field, row);

        if (container && container !== "tooltip" && container !== "popover") {
          $message.addClass(this.options.err.clazz);
        }

        // Remove all error messages and feedback icons
        $message
          .find(
            "." +
              clazz +
              "[data-" +
              ns +
              "-validator][data-" +
              ns +
              '-for="' +
              field +
              '"]'
          )
          .remove();
        $parent.find("i[data-" + ns + '-icon-for="' + field + '"]').remove();

        // Whenever the user change the field value, mark it as not validated yet
        $field.off(events).on(events, function () {
          that.updateStatus($(this), that.STATUS_NOT_VALIDATED);
        });

        // Create help block elements for showing the error messages
        $field.data(ns + ".messages", $message);
        for (validatorName in validators) {
          $field.data(
            ns + ".result." + validatorName,
            this.STATUS_NOT_VALIDATED
          );

          if (!updateAll || i === total - 1) {
            $("<small/>")
              .css("display", "none")
              .addClass(this.options.err.clazz)
              .attr("data-" + ns + "-validator", validatorName)
              .attr("data-" + ns + "-for", field)
              .attr("data-" + ns + "-result", this.STATUS_NOT_VALIDATED)
              .html(this._getMessage(field, validatorName))
              .appendTo($message);
          }

          // Init the validator
          alias = validators[validatorName].alias || validatorName;
          if ("function" === typeof FormValidation.Validator[alias].init) {
            FormValidation.Validator[alias].init(
              this,
              $field,
              this.options.fields[field].validators[validatorName],
              validatorName
            );
          }
        }

        // Prepare the feedback icons
        if (
          this.options.fields[field].icon !== false &&
          this.options.fields[field].icon !== "false" &&
          this.options.icon &&
          this.options.icon.valid &&
          this.options.icon.invalid &&
          this.options.icon.validating &&
          (!updateAll || i === total - 1)
        ) {
          // $parent.removeClass(this.options.row.valid).removeClass(this.options.row.invalid).addClass(this.options.row.feedback);
          // Keep error messages which are populated from back-end
          $parent.addClass(this.options.row.feedback);
          var $icon = $("<i/>")
            .css("display", "none")
            .addClass(this.options.icon.feedback)
            .attr("data-" + ns + "-icon-for", field)
            .insertAfter($field);

          // Store the icon as a data of field element
          (!updateAll ? $field : fields).data(ns + ".icon", $icon);

          if ("tooltip" === container || "popover" === container) {
            (!updateAll ? $field : fields)
              .on(this.options.events.fieldError, function () {
                $parent.addClass("fv-has-tooltip");
              })
              .on(this.options.events.fieldSuccess, function () {
                $parent.removeClass("fv-has-tooltip");
              });

            $field
              // Show tooltip/popover message when field gets focus
              .off("focus.container." + ns)
              .on("focus.container." + ns, function () {
                that._showTooltip($(this), container);
              })
              // and hide them when losing focus
              .off("blur.container." + ns)
              .on("blur.container." + ns, function () {
                that._hideTooltip($(this), container);
              });
          }

          if (
            "string" === typeof this.options.fields[field].icon &&
            this.options.fields[field].icon !== "true"
          ) {
            $icon.appendTo($(this.options.fields[field].icon));
          } else {
            this._fixIcon($field, $icon);
          }
        }
      }

      // Sort the validators by priority
      var sortedByPriority = [];
      for (validatorName in validators) {
        alias = validators[validatorName].alias || validatorName;

        // Determine the priority
        validators[validatorName].priority = parseInt(
          validators[validatorName].priority ||
            FormValidation.Validator[alias].priority ||
            1,
          10
        );
        sortedByPriority.push({
          validator: validatorName,
          priority: validators[validatorName].priority,
        });
      }
      sortedByPriority = sortedByPriority.sort(function (a, b) {
        return a.priority - b.priority;
      });

      // Prepare the events
      fields
        .data(ns + ".validators", sortedByPriority)
        .on(this.options.events.fieldSuccess, function (e, data) {
          var onSuccess = that.getOptions(data.field, null, "onSuccess");
          if (onSuccess) {
            FormValidation.Helper.call(onSuccess, [e, data]);
          }
        })
        .on(this.options.events.fieldError, function (e, data) {
          var onError = that.getOptions(data.field, null, "onError");
          if (onError) {
            FormValidation.Helper.call(onError, [e, data]);
          }
        })
        .on(this.options.events.fieldReset, function (e, data) {
          var onReset = that.getOptions(data.field, null, "onReset");
          if (onReset) {
            FormValidation.Helper.call(onReset, [e, data]);
          }
        })
        .on(this.options.events.fieldStatus, function (e, data) {
          var onStatus = that.getOptions(data.field, null, "onStatus");
          if (onStatus) {
            FormValidation.Helper.call(onStatus, [e, data]);
          }
        })
        .on(this.options.events.validatorError, function (e, data) {
          var onError = that.getOptions(data.field, data.validator, "onError");
          if (onError) {
            FormValidation.Helper.call(onError, [e, data]);
          }
        })
        .on(this.options.events.validatorIgnored, function (e, data) {
          var onIgnored = that.getOptions(
            data.field,
            data.validator,
            "onIgnored"
          );
          if (onIgnored) {
            FormValidation.Helper.call(onIgnored, [e, data]);
          }
        })
        .on(this.options.events.validatorSuccess, function (e, data) {
          var onSuccess = that.getOptions(
            data.field,
            data.validator,
            "onSuccess"
          );
          if (onSuccess) {
            FormValidation.Helper.call(onSuccess, [e, data]);
          }
        });

      // Set live mode
      this.onLiveChange(fields, "live", function () {
        if (that._exceedThreshold($(this))) {
          that.validateField($(this));
        }
      });

      fields.trigger($.Event(this.options.events.fieldInit), {
        bv: this, // Support backward
        fv: this,
        field: field,
        element: fields,
      });
    },

    /**
     * Check if the field is excluded.
     * Returning true means that the field will not be validated
     *
     * @param {jQuery} $field The field element
     * @returns {Boolean}
     */
    _isExcluded: function ($field) {
      var ns = this._namespace,
        excludedAttr = $field.attr("data-" + ns + "-excluded"),
        // I still need to check the 'name' attribute while initializing the field
        field = $field.attr("data-" + ns + "-field") || $field.attr("name");

      switch (true) {
        case !!field &&
          this.options.fields &&
          this.options.fields[field] &&
          (this.options.fields[field].excluded === "true" ||
            this.options.fields[field].excluded === true):
        case excludedAttr === "true":
        case excludedAttr === "":
          return true;

        case !!field &&
          this.options.fields &&
          this.options.fields[field] &&
          (this.options.fields[field].excluded === "false" ||
            this.options.fields[field].excluded === false):
        case excludedAttr === "false":
          return false;

        case !!field &&
          this.options.fields &&
          this.options.fields[field] &&
          "function" === typeof this.options.fields[field].excluded:
          return this.options.fields[field].excluded.call(this, $field, this);

        case !!field &&
          this.options.fields &&
          this.options.fields[field] &&
          "string" === typeof this.options.fields[field].excluded:
        case excludedAttr:
          return FormValidation.Helper.call(
            this.options.fields[field].excluded,
            [$field, this]
          );

        default:
          if (this.options.excluded) {
            // Convert to array first
            if ("string" === typeof this.options.excluded) {
              this.options.excluded = $.map(
                this.options.excluded.split(","),
                function (item) {
                  // Trim the spaces
                  return $.trim(item);
                }
              );
            }

            var length = this.options.excluded.length;
            for (var i = 0; i < length; i++) {
              if (
                ("string" === typeof this.options.excluded[i] &&
                  $field.is(this.options.excluded[i])) ||
                ("function" === typeof this.options.excluded[i] &&
                  this.options.excluded[i].call(this, $field, this) === true)
              ) {
                return true;
              }
            }
          }
          return false;
      }
    },

    /**
     * Get a field changed trigger event
     *
     * @param {jQuery} $field The field element
     * @returns {String[]} The event names triggered on field change
     */
    _getFieldTrigger: function ($field) {
      var ns = this._namespace,
        trigger = $field.data(ns + ".trigger");
      if (trigger) {
        return trigger;
      }

      // IE10/11 auto fires input event of elements using the placeholder attribute
      // https://connect.microsoft.com/IE/feedback/details/856700/
      var type = $field.attr("type"),
        name = $field.attr("data-" + ns + "-field"),
        event =
          "radio" === type ||
          "checkbox" === type ||
          "file" === type ||
          "SELECT" === $field.get(0).tagName
            ? "change"
            : this._ieVersion >= 10 && $field.attr("placeholder")
            ? "keyup"
            : this._changeEvent;
      trigger = (
        (this.options.fields[name]
          ? this.options.fields[name].trigger
          : null) ||
        this.options.trigger ||
        event
      ).split(" ");

      // Since the trigger data is used many times, I need to cache it to use later
      $field.data(ns + ".trigger", trigger);

      return trigger;
    },

    /**
     * Get the error message for given field and validator
     *
     * @param {String} field The field name
     * @param {String} validatorName The validator name
     * @returns {String}
     */
    _getMessage: function (field, validatorName) {
      if (
        !this.options.fields[field] ||
        !this.options.fields[field].validators
      ) {
        return "";
      }
      var validators = this.options.fields[field].validators,
        alias =
          validators[validatorName] && validators[validatorName].alias
            ? validators[validatorName].alias
            : validatorName;
      if (!FormValidation.Validator[alias]) {
        return "";
      }

      switch (true) {
        case !!validators[validatorName].message:
          return validators[validatorName].message;
        case !!this.options.fields[field].message:
          return this.options.fields[field].message;
        case !!this.options.message:
          return this.options.message;
        case !!FormValidation.I18n[this.options.locale] &&
          !!FormValidation.I18n[this.options.locale][alias] &&
          !!FormValidation.I18n[this.options.locale][alias]["default"]:
          return FormValidation.I18n[this.options.locale][alias]["default"];
        default:
          return this.DEFAULT_MESSAGE;
      }
    },

    /**
     * Get the element to place the error messages
     *
     * @param {jQuery} $field The field element
     * @param {String} row
     * @returns {jQuery}
     */
    _getMessageContainer: function ($field, row) {
      if (!this.options.err.parent) {
        throw new Error("The err.parent option is not defined");
      }

      var $parent = $field.parent();
      if ($parent.is(row)) {
        return $parent;
      }

      var cssClasses = $parent.attr("class");
      if (!cssClasses) {
        return this._getMessageContainer($parent, row);
      }

      if (this.options.err.parent.test(cssClasses)) {
        return $parent;
      }

      return this._getMessageContainer($parent, row);
    },

    /**
     * Parse the add-on options from HTML attributes
     *
     * @returns {Object}
     */
    _parseAddOnOptions: function () {
      var ns = this._namespace,
        names = this.$form.attr("data-" + ns + "-addons"),
        addOns = this.options.addOns || {};

      if (names) {
        names = names.replace(/\s/g, "").split(",");
        for (var i = 0; i < names.length; i++) {
          if (!addOns[names[i]]) {
            addOns[names[i]] = {};
          }
        }
      }

      // Try to parse each add-on options
      var addOn, attrMap, attr, option;
      for (addOn in addOns) {
        if (!FormValidation.AddOn[addOn]) {
          // Add-on is not found
          delete addOns[addOn];
          continue;
        }

        attrMap = FormValidation.AddOn[addOn].html5Attributes;
        if (attrMap) {
          for (attr in attrMap) {
            option = this.$form.attr(
              "data-" +
                ns +
                "-addons-" +
                addOn.toLowerCase() +
                "-" +
                attr.toLowerCase()
            );
            if (option) {
              addOns[addOn][attrMap[attr]] = option;
            }
          }
        }
      }

      return addOns;
    },

    /**
     * Parse the validator options from HTML attributes
     *
     * @param {jQuery} $field The field element
     * @returns {Object}
     */
    _parseOptions: function ($field) {
      var ns = this._namespace,
        field = $field.attr("name") || $field.attr("data-" + ns + "-field"),
        validators = {},
        aliasAttr = new RegExp("^data-" + ns + "-([a-z]+)-alias$"),
        validatorSet = $.extend({}, FormValidation.Validator),
        validator,
        v, // Validator name
        attrName,
        enabled,
        optionName,
        optionAttrName,
        optionValue,
        html5AttrName,
        html5AttrMap;

      // Determine whether the alias validator is used by checking the data-fv-validator-alias attribute
      $.each($field.get(0).attributes, function (i, attribute) {
        if (attribute.value && aliasAttr.test(attribute.name)) {
          v = attribute.name.split("-")[2];
          if (validatorSet[attribute.value]) {
            validatorSet[v] = validatorSet[attribute.value];
            validatorSet[v].alias = attribute.value;
          }
        }
      });

      for (v in validatorSet) {
        validator = validatorSet[v];
        (attrName = "data-" + ns + "-" + v.toLowerCase()),
          (enabled = $field.attr(attrName) + "");
        html5AttrMap =
          "function" === typeof validator.enableByHtml5
            ? validator.enableByHtml5($field)
            : null;

        if (
          (html5AttrMap && enabled !== "false") ||
          (html5AttrMap !== true &&
            ("" === enabled ||
              "true" === enabled ||
              attrName === enabled.toLowerCase()))
        ) {
          // Try to parse the options via attributes
          validator.html5Attributes = $.extend(
            {},
            {
              message: "message",
              onerror: "onError",
              onreset: "onReset",
              onsuccess: "onSuccess",
              priority: "priority",
              transformer: "transformer",
            },
            validator.html5Attributes
          );
          validators[v] = $.extend(
            {},
            html5AttrMap === true ? {} : html5AttrMap,
            validators[v]
          );
          if (validator.alias) {
            validators[v].alias = validator.alias;
          }

          for (html5AttrName in validator.html5Attributes) {
            optionName = validator.html5Attributes[html5AttrName];
            optionAttrName =
              "data-" + ns + "-" + v.toLowerCase() + "-" + html5AttrName;
            optionValue = $field.attr(optionAttrName);
            if (optionValue) {
              if (
                "true" === optionValue ||
                optionAttrName === optionValue.toLowerCase()
              ) {
                optionValue = true;
              } else if ("false" === optionValue) {
                optionValue = false;
              }
              validators[v][optionName] = optionValue;
            }
          }
        }
      }

      var opts = {
          autoFocus: $field.attr("data-" + ns + "-autofocus"),
          err:
            $field.attr("data-" + ns + "-err-container") ||
            $field.attr("data-" + ns + "-container"), // Support backward
          enabled: $field.attr("data-" + ns + "-enabled"),
          excluded: $field.attr("data-" + ns + "-excluded"),
          icon:
            $field.attr("data-" + ns + "-icon") ||
            $field.attr("data-" + ns + "-feedbackicons") ||
            (this.options.fields && this.options.fields[field]
              ? this.options.fields[field].feedbackIcons
              : null), // Support backward
          message: $field.attr("data-" + ns + "-message"),
          onError: $field.attr("data-" + ns + "-onerror"),
          onReset: $field.attr("data-" + ns + "-onreset"),
          onStatus: $field.attr("data-" + ns + "-onstatus"),
          onSuccess: $field.attr("data-" + ns + "-onsuccess"),
          row:
            $field.attr("data-" + ns + "-row") ||
            $field.attr("data-" + ns + "-group") ||
            (this.options.fields && this.options.fields[field]
              ? this.options.fields[field].group
              : null), // Support backward
          selector: $field.attr("data-" + ns + "-selector"),
          threshold: $field.attr("data-" + ns + "-threshold"),
          transformer: $field.attr("data-" + ns + "-transformer"),
          trigger: $field.attr("data-" + ns + "-trigger"),
          verbose: $field.attr("data-" + ns + "-verbose"),
          validators: validators,
        },
        emptyOptions = $.isEmptyObject(opts), // Check if the field options are set using HTML attributes
        emptyValidators = $.isEmptyObject(validators); // Check if the field validators are set using HTML attributes

      if (
        !emptyValidators ||
        (!emptyOptions && this.options.fields && this.options.fields[field])
      ) {
        //opts.validators = validators;
        return opts;
      } else {
        return null;
      }
    },

    /**
     * Called when all validations are completed
     */
    _submit: function () {
      var isValid = this.isValid();
      if (isValid === null) {
        return;
      }

      var eventType = isValid
          ? this.options.events.formSuccess
          : this.options.events.formError,
        e = $.Event(eventType);

      this.$form.trigger(e);

      // Call default handler
      // Check if whether the submit button is clicked
      if (this.$submitButton) {
        isValid ? this._onSuccess(e) : this._onError(e);
      }
    },

    // ~~~~~~
    // Events
    // ~~~~~~

    /**
     * The default handler of error.form.fv event.
     * It will be called when there is a invalid field
     *
     * @param {jQuery.Event} e The jQuery event object
     */
    _onError: function (e) {
      if (e.isDefaultPrevented()) {
        return;
      }

      if ("submitted" === this.options.live) {
        // Enable live mode
        this.options.live = "enabled";

        var that = this;
        for (var field in this.options.fields) {
          (function (f) {
            var fields = that.getFieldElements(f);
            if (fields.length) {
              that.onLiveChange(fields, "live", function () {
                if (that._exceedThreshold($(this))) {
                  that.validateField($(this));
                }
              });
            }
          })(field);
        }
      }

      // Determined the first invalid field which will be focused on automatically
      var ns = this._namespace;
      for (var i = 0; i < this.$invalidFields.length; i++) {
        var $field = this.$invalidFields.eq(i),
          autoFocus = this.isOptionEnabled(
            $field.attr("data-" + ns + "-field"),
            "autoFocus"
          );
        if (autoFocus) {
          // Focus the field
          $field.focus();
          break;
        }
      }
    },

    /**
     * Called after validating a field element
     *
     * @param {jQuery} $field The field element
     * @param {String} [validatorName] The validator name
     */
    _onFieldValidated: function ($field, validatorName) {
      var ns = this._namespace,
        field = $field.attr("data-" + ns + "-field"),
        validators = this.options.fields[field].validators,
        counter = {},
        numValidators = 0,
        data = {
          bv: this, // Support backward
          fv: this,
          field: field,
          element: $field,
          validator: validatorName,
          result: $field.data(ns + ".response." + validatorName),
        };

      // Trigger an event after given validator completes
      if (validatorName) {
        switch ($field.data(ns + ".result." + validatorName)) {
          case this.STATUS_INVALID:
            $field.trigger($.Event(this.options.events.validatorError), data);
            break;
          case this.STATUS_VALID:
            $field.trigger($.Event(this.options.events.validatorSuccess), data);
            break;
          case this.STATUS_IGNORED:
            $field.trigger($.Event(this.options.events.validatorIgnored), data);
            break;
          default:
            break;
        }
      }

      counter[this.STATUS_NOT_VALIDATED] = 0;
      counter[this.STATUS_VALIDATING] = 0;
      counter[this.STATUS_INVALID] = 0;
      counter[this.STATUS_VALID] = 0;
      counter[this.STATUS_IGNORED] = 0;

      for (var v in validators) {
        if (validators[v].enabled === false) {
          continue;
        }

        numValidators++;
        var result = $field.data(ns + ".result." + v);
        if (result) {
          counter[result]++;
        }
      }

      // The sum of valid fields now also include ignored fields
      if (
        counter[this.STATUS_VALID] + counter[this.STATUS_IGNORED] ===
        numValidators
      ) {
        // Remove from the list of invalid fields
        this.$invalidFields = this.$invalidFields.not($field);

        $field.trigger($.Event(this.options.events.fieldSuccess), data);
      }
      // If all validators are completed and there is at least one validator which doesn't pass
      else if (
        (counter[this.STATUS_NOT_VALIDATED] === 0 ||
          !this.isOptionEnabled(field, "verbose")) &&
        counter[this.STATUS_VALIDATING] === 0 &&
        counter[this.STATUS_INVALID] > 0
      ) {
        // Add to the list of invalid fields
        this.$invalidFields = this.$invalidFields.add($field);

        $field.trigger($.Event(this.options.events.fieldError), data);
      }
    },

    /**
     * The default handler of success.form.fv event.
     * It will be called when all the fields are valid
     *
     * @param {jQuery.Event} e The jQuery event object
     */
    _onSuccess: function (e) {
      if (e.isDefaultPrevented()) {
        return;
      }

      // Submit the form
      this.disableSubmitButtons(true).defaultSubmit();
    },

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Abstract methods
    // Need to be implemented by sub-class that supports specific framework
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    /**
     * Specific framework might need to adjust the icon position
     *
     * @param {jQuery} $field The field element
     * @param {jQuery} $icon The icon element
     */
    _fixIcon: function ($field, $icon) {},

    /**
     * Create a tooltip or popover
     * It will be shown when focusing on the field
     *
     * @param {jQuery} $field The field element
     * @param {String} message The message
     * @param {String} type Can be 'tooltip' or 'popover'
     */
    _createTooltip: function ($field, message, type) {},

    /**
     * Destroy the tooltip or popover
     *
     * @param {jQuery} $field The field element
     * @param {String} type Can be 'tooltip' or 'popover'
     */
    _destroyTooltip: function ($field, type) {},

    /**
     * Hide a tooltip or popover
     *
     * @param {jQuery} $field The field element
     * @param {String} type Can be 'tooltip' or 'popover'
     */
    _hideTooltip: function ($field, type) {},

    /**
     * Show a tooltip or popover
     *
     * @param {jQuery} $field The field element
     * @param {String} type Can be 'tooltip' or 'popover'
     */
    _showTooltip: function ($field, type) {},

    // ~~~~~~~~~~~~~~
    // Public methods
    // ~~~~~~~~~~~~~~

    /**
     * Submit the form using default submission.
     * It also does not perform any validations when submitting the form
     */
    defaultSubmit: function () {
      var ns = this._namespace;
      if (this.$submitButton) {
        // Create hidden input to send the submit buttons
        $("<input/>")
          .attr({
            type: "hidden",
            name: this.$submitButton.attr("name"),
          })
          .attr("data-" + ns + "-submit-hidden", "")
          .val(this.$submitButton.val())
          .appendTo(this.$form);
      }

      // Submit form
      this.$form.off("submit." + ns).submit();
    },

    /**
     * Disable/enable submit buttons
     *
     * @param {Boolean} disabled Can be true or false
     * @returns {FormValidation.Base}
     */
    disableSubmitButtons: function (disabled) {
      if (!disabled) {
        this.$form
          .find(this.options.button.selector)
          .removeAttr("disabled")
          .removeClass(this.options.button.disabled);
      } else if (this.options.live !== "disabled") {
        // Don't disable if the live validating mode is disabled
        this.$form
          .find(this.options.button.selector)
          .attr("disabled", "disabled")
          .addClass(this.options.button.disabled);
      }

      return this;
    },

    /**
     * Retrieve the field elements by given name
     *
     * @param {String} field The field name
     * @returns {null|jQuery[]}
     */
    getFieldElements: function (field) {
      if (!this._cacheFields[field]) {
        if (this.options.fields[field] && this.options.fields[field].selector) {
          // Look for the field inside the form first
          var f = this.$form.find(this.options.fields[field].selector);
          // If not found, search in entire document
          this._cacheFields[field] = f.length
            ? f
            : $(this.options.fields[field].selector);
        } else {
          this._cacheFields[field] = this.$form.find('[name="' + field + '"]');
        }
      }

      return this._cacheFields[field];
    },

    /**
     * Get the field value after applying transformer
     *
     * @param {String|jQuery} field The field name or field element
     * @param {String} validatorName The validator name
     * @returns {String}
     */
    getFieldValue: function (field, validatorName) {
      var $field,
        ns = this._namespace;
      if ("string" === typeof field) {
        $field = this.getFieldElements(field);
        if ($field.length === 0) {
          return null;
        }
      } else {
        $field = field;
        field = $field.attr("data-" + ns + "-field");
      }

      if (!field || !this.options.fields[field]) {
        return $field.val();
      }

      var transformer =
        (this.options.fields[field].validators &&
        this.options.fields[field].validators[validatorName]
          ? this.options.fields[field].validators[validatorName].transformer
          : null) || this.options.fields[field].transformer;
      return transformer
        ? FormValidation.Helper.call(transformer, [$field, validatorName, this])
        : $field.val();
    },

    /**
     * Get the namespace
     *
     * @returns {String}
     */
    getNamespace: function () {
      return this._namespace;
    },

    /**
     * Get the field options
     *
     * @param {String|jQuery} [field] The field name or field element. If it is not set, the method returns the form options
     * @param {String} [validator] The name of validator. It null, the method returns form options
     * @param {String} [option] The option name
     * @return {String|Object}
     */
    getOptions: function (field, validator, option) {
      var ns = this._namespace;
      if (!field) {
        return option ? this.options[option] : this.options;
      }
      if ("object" === typeof field) {
        field = field.attr("data-" + ns + "-field");
      }
      if (!this.options.fields[field]) {
        return null;
      }

      var options = this.options.fields[field];
      if (!validator) {
        return option ? options[option] : options;
      }
      if (!options.validators || !options.validators[validator]) {
        return null;
      }

      return option
        ? options.validators[validator][option]
        : options.validators[validator];
    },

    /**
     * Get the validating result of field
     *
     * @param {String|jQuery} field The field name or field element
     * @param {String} validatorName The validator name
     * @returns {String} The status. Can be 'NOT_VALIDATED', 'VALIDATING', 'INVALID', 'VALID' or 'IGNORED'
     */
    getStatus: function (field, validatorName) {
      var ns = this._namespace;
      switch (typeof field) {
        case "object":
          return field.data(ns + ".result." + validatorName);
        case "string":
        /* falls through */
        default:
          return this.getFieldElements(field)
            .eq(0)
            .data(ns + ".result." + validatorName);
      }
    },

    /**
     * Check whether or not a field option is enabled
     *
     * @param {String} field The field name
     * @param {String} option The option name, "verbose", "autoFocus", for example
     * @returns {Boolean}
     */
    isOptionEnabled: function (field, option) {
      if (
        this.options.fields[field] &&
        (this.options.fields[field][option] === "true" ||
          this.options.fields[field][option] === true)
      ) {
        return true;
      }
      if (
        this.options.fields[field] &&
        (this.options.fields[field][option] === "false" ||
          this.options.fields[field][option] === false)
      ) {
        return false;
      }
      return this.options[option] === "true" || this.options[option] === true;
    },

    /**
     * Check the form validity
     *
     * @returns {Boolean|null} Returns one of three values
     * - true, if all fields are valid
     * - false, if there is one invalid field
     * - null, if there is at least one field which is not validated yet or being validated
     */
    isValid: function () {
      for (var field in this.options.fields) {
        var isValidField = this.isValidField(field);
        if (isValidField === null) {
          return null;
        }
        if (isValidField === false) {
          return false;
        }
      }

      return true;
    },

    /**
     * Check if all fields inside a given container are valid.
     * It's useful when working with a wizard-like such as tab, collapse
     *
     * @param {String|jQuery} container The container selector or element
     * @returns {Boolean|null} Returns one of three values
     * - true, if all fields inside the container are valid
     * - false, if there is one invalid field inside the container
     * - null, if the container consists of at least one field which is not validated yet or being validated
     */
    isValidContainer: function (container) {
      var that = this,
        ns = this._namespace,
        fields = [],
        $container = "string" === typeof container ? $(container) : container;
      if ($container.length === 0) {
        return true;
      }

      $container.find("[data-" + ns + "-field]").each(function () {
        var $field = $(this);
        if (!that._isExcluded($field)) {
          fields.push($field);
        }
      });

      var total = fields.length,
        clazz = this.options.err.clazz.split(" ").join(".");
      for (var i = 0; i < total; i++) {
        var $f = fields[i],
          field = $f.attr("data-" + ns + "-field"),
          $errors = $f
            .data(ns + ".messages")
            .find(
              "." +
                clazz +
                "[data-" +
                ns +
                "-validator][data-" +
                ns +
                '-for="' +
                field +
                '"]'
            );

        if (
          this.options.fields &&
          this.options.fields[field] &&
          (this.options.fields[field].enabled === "false" ||
            this.options.fields[field].enabled === false)
        ) {
          continue;
        }

        if (
          $errors.filter(
            "[data-" + ns + '-result="' + this.STATUS_INVALID + '"]'
          ).length > 0
        ) {
          return false;
        }

        // If the field is not validated
        if (
          $errors.filter(
            "[data-" + ns + '-result="' + this.STATUS_NOT_VALIDATED + '"]'
          ).length > 0 ||
          $errors.filter(
            "[data-" + ns + '-result="' + this.STATUS_VALIDATING + '"]'
          ).length > 0
        ) {
          return null;
        }
      }

      return true;
    },

    /**
     * Check if the field is valid or not
     *
     * @param {String|jQuery} field The field name or field element
     * @returns {Boolean|null} Returns one of three values
     * - true, if the field passes all validators
     * - false, if the field doesn't pass any validator
     * - null, if there is at least one validator which isn't validated yet or being validated
     */
    isValidField: function (field) {
      var ns = this._namespace,
        fields = $([]);
      switch (typeof field) {
        case "object":
          fields = field;
          field = field.attr("data-" + ns + "-field");
          break;
        case "string":
          fields = this.getFieldElements(field);
          break;
        default:
          break;
      }
      if (
        fields.length === 0 ||
        !this.options.fields[field] ||
        this.options.fields[field].enabled === "false" ||
        this.options.fields[field].enabled === false
      ) {
        return true;
      }

      var type = fields.attr("type"),
        total = "radio" === type || "checkbox" === type ? 1 : fields.length,
        $field,
        validatorName,
        status;
      for (var i = 0; i < total; i++) {
        $field = fields.eq(i);
        if (this._isExcluded($field)) {
          continue;
        }

        for (validatorName in this.options.fields[field].validators) {
          if (
            this.options.fields[field].validators[validatorName].enabled ===
            false
          ) {
            continue;
          }

          status = $field.data(ns + ".result." + validatorName);
          if (
            status === this.STATUS_VALIDATING ||
            status === this.STATUS_NOT_VALIDATED
          ) {
            return null;
          } else if (status === this.STATUS_INVALID) {
            return false;
          }
        }
      }

      return true;
    },

    /**
     * Detach a handler function for a field live change event
     *
     * @param {jQuery[]} $fields The field elements
     * @param {String} namespace The event namespace
     * @returns {FormValidation.Base}
     */
    offLiveChange: function ($fields, namespace) {
      if ($fields === null || $fields.length === 0) {
        return this;
      }

      var ns = this._namespace,
        trigger = this._getFieldTrigger($fields.eq(0)),
        events = $.map(trigger, function (item) {
          return item + "." + namespace + "." + ns;
        }).join(" ");

      $fields.off(events);
      return this;
    },

    /**
     * Attach a handler function for a field live change event
     *
     * @param {jQuery[]} $fields The field elements
     * @param {String} namespace The event namespace
     * @param {Function} handler The handler function
     * @returns {FormValidation.Base}
     */
    onLiveChange: function ($fields, namespace, handler) {
      if ($fields === null || $fields.length === 0) {
        return this;
      }

      var ns = this._namespace,
        trigger = this._getFieldTrigger($fields.eq(0)),
        events = $.map(trigger, function (item) {
          return item + "." + namespace + "." + ns;
        }).join(" ");

      switch (this.options.live) {
        case "submitted":
          break;
        case "disabled":
          $fields.off(events);
          break;
        case "enabled":
        /* falls through */
        default:
          $fields.off(events).on(events, function (e) {
            handler.apply(this, arguments);
          });
          break;
      }

      return this;
    },

    /**
     * Update the error message
     *
     * @param {String|jQuery} field The field name or field element
     * @param {String} validator The validator name
     * @param {String} message The message
     * @returns {FormValidation.Base}
     */
    updateMessage: function (field, validator, message) {
      var ns = this._namespace,
        $fields = $([]);
      switch (typeof field) {
        case "object":
          $fields = field;
          field = field.attr("data-" + ns + "-field");
          break;
        case "string":
          $fields = this.getFieldElements(field);
          break;
        default:
          break;
      }

      var clazz = this.options.err.clazz.split(" ").join(".");
      $fields.each(function () {
        $(this)
          .data(ns + ".messages")
          .find(
            "." +
              clazz +
              "[data-" +
              ns +
              '-validator="' +
              validator +
              '"][data-' +
              ns +
              '-for="' +
              field +
              '"]'
          )
          .html(message);
      });

      return this;
    },

    /**
     * Update all validating results of field
     *
     * @param {String|jQuery} field The field name or field element
     * @param {String} status The status. Can be 'NOT_VALIDATED', 'VALIDATING', 'INVALID', 'VALID' or 'IGNORED'
     * @param {String} [validatorName] The validator name. If null, the method updates validity result for all validators
     * @returns {FormValidation.Base}
     */
    updateStatus: function (field, status, validatorName) {
      var ns = this._namespace,
        fields = $([]);
      switch (typeof field) {
        case "object":
          fields = field;
          field = field.attr("data-" + ns + "-field");
          break;
        case "string":
          fields = this.getFieldElements(field);
          break;
        default:
          break;
      }

      if (!field || !this.options.fields[field]) {
        return this;
      }

      if (status === this.STATUS_NOT_VALIDATED) {
        // Reset the flag
        // To prevent the form from doing submit when a deferred validator returns true while typing
        this._submitIfValid = false;
      }

      var that = this,
        type = fields.attr("type"),
        row = this.options.fields[field].row || this.options.row.selector,
        total = "radio" === type || "checkbox" === type ? 1 : fields.length,
        clazz = this.options.err.clazz.split(" ").join(".");

      for (var i = 0; i < total; i++) {
        var $field = fields.eq(i);
        if (this._isExcluded($field)) {
          continue;
        }

        var $parent = $field.closest(row),
          $message = $field.data(ns + ".messages"),
          $allErrors = $message.find(
            "." +
              clazz +
              "[data-" +
              ns +
              "-validator][data-" +
              ns +
              '-for="' +
              field +
              '"]'
          ),
          $errors = validatorName
            ? $allErrors.filter(
                "[data-" + ns + '-validator="' + validatorName + '"]'
              )
            : $allErrors,
          $icon = $field.data(ns + ".icon"),
          // Support backward
          container =
            "function" ===
            typeof (
              this.options.fields[field].container ||
              this.options.fields[field].err ||
              this.options.err.container
            )
              ? (
                  this.options.fields[field].container ||
                  this.options.fields[field].err ||
                  this.options.err.container
                ).call(this, $field, this)
              : this.options.fields[field].container ||
                this.options.fields[field].err ||
                this.options.err.container,
          isValidField = null,
          isValidating,
          isNotValidated;

        // Update status
        if (validatorName) {
          $field.data(ns + ".result." + validatorName, status);
        } else {
          for (var v in this.options.fields[field].validators) {
            $field.data(ns + ".result." + v, status);
          }
        }

        // Show/hide error elements and feedback icons
        $errors.attr("data-" + ns + "-result", status);

        switch (status) {
          case this.STATUS_VALIDATING:
            isValidField = null;
            this.disableSubmitButtons(true);
            $field
              .removeClass(this.options.control.valid)
              .removeClass(this.options.control.invalid);
            $parent
              .removeClass(this.options.row.valid)
              .removeClass(this.options.row.invalid);
            if ($icon) {
              $icon
                .removeClass(this.options.icon.valid)
                .removeClass(this.options.icon.invalid)
                .addClass(this.options.icon.validating)
                .show();
            }
            break;

          case this.STATUS_INVALID:
            isValidField = false;
            this.disableSubmitButtons(true);
            $field
              .removeClass(this.options.control.valid)
              .addClass(this.options.control.invalid);
            $parent
              .removeClass(this.options.row.valid)
              .addClass(this.options.row.invalid);
            if ($icon) {
              $icon
                .removeClass(this.options.icon.valid)
                .removeClass(this.options.icon.validating)
                .addClass(this.options.icon.invalid)
                .show();
            }
            break;

          case this.STATUS_IGNORED: // Treat ignored fields like they are valid with some specialties
          case this.STATUS_VALID:
            isValidating =
              $allErrors.filter(
                "[data-" + ns + '-result="' + this.STATUS_VALIDATING + '"]'
              ).length > 0;
            isNotValidated =
              $allErrors.filter(
                "[data-" + ns + '-result="' + this.STATUS_NOT_VALIDATED + '"]'
              ).length > 0;

            var numIgnored = $allErrors.filter(
              "[data-" + ns + '-result="' + this.STATUS_IGNORED + '"]'
            ).length;

            // If the field is valid (passes all validators)
            isValidField =
              isValidating || isNotValidated // There are some validators that have not done
                ? null
                : // All validators are completed
                  $allErrors.filter(
                    "[data-" + ns + '-result="' + this.STATUS_VALID + '"]'
                  ).length +
                    numIgnored ===
                  $allErrors.length;

            $field
              .removeClass(this.options.control.valid)
              .removeClass(this.options.control.invalid);

            if (isValidField === true) {
              this.disableSubmitButtons(this.isValid() === false);
              if (status === this.STATUS_VALID) {
                $field.addClass(this.options.control.valid);
              }
            } else if (isValidField === false) {
              this.disableSubmitButtons(true);
              if (status === this.STATUS_VALID) {
                $field.addClass(this.options.control.invalid);
              }
            }

            if ($icon) {
              $icon
                .removeClass(this.options.icon.invalid)
                .removeClass(this.options.icon.validating)
                .removeClass(this.options.icon.valid);
              if (
                status === this.STATUS_VALID ||
                numIgnored !== $allErrors.length
              ) {
                $icon
                  .addClass(
                    isValidating
                      ? this.options.icon.validating
                      : isValidField === null
                      ? ""
                      : isValidField
                      ? this.options.icon.valid
                      : this.options.icon.invalid
                  )
                  .show();
              }
            }

            var isValidContainer = this.isValidContainer($parent);
            if (isValidContainer !== null) {
              $parent
                .removeClass(this.options.row.valid)
                .removeClass(this.options.row.invalid);
              if (
                status === this.STATUS_VALID ||
                numIgnored !== $allErrors.length
              ) {
                $parent.addClass(
                  isValidContainer
                    ? this.options.row.valid
                    : this.options.row.invalid
                );
              }
            }
            break;

          case this.STATUS_NOT_VALIDATED:
          /* falls through */
          default:
            isValidField = null;
            this.disableSubmitButtons(false);
            $field
              .removeClass(this.options.control.valid)
              .removeClass(this.options.control.invalid);
            $parent
              .removeClass(this.options.row.valid)
              .removeClass(this.options.row.invalid);
            if ($icon) {
              $icon
                .removeClass(this.options.icon.valid)
                .removeClass(this.options.icon.invalid)
                .removeClass(this.options.icon.validating)
                .hide();
            }
            break;
        }

        if ($icon && ("tooltip" === container || "popover" === container)) {
          isValidField === false
            ? // Only show the first error message
              this._createTooltip(
                $field,
                $allErrors
                  .filter(
                    "[data-" + ns + '-result="' + that.STATUS_INVALID + '"]'
                  )
                  .eq(0)
                  .html(),
                container
              )
            : this._destroyTooltip($field, container);
        } else {
          status === this.STATUS_INVALID ? $errors.show() : $errors.hide();
        }

        // Trigger an event
        $field.trigger($.Event(this.options.events.fieldStatus), {
          bv: this, // Support backward
          fv: this,
          field: field,
          element: $field,
          status: status,
          validator: validatorName,
        });
        this._onFieldValidated($field, validatorName);
      }

      return this;
    },

    /**
     * Validate the form
     *
     * @returns {FormValidation.Base}
     */
    validate: function () {
      if ($.isEmptyObject(this.options.fields)) {
        this._submit();
        return this;
      }
      this.$form.trigger($.Event(this.options.events.formPreValidate));

      this.disableSubmitButtons(true);
      this._submitIfValid = false;
      for (var field in this.options.fields) {
        this.validateField(field);
      }

      this._submit();
      this._submitIfValid = true;

      return this;
    },

    /**
     * Validate given field
     *
     * @param {String|jQuery} field The field name or field element
     * @returns {FormValidation.Base}
     */
    validateField: function (field) {
      var ns = this._namespace,
        fields = $([]);
      switch (typeof field) {
        case "object":
          fields = field;
          field = field.attr("data-" + ns + "-field");
          break;
        case "string":
          fields = this.getFieldElements(field);
          break;
        default:
          break;
      }

      if (
        fields.length === 0 ||
        !this.options.fields[field] ||
        this.options.fields[field].enabled === "false" ||
        this.options.fields[field].enabled === false
      ) {
        return this;
      }

      var that = this,
        type = fields.attr("type"),
        total =
          ("radio" === type || "checkbox" === type) &&
          this.options.live !== "disabled"
            ? 1
            : fields.length,
        updateAll = "radio" === type || "checkbox" === type,
        validators = this.options.fields[field].validators,
        verbose = this.isOptionEnabled(field, "verbose"),
        validatorName,
        alias,
        validateResult;

      for (var i = 0; i < total; i++) {
        var $field = fields.eq(i);
        if (this._isExcluded($field)) {
          continue;
        }

        var stop = false,
          sortedByPriority = $field.data(ns + ".validators"),
          numValidators = sortedByPriority.length;

        for (var j = 0; j < numValidators; j++) {
          validatorName = sortedByPriority[j].validator;
          if ($field.data(ns + ".dfs." + validatorName)) {
            $field.data(ns + ".dfs." + validatorName).reject();
          }
          if (stop) {
            break;
          }

          // Don't validate field if it is already done
          var result = $field.data(ns + ".result." + validatorName);
          if (result === this.STATUS_VALID || result === this.STATUS_INVALID) {
            this._onFieldValidated($field, validatorName);
            continue;
          } else if (validators[validatorName].enabled === false) {
            // Changed in v0.6.2:
            // When the field validator is disabled, it should be treated as STATUS_IGNORED instead of STATUS_VALID
            // By doing that, the field with only disabled and ignored validators will not have success/error class
            this.updateStatus(
              updateAll ? field : $field,
              this.STATUS_IGNORED,
              validatorName
            );
            continue;
          }

          $field.data(ns + ".result." + validatorName, this.STATUS_VALIDATING);

          // Check whether or not the validator is just an alias of another
          alias = validators[validatorName].alias || validatorName;
          validateResult = FormValidation.Validator[alias].validate(
            this,
            $field,
            validators[validatorName],
            validatorName
          );

          // validateResult can be a $.Deferred object ...
          if ("object" === typeof validateResult && validateResult.resolve) {
            this.updateStatus(
              updateAll ? field : $field,
              this.STATUS_VALIDATING,
              validatorName
            );
            $field.data(ns + ".dfs." + validatorName, validateResult);

            validateResult.done(function ($f, v, response) {
              // v is validator name
              $f.removeData(ns + ".dfs." + v).data(
                ns + ".response." + v,
                response
              );
              if (response.message) {
                that.updateMessage($f, v, response.message);
              }

              that.updateStatus(
                updateAll ? $f.attr("data-" + ns + "-field") : $f,
                response.valid === true
                  ? that.STATUS_VALID
                  : response.valid === false
                  ? that.STATUS_INVALID
                  : that.STATUS_IGNORED,
                v
              );

              if (response.valid && that._submitIfValid === true) {
                // If a remote validator returns true and the form is ready to submit, then do it
                that._submit();
              } else if (response.valid === false && !verbose) {
                stop = true;
              }
            });
          }
          // ... or object { valid: true/false/null, message: 'dynamic message', otherKey: value, ... }
          else if (
            "object" === typeof validateResult &&
            validateResult.valid !== undefined
          ) {
            $field.data(ns + ".response." + validatorName, validateResult);
            if (validateResult.message) {
              this.updateMessage(
                updateAll ? field : $field,
                validatorName,
                validateResult.message
              );
            }
            this.updateStatus(
              updateAll ? field : $field,
              validateResult.valid === true
                ? this.STATUS_VALID
                : validateResult.valid === false
                ? this.STATUS_INVALID
                : this.STATUS_IGNORED,
              validatorName
            );
            if (validateResult.valid === false && !verbose) {
              break;
            }
          }
          // ... or a boolean value
          else if ("boolean" === typeof validateResult) {
            $field.data(ns + ".response." + validatorName, validateResult);
            this.updateStatus(
              updateAll ? field : $field,
              validateResult ? this.STATUS_VALID : this.STATUS_INVALID,
              validatorName
            );
            if (!validateResult && !verbose) {
              break;
            }
          }
          // ... or null
          // to indicate that the field should be ignored for current validator
          else if (null === validateResult) {
            $field.data(ns + ".response." + validatorName, validateResult);
            this.updateStatus(
              updateAll ? field : $field,
              this.STATUS_IGNORED,
              validatorName
            );
          }
        }
      }

      return this;
    },

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Useful APIs which aren't used internally
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    /**
     * Add a new field
     *
     * @param {String|jQuery} field The field name or field element
     * @param {Object} [options] The validator rules
     * @returns {FormValidation.Base}
     */
    addField: function (field, options) {
      var ns = this._namespace,
        fields = $([]);
      switch (typeof field) {
        case "object":
          fields = field;
          field = field.attr("data-" + ns + "-field") || field.attr("name");
          break;
        case "string":
          delete this._cacheFields[field];
          fields = this.getFieldElements(field);
          break;
        default:
          break;
      }

      fields.attr("data-" + ns + "-field", field);

      var type = fields.attr("type"),
        total = "radio" === type || "checkbox" === type ? 1 : fields.length;

      for (var i = 0; i < total; i++) {
        var $field = fields.eq(i);

        // Try to parse the options from HTML attributes
        var opts = this._parseOptions($field);
        opts = opts === null ? options : $.extend(true, opts, options);

        this.options.fields[field] = $.extend(
          true,
          this.options.fields[field],
          opts
        );

        // Update the cache
        this._cacheFields[field] = this._cacheFields[field]
          ? this._cacheFields[field].add($field)
          : $field;

        // Init the element
        this._initField(
          "checkbox" === type || "radio" === type ? field : $field
        );
      }

      this.disableSubmitButtons(false);
      // Trigger an event
      this.$form.trigger($.Event(this.options.events.fieldAdded), {
        field: field,
        element: fields,
        options: this.options.fields[field],
      });

      return this;
    },

    /**
     * Destroy the plugin
     * It will remove all error messages, feedback icons and turn off the events
     */
    destroy: function () {
      var ns = this._namespace,
        i,
        field,
        fields,
        $field,
        validator,
        $icon,
        row,
        alias;

      // Destroy the validators first
      for (field in this.options.fields) {
        fields = this.getFieldElements(field);
        for (i = 0; i < fields.length; i++) {
          $field = fields.eq(i);
          for (validator in this.options.fields[field].validators) {
            if ($field.data(ns + ".dfs." + validator)) {
              $field.data(ns + ".dfs." + validator).reject();
            }
            $field
              .removeData(ns + ".result." + validator)
              .removeData(ns + ".response." + validator)
              .removeData(ns + ".dfs." + validator);

            // Destroy the validator
            alias =
              this.options.fields[field].validators[validator].alias ||
              validator;
            if ("function" === typeof FormValidation.Validator[alias].destroy) {
              FormValidation.Validator[alias].destroy(
                this,
                $field,
                this.options.fields[field].validators[validator],
                validator
              );
            }
          }
        }
      }

      // Remove messages and icons
      var clazz = this.options.err.clazz.split(" ").join(".");
      for (field in this.options.fields) {
        fields = this.getFieldElements(field);
        row = this.options.fields[field].row || this.options.row.selector;
        for (i = 0; i < fields.length; i++) {
          $field = fields.eq(i);
          // Remove all error messages
          var $messages = $field.data(ns + ".messages");
          if ($messages) {
            $messages
              .find(
                "." +
                  clazz +
                  "[data-" +
                  ns +
                  "-validator][data-" +
                  ns +
                  '-for="' +
                  field +
                  '"]'
              )
              .remove();
          }
          $field
            .removeData(ns + ".messages")
            .removeData(ns + ".validators")
            // Remove feedback classes
            .closest(row)
            .removeClass(this.options.row.valid)
            .removeClass(this.options.row.invalid)
            .removeClass(this.options.row.feedback)
            .end()
            // Turn off events
            .off("." + ns)
            .removeAttr("data-" + ns + "-field");

          // Remove feedback icons, tooltip/popover container
          // Support backward
          var container =
            "function" ===
            typeof (
              this.options.fields[field].container ||
              this.options.fields[field].err ||
              this.options.err.container
            )
              ? (
                  this.options.fields[field].container ||
                  this.options.fields[field].err ||
                  this.options.err.container
                ).call(this, $field, this)
              : this.options.fields[field].container ||
                this.options.fields[field].err ||
                this.options.err.container;
          if ("tooltip" === container || "popover" === container) {
            this._destroyTooltip($field, container);
          }

          $icon = $field.data(ns + ".icon");
          if ($icon) {
            $icon.remove();
          }
          $field
            .removeData(ns + ".icon")
            // It's safe to remove trigger data here, because it might be used when destroying the validator
            .removeData(ns + ".trigger");
        }
      }

      // Destroy the add-ons
      for (var addOn in this.options.addOns) {
        if ("function" === typeof FormValidation.AddOn[addOn].destroy) {
          FormValidation.AddOn[addOn].destroy(this, this.options.addOns[addOn]);
        }
      }

      this.disableSubmitButtons(false); // Enable submit buttons
      this.$hiddenButton.remove(); // Remove the hidden button

      this.$form
        .removeClass(this.options.elementClass)
        .off("." + ns)
        .removeData("bootstrapValidator") // Support backward
        .removeData("formValidation")
        // Remove generated hidden elements
        .find("[data-" + ns + "-submit-hidden]")
        .remove()
        .end()
        .find('[type="submit"]')
        .off("click." + ns);
    },

    /**
     * Enable/Disable all validators to given field
     *
     * @param {String} field The field name
     * @param {Boolean} enabled Enable/Disable field validators
     * @param {String} [validatorName] The validator name. If null, all validators will be enabled/disabled
     * @returns {FormValidation.Base}
     */
    enableFieldValidators: function (field, enabled, validatorName) {
      var validators = this.options.fields[field].validators;

      // Enable/disable particular validator
      if (
        validatorName &&
        validators &&
        validators[validatorName] &&
        validators[validatorName].enabled !== enabled
      ) {
        this.options.fields[field].validators[validatorName].enabled = enabled;
        this.updateStatus(field, this.STATUS_NOT_VALIDATED, validatorName);
      }
      // Enable/disable all validators
      else if (
        !validatorName &&
        this.options.fields[field].enabled !== enabled
      ) {
        this.options.fields[field].enabled = enabled;
        for (var v in validators) {
          this.enableFieldValidators(field, enabled, v);
        }
      }

      return this;
    },

    /**
     * Some validators have option which its value is dynamic.
     * For example, the zipCode validator has the country option which might be changed dynamically by a select element.
     *
     * @param {jQuery|String} field The field name or element
     * @param {String|Function} option The option which can be determined by:
     * - a string
     * - name of field which defines the value
     * - name of function which returns the value
     * - a function returns the value
     *
     * The callback function has the format of
     *      callback: function(value, validator, $field) {
     *          // value is the value of field
     *          // validator is the BootstrapValidator instance
     *          // $field is the field element
     *      }
     *
     * @returns {String}
     */
    getDynamicOption: function (field, option) {
      var $field =
          "string" === typeof field ? this.getFieldElements(field) : field,
        value = $field.val();

      // Option can be determined by
      // ... a function
      if ("function" === typeof option) {
        return FormValidation.Helper.call(option, [value, this, $field]);
      }
      // ... value of other field
      else if ("string" === typeof option) {
        var $f = this.getFieldElements(option);
        if ($f.length) {
          return $f.val();
        }
        // ... return value of callback
        else {
          return (
            FormValidation.Helper.call(option, [value, this, $field]) || option
          );
        }
      }

      return null;
    },

    /**
     * Get the form element
     *
     * @returns {jQuery}
     */
    getForm: function () {
      return this.$form;
    },

    /**
     * Get the list of invalid fields
     *
     * @returns {jQuery[]}
     */
    getInvalidFields: function () {
      return this.$invalidFields;
    },

    /**
     * Get the current locale
     *
     * @return {String}
     */
    getLocale: function () {
      return this.options.locale;
    },

    /**
     * Get the error messages
     *
     * @param {String|jQuery} [field] The field name or field element
     * If the field is not defined, the method returns all error messages of all fields
     * @param {String} [validator] The name of validator
     * If the validator is not defined, the method returns error messages of all validators
     * @returns {String[]}
     */
    getMessages: function (field, validator) {
      var that = this,
        ns = this._namespace,
        messages = [],
        $fields = $([]);

      switch (true) {
        case field && "object" === typeof field:
          $fields = field;
          break;
        case field && "string" === typeof field:
          var f = this.getFieldElements(field);
          if (f.length > 0) {
            var type = f.attr("type");
            $fields = "radio" === type || "checkbox" === type ? f.eq(0) : f;
          }
          break;
        default:
          $fields = this.$invalidFields;
          break;
      }

      var filter = validator
          ? "[data-" + ns + '-validator="' + validator + '"]'
          : "",
        clazz = this.options.err.clazz.split(" ").join(".");
      $fields.each(function () {
        messages = messages.concat(
          $(this)
            .data(ns + ".messages")
            .find(
              "." +
                clazz +
                "[data-" +
                ns +
                '-for="' +
                $(this).attr("data-" + ns + "-field") +
                '"][data-' +
                ns +
                '-result="' +
                that.STATUS_INVALID +
                '"]' +
                filter
            )
            .map(function () {
              var v = $(this).attr("data-" + ns + "-validator"),
                f = $(this).attr("data-" + ns + "-for");
              return that.options.fields[f].validators[v].enabled === false
                ? ""
                : $(this).html();
            })
            .get()
        );
      });

      return messages;
    },

    /**
     * Returns the clicked submit button
     *
     * @returns {jQuery}
     */
    getSubmitButton: function () {
      return this.$submitButton;
    },

    /**
     * Remove a given field
     *
     * @param {String|jQuery} field The field name or field element
     * @returns {FormValidation.Base}
     */
    removeField: function (field) {
      var ns = this._namespace,
        fields = $([]);
      switch (typeof field) {
        case "object":
          fields = field;
          field = field.attr("data-" + ns + "-field") || field.attr("name");
          fields.attr("data-" + ns + "-field", field);
          break;
        case "string":
          fields = this.getFieldElements(field);
          break;
        default:
          break;
      }

      if (fields.length === 0) {
        return this;
      }

      var type = fields.attr("type"),
        total = "radio" === type || "checkbox" === type ? 1 : fields.length;

      for (var i = 0; i < total; i++) {
        var $field = fields.eq(i);

        // Remove from the list of invalid fields
        this.$invalidFields = this.$invalidFields.not($field);

        // Update the cache
        this._cacheFields[field] = this._cacheFields[field].not($field);
      }

      if (!this._cacheFields[field] || this._cacheFields[field].length === 0) {
        delete this.options.fields[field];
      }
      if ("checkbox" === type || "radio" === type) {
        this._initField(field);
      }

      this.disableSubmitButtons(false);
      // Trigger an event
      this.$form.trigger($.Event(this.options.events.fieldRemoved), {
        field: field,
        element: fields,
      });

      return this;
    },

    /**
     * Reset given field
     *
     * @param {String|jQuery} field The field name or field element
     * @param {Boolean} [resetValue] If true, the method resets field value to empty or remove checked/selected attribute (for radio/checkbox)
     * @returns {FormValidation.Base}
     */
    resetField: function (field, resetValue) {
      var ns = this._namespace,
        $fields = $([]);
      switch (typeof field) {
        case "object":
          $fields = field;
          field = field.attr("data-" + ns + "-field");
          break;
        case "string":
          $fields = this.getFieldElements(field);
          break;
        default:
          break;
      }

      var i = 0,
        total = $fields.length;
      if (this.options.fields[field]) {
        for (i = 0; i < total; i++) {
          for (var validator in this.options.fields[field].validators) {
            $fields.eq(i).removeData(ns + ".dfs." + validator);
          }
        }
      }

      if (resetValue) {
        var type = $fields.attr("type");
        "radio" === type || "checkbox" === type
          ? $fields.prop("checked", false).removeAttr("selected")
          : $fields.val("");
      }

      // Mark field as not validated yet
      this.updateStatus(field, this.STATUS_NOT_VALIDATED);

      for (i = 0; i < total; i++) {
        $fields.eq(i).trigger($.Event(this.options.events.fieldReset), {
          fv: this,
          field: field,
          element: $fields.eq(i),
          resetValue: resetValue,
        });
      }

      return this;
    },

    /**
     * Reset the form
     *
     * @param {Boolean} [resetValue] If true, the method resets field value to empty or remove checked/selected attribute (for radio/checkbox)
     * @returns {FormValidation.Base}
     */
    resetForm: function (resetValue) {
      for (var field in this.options.fields) {
        this.resetField(field, resetValue);
      }

      this.$invalidFields = $([]);
      this.$submitButton = null;

      // Enable submit buttons
      this.disableSubmitButtons(false);

      this.$form.trigger($.Event(this.options.events.formReset), {
        fv: this,
        resetValue: resetValue,
      });

      return this;
    },

    /**
     * Revalidate given field
     * It's used when you need to revalidate the field which its value is updated by other plugin
     *
     * @param {String|jQuery} field The field name of field element
     * @returns {FormValidation.Base}
     */
    revalidateField: function (field) {
      this.updateStatus(field, this.STATUS_NOT_VALIDATED).validateField(field);

      return this;
    },

    /**
     * Set the locale
     *
     * @param {String} locale The locale in format of countrycode_LANGUAGECODE
     * @returns {FormValidation.Base}
     */
    setLocale: function (locale) {
      this.options.locale = locale;
      this.$form.trigger($.Event(this.options.events.localeChanged), {
        locale: locale,
        bv: this, // Support backward
        fv: this,
      });

      return this;
    },

    /**
     * Update the option of a specific validator
     *
     * @param {String|jQuery} field The field name or field element
     * @param {String} validator The validator name
     * @param {String} option The option name
     * @param {String} value The value to set
     * @returns {FormValidation.Base}
     */
    updateOption: function (field, validator, option, value) {
      var ns = this._namespace;
      if ("object" === typeof field) {
        field = field.attr("data-" + ns + "-field");
      }
      if (
        this.options.fields[field] &&
        this.options.fields[field].validators[validator]
      ) {
        this.options.fields[field].validators[validator][option] = value;
        this.updateStatus(field, this.STATUS_NOT_VALIDATED, validator);
      }

      return this;
    },

    /**
     * Validate given container
     * It can be used with isValidContainer() when you want to work with wizard form
     *
     * @param {String|jQuery} container The container selector or element
     * @returns {FormValidation.Base}
     */
    validateContainer: function (container) {
      var that = this,
        ns = this._namespace,
        fields = [],
        $container = "string" === typeof container ? $(container) : container;
      if ($container.length === 0) {
        return this;
      }

      $container.find("[data-" + ns + "-field]").each(function () {
        var $field = $(this);
        if (!that._isExcluded($field)) {
          fields.push($field);
        }
      });

      var total = fields.length;
      for (var i = 0; i < total; i++) {
        this.validateField(fields[i]);
      }

      return this;
    },
  };

  // Plugin definition
  $.fn.formValidation = function (option) {
    var params = arguments;
    return this.each(function () {
      var $this = $(this),
        data = $this.data("formValidation"),
        options = "object" === typeof option && option;
      if (!data) {
        var framework = (
            options.framework ||
            $this.attr("data-fv-framework") ||
            "bootstrap"
          ).toLowerCase(),
          clazz = framework.substr(0, 1).toUpperCase() + framework.substr(1);

        if (typeof FormValidation.Framework[clazz] === "undefined") {
          throw new Error(
            "The class FormValidation.Framework." +
              clazz +
              " is not implemented"
          );
        }

        data = new FormValidation.Framework[clazz](this, options);
        $this.addClass("fv-form-" + framework).data("formValidation", data);
      }

      // Allow to call plugin method
      if ("string" === typeof option) {
        data[option].apply(data, Array.prototype.slice.call(params, 1));
      }
    });
  };

  $.fn.formValidation.Constructor = FormValidation.Base;

  // Default message
  $.fn.formValidation.DEFAULT_MESSAGE = "This value is not valid";

  // The default options sorted in alphabetical order
  $.fn.formValidation.DEFAULT_OPTIONS = {
    // The first invalid field will be focused automatically
    autoFocus: true,

    // Support declarative usage (setting options via HTML 5 attributes)
    // Setting to false can improve the performance
    declarative: true,

    // The form CSS class
    elementClass: "fv-form",

    // Use custom event name to avoid window.onerror being invoked by jQuery
    // See #630
    events: {
      // Support backward
      formInit: "init.form.fv",
      formPreValidate: "prevalidate.form.fv",
      formError: "err.form.fv",
      formReset: "rst.form.fv",
      formSuccess: "success.form.fv",
      fieldAdded: "added.field.fv",
      fieldRemoved: "removed.field.fv",
      fieldInit: "init.field.fv",
      fieldError: "err.field.fv",
      fieldReset: "rst.field.fv",
      fieldSuccess: "success.field.fv",
      fieldStatus: "status.field.fv",
      localeChanged: "changed.locale.fv",
      validatorError: "err.validator.fv",
      validatorSuccess: "success.validator.fv",
      validatorIgnored: "ignored.validator.fv",
    },

    // Indicate fields which won't be validated
    // By default, the plugin will not validate the following kind of fields:
    // - disabled
    // - hidden
    // - invisible
    //
    // The setting consists of jQuery filters. Accept 3 formats:
    // - A string. Use a comma to separate filter
    // - An array. Each element is a filter
    // - An array. Each element can be a callback function
    //      function($field, validator) {
    //          $field is jQuery object representing the field element
    //          validator is the BootstrapValidator instance
    //          return true or false;
    //      }
    //
    // The 3 following settings are equivalent:
    //
    // 1) ':disabled, :hidden, :not(:visible)'
    // 2) [':disabled', ':hidden', ':not(:visible)']
    // 3) [':disabled', ':hidden', function($field) {
    //        return !$field.is(':visible');
    //    }]
    excluded: [":disabled", ":hidden", ":not(:visible)"],

    // Map the field name with validator rules
    fields: null,

    // Live validating option
    // Can be one of 3 values:
    // - enabled: The plugin validates fields as soon as they are changed
    // - disabled: Disable the live validating. The error messages are only shown after the form is submitted
    // - submitted: The live validating is enabled after the form is submitted
    live: "enabled",

    // Locale in the format of languagecode_COUNTRYCODE
    locale: "en_US",

    // Default invalid message
    message: null,

    // The field will not be live validated if its length is less than this number of characters
    threshold: null,

    // Whether to be verbose when validating a field or not.
    // Possible values:
    // - true:  when a field has multiple validators, all of them will be checked, and respectively - if errors occur in
    //          multiple validators, all of them will be displayed to the user
    // - false: when a field has multiple validators, validation for this field will be terminated upon the first encountered error.
    //          Thus, only the very first error message related to this field will be displayed to the user
    verbose: true,

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // These options mostly are overridden by specific framework
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    button: {
      // The submit buttons selector
      // These buttons will be disabled to prevent the valid form from multiple submissions
      // Don't perform validation when clicking on the submit button/input which have formnovalidate attribute
      selector: '[type="submit"]:not([formnovalidate])',

      // The disabled class
      disabled: "",
    },

    control: {
      // The CSS class for valid control
      valid: "",

      // The CSS class for invalid control
      invalid: "",
    },

    err: {
      // The CSS class of each message element
      clazz: "",

      // The error messages container. It can be:
      // - 'tooltip' if you want to use Bootstrap tooltip to show error messages
      // - 'popover' if you want to use Bootstrap popover to show error messages
      // - a CSS selector indicating the container
      // In the first two cases, since the tooltip/popover should be small enough, the plugin only shows only one error message
      // You also can define the message container for particular field
      container: null,

      // Used to determine where the messages are placed
      parent: null,
    },

    // Shows ok/error/loading icons based on the field validity.
    icon: {
      valid: null,
      invalid: null,
      validating: null,
      feedback: "",
    },

    row: {
      // The CSS selector for indicating the element consists of the field
      // You should adjust this option if your form group consists of many fields which not all of them need to be validated
      selector: null,
      valid: "",
      invalid: "",
      feedback: "",
    },
  };
})(jQuery);
(function ($) {
  // Helper methods, which can be used in validator class
  FormValidation.Helper = {
    /**
     * Execute a callback function
     *
     * @param {String|Function} functionName Can be
     * - name of global function
     * - name of namespace function (such as A.B.C)
     * - a function
     * @param {Array} args The callback arguments
     */
    call: function (functionName, args) {
      if ("function" === typeof functionName) {
        return functionName.apply(this, args);
      } else if ("string" === typeof functionName) {
        if ("()" === functionName.substring(functionName.length - 2)) {
          functionName = functionName.substring(0, functionName.length - 2);
        }
        var ns = functionName.split("."),
          func = ns.pop(),
          context = window;
        for (var i = 0; i < ns.length; i++) {
          context = context[ns[i]];
        }

        return typeof context[func] === "undefined"
          ? null
          : context[func].apply(this, args);
      }
    },

    /**
     * Validate a date
     *
     * @param {Number} year The full year in 4 digits
     * @param {Number} month The month number
     * @param {Number} day The day number
     * @param {Boolean} [notInFuture] If true, the date must not be in the future
     * @returns {Boolean}
     */
    date: function (year, month, day, notInFuture) {
      if (isNaN(year) || isNaN(month) || isNaN(day)) {
        return false;
      }
      if (day.length > 2 || month.length > 2 || year.length > 4) {
        return false;
      }

      day = parseInt(day, 10);
      month = parseInt(month, 10);
      year = parseInt(year, 10);

      if (year < 1000 || year > 9999 || month <= 0 || month > 12) {
        return false;
      }
      var numDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      // Update the number of days in Feb of leap year
      if (year % 400 === 0 || (year % 100 !== 0 && year % 4 === 0)) {
        numDays[1] = 29;
      }

      // Check the day
      if (day <= 0 || day > numDays[month - 1]) {
        return false;
      }

      if (notInFuture === true) {
        var currentDate = new Date(),
          currentYear = currentDate.getFullYear(),
          currentMonth = currentDate.getMonth(),
          currentDay = currentDate.getDate();
        return (
          year < currentYear ||
          (year === currentYear && month - 1 < currentMonth) ||
          (year === currentYear &&
            month - 1 === currentMonth &&
            day < currentDay)
        );
      }

      return true;
    },

    /**
     * Format a string
     * It's used to format the error message
     * format('The field must between %s and %s', [10, 20]) = 'The field must between 10 and 20'
     *
     * @param {String} message
     * @param {Array} parameters
     * @returns {String}
     */
    format: function (message, parameters) {
      if (!$.isArray(parameters)) {
        parameters = [parameters];
      }

      for (var i in parameters) {
        message = message.replace("%s", parameters[i]);
      }

      return message;
    },

    /**
     * Implement Luhn validation algorithm
     * Credit to https://gist.github.com/ShirtlessKirk/2134376
     *
     * @see http://en.wikipedia.org/wiki/Luhn
     * @param {String} value
     * @returns {Boolean}
     */
    luhn: function (value) {
      var length = value.length,
        mul = 0,
        prodArr = [
          [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
          [0, 2, 4, 6, 8, 1, 3, 5, 7, 9],
        ],
        sum = 0;

      while (length--) {
        sum += prodArr[mul][parseInt(value.charAt(length), 10)];
        mul ^= 1;
      }

      return sum % 10 === 0 && sum > 0;
    },

    /**
     * Implement modulus 11, 10 (ISO 7064) algorithm
     *
     * @param {String} value
     * @returns {Boolean}
     */
    mod11And10: function (value) {
      var check = 5,
        length = value.length;
      for (var i = 0; i < length; i++) {
        check =
          ((((check || 10) * 2) % 11) + parseInt(value.charAt(i), 10)) % 10;
      }
      return check === 1;
    },

    /**
     * Implements Mod 37, 36 (ISO 7064) algorithm
     * Usages:
     * mod37And36('A12425GABC1234002M')
     * mod37And36('002006673085', '0123456789')
     *
     * @param {String} value
     * @param {String} [alphabet]
     * @returns {Boolean}
     */
    mod37And36: function (value, alphabet) {
      alphabet = alphabet || "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      var modulus = alphabet.length,
        length = value.length,
        check = Math.floor(modulus / 2);
      for (var i = 0; i < length; i++) {
        check =
          ((((check || modulus) * 2) % (modulus + 1)) +
            alphabet.indexOf(value.charAt(i))) %
          modulus;
      }
      return check === 1;
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      base64: {
        default: "Please enter a valid base 64 encoded",
      },
    },
  });

  FormValidation.Validator.base64 = {
    /**
     * Return true if the input value is a base 64 encoded string.
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following keys:
     * - message: The invalid message
     * @returns {Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$/.test(
        value
      );
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      between: {
        default: "Please enter a value between %s and %s",
        notInclusive: "Please enter a value between %s and %s strictly",
      },
    },
  });

  FormValidation.Validator.between = {
    html5Attributes: {
      message: "message",
      min: "min",
      max: "max",
      inclusive: "inclusive",
    },

    enableByHtml5: function ($field) {
      if ("range" === $field.attr("type")) {
        return {
          min: $field.attr("min"),
          max: $field.attr("max"),
        };
      }

      return false;
    },

    /**
     * Return true if the input value is between (strictly or not) two given numbers
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following keys:
     * - min
     * - max
     *
     * The min, max keys define the number which the field value compares to. min, max can be
     *      - A number
     *      - Name of field which its value defines the number
     *      - Name of callback function that returns the number
     *      - A callback function that returns the number
     *
     * - inclusive [optional]: Can be true or false. Default is true
     * - message: The invalid message
     * @returns {Boolean|Object}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      value = this._format(value);

      var locale = validator.getLocale(),
        min = $.isNumeric(options.min)
          ? options.min
          : validator.getDynamicOption($field, options.min),
        max = $.isNumeric(options.max)
          ? options.max
          : validator.getDynamicOption($field, options.max),
        minValue = this._format(min),
        maxValue = this._format(max);

      return options.inclusive === true || options.inclusive === undefined
        ? {
            valid:
              $.isNumeric(value) &&
              parseFloat(value) >= minValue &&
              parseFloat(value) <= maxValue,
            message: FormValidation.Helper.format(
              options.message || FormValidation.I18n[locale].between["default"],
              [min, max]
            ),
          }
        : {
            valid:
              $.isNumeric(value) &&
              parseFloat(value) > minValue &&
              parseFloat(value) < maxValue,
            message: FormValidation.Helper.format(
              options.message ||
                FormValidation.I18n[locale].between.notInclusive,
              [min, max]
            ),
          };
    },

    _format: function (value) {
      return (value + "").replace(",", ".");
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      bic: {
        default: "Please enter a valid BIC number",
      },
    },
  });

  FormValidation.Validator.bic = {
    /**
     * Validate an Business Identifier Code (BIC), also known as ISO 9362, SWIFT-BIC, SWIFT ID or SWIFT code
     *
     * For more information see http://en.wikipedia.org/wiki/ISO_9362
     *
     * @todo The 5 and 6 characters are an ISO 3166-1 country code, this could also be validated
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following keys:
     * - message: The invalid message
     * @returns {Object}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }
      return /^[a-zA-Z]{6}[a-zA-Z0-9]{2}([a-zA-Z0-9]{3})?$/.test(value);
    },
  };
})(jQuery);
(function ($) {
  FormValidation.Validator.blank = {
    /**
     * Placeholder validator that can be used to display a custom validation message
     * returned from the server
     * Example:
     *
     * (1) a "blank" validator is applied to an input field.
     * (2) data is entered via the UI that is unable to be validated client-side.
     * (3) server returns a 400 with JSON data that contains the field that failed
     *     validation and an associated message.
     * (4) ajax 400 call handler does the following:
     *
     *      fv.updateMessage(field, 'blank', errorMessage);
     *      fv.updateStatus(field, 'INVALID', 'blank');
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following keys:
     * - message: The invalid message
     * @returns {Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      return true;
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      callback: {
        default: "Please enter a valid value",
      },
    },
  });

  FormValidation.Validator.callback = {
    priority: 999,

    html5Attributes: {
      message: "message",
      callback: "callback",
    },

    /**
     * Return result from the callback method
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following keys:
     * - callback: The callback method that passes parameters:
     *      callback: function(fieldValue, validator, $field) {
     *          // fieldValue is the value of field
     *          // validator is instance of FormValidation.Base
     *          // $field is the field element
     *      }
     * - message: The invalid message
     * @returns {Deferred}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName),
        dfd = new $.Deferred(),
        result = { valid: true };

      if (options.callback) {
        var response = FormValidation.Helper.call(options.callback, [
          value,
          validator,
          $field,
        ]);
        result =
          "boolean" === typeof response || null === response
            ? { valid: response }
            : response;
      }

      dfd.resolve($field, validatorName, result);
      return dfd;
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      choice: {
        default: "Please enter a valid value",
        less: "Please choose %s options at minimum",
        more: "Please choose %s options at maximum",
        between: "Please choose %s - %s options",
      },
    },
  });

  FormValidation.Validator.choice = {
    html5Attributes: {
      message: "message",
      min: "min",
      max: "max",
    },

    /**
     * Check if the number of checked boxes are less or more than a given number
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Consists of following keys:
     * - min
     * - max
     *
     * At least one of two keys is required
     * The min, max keys define the number which the field value compares to. min, max can be
     *      - A number
     *      - Name of field which its value defines the number
     *      - Name of callback function that returns the number
     *      - A callback function that returns the number
     *
     * - message: The invalid message
     * @returns {Object}
     */
    validate: function (validator, $field, options, validatorName) {
      var locale = validator.getLocale(),
        ns = validator.getNamespace(),
        numChoices = $field.is("select")
          ? validator
              .getFieldElements($field.attr("data-" + ns + "-field"))
              .find("option")
              .filter(":selected").length
          : validator
              .getFieldElements($field.attr("data-" + ns + "-field"))
              .filter(":checked").length,
        min = options.min
          ? $.isNumeric(options.min)
            ? options.min
            : validator.getDynamicOption($field, options.min)
          : null,
        max = options.max
          ? $.isNumeric(options.max)
            ? options.max
            : validator.getDynamicOption($field, options.max)
          : null,
        isValid = true,
        message =
          options.message || FormValidation.I18n[locale].choice["default"];

      if (
        (min && numChoices < parseInt(min, 10)) ||
        (max && numChoices > parseInt(max, 10))
      ) {
        isValid = false;
      }

      switch (true) {
        case !!min && !!max:
          message = FormValidation.Helper.format(
            options.message || FormValidation.I18n[locale].choice.between,
            [parseInt(min, 10), parseInt(max, 10)]
          );
          break;

        case !!min:
          message = FormValidation.Helper.format(
            options.message || FormValidation.I18n[locale].choice.less,
            parseInt(min, 10)
          );
          break;

        case !!max:
          message = FormValidation.Helper.format(
            options.message || FormValidation.I18n[locale].choice.more,
            parseInt(max, 10)
          );
          break;

        default:
          break;
      }

      return { valid: isValid, message: message };
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      color: {
        default: "Please enter a valid color",
      },
    },
  });

  FormValidation.Validator.color = {
    html5Attributes: {
      message: "message",
      type: "type",
    },

    enableByHtml5: function ($field) {
      return "color" === $field.attr("type");
    },

    SUPPORTED_TYPES: ["hex", "rgb", "rgba", "hsl", "hsla", "keyword"],

    KEYWORD_COLORS: [
      // Colors start with A
      "aliceblue",
      "antiquewhite",
      "aqua",
      "aquamarine",
      "azure",
      // B
      "beige",
      "bisque",
      "black",
      "blanchedalmond",
      "blue",
      "blueviolet",
      "brown",
      "burlywood",
      // C
      "cadetblue",
      "chartreuse",
      "chocolate",
      "coral",
      "cornflowerblue",
      "cornsilk",
      "crimson",
      "cyan",
      // D
      "darkblue",
      "darkcyan",
      "darkgoldenrod",
      "darkgray",
      "darkgreen",
      "darkgrey",
      "darkkhaki",
      "darkmagenta",
      "darkolivegreen",
      "darkorange",
      "darkorchid",
      "darkred",
      "darksalmon",
      "darkseagreen",
      "darkslateblue",
      "darkslategray",
      "darkslategrey",
      "darkturquoise",
      "darkviolet",
      "deeppink",
      "deepskyblue",
      "dimgray",
      "dimgrey",
      "dodgerblue",
      // F
      "firebrick",
      "floralwhite",
      "forestgreen",
      "fuchsia",
      // G
      "gainsboro",
      "ghostwhite",
      "gold",
      "goldenrod",
      "gray",
      "green",
      "greenyellow",
      "grey",
      // H
      "honeydew",
      "hotpink",
      // I
      "indianred",
      "indigo",
      "ivory",
      // K
      "khaki",
      // L
      "lavender",
      "lavenderblush",
      "lawngreen",
      "lemonchiffon",
      "lightblue",
      "lightcoral",
      "lightcyan",
      "lightgoldenrodyellow",
      "lightgray",
      "lightgreen",
      "lightgrey",
      "lightpink",
      "lightsalmon",
      "lightseagreen",
      "lightskyblue",
      "lightslategray",
      "lightslategrey",
      "lightsteelblue",
      "lightyellow",
      "lime",
      "limegreen",
      "linen",
      // M
      "magenta",
      "maroon",
      "mediumaquamarine",
      "mediumblue",
      "mediumorchid",
      "mediumpurple",
      "mediumseagreen",
      "mediumslateblue",
      "mediumspringgreen",
      "mediumturquoise",
      "mediumvioletred",
      "midnightblue",
      "mintcream",
      "mistyrose",
      "moccasin",
      // N
      "navajowhite",
      "navy",
      // O
      "oldlace",
      "olive",
      "olivedrab",
      "orange",
      "orangered",
      "orchid",
      // P
      "palegoldenrod",
      "palegreen",
      "paleturquoise",
      "palevioletred",
      "papayawhip",
      "peachpuff",
      "peru",
      "pink",
      "plum",
      "powderblue",
      "purple",
      // R
      "red",
      "rosybrown",
      "royalblue",
      // S
      "saddlebrown",
      "salmon",
      "sandybrown",
      "seagreen",
      "seashell",
      "sienna",
      "silver",
      "skyblue",
      "slateblue",
      "slategray",
      "slategrey",
      "snow",
      "springgreen",
      "steelblue",
      // T
      "tan",
      "teal",
      "thistle",
      "tomato",
      "transparent",
      "turquoise",
      // V
      "violet",
      // W
      "wheat",
      "white",
      "whitesmoke",
      // Y
      "yellow",
      "yellowgreen",
    ],

    /**
     * Return true if the input value is a valid color
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following keys:
     * - message: The invalid message
     * - type: The array of valid color types
     * @returns {Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      // Only accept 6 hex character values due to the HTML 5 spec
      // See http://www.w3.org/TR/html-markup/input.color.html#input.color.attrs.value
      if (this.enableByHtml5($field)) {
        return /^#[0-9A-F]{6}$/i.test(value);
      }

      var types = options.type || this.SUPPORTED_TYPES;
      if (!$.isArray(types)) {
        types = types.replace(/s/g, "").split(",");
      }

      var method,
        type,
        isValid = false;

      for (var i = 0; i < types.length; i++) {
        type = types[i];
        method = "_" + type.toLowerCase();
        isValid = isValid || this[method](value);
        if (isValid) {
          return true;
        }
      }

      return false;
    },

    _hex: function (value) {
      return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(value);
    },

    _hsl: function (value) {
      return /^hsl\((\s*(-?\d+)\s*,)(\s*(\b(0?\d{1,2}|100)\b%)\s*,)(\s*(\b(0?\d{1,2}|100)\b%)\s*)\)$/.test(
        value
      );
    },

    _hsla: function (value) {
      return /^hsla\((\s*(-?\d+)\s*,)(\s*(\b(0?\d{1,2}|100)\b%)\s*,){2}(\s*(0?(\.\d+)?|1(\.0+)?)\s*)\)$/.test(
        value
      );
    },

    _keyword: function (value) {
      return $.inArray(value, this.KEYWORD_COLORS) >= 0;
    },

    _rgb: function (value) {
      var regexInteger =
          /^rgb\((\s*(\b([01]?\d{1,2}|2[0-4]\d|25[0-5])\b)\s*,){2}(\s*(\b([01]?\d{1,2}|2[0-4]\d|25[0-5])\b)\s*)\)$/,
        regexPercent =
          /^rgb\((\s*(\b(0?\d{1,2}|100)\b%)\s*,){2}(\s*(\b(0?\d{1,2}|100)\b%)\s*)\)$/;
      return regexInteger.test(value) || regexPercent.test(value);
    },

    _rgba: function (value) {
      var regexInteger =
          /^rgba\((\s*(\b([01]?\d{1,2}|2[0-4]\d|25[0-5])\b)\s*,){3}(\s*(0?(\.\d+)?|1(\.0+)?)\s*)\)$/,
        regexPercent =
          /^rgba\((\s*(\b(0?\d{1,2}|100)\b%)\s*,){3}(\s*(0?(\.\d+)?|1(\.0+)?)\s*)\)$/;
      return regexInteger.test(value) || regexPercent.test(value);
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      creditCard: {
        default: "Please enter a valid credit card number",
      },
    },
  });

  FormValidation.Validator.creditCard = {
    /**
     * Return true if the input value is valid credit card number
     * Based on https://gist.github.com/DiegoSalazar/4075533
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} [options] Can consist of the following key:
     * - message: The invalid message
     * @returns {Boolean|Object}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      // Accept only digits, dashes or spaces
      if (/[^0-9-\s]+/.test(value)) {
        return false;
      }
      value = value.replace(/\D/g, "");

      if (!FormValidation.Helper.luhn(value)) {
        return false;
      }

      // Validate the card number based on prefix (IIN ranges) and length
      var cards = {
        AMERICAN_EXPRESS: {
          length: [15],
          prefix: ["34", "37"],
        },
        DANKORT: {
          length: [16],
          prefix: ["5019"],
        },
        DINERS_CLUB: {
          length: [14],
          prefix: ["300", "301", "302", "303", "304", "305", "36"],
        },
        DINERS_CLUB_US: {
          length: [16],
          prefix: ["54", "55"],
        },
        DISCOVER: {
          length: [16],
          prefix: [
            "6011",
            "622126",
            "622127",
            "622128",
            "622129",
            "62213",
            "62214",
            "62215",
            "62216",
            "62217",
            "62218",
            "62219",
            "6222",
            "6223",
            "6224",
            "6225",
            "6226",
            "6227",
            "6228",
            "62290",
            "62291",
            "622920",
            "622921",
            "622922",
            "622923",
            "622924",
            "622925",
            "644",
            "645",
            "646",
            "647",
            "648",
            "649",
            "65",
          ],
        },
        ELO: {
          length: [16],
          prefix: [
            "4011",
            "4312",
            "4389",
            "4514",
            "4573",
            "4576",
            "5041",
            "5066",
            "5067",
            "509",
            "6277",
            "6362",
            "6363",
            "650",
            "6516",
            "6550",
          ],
        },
        FORBRUGSFORENINGEN: {
          length: [16],
          prefix: ["600722"],
        },
        JCB: {
          length: [16],
          prefix: ["3528", "3529", "353", "354", "355", "356", "357", "358"],
        },
        LASER: {
          length: [16, 17, 18, 19],
          prefix: ["6304", "6706", "6771", "6709"],
        },
        MAESTRO: {
          length: [12, 13, 14, 15, 16, 17, 18, 19],
          prefix: [
            "5018",
            "5020",
            "5038",
            "5868",
            "6304",
            "6759",
            "6761",
            "6762",
            "6763",
            "6764",
            "6765",
            "6766",
          ],
        },
        MASTERCARD: {
          length: [16],
          prefix: ["51", "52", "53", "54", "55"],
        },
        SOLO: {
          length: [16, 18, 19],
          prefix: ["6334", "6767"],
        },
        UNIONPAY: {
          length: [16, 17, 18, 19],
          prefix: [
            "622126",
            "622127",
            "622128",
            "622129",
            "62213",
            "62214",
            "62215",
            "62216",
            "62217",
            "62218",
            "62219",
            "6222",
            "6223",
            "6224",
            "6225",
            "6226",
            "6227",
            "6228",
            "62290",
            "62291",
            "622920",
            "622921",
            "622922",
            "622923",
            "622924",
            "622925",
          ],
        },
        VISA_ELECTRON: {
          length: [16],
          prefix: ["4026", "417500", "4405", "4508", "4844", "4913", "4917"],
        },
        VISA: {
          length: [16],
          prefix: ["4"],
        },
      };

      var type, i;
      for (type in cards) {
        for (i in cards[type].prefix) {
          if (
            value.substr(0, cards[type].prefix[i].length) ===
              cards[type].prefix[i] && // Check the prefix
            $.inArray(value.length, cards[type].length) !== -1
          ) {
            // and length
            return {
              valid: true,
              type: type,
            };
          }
        }
      }

      return false;
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      cusip: {
        default: "Please enter a valid CUSIP number",
      },
    },
  });

  FormValidation.Validator.cusip = {
    /**
     * Validate a CUSIP number
     *
     * @see http://en.wikipedia.org/wiki/CUSIP
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} [options] Can consist of the following keys:
     * - message: The invalid message
     * @returns {Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      value = value.toUpperCase();
      if (!/^[0-9A-Z]{9}$/.test(value)) {
        return false;
      }

      var converted = $.map(value.split(""), function (item) {
          var code = item.charCodeAt(0);
          return code >= "A".charCodeAt(0) && code <= "Z".charCodeAt(0)
            ? // Replace A, B, C, ..., Z with 10, 11, ..., 35
              code - "A".charCodeAt(0) + 10
            : item;
        }),
        length = converted.length,
        sum = 0;
      for (var i = 0; i < length - 1; i++) {
        var num = parseInt(converted[i], 10);
        if (i % 2 !== 0) {
          num *= 2;
        }
        if (num > 9) {
          num -= 9;
        }
        sum += num;
      }

      sum = (10 - (sum % 10)) % 10;
      return sum === parseInt(converted[length - 1], 10);
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      cvv: {
        default: "Please enter a valid CVV number",
      },
    },
  });

  FormValidation.Validator.cvv = {
    html5Attributes: {
      message: "message",
      ccfield: "creditCardField",
    },

    /**
     * Bind the validator on the live change of the credit card field
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Consists of the following key:
     * - creditCardField: The credit card number field
     */
    init: function (validator, $field, options, validatorName) {
      if (options.creditCardField) {
        var creditCardField = validator.getFieldElements(
          options.creditCardField
        );
        validator.onLiveChange(
          creditCardField,
          "live_" + validatorName,
          function () {
            var status = validator.getStatus($field, validatorName);
            if (status !== validator.STATUS_NOT_VALIDATED) {
              validator.revalidateField($field);
            }
          }
        );
      }
    },

    /**
     * Unbind the validator on the live change of the credit card field
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Consists of the following key:
     * - creditCardField: The credit card number field
     */
    destroy: function (validator, $field, options, validatorName) {
      if (options.creditCardField) {
        var creditCardField = validator.getFieldElements(
          options.creditCardField
        );
        validator.offLiveChange(creditCardField, "live_" + validatorName);
      }
    },

    /**
     * Return true if the input value is a valid CVV number.
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following keys:
     * - creditCardField: The credit card number field. It can be null
     * - message: The invalid message
     * @returns {Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      if (!/^[0-9]{3,4}$/.test(value)) {
        return false;
      }

      if (!options.creditCardField) {
        return true;
      }

      // Get the credit card number
      var creditCard = validator.getFieldValue(
        options.creditCardField,
        "creditCard"
      );
      if (creditCard === null || creditCard === "") {
        return true;
      }

      creditCard = creditCard.replace(/\D/g, "");

      // Supported credit card types
      var cards = {
        AMERICAN_EXPRESS: {
          length: [15],
          prefix: ["34", "37"],
        },
        DANKORT: {
          length: [16],
          prefix: ["5019"],
        },
        DINERS_CLUB: {
          length: [14],
          prefix: ["300", "301", "302", "303", "304", "305", "36"],
        },
        DINERS_CLUB_US: {
          length: [16],
          prefix: ["54", "55"],
        },
        DISCOVER: {
          length: [16],
          prefix: [
            "6011",
            "622126",
            "622127",
            "622128",
            "622129",
            "62213",
            "62214",
            "62215",
            "62216",
            "62217",
            "62218",
            "62219",
            "6222",
            "6223",
            "6224",
            "6225",
            "6226",
            "6227",
            "6228",
            "62290",
            "62291",
            "622920",
            "622921",
            "622922",
            "622923",
            "622924",
            "622925",
            "644",
            "645",
            "646",
            "647",
            "648",
            "649",
            "65",
          ],
        },
        ELO: {
          length: [16],
          prefix: [
            "4011",
            "4312",
            "4389",
            "4514",
            "4573",
            "4576",
            "5041",
            "5066",
            "5067",
            "509",
            "6277",
            "6362",
            "6363",
            "650",
            "6516",
            "6550",
          ],
        },
        FORBRUGSFORENINGEN: {
          length: [16],
          prefix: ["600722"],
        },
        JCB: {
          length: [16],
          prefix: ["3528", "3529", "353", "354", "355", "356", "357", "358"],
        },
        LASER: {
          length: [16, 17, 18, 19],
          prefix: ["6304", "6706", "6771", "6709"],
        },
        MAESTRO: {
          length: [12, 13, 14, 15, 16, 17, 18, 19],
          prefix: [
            "5018",
            "5020",
            "5038",
            "5868",
            "6304",
            "6759",
            "6761",
            "6762",
            "6763",
            "6764",
            "6765",
            "6766",
          ],
        },
        MASTERCARD: {
          length: [16],
          prefix: ["51", "52", "53", "54", "55"],
        },
        SOLO: {
          length: [16, 18, 19],
          prefix: ["6334", "6767"],
        },
        UNIONPAY: {
          length: [16, 17, 18, 19],
          prefix: [
            "622126",
            "622127",
            "622128",
            "622129",
            "62213",
            "62214",
            "62215",
            "62216",
            "62217",
            "62218",
            "62219",
            "6222",
            "6223",
            "6224",
            "6225",
            "6226",
            "6227",
            "6228",
            "62290",
            "62291",
            "622920",
            "622921",
            "622922",
            "622923",
            "622924",
            "622925",
          ],
        },
        VISA_ELECTRON: {
          length: [16],
          prefix: ["4026", "417500", "4405", "4508", "4844", "4913", "4917"],
        },
        VISA: {
          length: [16],
          prefix: ["4"],
        },
      };
      var type,
        i,
        creditCardType = null;
      for (type in cards) {
        for (i in cards[type].prefix) {
          if (
            creditCard.substr(0, cards[type].prefix[i].length) ===
              cards[type].prefix[i] && // Check the prefix
            $.inArray(creditCard.length, cards[type].length) !== -1
          ) {
            // and length
            creditCardType = type;
            break;
          }
        }
      }

      return creditCardType === null
        ? false
        : "AMERICAN_EXPRESS" === creditCardType
        ? value.length === 4
        : value.length === 3;
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      date: {
        default: "Please enter a valid date",
        min: "Please enter a date after %s",
        max: "Please enter a date before %s",
        range: "Please enter a date in the range %s - %s",
      },
    },
  });

  FormValidation.Validator.date = {
    html5Attributes: {
      message: "message",
      format: "format",
      min: "min",
      max: "max",
      separator: "separator",
    },

    /**
     * Return true if the input value is valid date
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following keys:
     * - message: The invalid message
     * - min: the minimum date
     * - max: the maximum date
     * - separator: Use to separate the date, month, and year.
     * By default, it is /
     * - format: The date format. Default is MM/DD/YYYY
     * The format can be:
     *
     * i) date: Consist of DD, MM, YYYY parts which are separated by the separator option
     * ii) date and time:
     * The time can consist of h, m, s parts which are separated by :
     * ii) date, time and A (indicating AM or PM)
     * @returns {Boolean|Object}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      options.format = options.format || "MM/DD/YYYY";

      // #683: Force the format to YYYY-MM-DD as the default browser behaviour when using type="date" attribute
      if ($field.attr("type") === "date") {
        options.format = "YYYY-MM-DD";
      }

      var locale = validator.getLocale(),
        message =
          options.message || FormValidation.I18n[locale].date["default"],
        formats = options.format.split(" "),
        dateFormat = formats[0],
        timeFormat = formats.length > 1 ? formats[1] : null,
        amOrPm = formats.length > 2 ? formats[2] : null,
        sections = value.split(" "),
        date = sections[0],
        time = sections.length > 1 ? sections[1] : null;

      if (formats.length !== sections.length) {
        return {
          valid: false,
          message: message,
        };
      }

      // Determine the separator
      var separator = options.separator;
      if (!separator) {
        separator =
          date.indexOf("/") !== -1
            ? "/"
            : date.indexOf("-") !== -1
            ? "-"
            : date.indexOf(".") !== -1
            ? "."
            : null;
      }
      if (separator === null || date.indexOf(separator) === -1) {
        return {
          valid: false,
          message: message,
        };
      }

      // Determine the date
      date = date.split(separator);
      dateFormat = dateFormat.split(separator);
      if (date.length !== dateFormat.length) {
        return {
          valid: false,
          message: message,
        };
      }

      var year = date[$.inArray("YYYY", dateFormat)],
        month = date[$.inArray("MM", dateFormat)],
        day = date[$.inArray("DD", dateFormat)];

      if (!year || !month || !day || year.length !== 4) {
        return {
          valid: false,
          message: message,
        };
      }

      // Determine the time
      var minutes = null,
        hours = null,
        seconds = null;
      if (timeFormat) {
        timeFormat = timeFormat.split(":");
        time = time.split(":");

        if (timeFormat.length !== time.length) {
          return {
            valid: false,
            message: message,
          };
        }

        hours = time.length > 0 ? time[0] : null;
        minutes = time.length > 1 ? time[1] : null;
        seconds = time.length > 2 ? time[2] : null;

        if (hours === "" || minutes === "" || seconds === "") {
          return {
            valid: false,
            message: message,
          };
        }

        // Validate seconds
        if (seconds) {
          if (isNaN(seconds) || seconds.length > 2) {
            return {
              valid: false,
              message: message,
            };
          }
          seconds = parseInt(seconds, 10);
          if (seconds < 0 || seconds > 60) {
            return {
              valid: false,
              message: message,
            };
          }
        }

        // Validate hours
        if (hours) {
          if (isNaN(hours) || hours.length > 2) {
            return {
              valid: false,
              message: message,
            };
          }
          hours = parseInt(hours, 10);
          if (hours < 0 || hours >= 24 || (amOrPm && hours > 12)) {
            return {
              valid: false,
              message: message,
            };
          }
        }

        // Validate minutes
        if (minutes) {
          if (isNaN(minutes) || minutes.length > 2) {
            return {
              valid: false,
              message: message,
            };
          }
          minutes = parseInt(minutes, 10);
          if (minutes < 0 || minutes > 59) {
            return {
              valid: false,
              message: message,
            };
          }
        }
      }

      // Validate day, month, and year
      var valid = FormValidation.Helper.date(year, month, day),
        min = null,
        max = null,
        minOption = options.min,
        maxOption = options.max;

      if (minOption) {
        min =
          minOption instanceof Date
            ? minOption
            : this._parseDate(minOption, dateFormat, separator) ||
              this._parseDate(
                validator.getDynamicOption($field, minOption),
                dateFormat,
                separator
              );

        // In order to avoid displaying a date string like "Mon Dec 08 2014 19:14:12 GMT+0000 (WET)"
        minOption = this._formatDate(min, options.format);
      }

      if (maxOption) {
        max =
          maxOption instanceof Date
            ? maxOption
            : this._parseDate(maxOption, dateFormat, separator) ||
              this._parseDate(
                validator.getDynamicOption($field, maxOption),
                dateFormat,
                separator
              );

        // In order to avoid displaying a date string like "Mon Dec 08 2014 19:14:12 GMT+0000 (WET)"
        maxOption = this._formatDate(max, options.format);
      }

      date = new Date(year, month - 1, day, hours, minutes, seconds);

      switch (true) {
        case minOption && !maxOption && valid:
          valid = date.getTime() >= min.getTime();
          message =
            options.message ||
            FormValidation.Helper.format(
              FormValidation.I18n[locale].date.min,
              minOption
            );
          break;

        case maxOption && !minOption && valid:
          valid = date.getTime() <= max.getTime();
          message =
            options.message ||
            FormValidation.Helper.format(
              FormValidation.I18n[locale].date.max,
              maxOption
            );
          break;

        case maxOption && minOption && valid:
          valid =
            date.getTime() <= max.getTime() && date.getTime() >= min.getTime();
          message =
            options.message ||
            FormValidation.Helper.format(
              FormValidation.I18n[locale].date.range,
              [minOption, maxOption]
            );
          break;

        default:
          break;
      }

      return {
        valid: valid,
        date: date,
        message: message,
      };
    },

    /**
     * Return a date object after parsing the date string
     *
     * @param {Date|String} date   The date string to parse
     * @param {String} format The date format
     * The format can be:
     *   - date: Consist of DD, MM, YYYY parts which are separated by the separator option
     *   - date and time:
     *     The time can consist of h, m, s parts which are separated by :
     * @param {String} separator The separator used to separate the date, month, and year
     * @returns {Date}
     */
    _parseDate: function (date, format, separator) {
      if (date instanceof Date) {
        return date;
      }
      if (typeof date !== "string") {
        return null;
      }

      // Ensure that the format must consist of year, month and day patterns
      var yearIndex = $.inArray("YYYY", format),
        monthIndex = $.inArray("MM", format),
        dayIndex = $.inArray("DD", format);
      if (yearIndex === -1 || monthIndex === -1 || dayIndex === -1) {
        return null;
      }

      var minutes = 0,
        hours = 0,
        seconds = 0,
        sections = date.split(" "),
        dateSection = sections[0].split(separator);
      if (dateSection.length < 3) {
        return null;
      }

      if (sections.length > 1) {
        var timeSection = sections[1].split(":");
        hours = timeSection.length > 0 ? timeSection[0] : null;
        minutes = timeSection.length > 1 ? timeSection[1] : null;
        seconds = timeSection.length > 2 ? timeSection[2] : null;
      }

      return new Date(
        dateSection[yearIndex],
        dateSection[monthIndex] - 1,
        dateSection[dayIndex],
        hours,
        minutes,
        seconds
      );
    },

    /**
     * Format date
     *
     * @param {Date} date The date object to format
     * @param {String} format The date format
     * The format can consist of the following tokens:
     *      d       Day of the month without leading zeros (1 through 31)
     *      dd      Day of the month with leading zeros (01 through 31)
     *      m       Month without leading zeros (1 through 12)
     *      mm      Month with leading zeros (01 through 12)
     *      yy      Last two digits of year (for example: 14)
     *      yyyy    Full four digits of year (for example: 2014)
     *      h       Hours without leading zeros (1 through 12)
     *      hh      Hours with leading zeros (01 through 12)
     *      H       Hours without leading zeros (0 through 23)
     *      HH      Hours with leading zeros (00 through 23)
     *      M       Minutes without leading zeros (0 through 59)
     *      MM      Minutes with leading zeros (00 through 59)
     *      s       Seconds without leading zeros (0 through 59)
     *      ss      Seconds with leading zeros (00 through 59)
     * @returns {String}
     */
    _formatDate: function (date, format) {
      format = format
        .replace(/Y/g, "y")
        .replace(/M/g, "m")
        .replace(/D/g, "d")
        .replace(/:m/g, ":M")
        .replace(/:mm/g, ":MM")
        .replace(/:S/, ":s")
        .replace(/:SS/, ":ss");

      var replacer = {
        d: function (date) {
          return date.getDate();
        },
        dd: function (date) {
          var d = date.getDate();
          return d < 10 ? "0" + d : d;
        },
        m: function (date) {
          return date.getMonth() + 1;
        },
        mm: function (date) {
          var m = date.getMonth() + 1;
          return m < 10 ? "0" + m : m;
        },
        yy: function (date) {
          return ("" + date.getFullYear()).substr(2);
        },
        yyyy: function (date) {
          return date.getFullYear();
        },
        h: function (date) {
          return date.getHours() % 12 || 12;
        },
        hh: function (date) {
          var h = date.getHours() % 12 || 12;
          return h < 10 ? "0" + h : h;
        },
        H: function (date) {
          return date.getHours();
        },
        HH: function (date) {
          var H = date.getHours();
          return H < 10 ? "0" + H : H;
        },
        M: function (date) {
          return date.getMinutes();
        },
        MM: function (date) {
          var M = date.getMinutes();
          return M < 10 ? "0" + M : M;
        },
        s: function (date) {
          return date.getSeconds();
        },
        ss: function (date) {
          var s = date.getSeconds();
          return s < 10 ? "0" + s : s;
        },
      };

      return format.replace(
        /d{1,4}|m{1,4}|yy(?:yy)?|([HhMs])\1?|"[^"]*"|'[^']*'/g,
        function (match) {
          return replacer[match]
            ? replacer[match](date)
            : match.slice(1, match.length - 1);
        }
      );
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      different: {
        default: "Please enter a different value",
      },
    },
  });

  FormValidation.Validator.different = {
    html5Attributes: {
      message: "message",
      field: "field",
    },

    /**
     * Bind the validator on the live change of the field to compare with current one
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Consists of the following key:
     * - field: The name of field that will be used to compare with current one
     */
    init: function (validator, $field, options, validatorName) {
      var fields = options.field.split(",");
      for (var i = 0; i < fields.length; i++) {
        var compareWith = validator.getFieldElements($.trim(fields[i]));
        validator.onLiveChange(
          compareWith,
          "live_" + validatorName,
          function () {
            var status = validator.getStatus($field, validatorName);
            if (status !== validator.STATUS_NOT_VALIDATED) {
              validator.revalidateField($field);
            }
          }
        );
      }
    },

    /**
     * Unbind the validator on the live change of the field to compare with current one
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Consists of the following key:
     * - field: The name of field that will be used to compare with current one
     */
    destroy: function (validator, $field, options, validatorName) {
      var fields = options.field.split(",");
      for (var i = 0; i < fields.length; i++) {
        var compareWith = validator.getFieldElements($.trim(fields[i]));
        validator.offLiveChange(compareWith, "live_" + validatorName);
      }
    },

    /**
     * Return true if the input value is different with given field's value
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Consists of the following key:
     * - field: The name of field that will be used to compare with current one
     * - message: The invalid message
     * @returns {Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      var fields = options.field.split(","),
        isValid = true;

      for (var i = 0; i < fields.length; i++) {
        var compareWith = validator.getFieldElements($.trim(fields[i]));
        if (compareWith == null || compareWith.length === 0) {
          continue;
        }

        var compareValue = validator.getFieldValue(compareWith, validatorName);
        if (value === compareValue) {
          isValid = false;
        } else if (compareValue !== "") {
          validator.updateStatus(
            compareWith,
            validator.STATUS_VALID,
            validatorName
          );
        }
      }

      return isValid;
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      digits: {
        default: "Please enter only digits",
      },
    },
  });

  FormValidation.Validator.digits = {
    /**
     * Return true if the input value contains digits only
     *
     * @param {FormValidation.Base} validator Validate plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} [options]
     * @returns {Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      return /^\d+$/.test(value);
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      ean: {
        default: "Please enter a valid EAN number",
      },
    },
  });

  FormValidation.Validator.ean = {
    /**
     * Validate EAN (International Article Number)
     *
     * @see http://en.wikipedia.org/wiki/European_Article_Number
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following keys:
     * - message: The invalid message
     * @returns {Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      if (!/^(\d{8}|\d{12}|\d{13})$/.test(value)) {
        return false;
      }

      var length = value.length,
        sum = 0,
        weight = length === 8 ? [3, 1] : [1, 3];
      for (var i = 0; i < length - 1; i++) {
        sum += parseInt(value.charAt(i), 10) * weight[i % 2];
      }
      sum = (10 - (sum % 10)) % 10;
      return sum + "" === value.charAt(length - 1);
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      ein: {
        default: "Please enter a valid EIN number",
      },
    },
  });

  FormValidation.Validator.ein = {
    // The first two digits are called campus
    // See http://en.wikipedia.org/wiki/Employer_Identification_Number
    // http://www.irs.gov/Businesses/Small-Businesses-&-Self-Employed/How-EINs-are-Assigned-and-Valid-EIN-Prefixes
    CAMPUS: {
      ANDOVER: ["10", "12"],
      ATLANTA: ["60", "67"],
      AUSTIN: ["50", "53"],
      BROOKHAVEN: [
        "01",
        "02",
        "03",
        "04",
        "05",
        "06",
        "11",
        "13",
        "14",
        "16",
        "21",
        "22",
        "23",
        "25",
        "34",
        "51",
        "52",
        "54",
        "55",
        "56",
        "57",
        "58",
        "59",
        "65",
      ],
      CINCINNATI: ["30", "32", "35", "36", "37", "38", "61"],
      FRESNO: ["15", "24"],
      KANSAS_CITY: ["40", "44"],
      MEMPHIS: ["94", "95"],
      OGDEN: ["80", "90"],
      PHILADELPHIA: [
        "33",
        "39",
        "41",
        "42",
        "43",
        "48",
        "62",
        "63",
        "64",
        "66",
        "68",
        "71",
        "72",
        "73",
        "74",
        "75",
        "76",
        "77",
        "81",
        "82",
        "83",
        "84",
        "85",
        "86",
        "87",
        "88",
        "91",
        "92",
        "93",
        "98",
        "99",
      ],
      INTERNET: ["20", "26", "27", "45", "46", "47"],
      SMALL_BUSINESS_ADMINISTRATION: ["31"],
    },

    /**
     * Validate EIN (Employer Identification Number) which is also known as
     * Federal Employer Identification Number (FEIN) or Federal Tax Identification Number
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following keys:
     * - message: The invalid message
     * @returns {Object|Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      if (!/^[0-9]{2}-?[0-9]{7}$/.test(value)) {
        return false;
      }
      // Check the first two digits
      var campus = value.substr(0, 2) + "";
      for (var key in this.CAMPUS) {
        if ($.inArray(campus, this.CAMPUS[key]) !== -1) {
          return {
            valid: true,
            campus: key,
          };
        }
      }

      return false;
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      emailAddress: {
        default: "Please enter a valid email address",
      },
    },
  });

  FormValidation.Validator.emailAddress = {
    html5Attributes: {
      message: "message",
      multiple: "multiple",
      separator: "separator",
    },

    enableByHtml5: function ($field) {
      return "email" === $field.attr("type");
    },

    /**
     * Return true if and only if the input value is a valid email address
     *
     * @param {FormValidation.Base} validator Validate plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} [options]
     * - multiple: Allow multiple email addresses, separated by a comma or semicolon; default is false.
     * - separator: Regex for character or characters expected as separator between addresses; default is comma /[,;]/, i.e. comma or semicolon.
     * @returns {Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      // Email address regular expression
      // http://stackoverflow.com/questions/46155/validate-email-address-in-javascript
      var emailRegExp =
          /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,
        allowMultiple =
          options.multiple === true || options.multiple === "true";

      if (allowMultiple) {
        var separator = options.separator || /[,;]/,
          addresses = this._splitEmailAddresses(value, separator);

        for (var i = 0; i < addresses.length; i++) {
          if (!emailRegExp.test(addresses[i])) {
            return false;
          }
        }

        return true;
      } else {
        return emailRegExp.test(value);
      }
    },

    _splitEmailAddresses: function (emailAddresses, separator) {
      var quotedFragments = emailAddresses.split(/"/),
        quotedFragmentCount = quotedFragments.length,
        emailAddressArray = [],
        nextEmailAddress = "";

      for (var i = 0; i < quotedFragmentCount; i++) {
        if (i % 2 === 0) {
          var splitEmailAddressFragments = quotedFragments[i].split(separator),
            splitEmailAddressFragmentCount = splitEmailAddressFragments.length;

          if (splitEmailAddressFragmentCount === 1) {
            nextEmailAddress += splitEmailAddressFragments[0];
          } else {
            emailAddressArray.push(
              nextEmailAddress + splitEmailAddressFragments[0]
            );

            for (var j = 1; j < splitEmailAddressFragmentCount - 1; j++) {
              emailAddressArray.push(splitEmailAddressFragments[j]);
            }
            nextEmailAddress =
              splitEmailAddressFragments[splitEmailAddressFragmentCount - 1];
          }
        } else {
          nextEmailAddress += '"' + quotedFragments[i];
          if (i < quotedFragmentCount - 1) {
            nextEmailAddress += '"';
          }
        }
      }

      emailAddressArray.push(nextEmailAddress);
      return emailAddressArray;
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      file: {
        default: "Please choose a valid file",
      },
    },
  });

  FormValidation.Validator.file = {
    Error: {
      EXTENSION: "EXTENSION",
      MAX_FILES: "MAX_FILES",
      MAX_SIZE: "MAX_SIZE",
      MAX_TOTAL_SIZE: "MAX_TOTAL_SIZE",
      MIN_FILES: "MIN_FILES",
      MIN_SIZE: "MIN_SIZE",
      MIN_TOTAL_SIZE: "MIN_TOTAL_SIZE",
      TYPE: "TYPE",
    },

    html5Attributes: {
      extension: "extension",
      maxfiles: "maxFiles",
      minfiles: "minFiles",
      maxsize: "maxSize",
      minsize: "minSize",
      maxtotalsize: "maxTotalSize",
      mintotalsize: "minTotalSize",
      message: "message",
      type: "type",
    },

    /**
     * Validate upload file. Use HTML 5 API if the browser supports
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following keys:
     * - extension: The allowed extensions, separated by a comma
     * - maxFiles: The maximum number of files
     * - minFiles: The minimum number of files
     * - maxSize: The maximum size in bytes
     * - minSize: The minimum size in bytes
     * - maxTotalSize: The maximum size in bytes for all files
     * - minTotalSize: The minimum size in bytes for all files
     * - message: The invalid message
     * - type: The allowed MIME type, separated by a comma
     * @returns {Boolean|Object}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      var ext,
        extensions = options.extension
          ? options.extension.toLowerCase().split(",")
          : null,
        types = options.type ? options.type.toLowerCase().split(",") : null,
        html5 = window.File && window.FileList && window.FileReader;

      if (html5) {
        // Get FileList instance
        var files = $field.get(0).files,
          total = files.length,
          totalSize = 0;

        // Check the maxFiles
        if (options.maxFiles && total > parseInt(options.maxFiles, 10)) {
          return {
            valid: false,
            error: this.Error.MAX_FILES,
          };
        }

        // Check the minFiles
        if (options.minFiles && total < parseInt(options.minFiles, 10)) {
          return {
            valid: false,
            error: this.Error.MIN_FILES,
          };
        }

        var metaData = {};
        for (var i = 0; i < total; i++) {
          totalSize += files[i].size;
          ext = files[i].name.substr(files[i].name.lastIndexOf(".") + 1);
          metaData = {
            file: files[i],
            size: files[i].size,
            ext: ext,
            type: files[i].type,
          };

          // Check the minSize
          if (
            options.minSize &&
            files[i].size < parseInt(options.minSize, 10)
          ) {
            return {
              valid: false,
              error: this.Error.MIN_SIZE,
              metaData: metaData,
            };
          }

          // Check the maxSize
          if (
            options.maxSize &&
            files[i].size > parseInt(options.maxSize, 10)
          ) {
            return {
              valid: false,
              error: this.Error.MAX_SIZE,
              metaData: metaData,
            };
          }

          // Check file extension
          if (extensions && $.inArray(ext.toLowerCase(), extensions) === -1) {
            return {
              valid: false,
              error: this.Error.EXTENSION,
              metaData: metaData,
            };
          }

          // Check file type
          if (
            files[i].type &&
            types &&
            $.inArray(files[i].type.toLowerCase(), types) === -1
          ) {
            return {
              valid: false,
              error: this.Error.TYPE,
              metaData: metaData,
            };
          }
        }

        // Check the maxTotalSize
        if (
          options.maxTotalSize &&
          totalSize > parseInt(options.maxTotalSize, 10)
        ) {
          return {
            valid: false,
            error: this.Error.MAX_TOTAL_SIZE,
            metaData: {
              totalSize: totalSize,
            },
          };
        }

        // Check the minTotalSize
        if (
          options.minTotalSize &&
          totalSize < parseInt(options.minTotalSize, 10)
        ) {
          return {
            valid: false,
            error: this.Error.MIN_TOTAL_SIZE,
            metaData: {
              totalSize: totalSize,
            },
          };
        }
      } else {
        // Check file extension
        ext = value.substr(value.lastIndexOf(".") + 1);
        if (extensions && $.inArray(ext.toLowerCase(), extensions) === -1) {
          return {
            valid: false,
            error: this.Error.EXTENSION,
            metaData: {
              ext: ext,
            },
          };
        }
      }

      return true;
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      greaterThan: {
        default: "Please enter a value greater than or equal to %s",
        notInclusive: "Please enter a value greater than %s",
      },
    },
  });

  FormValidation.Validator.greaterThan = {
    html5Attributes: {
      message: "message",
      value: "value",
      inclusive: "inclusive",
    },

    enableByHtml5: function ($field) {
      var type = $field.attr("type"),
        min = $field.attr("min");
      if (min && type !== "date") {
        return {
          value: min,
        };
      }

      return false;
    },

    /**
     * Return true if the input value is greater than or equals to given number
     *
     * @param {FormValidation.Base} validator Validate plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following keys:
     * - value: Define the number to compare with. It can be
     *      - A number
     *      - Name of field which its value defines the number
     *      - Name of callback function that returns the number
     *      - A callback function that returns the number
     *
     * - inclusive [optional]: Can be true or false. Default is true
     * - message: The invalid message
     * @returns {Boolean|Object}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      value = this._format(value);

      var locale = validator.getLocale(),
        compareTo = $.isNumeric(options.value)
          ? options.value
          : validator.getDynamicOption($field, options.value),
        compareToValue = this._format(compareTo);

      return options.inclusive === true || options.inclusive === undefined
        ? {
            valid: $.isNumeric(value) && parseFloat(value) >= compareToValue,
            message: FormValidation.Helper.format(
              options.message ||
                FormValidation.I18n[locale].greaterThan["default"],
              compareTo
            ),
          }
        : {
            valid: $.isNumeric(value) && parseFloat(value) > compareToValue,
            message: FormValidation.Helper.format(
              options.message ||
                FormValidation.I18n[locale].greaterThan.notInclusive,
              compareTo
            ),
          };
    },

    _format: function (value) {
      return (value + "").replace(",", ".");
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      grid: {
        default: "Please enter a valid GRId number",
      },
    },
  });

  FormValidation.Validator.grid = {
    /**
     * Validate GRId (Global Release Identifier)
     *
     * @see http://en.wikipedia.org/wiki/Global_Release_Identifier
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following keys:
     * - message: The invalid message
     * @returns {Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      value = value.toUpperCase();
      if (
        !/^[GRID:]*([0-9A-Z]{2})[-\s]*([0-9A-Z]{5})[-\s]*([0-9A-Z]{10})[-\s]*([0-9A-Z]{1})$/g.test(
          value
        )
      ) {
        return false;
      }
      value = value.replace(/\s/g, "").replace(/-/g, "");
      if ("GRID:" === value.substr(0, 5)) {
        value = value.substr(5);
      }
      return FormValidation.Helper.mod37And36(value);
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      hex: {
        default: "Please enter a valid hexadecimal number",
      },
    },
  });

  FormValidation.Validator.hex = {
    /**
     * Return true if and only if the input value is a valid hexadecimal number
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Consist of key:
     * - message: The invalid message
     * @returns {Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      return /^[0-9a-fA-F]+$/.test(value);
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      iban: {
        default: "Please enter a valid IBAN number",
        country: "Please enter a valid IBAN number in %s",
        countries: {
          AD: "Andorra",
          AE: "United Arab Emirates",
          AL: "Albania",
          AO: "Angola",
          AT: "Austria",
          AZ: "Azerbaijan",
          BA: "Bosnia and Herzegovina",
          BE: "Belgium",
          BF: "Burkina Faso",
          BG: "Bulgaria",
          BH: "Bahrain",
          BI: "Burundi",
          BJ: "Benin",
          BR: "Brazil",
          CH: "Switzerland",
          CI: "Ivory Coast",
          CM: "Cameroon",
          CR: "Costa Rica",
          CV: "Cape Verde",
          CY: "Cyprus",
          CZ: "Czech Republic",
          DE: "Germany",
          DK: "Denmark",
          DO: "Dominican Republic",
          DZ: "Algeria",
          EE: "Estonia",
          ES: "Spain",
          FI: "Finland",
          FO: "Faroe Islands",
          FR: "France",
          GB: "United Kingdom",
          GE: "Georgia",
          GI: "Gibraltar",
          GL: "Greenland",
          GR: "Greece",
          GT: "Guatemala",
          HR: "Croatia",
          HU: "Hungary",
          IE: "Ireland",
          IL: "Israel",
          IR: "Iran",
          IS: "Iceland",
          IT: "Italy",
          JO: "Jordan",
          KW: "Kuwait",
          KZ: "Kazakhstan",
          LB: "Lebanon",
          LI: "Liechtenstein",
          LT: "Lithuania",
          LU: "Luxembourg",
          LV: "Latvia",
          MC: "Monaco",
          MD: "Moldova",
          ME: "Montenegro",
          MG: "Madagascar",
          MK: "Macedonia",
          ML: "Mali",
          MR: "Mauritania",
          MT: "Malta",
          MU: "Mauritius",
          MZ: "Mozambique",
          NL: "Netherlands",
          NO: "Norway",
          PK: "Pakistan",
          PL: "Poland",
          PS: "Palestine",
          PT: "Portugal",
          QA: "Qatar",
          RO: "Romania",
          RS: "Serbia",
          SA: "Saudi Arabia",
          SE: "Sweden",
          SI: "Slovenia",
          SK: "Slovakia",
          SM: "San Marino",
          SN: "Senegal",
          TL: "East Timor",
          TN: "Tunisia",
          TR: "Turkey",
          VG: "Virgin Islands, British",
          XK: "Republic of Kosovo",
        },
      },
    },
  });

  FormValidation.Validator.iban = {
    html5Attributes: {
      message: "message",
      country: "country",
      sepa: "sepa",
    },

    // http://www.swift.com/dsp/resources/documents/IBAN_Registry.pdf
    // http://en.wikipedia.org/wiki/International_Bank_Account_Number#IBAN_formats_by_country
    REGEX: {
      AD: "AD[0-9]{2}[0-9]{4}[0-9]{4}[A-Z0-9]{12}", // Andorra
      AE: "AE[0-9]{2}[0-9]{3}[0-9]{16}", // United Arab Emirates
      AL: "AL[0-9]{2}[0-9]{8}[A-Z0-9]{16}", // Albania
      AO: "AO[0-9]{2}[0-9]{21}", // Angola
      AT: "AT[0-9]{2}[0-9]{5}[0-9]{11}", // Austria
      AZ: "AZ[0-9]{2}[A-Z]{4}[A-Z0-9]{20}", // Azerbaijan
      BA: "BA[0-9]{2}[0-9]{3}[0-9]{3}[0-9]{8}[0-9]{2}", // Bosnia and Herzegovina
      BE: "BE[0-9]{2}[0-9]{3}[0-9]{7}[0-9]{2}", // Belgium
      BF: "BF[0-9]{2}[0-9]{23}", // Burkina Faso
      BG: "BG[0-9]{2}[A-Z]{4}[0-9]{4}[0-9]{2}[A-Z0-9]{8}", // Bulgaria
      BH: "BH[0-9]{2}[A-Z]{4}[A-Z0-9]{14}", // Bahrain
      BI: "BI[0-9]{2}[0-9]{12}", // Burundi
      BJ: "BJ[0-9]{2}[A-Z]{1}[0-9]{23}", // Benin
      BR: "BR[0-9]{2}[0-9]{8}[0-9]{5}[0-9]{10}[A-Z][A-Z0-9]", // Brazil
      CH: "CH[0-9]{2}[0-9]{5}[A-Z0-9]{12}", // Switzerland
      CI: "CI[0-9]{2}[A-Z]{1}[0-9]{23}", // Ivory Coast
      CM: "CM[0-9]{2}[0-9]{23}", // Cameroon
      CR: "CR[0-9]{2}[0-9]{3}[0-9]{14}", // Costa Rica
      CV: "CV[0-9]{2}[0-9]{21}", // Cape Verde
      CY: "CY[0-9]{2}[0-9]{3}[0-9]{5}[A-Z0-9]{16}", // Cyprus
      CZ: "CZ[0-9]{2}[0-9]{20}", // Czech Republic
      DE: "DE[0-9]{2}[0-9]{8}[0-9]{10}", // Germany
      DK: "DK[0-9]{2}[0-9]{14}", // Denmark
      DO: "DO[0-9]{2}[A-Z0-9]{4}[0-9]{20}", // Dominican Republic
      DZ: "DZ[0-9]{2}[0-9]{20}", // Algeria
      EE: "EE[0-9]{2}[0-9]{2}[0-9]{2}[0-9]{11}[0-9]{1}", // Estonia
      ES: "ES[0-9]{2}[0-9]{4}[0-9]{4}[0-9]{1}[0-9]{1}[0-9]{10}", // Spain
      FI: "FI[0-9]{2}[0-9]{6}[0-9]{7}[0-9]{1}", // Finland
      FO: "FO[0-9]{2}[0-9]{4}[0-9]{9}[0-9]{1}", // Faroe Islands
      FR: "FR[0-9]{2}[0-9]{5}[0-9]{5}[A-Z0-9]{11}[0-9]{2}", // France
      GB: "GB[0-9]{2}[A-Z]{4}[0-9]{6}[0-9]{8}", // United Kingdom
      GE: "GE[0-9]{2}[A-Z]{2}[0-9]{16}", // Georgia
      GI: "GI[0-9]{2}[A-Z]{4}[A-Z0-9]{15}", // Gibraltar
      GL: "GL[0-9]{2}[0-9]{4}[0-9]{9}[0-9]{1}", // Greenland
      GR: "GR[0-9]{2}[0-9]{3}[0-9]{4}[A-Z0-9]{16}", // Greece
      GT: "GT[0-9]{2}[A-Z0-9]{4}[A-Z0-9]{20}", // Guatemala
      HR: "HR[0-9]{2}[0-9]{7}[0-9]{10}", // Croatia
      HU: "HU[0-9]{2}[0-9]{3}[0-9]{4}[0-9]{1}[0-9]{15}[0-9]{1}", // Hungary
      IE: "IE[0-9]{2}[A-Z]{4}[0-9]{6}[0-9]{8}", // Ireland
      IL: "IL[0-9]{2}[0-9]{3}[0-9]{3}[0-9]{13}", // Israel
      IR: "IR[0-9]{2}[0-9]{22}", // Iran
      IS: "IS[0-9]{2}[0-9]{4}[0-9]{2}[0-9]{6}[0-9]{10}", // Iceland
      IT: "IT[0-9]{2}[A-Z]{1}[0-9]{5}[0-9]{5}[A-Z0-9]{12}", // Italy
      JO: "JO[0-9]{2}[A-Z]{4}[0-9]{4}[0]{8}[A-Z0-9]{10}", // Jordan
      KW: "KW[0-9]{2}[A-Z]{4}[0-9]{22}", // Kuwait
      KZ: "KZ[0-9]{2}[0-9]{3}[A-Z0-9]{13}", // Kazakhstan
      LB: "LB[0-9]{2}[0-9]{4}[A-Z0-9]{20}", // Lebanon
      LI: "LI[0-9]{2}[0-9]{5}[A-Z0-9]{12}", // Liechtenstein
      LT: "LT[0-9]{2}[0-9]{5}[0-9]{11}", // Lithuania
      LU: "LU[0-9]{2}[0-9]{3}[A-Z0-9]{13}", // Luxembourg
      LV: "LV[0-9]{2}[A-Z]{4}[A-Z0-9]{13}", // Latvia
      MC: "MC[0-9]{2}[0-9]{5}[0-9]{5}[A-Z0-9]{11}[0-9]{2}", // Monaco
      MD: "MD[0-9]{2}[A-Z0-9]{20}", // Moldova
      ME: "ME[0-9]{2}[0-9]{3}[0-9]{13}[0-9]{2}", // Montenegro
      MG: "MG[0-9]{2}[0-9]{23}", // Madagascar
      MK: "MK[0-9]{2}[0-9]{3}[A-Z0-9]{10}[0-9]{2}", // Macedonia
      ML: "ML[0-9]{2}[A-Z]{1}[0-9]{23}", // Mali
      MR: "MR13[0-9]{5}[0-9]{5}[0-9]{11}[0-9]{2}", // Mauritania
      MT: "MT[0-9]{2}[A-Z]{4}[0-9]{5}[A-Z0-9]{18}", // Malta
      MU: "MU[0-9]{2}[A-Z]{4}[0-9]{2}[0-9]{2}[0-9]{12}[0-9]{3}[A-Z]{3}", // Mauritius
      MZ: "MZ[0-9]{2}[0-9]{21}", // Mozambique
      NL: "NL[0-9]{2}[A-Z]{4}[0-9]{10}", // Netherlands
      NO: "NO[0-9]{2}[0-9]{4}[0-9]{6}[0-9]{1}", // Norway
      PK: "PK[0-9]{2}[A-Z]{4}[A-Z0-9]{16}", // Pakistan
      PL: "PL[0-9]{2}[0-9]{8}[0-9]{16}", // Poland
      PS: "PS[0-9]{2}[A-Z]{4}[A-Z0-9]{21}", // Palestinian
      PT: "PT[0-9]{2}[0-9]{4}[0-9]{4}[0-9]{11}[0-9]{2}", // Portugal
      QA: "QA[0-9]{2}[A-Z]{4}[A-Z0-9]{21}", // Qatar
      RO: "RO[0-9]{2}[A-Z]{4}[A-Z0-9]{16}", // Romania
      RS: "RS[0-9]{2}[0-9]{3}[0-9]{13}[0-9]{2}", // Serbia
      SA: "SA[0-9]{2}[0-9]{2}[A-Z0-9]{18}", // Saudi Arabia
      SE: "SE[0-9]{2}[0-9]{3}[0-9]{16}[0-9]{1}", // Sweden
      SI: "SI[0-9]{2}[0-9]{5}[0-9]{8}[0-9]{2}", // Slovenia
      SK: "SK[0-9]{2}[0-9]{4}[0-9]{6}[0-9]{10}", // Slovakia
      SM: "SM[0-9]{2}[A-Z]{1}[0-9]{5}[0-9]{5}[A-Z0-9]{12}", // San Marino
      SN: "SN[0-9]{2}[A-Z]{1}[0-9]{23}", // Senegal
      TL: "TL38[0-9]{3}[0-9]{14}[0-9]{2}", // East Timor
      TN: "TN59[0-9]{2}[0-9]{3}[0-9]{13}[0-9]{2}", // Tunisia
      TR: "TR[0-9]{2}[0-9]{5}[A-Z0-9]{1}[A-Z0-9]{16}", // Turkey
      VG: "VG[0-9]{2}[A-Z]{4}[0-9]{16}", // Virgin Islands, British
      XK: "XK[0-9]{2}[0-9]{4}[0-9]{10}[0-9]{2}", // Republic of Kosovo
    },

    // List of SEPA country codes
    SEPA_COUNTRIES: [
      "AT",
      "BE",
      "BG",
      "CH",
      "CY",
      "CZ",
      "DE",
      "DK",
      "EE",
      "ES",
      "FI",
      "FR",
      "GB",
      "GI",
      "GR",
      "HR",
      "HU",
      "IE",
      "IS",
      "IT",
      "LI",
      "LT",
      "LU",
      "LV",
      "MC",
      "MT",
      "NL",
      "NO",
      "PL",
      "PT",
      "RO",
      "SE",
      "SI",
      "SK",
      "SM",
    ],

    /**
     * Validate an International Bank Account Number (IBAN)
     * To test it, take the sample IBAN from
     * http://www.nordea.com/Our+services/International+products+and+services/Cash+Management/IBAN+countries/908462.html
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following keys:
     * - message: The invalid message
     * - country: The ISO 3166-1 country code. It can be
     *      - A country code
     *      - Name of field which its value defines the country code
     *      - Name of callback function that returns the country code
     *      - A callback function that returns the country code
     * - sepa: Set it to true (false) to indicate that the IBAN number must be (not be) from SEPA countries
     * By default, this option is not defined
     * @returns {Boolean|Object}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      value = value.replace(/[^a-zA-Z0-9]/g, "").toUpperCase();
      var country = options.country;
      if (!country) {
        country = value.substr(0, 2);
      } else if (typeof country !== "string" || !this.REGEX[country]) {
        // Determine the country code
        country = validator.getDynamicOption($field, country);
      }

      var locale = validator.getLocale();
      if (!this.REGEX[country]) {
        return false;
      }

      // Check whether or not the sepa option is enabled
      if (typeof options.sepa !== undefined) {
        var isSepaCountry = $.inArray(country, this.SEPA_COUNTRIES) !== -1;
        if (
          ((options.sepa === "true" || options.sepa === true) &&
            !isSepaCountry) ||
          ((options.sepa === "false" || options.sepa === false) &&
            isSepaCountry)
        ) {
          return false;
        }
      }

      if (!new RegExp("^" + this.REGEX[country] + "$").test(value)) {
        return {
          valid: false,
          message: FormValidation.Helper.format(
            options.message || FormValidation.I18n[locale].iban.country,
            FormValidation.I18n[locale].iban.countries[country]
          ),
        };
      }

      value = value.substr(4) + value.substr(0, 4);
      value = $.map(value.split(""), function (n) {
        var code = n.charCodeAt(0);
        return code >= "A".charCodeAt(0) && code <= "Z".charCodeAt(0)
          ? // Replace A, B, C, ..., Z with 10, 11, ..., 35
            code - "A".charCodeAt(0) + 10
          : n;
      });
      value = value.join("");

      var temp = parseInt(value.substr(0, 1), 10),
        length = value.length;
      for (var i = 1; i < length; ++i) {
        temp = (temp * 10 + parseInt(value.substr(i, 1), 10)) % 97;
      }

      return {
        valid: temp === 1,
        message: FormValidation.Helper.format(
          options.message || FormValidation.I18n[locale].iban.country,
          FormValidation.I18n[locale].iban.countries[country]
        ),
      };
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      id: {
        default: "Please enter a valid identification number",
        country: "Please enter a valid identification number in %s",
        countries: {
          BA: "Bosnia and Herzegovina",
          BG: "Bulgaria",
          BR: "Brazil",
          CH: "Switzerland",
          CL: "Chile",
          CN: "China",
          CZ: "Czech Republic",
          DK: "Denmark",
          EE: "Estonia",
          ES: "Spain",
          FI: "Finland",
          HR: "Croatia",
          IE: "Ireland",
          IS: "Iceland",
          LT: "Lithuania",
          LV: "Latvia",
          ME: "Montenegro",
          MK: "Macedonia",
          NL: "Netherlands",
          PL: "Poland",
          RO: "Romania",
          RS: "Serbia",
          SE: "Sweden",
          SI: "Slovenia",
          SK: "Slovakia",
          SM: "San Marino",
          TH: "Thailand",
          TR: "Turkey",
          ZA: "South Africa",
        },
      },
    },
  });

  FormValidation.Validator.id = {
    html5Attributes: {
      message: "message",
      country: "country",
    },

    // Supported country codes
    COUNTRY_CODES: [
      "BA",
      "BG",
      "BR",
      "CH",
      "CL",
      "CN",
      "CZ",
      "DK",
      "EE",
      "ES",
      "FI",
      "HR",
      "IE",
      "IS",
      "LT",
      "LV",
      "ME",
      "MK",
      "NL",
      "PL",
      "RO",
      "RS",
      "SE",
      "SI",
      "SK",
      "SM",
      "TH",
      "TR",
      "ZA",
    ],

    /**
     * Validate identification number in different countries
     *
     * @see http://en.wikipedia.org/wiki/National_identification_number
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Consist of key:
     * - message: The invalid message
     * - country: The ISO 3166-1 country code. It can be
     *      - One of country code defined in COUNTRY_CODES
     *      - Name of field which its value defines the country code
     *      - Name of callback function that returns the country code
     *      - A callback function that returns the country code
     * @returns {Object}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      var locale = validator.getLocale(),
        country = options.country;
      if (!country) {
        country = value.substr(0, 2);
      } else if (
        typeof country !== "string" ||
        $.inArray(country.toUpperCase(), this.COUNTRY_CODES) === -1
      ) {
        // Determine the country code
        country = validator.getDynamicOption($field, country);
      }

      if ($.inArray(country, this.COUNTRY_CODES) === -1) {
        return true;
      }

      var method = ["_", country.toLowerCase()].join(""),
        result = this[method](value);
      result = result === true || result === false ? { valid: result } : result;
      result.message = FormValidation.Helper.format(
        options.message || FormValidation.I18n[locale].id.country,
        FormValidation.I18n[locale].id.countries[country.toUpperCase()]
      );

      return result;
    },

    /**
     * Validate Unique Master Citizen Number which uses in
     * - Bosnia and Herzegovina (country code: BA)
     * - Macedonia (MK)
     * - Montenegro (ME)
     * - Serbia (RS)
     * - Slovenia (SI)
     *
     * @see http://en.wikipedia.org/wiki/Unique_Master_Citizen_Number
     * @param {String} value The ID
     * @param {String} countryCode The ISO country code, can be BA, MK, ME, RS, SI
     * @returns {Boolean}
     */
    _validateJMBG: function (value, countryCode) {
      if (!/^\d{13}$/.test(value)) {
        return false;
      }
      var day = parseInt(value.substr(0, 2), 10),
        month = parseInt(value.substr(2, 2), 10),
        year = parseInt(value.substr(4, 3), 10),
        rr = parseInt(value.substr(7, 2), 10),
        k = parseInt(value.substr(12, 1), 10);

      // Validate date of birth
      // FIXME: Validate the year of birth
      if (day > 31 || month > 12) {
        return false;
      }

      // Validate checksum
      var sum = 0;
      for (var i = 0; i < 6; i++) {
        sum +=
          (7 - i) *
          (parseInt(value.charAt(i), 10) + parseInt(value.charAt(i + 6), 10));
      }
      sum = 11 - (sum % 11);
      if (sum === 10 || sum === 11) {
        sum = 0;
      }
      if (sum !== k) {
        return false;
      }

      // Validate political region
      // rr is the political region of birth, which can be in ranges:
      // 10-19: Bosnia and Herzegovina
      // 20-29: Montenegro
      // 30-39: Croatia (not used anymore)
      // 41-49: Macedonia
      // 50-59: Slovenia (only 50 is used)
      // 70-79: Central Serbia
      // 80-89: Serbian province of Vojvodina
      // 90-99: Kosovo
      switch (countryCode.toUpperCase()) {
        case "BA":
          return 10 <= rr && rr <= 19;
        case "MK":
          return 41 <= rr && rr <= 49;
        case "ME":
          return 20 <= rr && rr <= 29;
        case "RS":
          return 70 <= rr && rr <= 99;
        case "SI":
          return 50 <= rr && rr <= 59;
        default:
          return true;
      }
    },

    _ba: function (value) {
      return this._validateJMBG(value, "BA");
    },
    _mk: function (value) {
      return this._validateJMBG(value, "MK");
    },
    _me: function (value) {
      return this._validateJMBG(value, "ME");
    },
    _rs: function (value) {
      return this._validateJMBG(value, "RS");
    },

    /**
     * Examples: 0101006500006
     */
    _si: function (value) {
      return this._validateJMBG(value, "SI");
    },

    /**
     * Validate Bulgarian national identification number (EGN)
     *
     * @see http://en.wikipedia.org/wiki/Uniform_civil_number
     * @param {String} value The ID
     * @returns {Boolean}
     */
    _bg: function (value) {
      if (!/^\d{10}$/.test(value) && !/^\d{6}\s\d{3}\s\d{1}$/.test(value)) {
        return false;
      }
      value = value.replace(/\s/g, "");
      // Check the birth date
      var year = parseInt(value.substr(0, 2), 10) + 1900,
        month = parseInt(value.substr(2, 2), 10),
        day = parseInt(value.substr(4, 2), 10);
      if (month > 40) {
        year += 100;
        month -= 40;
      } else if (month > 20) {
        year -= 100;
        month -= 20;
      }

      if (!FormValidation.Helper.date(year, month, day)) {
        return false;
      }

      var sum = 0,
        weight = [2, 4, 8, 5, 10, 9, 7, 3, 6];
      for (var i = 0; i < 9; i++) {
        sum += parseInt(value.charAt(i), 10) * weight[i];
      }
      sum = (sum % 11) % 10;
      return sum + "" === value.substr(9, 1);
    },

    /**
     * Validate Brazilian national identification number (CPF)
     *
     * @see http://en.wikipedia.org/wiki/Cadastro_de_Pessoas_F%C3%ADsicas
     * @param {String} value The ID
     * @returns {Boolean}
     */
    _br: function (value) {
      value = value.replace(/\D/g, "");

      if (
        !/^\d{11}$/.test(value) ||
        /^1{11}|2{11}|3{11}|4{11}|5{11}|6{11}|7{11}|8{11}|9{11}|0{11}$/.test(
          value
        )
      ) {
        return false;
      }

      var d1 = 0;
      for (var i = 0; i < 9; i++) {
        d1 += (10 - i) * parseInt(value.charAt(i), 10);
      }
      d1 = 11 - (d1 % 11);
      if (d1 === 10 || d1 === 11) {
        d1 = 0;
      }
      if (d1 + "" !== value.charAt(9)) {
        return false;
      }

      var d2 = 0;
      for (i = 0; i < 10; i++) {
        d2 += (11 - i) * parseInt(value.charAt(i), 10);
      }
      d2 = 11 - (d2 % 11);
      if (d2 === 10 || d2 === 11) {
        d2 = 0;
      }

      return d2 + "" === value.charAt(10);
    },

    /**
     * Validate Swiss Social Security Number (AHV-Nr/No AVS)
     *
     * @see http://en.wikipedia.org/wiki/National_identification_number#Switzerland
     * @see http://www.bsv.admin.ch/themen/ahv/00011/02185/index.html?lang=de
     * @param {String} value The ID
     * @returns {Boolean}
     */
    _ch: function (value) {
      if (
        !/^756[\.]{0,1}[0-9]{4}[\.]{0,1}[0-9]{4}[\.]{0,1}[0-9]{2}$/.test(value)
      ) {
        return false;
      }
      value = value.replace(/\D/g, "").substr(3);
      var length = value.length,
        sum = 0,
        weight = length === 8 ? [3, 1] : [1, 3];
      for (var i = 0; i < length - 1; i++) {
        sum += parseInt(value.charAt(i), 10) * weight[i % 2];
      }
      sum = 10 - (sum % 10);
      return sum + "" === value.charAt(length - 1);
    },

    /**
     * Validate Chilean national identification number (RUN/RUT)
     *
     * @see http://en.wikipedia.org/wiki/National_identification_number#Chile
     * @see https://palena.sii.cl/cvc/dte/ee_empresas_emisoras.html for samples
     * @param {String} value The ID
     * @returns {Boolean}
     */
    _cl: function (value) {
      if (!/^\d{7,8}[-]{0,1}[0-9K]$/i.test(value)) {
        return false;
      }
      value = value.replace(/\-/g, "");
      while (value.length < 9) {
        value = "0" + value;
      }
      var sum = 0,
        weight = [3, 2, 7, 6, 5, 4, 3, 2];
      for (var i = 0; i < 8; i++) {
        sum += parseInt(value.charAt(i), 10) * weight[i];
      }
      sum = 11 - (sum % 11);
      if (sum === 11) {
        sum = 0;
      } else if (sum === 10) {
        sum = "K";
      }
      return sum + "" === value.charAt(8).toUpperCase();
    },

    /**
     * Validate Chinese citizen identification number
     *
     * Rules:
     * - For current 18-digit system (since 1st Oct 1999, defined by GB11643—1999 national standard):
     *     - Digit 0-5: Must be a valid administrative division code of China PR.
     *     - Digit 6-13: Must be a valid YYYYMMDD date of birth. A future date is tolerated.
     *     - Digit 14-16: Order code, any integer.
     *     - Digit 17: An ISO 7064:1983, MOD 11-2 checksum.
     *       Both upper/lower case of X are tolerated.
     * - For deprecated 15-digit system:
     *     - Digit 0-5: Must be a valid administrative division code of China PR.
     *     - Digit 6-11: Must be a valid YYMMDD date of birth, indicating the year of 19XX.
     *     - Digit 12-14: Order code, any integer.
     * Lists of valid administrative division codes of China PR can be seen here:
     * <http://www.stats.gov.cn/tjsj/tjbz/xzqhdm/>
     * Published and maintained by National Bureau of Statistics of China PR.
     * NOTE: Current and deprecated codes MUST BOTH be considered valid.
     * Many Chinese citizens born in once existed administrative divisions!
     *
     * @see http://en.wikipedia.org/wiki/Resident_Identity_Card#Identity_card_number
     * @param {String} value The ID
     * @returns {Boolean}
     */
    _cn: function (value) {
      // Basic format check (18 or 15 digits, considering X in checksum)
      value = value.trim();
      if (!/^\d{15}$/.test(value) && !/^\d{17}[\dXx]{1}$/.test(value)) {
        return false;
      }

      // Check China PR Administrative division code
      var adminDivisionCodes = {
        11: {
          0: [0],
          1: [
            [0, 9],
            [11, 17],
          ],
          2: [0, 28, 29],
        },
        12: {
          0: [0],
          1: [[0, 16]],
          2: [0, 21, 23, 25],
        },
        13: {
          0: [0],
          1: [[0, 5], 7, 8, 21, [23, 33], [81, 85]],
          2: [[0, 5], [7, 9], [23, 25], 27, 29, 30, 81, 83],
          3: [
            [0, 4],
            [21, 24],
          ],
          4: [[0, 4], 6, 21, [23, 35], 81],
          5: [[0, 3], [21, 35], 81, 82],
          6: [
            [0, 4],
            [21, 38],
            [81, 84],
          ],
          7: [[0, 3], 5, 6, [21, 33]],
          8: [
            [0, 4],
            [21, 28],
          ],
          9: [
            [0, 3],
            [21, 30],
            [81, 84],
          ],
          10: [[0, 3], [22, 26], 28, 81, 82],
          11: [[0, 2], [21, 28], 81, 82],
        },
        14: {
          0: [0],
          1: [0, 1, [5, 10], [21, 23], 81],
          2: [[0, 3], 11, 12, [21, 27]],
          3: [[0, 3], 11, 21, 22],
          4: [[0, 2], 11, 21, [23, 31], 81],
          5: [[0, 2], 21, 22, 24, 25, 81],
          6: [
            [0, 3],
            [21, 24],
          ],
          7: [[0, 2], [21, 29], 81],
          8: [[0, 2], [21, 30], 81, 82],
          9: [[0, 2], [21, 32], 81],
          10: [[0, 2], [21, 34], 81, 82],
          11: [[0, 2], [21, 30], 81, 82],
          23: [[0, 3], 22, 23, [25, 30], 32, 33],
        },
        15: {
          0: [0],
          1: [
            [0, 5],
            [21, 25],
          ],
          2: [
            [0, 7],
            [21, 23],
          ],
          3: [[0, 4]],
          4: [
            [0, 4],
            [21, 26],
            [28, 30],
          ],
          5: [[0, 2], [21, 26], 81],
          6: [
            [0, 2],
            [21, 27],
          ],
          7: [
            [0, 3],
            [21, 27],
            [81, 85],
          ],
          8: [
            [0, 2],
            [21, 26],
          ],
          9: [[0, 2], [21, 29], 81],
          22: [
            [0, 2],
            [21, 24],
          ],
          25: [
            [0, 2],
            [22, 31],
          ],
          26: [[0, 2], [24, 27], [29, 32], 34],
          28: [0, 1, [22, 27]],
          29: [0, [21, 23]],
        },
        21: {
          0: [0],
          1: [[0, 6], [11, 14], [22, 24], 81],
          2: [[0, 4], [11, 13], 24, [81, 83]],
          3: [[0, 4], 11, 21, 23, 81],
          4: [[0, 4], 11, [21, 23]],
          5: [[0, 5], 21, 22],
          6: [[0, 4], 24, 81, 82],
          7: [[0, 3], 11, 26, 27, 81, 82],
          8: [[0, 4], 11, 81, 82],
          9: [[0, 5], 11, 21, 22],
          10: [[0, 5], 11, 21, 81],
          11: [[0, 3], 21, 22],
          12: [[0, 2], 4, 21, 23, 24, 81, 82],
          13: [[0, 3], 21, 22, 24, 81, 82],
          14: [[0, 4], 21, 22, 81],
        },
        22: {
          0: [0],
          1: [[0, 6], 12, 22, [81, 83]],
          2: [[0, 4], 11, 21, [81, 84]],
          3: [[0, 3], 22, 23, 81, 82],
          4: [[0, 3], 21, 22],
          5: [[0, 3], 21, 23, 24, 81, 82],
          6: [[0, 2], 4, 5, [21, 23], 25, 81],
          7: [[0, 2], [21, 24], 81],
          8: [[0, 2], 21, 22, 81, 82],
          24: [[0, 6], 24, 26],
        },
        23: {
          0: [0],
          1: [[0, 12], 21, [23, 29], [81, 84]],
          2: [[0, 8], 21, [23, 25], 27, [29, 31], 81],
          3: [[0, 7], 21, 81, 82],
          4: [[0, 7], 21, 22],
          5: [[0, 3], 5, 6, [21, 24]],
          6: [
            [0, 6],
            [21, 24],
          ],
          7: [[0, 16], 22, 81],
          8: [[0, 5], 11, 22, 26, 28, 33, 81, 82],
          9: [[0, 4], 21],
          10: [[0, 5], 24, 25, 81, [83, 85]],
          11: [[0, 2], 21, 23, 24, 81, 82],
          12: [
            [0, 2],
            [21, 26],
            [81, 83],
          ],
          27: [
            [0, 4],
            [21, 23],
          ],
        },
        31: {
          0: [0],
          1: [0, 1, [3, 10], [12, 20]],
          2: [0, 30],
        },
        32: {
          0: [0],
          1: [[0, 7], 11, [13, 18], 24, 25],
          2: [[0, 6], 11, 81, 82],
          3: [[0, 5], 11, 12, [21, 24], 81, 82],
          4: [[0, 2], 4, 5, 11, 12, 81, 82],
          5: [
            [0, 9],
            [81, 85],
          ],
          6: [[0, 2], 11, 12, 21, 23, [81, 84]],
          7: [0, 1, 3, 5, 6, [21, 24]],
          8: [[0, 4], 11, 26, [29, 31]],
          9: [[0, 3], [21, 25], 28, 81, 82],
          10: [[0, 3], 11, 12, 23, 81, 84, 88],
          11: [[0, 2], 11, 12, [81, 83]],
          12: [
            [0, 4],
            [81, 84],
          ],
          13: [[0, 2], 11, [21, 24]],
        },
        33: {
          0: [0],
          1: [[0, 6], [8, 10], 22, 27, 82, 83, 85],
          2: [0, 1, [3, 6], 11, 12, 25, 26, [81, 83]],
          3: [[0, 4], 22, 24, [26, 29], 81, 82],
          4: [[0, 2], 11, 21, 24, [81, 83]],
          5: [
            [0, 3],
            [21, 23],
          ],
          6: [[0, 2], 21, 24, [81, 83]],
          7: [[0, 3], 23, 26, 27, [81, 84]],
          8: [[0, 3], 22, 24, 25, 81],
          9: [[0, 3], 21, 22],
          10: [[0, 4], [21, 24], 81, 82],
          11: [[0, 2], [21, 27], 81],
        },
        34: {
          0: [0],
          1: [[0, 4], 11, [21, 24], 81],
          2: [[0, 4], 7, 8, [21, 23], 25],
          3: [[0, 4], 11, [21, 23]],
          4: [[0, 6], 21],
          5: [[0, 4], 6, [21, 23]],
          6: [[0, 4], 21],
          7: [[0, 3], 11, 21],
          8: [[0, 3], 11, [22, 28], 81],
          10: [
            [0, 4],
            [21, 24],
          ],
          11: [[0, 3], 22, [24, 26], 81, 82],
          12: [[0, 4], 21, 22, 25, 26, 82],
          13: [
            [0, 2],
            [21, 24],
          ],
          14: [
            [0, 2],
            [21, 24],
          ],
          15: [
            [0, 3],
            [21, 25],
          ],
          16: [
            [0, 2],
            [21, 23],
          ],
          17: [
            [0, 2],
            [21, 23],
          ],
          18: [[0, 2], [21, 25], 81],
        },
        35: {
          0: [0],
          1: [[0, 5], 11, [21, 25], 28, 81, 82],
          2: [
            [0, 6],
            [11, 13],
          ],
          3: [[0, 5], 22],
          4: [[0, 3], 21, [23, 30], 81],
          5: [[0, 5], 21, [24, 27], [81, 83]],
          6: [[0, 3], [22, 29], 81],
          7: [
            [0, 2],
            [21, 25],
            [81, 84],
          ],
          8: [[0, 2], [21, 25], 81],
          9: [[0, 2], [21, 26], 81, 82],
        },
        36: {
          0: [0],
          1: [[0, 5], 11, [21, 24]],
          2: [[0, 3], 22, 81],
          3: [[0, 2], 13, [21, 23]],
          4: [[0, 3], 21, [23, 30], 81, 82],
          5: [[0, 2], 21],
          6: [[0, 2], 22, 81],
          7: [[0, 2], [21, 35], 81, 82],
          8: [[0, 3], [21, 30], 81],
          9: [
            [0, 2],
            [21, 26],
            [81, 83],
          ],
          10: [
            [0, 2],
            [21, 30],
          ],
          11: [[0, 2], [21, 30], 81],
        },
        37: {
          0: [0],
          1: [[0, 5], 12, 13, [24, 26], 81],
          2: [[0, 3], 5, [11, 14], [81, 85]],
          3: [
            [0, 6],
            [21, 23],
          ],
          4: [[0, 6], 81],
          5: [
            [0, 3],
            [21, 23],
          ],
          6: [[0, 2], [11, 13], 34, [81, 87]],
          7: [[0, 5], 24, 25, [81, 86]],
          8: [[0, 2], 11, [26, 32], [81, 83]],
          9: [[0, 3], 11, 21, 23, 82, 83],
          10: [
            [0, 2],
            [81, 83],
          ],
          11: [[0, 3], 21, 22],
          12: [[0, 3]],
          13: [[0, 2], 11, 12, [21, 29]],
          14: [[0, 2], [21, 28], 81, 82],
          15: [[0, 2], [21, 26], 81],
          16: [
            [0, 2],
            [21, 26],
          ],
          17: [
            [0, 2],
            [21, 28],
          ],
        },
        41: {
          0: [0],
          1: [[0, 6], 8, 22, [81, 85]],
          2: [[0, 5], 11, [21, 25]],
          3: [[0, 7], 11, [22, 29], 81],
          4: [[0, 4], 11, [21, 23], 25, 81, 82],
          5: [[0, 3], 5, 6, 22, 23, 26, 27, 81],
          6: [[0, 3], 11, 21, 22],
          7: [[0, 4], 11, 21, [24, 28], 81, 82],
          8: [[0, 4], 11, [21, 23], 25, [81, 83]],
          9: [[0, 2], 22, 23, [26, 28]],
          10: [[0, 2], [23, 25], 81, 82],
          11: [
            [0, 4],
            [21, 23],
          ],
          12: [[0, 2], 21, 22, 24, 81, 82],
          13: [[0, 3], [21, 30], 81],
          14: [[0, 3], [21, 26], 81],
          15: [
            [0, 3],
            [21, 28],
          ],
          16: [[0, 2], [21, 28], 81],
          17: [
            [0, 2],
            [21, 29],
          ],
          90: [0, 1],
        },
        42: {
          0: [0],
          1: [
            [0, 7],
            [11, 17],
          ],
          2: [[0, 5], 22, 81],
          3: [[0, 3], [21, 25], 81],
          5: [
            [0, 6],
            [25, 29],
            [81, 83],
          ],
          6: [[0, 2], 6, 7, [24, 26], [82, 84]],
          7: [[0, 4]],
          8: [[0, 2], 4, 21, 22, 81],
          9: [[0, 2], [21, 23], 81, 82, 84],
          10: [[0, 3], [22, 24], 81, 83, 87],
          11: [[0, 2], [21, 27], 81, 82],
          12: [[0, 2], [21, 24], 81],
          13: [[0, 3], 21, 81],
          28: [[0, 2], 22, 23, [25, 28]],
          90: [0, [4, 6], 21],
        },
        43: {
          0: [0],
          1: [[0, 5], 11, 12, 21, 22, 24, 81],
          2: [[0, 4], 11, 21, [23, 25], 81],
          3: [[0, 2], 4, 21, 81, 82],
          4: [0, 1, [5, 8], 12, [21, 24], 26, 81, 82],
          5: [[0, 3], 11, [21, 25], [27, 29], 81],
          6: [[0, 3], 11, 21, 23, 24, 26, 81, 82],
          7: [[0, 3], [21, 26], 81],
          8: [[0, 2], 11, 21, 22],
          9: [[0, 3], [21, 23], 81],
          10: [[0, 3], [21, 28], 81],
          11: [
            [0, 3],
            [21, 29],
          ],
          12: [[0, 2], [21, 30], 81],
          13: [[0, 2], 21, 22, 81, 82],
          31: [0, 1, [22, 27], 30],
        },
        44: {
          0: [0],
          1: [[0, 7], [11, 16], 83, 84],
          2: [[0, 5], 21, 22, 24, 29, 32, 33, 81, 82],
          3: [0, 1, [3, 8]],
          4: [[0, 4]],
          5: [0, 1, [6, 15], 23, 82, 83],
          6: [0, 1, [4, 8]],
          7: [0, 1, [3, 5], 81, [83, 85]],
          8: [[0, 4], 11, 23, 25, [81, 83]],
          9: [[0, 3], 23, [81, 83]],
          12: [[0, 3], [23, 26], 83, 84],
          13: [[0, 3], [22, 24], 81],
          14: [[0, 2], [21, 24], 26, 27, 81],
          15: [[0, 2], 21, 23, 81],
          16: [
            [0, 2],
            [21, 25],
          ],
          17: [[0, 2], 21, 23, 81],
          18: [[0, 3], 21, 23, [25, 27], 81, 82],
          19: [0],
          20: [0],
          51: [[0, 3], 21, 22],
          52: [[0, 3], 21, 22, 24, 81],
          53: [[0, 2], [21, 23], 81],
        },
        45: {
          0: [0],
          1: [
            [0, 9],
            [21, 27],
          ],
          2: [
            [0, 5],
            [21, 26],
          ],
          3: [[0, 5], 11, 12, [21, 32]],
          4: [0, 1, [3, 6], 11, [21, 23], 81],
          5: [[0, 3], 12, 21],
          6: [[0, 3], 21, 81],
          7: [[0, 3], 21, 22],
          8: [[0, 4], 21, 81],
          9: [[0, 3], [21, 24], 81],
          10: [
            [0, 2],
            [21, 31],
          ],
          11: [
            [0, 2],
            [21, 23],
          ],
          12: [[0, 2], [21, 29], 81],
          13: [[0, 2], [21, 24], 81],
          14: [[0, 2], [21, 25], 81],
        },
        46: {
          0: [0],
          1: [0, 1, [5, 8]],
          2: [0, 1],
          3: [0, [21, 23]],
          90: [
            [0, 3],
            [5, 7],
            [21, 39],
          ],
        },
        50: {
          0: [0],
          1: [[0, 19]],
          2: [0, [22, 38], [40, 43]],
          3: [0, [81, 84]],
        },
        51: {
          0: [0],
          1: [0, 1, [4, 8], [12, 15], [21, 24], 29, 31, 32, [81, 84]],
          3: [[0, 4], 11, 21, 22],
          4: [[0, 3], 11, 21, 22],
          5: [[0, 4], 21, 22, 24, 25],
          6: [0, 1, 3, 23, 26, [81, 83]],
          7: [0, 1, 3, 4, [22, 27], 81],
          8: [[0, 2], 11, 12, [21, 24]],
          9: [
            [0, 4],
            [21, 23],
          ],
          10: [[0, 2], 11, 24, 25, 28],
          11: [[0, 2], [11, 13], 23, 24, 26, 29, 32, 33, 81],
          13: [[0, 4], [21, 25], 81],
          14: [
            [0, 2],
            [21, 25],
          ],
          15: [
            [0, 3],
            [21, 29],
          ],
          16: [[0, 3], [21, 23], 81],
          17: [[0, 3], [21, 25], 81],
          18: [
            [0, 3],
            [21, 27],
          ],
          19: [
            [0, 3],
            [21, 23],
          ],
          20: [[0, 2], 21, 22, 81],
          32: [0, [21, 33]],
          33: [0, [21, 38]],
          34: [0, 1, [22, 37]],
        },
        52: {
          0: [0],
          1: [[0, 3], [11, 15], [21, 23], 81],
          2: [0, 1, 3, 21, 22],
          3: [[0, 3], [21, 30], 81, 82],
          4: [
            [0, 2],
            [21, 25],
          ],
          5: [
            [0, 2],
            [21, 27],
          ],
          6: [
            [0, 3],
            [21, 28],
          ],
          22: [0, 1, [22, 30]],
          23: [0, 1, [22, 28]],
          24: [0, 1, [22, 28]],
          26: [0, 1, [22, 36]],
          27: [[0, 2], 22, 23, [25, 32]],
        },
        53: {
          0: [0],
          1: [[0, 3], [11, 14], 21, 22, [24, 29], 81],
          3: [[0, 2], [21, 26], 28, 81],
          4: [
            [0, 2],
            [21, 28],
          ],
          5: [
            [0, 2],
            [21, 24],
          ],
          6: [
            [0, 2],
            [21, 30],
          ],
          7: [
            [0, 2],
            [21, 24],
          ],
          8: [
            [0, 2],
            [21, 29],
          ],
          9: [
            [0, 2],
            [21, 27],
          ],
          23: [0, 1, [22, 29], 31],
          25: [
            [0, 4],
            [22, 32],
          ],
          26: [0, 1, [21, 28]],
          27: [0, 1, [22, 30]],
          28: [0, 1, 22, 23],
          29: [0, 1, [22, 32]],
          31: [0, 2, 3, [22, 24]],
          34: [0, [21, 23]],
          33: [0, 21, [23, 25]],
          35: [0, [21, 28]],
        },
        54: {
          0: [0],
          1: [
            [0, 2],
            [21, 27],
          ],
          21: [0, [21, 29], 32, 33],
          22: [0, [21, 29], [31, 33]],
          23: [0, 1, [22, 38]],
          24: [0, [21, 31]],
          25: [0, [21, 27]],
          26: [0, [21, 27]],
        },
        61: {
          0: [0],
          1: [[0, 4], [11, 16], 22, [24, 26]],
          2: [[0, 4], 22],
          3: [
            [0, 4],
            [21, 24],
            [26, 31],
          ],
          4: [[0, 4], [22, 31], 81],
          5: [[0, 2], [21, 28], 81, 82],
          6: [
            [0, 2],
            [21, 32],
          ],
          7: [
            [0, 2],
            [21, 30],
          ],
          8: [
            [0, 2],
            [21, 31],
          ],
          9: [
            [0, 2],
            [21, 29],
          ],
          10: [
            [0, 2],
            [21, 26],
          ],
        },
        62: {
          0: [0],
          1: [[0, 5], 11, [21, 23]],
          2: [0, 1],
          3: [[0, 2], 21],
          4: [
            [0, 3],
            [21, 23],
          ],
          5: [
            [0, 3],
            [21, 25],
          ],
          6: [
            [0, 2],
            [21, 23],
          ],
          7: [
            [0, 2],
            [21, 25],
          ],
          8: [
            [0, 2],
            [21, 26],
          ],
          9: [[0, 2], [21, 24], 81, 82],
          10: [
            [0, 2],
            [21, 27],
          ],
          11: [
            [0, 2],
            [21, 26],
          ],
          12: [
            [0, 2],
            [21, 28],
          ],
          24: [0, 21, [24, 29]],
          26: [0, 21, [23, 30]],
          29: [0, 1, [21, 27]],
          30: [0, 1, [21, 27]],
        },
        63: {
          0: [0],
          1: [
            [0, 5],
            [21, 23],
          ],
          2: [0, 2, [21, 25]],
          21: [0, [21, 23], [26, 28]],
          22: [0, [21, 24]],
          23: [0, [21, 24]],
          25: [0, [21, 25]],
          26: [0, [21, 26]],
          27: [0, 1, [21, 26]],
          28: [
            [0, 2],
            [21, 23],
          ],
        },
        64: {
          0: [0],
          1: [0, 1, [4, 6], 21, 22, 81],
          2: [[0, 3], 5, [21, 23]],
          3: [[0, 3], [21, 24], 81],
          4: [
            [0, 2],
            [21, 25],
          ],
          5: [[0, 2], 21, 22],
        },
        65: {
          0: [0],
          1: [[0, 9], 21],
          2: [[0, 5]],
          21: [0, 1, 22, 23],
          22: [0, 1, 22, 23],
          23: [[0, 3], [23, 25], 27, 28],
          28: [0, 1, [22, 29]],
          29: [0, 1, [22, 29]],
          30: [0, 1, [22, 24]],
          31: [0, 1, [21, 31]],
          32: [0, 1, [21, 27]],
          40: [0, 2, 3, [21, 28]],
          42: [[0, 2], 21, [23, 26]],
          43: [0, 1, [21, 26]],
          90: [[0, 4]],
          27: [[0, 2], 22, 23],
        },
        71: { 0: [0] },
        81: { 0: [0] },
        82: { 0: [0] },
      };

      var provincial = parseInt(value.substr(0, 2), 10),
        prefectural = parseInt(value.substr(2, 2), 10),
        county = parseInt(value.substr(4, 2), 10);

      if (
        !adminDivisionCodes[provincial] ||
        !adminDivisionCodes[provincial][prefectural]
      ) {
        return false;
      }
      var inRange = false,
        rangeDef = adminDivisionCodes[provincial][prefectural];
      for (var i = 0; i < rangeDef.length; i++) {
        if (
          ($.isArray(rangeDef[i]) &&
            rangeDef[i][0] <= county &&
            county <= rangeDef[i][1]) ||
          (!$.isArray(rangeDef[i]) && county === rangeDef[i])
        ) {
          inRange = true;
          break;
        }
      }

      if (!inRange) {
        return false;
      }

      // Check date of birth
      var dob;
      if (value.length === 18) {
        dob = value.substr(6, 8);
      } /* length == 15 */ else {
        dob = "19" + value.substr(6, 6);
      }
      var year = parseInt(dob.substr(0, 4), 10),
        month = parseInt(dob.substr(4, 2), 10),
        day = parseInt(dob.substr(6, 2), 10);
      if (!FormValidation.Helper.date(year, month, day)) {
        return false;
      }

      // Check checksum (18-digit system only)
      if (value.length === 18) {
        var sum = 0,
          weight = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2];
        for (i = 0; i < 17; i++) {
          sum += parseInt(value.charAt(i), 10) * weight[i];
        }
        sum = (12 - (sum % 11)) % 11;
        var checksum =
          value.charAt(17).toUpperCase() !== "X"
            ? parseInt(value.charAt(17), 10)
            : 10;
        return checksum === sum;
      }

      return true;
    },

    /**
     * Validate Czech national identification number (RC)
     *
     * @param {String} value The ID
     * @returns {Boolean}
     */
    _cz: function (value) {
      if (!/^\d{9,10}$/.test(value)) {
        return false;
      }
      var year = 1900 + parseInt(value.substr(0, 2), 10),
        month = (parseInt(value.substr(2, 2), 10) % 50) % 20,
        day = parseInt(value.substr(4, 2), 10);
      if (value.length === 9) {
        if (year >= 1980) {
          year -= 100;
        }
        if (year > 1953) {
          return false;
        }
      } else if (year < 1954) {
        year += 100;
      }

      if (!FormValidation.Helper.date(year, month, day)) {
        return false;
      }

      // Check that the birth date is not in the future
      if (value.length === 10) {
        var check = parseInt(value.substr(0, 9), 10) % 11;
        if (year < 1985) {
          check = check % 10;
        }
        return check + "" === value.substr(9, 1);
      }

      return true;
    },

    /**
     * Validate Danish Personal Identification number (CPR)
     *
     * @see https://en.wikipedia.org/wiki/Personal_identification_number_(Denmark)
     * @param {String} value The ID
     * @returns {Boolean}
     */
    _dk: function (value) {
      if (!/^[0-9]{6}[-]{0,1}[0-9]{4}$/.test(value)) {
        return false;
      }
      value = value.replace(/-/g, "");
      var day = parseInt(value.substr(0, 2), 10),
        month = parseInt(value.substr(2, 2), 10),
        year = parseInt(value.substr(4, 2), 10);

      switch (true) {
        case "5678".indexOf(value.charAt(6)) !== -1 && year >= 58:
          year += 1800;
          break;
        case "0123".indexOf(value.charAt(6)) !== -1:
        case "49".indexOf(value.charAt(6)) !== -1 && year >= 37:
          year += 1900;
          break;
        default:
          year += 2000;
          break;
      }

      return FormValidation.Helper.date(year, month, day);
    },

    /**
     * Validate Estonian Personal Identification Code (isikukood)
     *
     * @see http://et.wikipedia.org/wiki/Isikukood
     * @param {String} value The ID
     * @returns {Boolean}
     */
    _ee: function (value) {
      // Use the same format as Lithuanian Personal Code
      return this._lt(value);
    },

    /**
     * Validate Spanish personal identity code (DNI)
     * Support DNI (for Spanish citizens), NIE (for foreign people) and CIF (for legal entities)
     *
     * @see https://en.wikipedia.org/wiki/National_identification_number#Spain
     * @param {String} value The ID
     * @returns {Boolean|Object}
     */
    _es: function (value) {
      var isDNI = /^[0-9]{8}[-]{0,1}[A-HJ-NP-TV-Z]$/.test(value),
        isNIE = /^[XYZ][-]{0,1}[0-9]{7}[-]{0,1}[A-HJ-NP-TV-Z]$/.test(value),
        isCIF = /^[A-HNPQS][-]{0,1}[0-9]{7}[-]{0,1}[0-9A-J]$/.test(value);
      if (!isDNI && !isNIE && !isCIF) {
        return false;
      }

      value = value.replace(/-/g, "");
      var check,
        type,
        isValid = true;
      if (isDNI || isNIE) {
        type = "DNI";
        var index = "XYZ".indexOf(value.charAt(0));
        if (index !== -1) {
          // It is NIE number
          value = index + value.substr(1) + "";
          type = "NIE";
        }

        check = parseInt(value.substr(0, 8), 10);
        check = "TRWAGMYFPDXBNJZSQVHLCKE"[check % 23];
        return {
          valid: check === value.substr(8, 1),
          type: type,
        };
      } else {
        check = value.substr(1, 7);
        type = "CIF";
        var letter = value[0],
          control = value.substr(-1),
          sum = 0;

        // The digits in the even positions are added to the sum directly.
        // The ones in the odd positions are multiplied by 2 and then added to the sum.
        // If the result of multiplying by 2 is 10 or higher, add the two digits
        // together and add that to the sum instead
        for (var i = 0; i < check.length; i++) {
          if (i % 2 !== 0) {
            sum += parseInt(check[i], 10);
          } else {
            var tmp = "" + parseInt(check[i], 10) * 2;
            sum += parseInt(tmp[0], 10);
            if (tmp.length === 2) {
              sum += parseInt(tmp[1], 10);
            }
          }
        }

        // The control digit is calculated from the last digit of the sum.
        // If that last digit is not 0, subtract it from 10
        var lastDigit = sum - Math.floor(sum / 10) * 10;
        if (lastDigit !== 0) {
          lastDigit = 10 - lastDigit;
        }

        if ("KQS".indexOf(letter) !== -1) {
          // If the CIF starts with a K, Q or S, the control digit must be a letter
          isValid = control === "JABCDEFGHI"[lastDigit];
        } else if ("ABEH".indexOf(letter) !== -1) {
          // If it starts with A, B, E or H, it has to be a number
          isValid = control === "" + lastDigit;
        } else {
          // In any other case, it doesn't matter
          isValid =
            control === "" + lastDigit || control === "JABCDEFGHI"[lastDigit];
        }

        return {
          valid: isValid,
          type: type,
        };
      }
    },

    /**
     * Validate Finnish Personal Identity Code (HETU)
     *
     * @param {String} value The ID
     * @returns {Boolean}
     */
    _fi: function (value) {
      if (!/^[0-9]{6}[-+A][0-9]{3}[0-9ABCDEFHJKLMNPRSTUVWXY]$/.test(value)) {
        return false;
      }
      var day = parseInt(value.substr(0, 2), 10),
        month = parseInt(value.substr(2, 2), 10),
        year = parseInt(value.substr(4, 2), 10),
        centuries = {
          "+": 1800,
          "-": 1900,
          A: 2000,
        };
      year = centuries[value.charAt(6)] + year;

      if (!FormValidation.Helper.date(year, month, day)) {
        return false;
      }

      var individual = parseInt(value.substr(7, 3), 10);
      if (individual < 2) {
        return false;
      }
      var n = value.substr(0, 6) + value.substr(7, 3) + "";
      n = parseInt(n, 10);
      return (
        "0123456789ABCDEFHJKLMNPRSTUVWXY".charAt(n % 31) === value.charAt(10)
      );
    },

    /**
     * Validate Croatian personal identification number (OIB)
     *
     * @param {String} value The ID
     * @returns {Boolean}
     */
    _hr: function (value) {
      if (!/^[0-9]{11}$/.test(value)) {
        return false;
      }
      return FormValidation.Helper.mod11And10(value);
    },

    /**
     * Validate Irish Personal Public Service Number (PPS)
     *
     * @see https://en.wikipedia.org/wiki/Personal_Public_Service_Number
     * @param {String} value The ID
     * @returns {Boolean}
     */
    _ie: function (value) {
      if (!/^\d{7}[A-W][AHWTX]?$/.test(value)) {
        return false;
      }

      var getCheckDigit = function (value) {
        while (value.length < 7) {
          value = "0" + value;
        }
        var alphabet = "WABCDEFGHIJKLMNOPQRSTUV",
          sum = 0;
        for (var i = 0; i < 7; i++) {
          sum += parseInt(value.charAt(i), 10) * (8 - i);
        }
        sum += 9 * alphabet.indexOf(value.substr(7));
        return alphabet[sum % 23];
      };

      // 2013 format
      if (
        value.length === 9 &&
        ("A" === value.charAt(8) || "H" === value.charAt(8))
      ) {
        return (
          value.charAt(7) ===
          getCheckDigit(value.substr(0, 7) + value.substr(8) + "")
        );
      }
      // The old format
      else {
        return value.charAt(7) === getCheckDigit(value.substr(0, 7));
      }
    },

    /**
     * Validate Iceland national identification number (Kennitala)
     *
     *  @see http://en.wikipedia.org/wiki/Kennitala
     * @param {String} value The ID
     * @returns {Boolean}
     */
    _is: function (value) {
      if (!/^[0-9]{6}[-]{0,1}[0-9]{4}$/.test(value)) {
        return false;
      }
      value = value.replace(/-/g, "");
      var day = parseInt(value.substr(0, 2), 10),
        month = parseInt(value.substr(2, 2), 10),
        year = parseInt(value.substr(4, 2), 10),
        century = parseInt(value.charAt(9), 10);

      year = century === 9 ? 1900 + year : (20 + century) * 100 + year;
      if (!FormValidation.Helper.date(year, month, day, true)) {
        return false;
      }
      // Validate the check digit
      var sum = 0,
        weight = [3, 2, 7, 6, 5, 4, 3, 2];
      for (var i = 0; i < 8; i++) {
        sum += parseInt(value.charAt(i), 10) * weight[i];
      }
      sum = 11 - (sum % 11);
      return sum + "" === value.charAt(8);
    },

    /**
     * Validate Lithuanian Personal Code (Asmens kodas)
     *
     * @see http://en.wikipedia.org/wiki/National_identification_number#Lithuania
     * @see http://www.adomas.org/midi2007/pcode.html
     * @param {String} value The ID
     * @returns {Boolean}
     */
    _lt: function (value) {
      if (!/^[0-9]{11}$/.test(value)) {
        return false;
      }
      var gender = parseInt(value.charAt(0), 10),
        year = parseInt(value.substr(1, 2), 10),
        month = parseInt(value.substr(3, 2), 10),
        day = parseInt(value.substr(5, 2), 10),
        century = gender % 2 === 0 ? 17 + gender / 2 : 17 + (gender + 1) / 2;
      year = century * 100 + year;
      if (!FormValidation.Helper.date(year, month, day, true)) {
        return false;
      }

      // Validate the check digit
      var sum = 0,
        weight = [1, 2, 3, 4, 5, 6, 7, 8, 9, 1];
      for (var i = 0; i < 10; i++) {
        sum += parseInt(value.charAt(i), 10) * weight[i];
      }
      sum = sum % 11;
      if (sum !== 10) {
        return sum + "" === value.charAt(10);
      }

      // Re-calculate the check digit
      sum = 0;
      weight = [3, 4, 5, 6, 7, 8, 9, 1, 2, 3];
      for (i = 0; i < 10; i++) {
        sum += parseInt(value.charAt(i), 10) * weight[i];
      }
      sum = sum % 11;
      if (sum === 10) {
        sum = 0;
      }
      return sum + "" === value.charAt(10);
    },

    /**
     * Validate Latvian Personal Code (Personas kods)
     *
     * @see http://laacz.lv/2006/11/25/pk-parbaudes-algoritms/
     * @param {String} value The ID
     * @returns {Boolean}
     */
    _lv: function (value) {
      if (!/^[0-9]{6}[-]{0,1}[0-9]{5}$/.test(value)) {
        return false;
      }
      value = value.replace(/\D/g, "");
      // Check birth date
      var day = parseInt(value.substr(0, 2), 10),
        month = parseInt(value.substr(2, 2), 10),
        year = parseInt(value.substr(4, 2), 10);
      year = year + 1800 + parseInt(value.charAt(6), 10) * 100;

      if (!FormValidation.Helper.date(year, month, day, true)) {
        return false;
      }

      // Check personal code
      var sum = 0,
        weight = [10, 5, 8, 4, 2, 1, 6, 3, 7, 9];
      for (var i = 0; i < 10; i++) {
        sum += parseInt(value.charAt(i), 10) * weight[i];
      }
      sum = ((sum + 1) % 11) % 10;
      return sum + "" === value.charAt(10);
    },

    /**
     * Validate Dutch national identification number (BSN)
     *
     * @see https://nl.wikipedia.org/wiki/Burgerservicenummer
     * @param {String} value The ID
     * @returns {Boolean}
     */
    _nl: function (value) {
      if (value.length < 8) {
        return false;
      }

      if (value.length === 8) {
        value = "0" + value;
      }
      if (!/^[0-9]{4}[.]{0,1}[0-9]{2}[.]{0,1}[0-9]{3}$/.test(value)) {
        return false;
      }
      value = value.replace(/\./g, "");
      if (parseInt(value, 10) === 0) {
        return false;
      }
      var sum = 0,
        length = value.length;
      for (var i = 0; i < length - 1; i++) {
        sum += (9 - i) * parseInt(value.charAt(i), 10);
      }
      sum = sum % 11;
      if (sum === 10) {
        sum = 0;
      }
      return sum + "" === value.charAt(length - 1);
    },

    /**
     * Validate Poland citizen number (PESEL)
     *
     * @see http://en.wikipedia.org/wiki/National_identification_number#Poland
     * @see http://en.wikipedia.org/wiki/PESEL
     * @param {String} value The ID
     * @returns {Boolean}
     */
    _pl: function (value) {
      if (!/^[0-9]{11}$/.test(value)) {
        return false;
      }

      var sum = 0,
        length = value.length,
        weight = [1, 3, 7, 9, 1, 3, 7, 9, 1, 3, 7];

      for (var i = 0; i < length - 1; i++) {
        sum += weight[i] * parseInt(value.charAt(i), 10);
      }
      sum = sum % 10;
      if (sum === 0) {
        sum = 10;
      }
      sum = 10 - sum;

      return sum + "" === value.charAt(length - 1);
    },

    /**
     * Validate Romanian numerical personal code (CNP)
     *
     * @see http://en.wikipedia.org/wiki/National_identification_number#Romania
     * @param {String} value The ID
     * @returns {Boolean}
     */
    _ro: function (value) {
      if (!/^[0-9]{13}$/.test(value)) {
        return false;
      }
      var gender = parseInt(value.charAt(0), 10);
      if (gender === 0 || gender === 7 || gender === 8) {
        return false;
      }

      // Determine the date of birth
      var year = parseInt(value.substr(1, 2), 10),
        month = parseInt(value.substr(3, 2), 10),
        day = parseInt(value.substr(5, 2), 10),
        // The year of date is determined base on the gender
        centuries = {
          1: 1900, // Male born between 1900 and 1999
          2: 1900, // Female born between 1900 and 1999
          3: 1800, // Male born between 1800 and 1899
          4: 1800, // Female born between 1800 and 1899
          5: 2000, // Male born after 2000
          6: 2000, // Female born after 2000
        };
      if (day > 31 && month > 12) {
        return false;
      }
      if (gender !== 9) {
        year = centuries[gender + ""] + year;
        if (!FormValidation.Helper.date(year, month, day)) {
          return false;
        }
      }

      // Validate the check digit
      var sum = 0,
        weight = [2, 7, 9, 1, 4, 6, 3, 5, 8, 2, 7, 9],
        length = value.length;
      for (var i = 0; i < length - 1; i++) {
        sum += parseInt(value.charAt(i), 10) * weight[i];
      }
      sum = sum % 11;
      if (sum === 10) {
        sum = 1;
      }
      return sum + "" === value.charAt(length - 1);
    },

    /**
     * Validate Swedish personal identity number (personnummer)
     *
     * @see http://en.wikipedia.org/wiki/Personal_identity_number_(Sweden)
     * @param {String} value The ID
     * @returns {Boolean}
     */
    _se: function (value) {
      if (
        !/^[0-9]{10}$/.test(value) &&
        !/^[0-9]{6}[-|+][0-9]{4}$/.test(value)
      ) {
        return false;
      }
      value = value.replace(/[^0-9]/g, "");

      var year = parseInt(value.substr(0, 2), 10) + 1900,
        month = parseInt(value.substr(2, 2), 10),
        day = parseInt(value.substr(4, 2), 10);
      if (!FormValidation.Helper.date(year, month, day)) {
        return false;
      }

      // Validate the last check digit
      return FormValidation.Helper.luhn(value);
    },

    /**
     * Validate Slovak national identifier number (RC)
     *
     * @param {String} value The ID
     * @returns {Boolean}
     */
    _sk: function (value) {
      // Slovakia uses the same format as Czech Republic
      return this._cz(value);
    },

    /**
     * Validate San Marino citizen number
     *
     * @see http://en.wikipedia.org/wiki/National_identification_number#San_Marino
     * @param {String} value The ID
     * @returns {Boolean}
     */
    _sm: function (value) {
      return /^\d{5}$/.test(value);
    },

    /**
     * Validate Thailand citizen number
     *
     * @see http://en.wikipedia.org/wiki/National_identification_number#Thailand
     * @param {String} value The ID
     * @returns {Boolean}
     */
    _th: function (value) {
      if (value.length !== 13) {
        return false;
      }

      var sum = 0;
      for (var i = 0; i < 12; i++) {
        sum += parseInt(value.charAt(i), 10) * (13 - i);
      }

      return (11 - (sum % 11)) % 10 === parseInt(value.charAt(12), 10);
    },

    /**
     * Validate Turkish Identification Number
     *
     * @see https://en.wikipedia.org/wiki/Turkish_Identification_Number
     * @param {String} value The ID
     * @returns {Boolean}
     */
    _tr: function (value) {
      if (value.length !== 11) {
        return false;
      }

      var sum = 0;
      for (var i = 0; i < 10; i++) {
        sum += parseInt(value.charAt(i), 10);
      }

      return sum % 10 === parseInt(value.charAt(10), 10);
    },

    /**
     * Validate South African ID
     *
     * @see http://en.wikipedia.org/wiki/National_identification_number#South_Africa
     * @param {String} value The ID
     * @returns {Boolean}
     */
    _za: function (value) {
      if (!/^[0-9]{10}[0|1][8|9][0-9]$/.test(value)) {
        return false;
      }
      var year = parseInt(value.substr(0, 2), 10),
        currentYear = new Date().getFullYear() % 100,
        month = parseInt(value.substr(2, 2), 10),
        day = parseInt(value.substr(4, 2), 10);
      year = year >= currentYear ? year + 1900 : year + 2000;

      if (!FormValidation.Helper.date(year, month, day)) {
        return false;
      }

      // Validate the last check digit
      return FormValidation.Helper.luhn(value);
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      identical: {
        default: "Please enter the same value",
      },
    },
  });

  FormValidation.Validator.identical = {
    html5Attributes: {
      message: "message",
      field: "field",
    },

    /**
     * Bind the validator on the live change of the field to compare with current one
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Consists of the following key:
     * - field: The name of field that will be used to compare with current one
     */
    init: function (validator, $field, options, validatorName) {
      var compareWith = validator.getFieldElements(options.field);
      validator.onLiveChange(compareWith, "live_" + validatorName, function () {
        var status = validator.getStatus($field, validatorName);
        if (status !== validator.STATUS_NOT_VALIDATED) {
          validator.revalidateField($field);
        }
      });
    },

    /**
     * Unbind the validator on the live change of the field to compare with current one
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Consists of the following key:
     * - field: The name of field that will be used to compare with current one
     */
    destroy: function (validator, $field, options, validatorName) {
      var compareWith = validator.getFieldElements(options.field);
      validator.offLiveChange(compareWith, "live_" + validatorName);
    },

    /**
     * Check if input value equals to value of particular one
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Consists of the following key:
     * - field: The name of field that will be used to compare with current one
     * @returns {Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName),
        compareWith = validator.getFieldElements(options.field);
      if (compareWith === null || compareWith.length === 0) {
        return true;
      }

      var compareValue = validator.getFieldValue(compareWith, validatorName);
      if (value === compareValue) {
        validator.updateStatus(
          compareWith,
          validator.STATUS_VALID,
          validatorName
        );
        return true;
      }

      return false;
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      imei: {
        default: "Please enter a valid IMEI number",
      },
    },
  });

  FormValidation.Validator.imei = {
    /**
     * Validate IMEI (International Mobile Station Equipment Identity)
     *
     * @see http://en.wikipedia.org/wiki/International_Mobile_Station_Equipment_Identity
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following keys:
     * - message: The invalid message
     * @returns {Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      switch (true) {
        case /^\d{15}$/.test(value):
        case /^\d{2}-\d{6}-\d{6}-\d{1}$/.test(value):
        case /^\d{2}\s\d{6}\s\d{6}\s\d{1}$/.test(value):
          value = value.replace(/[^0-9]/g, "");
          return FormValidation.Helper.luhn(value);

        case /^\d{14}$/.test(value):
        case /^\d{16}$/.test(value):
        case /^\d{2}-\d{6}-\d{6}(|-\d{2})$/.test(value):
        case /^\d{2}\s\d{6}\s\d{6}(|\s\d{2})$/.test(value):
          return true;

        default:
          return false;
      }
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      imo: {
        default: "Please enter a valid IMO number",
      },
    },
  });

  FormValidation.Validator.imo = {
    /**
     * Validate IMO (International Maritime Organization)
     *
     * @see http://en.wikipedia.org/wiki/IMO_Number
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following keys:
     * - message: The invalid message
     * @returns {Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      if (!/^IMO \d{7}$/i.test(value)) {
        return false;
      }

      // Grab just the digits
      var sum = 0,
        digits = value.replace(/^.*(\d{7})$/, "$1");
      for (var i = 6; i >= 1; i--) {
        sum += digits.slice(6 - i, -i) * (i + 1);
      }

      return sum % 10 === parseInt(digits.charAt(6), 10);
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      integer: {
        default: "Please enter a valid number",
      },
    },
  });

  FormValidation.Validator.integer = {
    html5Attributes: {
      message: "message",
      thousandsseparator: "thousandsSeparator",
      decimalseparator: "decimalSeparator",
    },

    enableByHtml5: function ($field) {
      return (
        "number" === $field.attr("type") &&
        ($field.attr("step") === undefined || $field.attr("step") % 1 === 0)
      );
    },

    /**
     * Return true if the input value is an integer
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following key:
     * - message: The invalid message
     * - thousandsSeparator: The thousands separator. It's empty by default
     * - decimalSeparator: The decimal separator. It's '.' by default
     * @returns {Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      if (
        this.enableByHtml5($field) &&
        $field.get(0).validity &&
        $field.get(0).validity.badInput === true
      ) {
        return false;
      }

      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      var decimalSeparator = options.decimalSeparator || ".",
        thousandsSeparator = options.thousandsSeparator || "";
      decimalSeparator = decimalSeparator === "." ? "\\." : decimalSeparator;
      thousandsSeparator =
        thousandsSeparator === "." ? "\\." : thousandsSeparator;

      var testRegexp = new RegExp(
          "^-?[0-9]{1,3}(" +
            thousandsSeparator +
            "[0-9]{3})*(" +
            decimalSeparator +
            "[0-9]+)?$"
        ),
        thousandsReplacer = new RegExp(thousandsSeparator, "g");

      if (!testRegexp.test(value)) {
        return false;
      }

      // Replace thousands separator with blank
      if (thousandsSeparator) {
        value = value.replace(thousandsReplacer, "");
      }
      // Replace decimal separator with a dot
      if (decimalSeparator) {
        value = value.replace(decimalSeparator, ".");
      }

      if (isNaN(value) || !isFinite(value)) {
        return false;
      }
      // TODO: Use Number.isInteger() if available
      value = parseFloat(value);
      return Math.floor(value) === value;
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      ip: {
        default: "Please enter a valid IP address",
        ipv4: "Please enter a valid IPv4 address",
        ipv6: "Please enter a valid IPv6 address",
      },
    },
  });

  FormValidation.Validator.ip = {
    html5Attributes: {
      message: "message",
      ipv4: "ipv4",
      ipv6: "ipv6",
    },

    /**
     * Return true if the input value is a IP address.
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following keys:
     * - ipv4: Enable IPv4 validator, default to true
     * - ipv6: Enable IPv6 validator, default to true
     * - message: The invalid message
     * @returns {Boolean|Object}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }
      options = $.extend({}, { ipv4: true, ipv6: true }, options);

      var locale = validator.getLocale(),
        ipv4Regex =
          /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\/([0-9]|[1-2][0-9]|3[0-2]))?$/,
        ipv6Regex =
          /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*(\/(\d|\d\d|1[0-1]\d|12[0-8]))?$/,
        valid = false,
        message;

      switch (true) {
        case options.ipv4 && !options.ipv6:
          valid = ipv4Regex.test(value);
          message = options.message || FormValidation.I18n[locale].ip.ipv4;
          break;

        case !options.ipv4 && options.ipv6:
          valid = ipv6Regex.test(value);
          message = options.message || FormValidation.I18n[locale].ip.ipv6;
          break;

        case options.ipv4 && options.ipv6:
        /* falls through */
        default:
          valid = ipv4Regex.test(value) || ipv6Regex.test(value);
          message =
            options.message || FormValidation.I18n[locale].ip["default"];
          break;
      }

      return {
        valid: valid,
        message: message,
      };
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      isbn: {
        default: "Please enter a valid ISBN number",
      },
    },
  });

  FormValidation.Validator.isbn = {
    /**
     * Return true if the input value is a valid ISBN 10 or ISBN 13 number
     *
     * @see http://en.wikipedia.org/wiki/International_Standard_Book_Number
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} [options] Can consist of the following keys:
     * - message: The invalid message
     * @returns {Boolean|Object}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      // http://en.wikipedia.org/wiki/International_Standard_Book_Number#Overview
      // Groups are separated by a hyphen or a space
      var type;
      switch (true) {
        case /^\d{9}[\dX]$/.test(value):
        case value.length === 13 && /^(\d+)-(\d+)-(\d+)-([\dX])$/.test(value):
        case value.length === 13 &&
          /^(\d+)\s(\d+)\s(\d+)\s([\dX])$/.test(value):
          type = "ISBN10";
          break;
        case /^(978|979)\d{9}[\dX]$/.test(value):
        case value.length === 17 &&
          /^(978|979)-(\d+)-(\d+)-(\d+)-([\dX])$/.test(value):
        case value.length === 17 &&
          /^(978|979)\s(\d+)\s(\d+)\s(\d+)\s([\dX])$/.test(value):
          type = "ISBN13";
          break;
        default:
          return false;
      }

      // Replace all special characters except digits and X
      value = value.replace(/[^0-9X]/gi, "");
      var chars = value.split(""),
        length = chars.length,
        sum = 0,
        i,
        checksum;

      switch (type) {
        case "ISBN10":
          sum = 0;
          for (i = 0; i < length - 1; i++) {
            sum += parseInt(chars[i], 10) * (10 - i);
          }
          checksum = 11 - (sum % 11);
          if (checksum === 11) {
            checksum = 0;
          } else if (checksum === 10) {
            checksum = "X";
          }
          return {
            type: type,
            valid: checksum + "" === chars[length - 1],
          };

        case "ISBN13":
          sum = 0;
          for (i = 0; i < length - 1; i++) {
            sum +=
              i % 2 === 0 ? parseInt(chars[i], 10) : parseInt(chars[i], 10) * 3;
          }
          checksum = 10 - (sum % 10);
          if (checksum === 10) {
            checksum = "0";
          }
          return {
            type: type,
            valid: checksum + "" === chars[length - 1],
          };

        default:
          return false;
      }
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      isin: {
        default: "Please enter a valid ISIN number",
      },
    },
  });

  FormValidation.Validator.isin = {
    // Available country codes
    // See http://isin.net/country-codes/
    COUNTRY_CODES:
      "AF|AX|AL|DZ|AS|AD|AO|AI|AQ|AG|AR|AM|AW|AU|AT|AZ|BS|BH|BD|BB|BY|BE|BZ|BJ|BM|BT|BO|BQ|BA|BW|BV|BR|IO|BN|BG|BF|BI|KH|CM|CA|CV|KY|CF|TD|CL|CN|CX|CC|CO|KM|CG|CD|CK|CR|CI|HR|CU|CW|CY|CZ|DK|DJ|DM|DO|EC|EG|SV|GQ|ER|EE|ET|FK|FO|FJ|FI|FR|GF|PF|TF|GA|GM|GE|DE|GH|GI|GR|GL|GD|GP|GU|GT|GG|GN|GW|GY|HT|HM|VA|HN|HK|HU|IS|IN|ID|IR|IQ|IE|IM|IL|IT|JM|JP|JE|JO|KZ|KE|KI|KP|KR|KW|KG|LA|LV|LB|LS|LR|LY|LI|LT|LU|MO|MK|MG|MW|MY|MV|ML|MT|MH|MQ|MR|MU|YT|MX|FM|MD|MC|MN|ME|MS|MA|MZ|MM|NA|NR|NP|NL|NC|NZ|NI|NE|NG|NU|NF|MP|NO|OM|PK|PW|PS|PA|PG|PY|PE|PH|PN|PL|PT|PR|QA|RE|RO|RU|RW|BL|SH|KN|LC|MF|PM|VC|WS|SM|ST|SA|SN|RS|SC|SL|SG|SX|SK|SI|SB|SO|ZA|GS|SS|ES|LK|SD|SR|SJ|SZ|SE|CH|SY|TW|TJ|TZ|TH|TL|TG|TK|TO|TT|TN|TR|TM|TC|TV|UG|UA|AE|GB|US|UM|UY|UZ|VU|VE|VN|VG|VI|WF|EH|YE|ZM|ZW",

    /**
     * Validate an ISIN (International Securities Identification Number)
     *
     * @see http://en.wikipedia.org/wiki/International_Securities_Identifying_Number
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following keys:
     * - message: The invalid message
     * @returns {Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      value = value.toUpperCase();
      var regex = new RegExp("^(" + this.COUNTRY_CODES + ")[0-9A-Z]{10}$");
      if (!regex.test(value)) {
        return false;
      }

      var converted = "",
        length = value.length;
      // Convert letters to number
      for (var i = 0; i < length - 1; i++) {
        var c = value.charCodeAt(i);
        converted += c > 57 ? (c - 55).toString() : value.charAt(i);
      }

      var digits = "",
        n = converted.length,
        group = n % 2 !== 0 ? 0 : 1;
      for (i = 0; i < n; i++) {
        digits += parseInt(converted[i], 10) * (i % 2 === group ? 2 : 1) + "";
      }

      var sum = 0;
      for (i = 0; i < digits.length; i++) {
        sum += parseInt(digits.charAt(i), 10);
      }
      sum = (10 - (sum % 10)) % 10;
      return sum + "" === value.charAt(length - 1);
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      ismn: {
        default: "Please enter a valid ISMN number",
      },
    },
  });

  FormValidation.Validator.ismn = {
    /**
     * Validate ISMN (International Standard Music Number)
     *
     * @see http://en.wikipedia.org/wiki/International_Standard_Music_Number
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following keys:
     * - message: The invalid message
     * @returns {Boolean|Object}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      // Groups are separated by a hyphen or a space
      var type;
      switch (true) {
        case /^M\d{9}$/.test(value):
        case /^M-\d{4}-\d{4}-\d{1}$/.test(value):
        case /^M\s\d{4}\s\d{4}\s\d{1}$/.test(value):
          type = "ISMN10";
          break;
        case /^9790\d{9}$/.test(value):
        case /^979-0-\d{4}-\d{4}-\d{1}$/.test(value):
        case /^979\s0\s\d{4}\s\d{4}\s\d{1}$/.test(value):
          type = "ISMN13";
          break;
        default:
          return false;
      }

      if ("ISMN10" === type) {
        value = "9790" + value.substr(1);
      }

      // Replace all special characters except digits
      value = value.replace(/[^0-9]/gi, "");
      var length = value.length,
        sum = 0,
        weight = [1, 3];
      for (var i = 0; i < length - 1; i++) {
        sum += parseInt(value.charAt(i), 10) * weight[i % 2];
      }
      sum = 10 - (sum % 10);
      return {
        type: type,
        valid: sum + "" === value.charAt(length - 1),
      };
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      issn: {
        default: "Please enter a valid ISSN number",
      },
    },
  });

  FormValidation.Validator.issn = {
    /**
     * Validate ISSN (International Standard Serial Number)
     *
     * @see http://en.wikipedia.org/wiki/International_Standard_Serial_Number
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following keys:
     * - message: The invalid message
     * @returns {Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      // Groups are separated by a hyphen or a space
      if (!/^\d{4}\-\d{3}[\dX]$/.test(value)) {
        return false;
      }

      // Replace all special characters except digits and X
      value = value.replace(/[^0-9X]/gi, "");
      var chars = value.split(""),
        length = chars.length,
        sum = 0;

      if (chars[7] === "X") {
        chars[7] = 10;
      }
      for (var i = 0; i < length; i++) {
        sum += parseInt(chars[i], 10) * (8 - i);
      }
      return sum % 11 === 0;
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      lessThan: {
        default: "Please enter a value less than or equal to %s",
        notInclusive: "Please enter a value less than %s",
      },
    },
  });

  FormValidation.Validator.lessThan = {
    html5Attributes: {
      message: "message",
      value: "value",
      inclusive: "inclusive",
    },

    enableByHtml5: function ($field) {
      var type = $field.attr("type"),
        max = $field.attr("max");
      if (max && type !== "date") {
        return {
          value: max,
        };
      }

      return false;
    },

    /**
     * Return true if the input value is less than or equal to given number
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following keys:
     * - value: The number used to compare to. It can be
     *      - A number
     *      - Name of field which its value defines the number
     *      - Name of callback function that returns the number
     *      - A callback function that returns the number
     *
     * - inclusive [optional]: Can be true or false. Default is true
     * - message: The invalid message
     * @returns {Boolean|Object}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      value = this._format(value);

      var locale = validator.getLocale(),
        compareTo = $.isNumeric(options.value)
          ? options.value
          : validator.getDynamicOption($field, options.value),
        compareToValue = this._format(compareTo);

      return options.inclusive === true || options.inclusive === undefined
        ? {
            valid: $.isNumeric(value) && parseFloat(value) <= compareToValue,
            message: FormValidation.Helper.format(
              options.message ||
                FormValidation.I18n[locale].lessThan["default"],
              compareTo
            ),
          }
        : {
            valid: $.isNumeric(value) && parseFloat(value) < compareToValue,
            message: FormValidation.Helper.format(
              options.message ||
                FormValidation.I18n[locale].lessThan.notInclusive,
              compareTo
            ),
          };
    },

    _format: function (value) {
      return (value + "").replace(",", ".");
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      mac: {
        default: "Please enter a valid MAC address",
      },
    },
  });

  FormValidation.Validator.mac = {
    /**
     * Return true if the input value is a MAC address.
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following keys:
     * - message: The invalid message
     * @returns {Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      return (
        /^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$/.test(value) ||
        /^([0-9A-Fa-f]{4}\.){2}([0-9A-Fa-f]{4})$/.test(value)
      );
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      meid: {
        default: "Please enter a valid MEID number",
      },
    },
  });

  FormValidation.Validator.meid = {
    /**
     * Validate MEID (Mobile Equipment Identifier)
     *
     * @see http://en.wikipedia.org/wiki/Mobile_equipment_identifier
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following keys:
     * - message: The invalid message
     * @returns {Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      switch (true) {
        // 14 digit hex representation (no check digit)
        case /^[0-9A-F]{15}$/i.test(value):
        // 14 digit hex representation + dashes or spaces (no check digit)
        case /^[0-9A-F]{2}[- ][0-9A-F]{6}[- ][0-9A-F]{6}[- ][0-9A-F]$/i.test(
          value
        ):
        // 18 digit decimal representation (no check digit)
        case /^\d{19}$/.test(value):
        // 18 digit decimal representation + dashes or spaces (no check digit)
        case /^\d{5}[- ]\d{5}[- ]\d{4}[- ]\d{4}[- ]\d$/.test(value):
          // Grab the check digit
          var cd = value.charAt(value.length - 1);

          // Strip any non-hex chars
          value = value.replace(/[- ]/g, "");

          // If it's all digits, luhn base 10 is used
          if (value.match(/^\d*$/i)) {
            return FormValidation.Helper.luhn(value);
          }

          // Strip the check digit
          value = value.slice(0, -1);

          // Get every other char, and double it
          var cdCalc = "";
          for (var i = 1; i <= 13; i += 2) {
            cdCalc += (parseInt(value.charAt(i), 16) * 2).toString(16);
          }

          // Get the sum of each char in the string
          var sum = 0;
          for (i = 0; i < cdCalc.length; i++) {
            sum += parseInt(cdCalc.charAt(i), 16);
          }

          // If the last digit of the calc is 0, the check digit is 0
          return sum % 10 === 0
            ? cd === "0"
            : // Subtract it from the next highest 10s number (64 goes to 70) and subtract the sum
              // Double it and turn it into a hex char
              cd ===
                ((Math.floor((sum + 10) / 10) * 10 - sum) * 2).toString(16);

        // 14 digit hex representation (no check digit)
        case /^[0-9A-F]{14}$/i.test(value):
        // 14 digit hex representation + dashes or spaces (no check digit)
        case /^[0-9A-F]{2}[- ][0-9A-F]{6}[- ][0-9A-F]{6}$/i.test(value):
        // 18 digit decimal representation (no check digit)
        case /^\d{18}$/.test(value):
        // 18 digit decimal representation + dashes or spaces (no check digit)
        case /^\d{5}[- ]\d{5}[- ]\d{4}[- ]\d{4}$/.test(value):
          return true;

        default:
          return false;
      }
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      notEmpty: {
        default: "Please enter a value",
      },
    },
  });

  FormValidation.Validator.notEmpty = {
    enableByHtml5: function ($field) {
      var required = $field.attr("required") + "";
      return "required" === required || "true" === required;
    },

    /**
     * Check if input value is empty or not
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options
     * @returns {Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      var type = $field.attr("type");
      if ("radio" === type || "checkbox" === type) {
        var ns = validator.getNamespace();
        return (
          validator
            .getFieldElements($field.attr("data-" + ns + "-field"))
            .filter(":checked").length > 0
        );
      }

      if (
        "number" === type &&
        $field.get(0).validity &&
        $field.get(0).validity.badInput === true
      ) {
        return true;
      }

      var value = validator.getFieldValue($field, validatorName);
      return $.trim(value) !== "";
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      numeric: {
        default: "Please enter a valid float number",
      },
    },
  });

  FormValidation.Validator.numeric = {
    html5Attributes: {
      message: "message",
      separator: "separator", // deprecated
      thousandsseparator: "thousandsSeparator",
      decimalseparator: "decimalSeparator",
    },

    enableByHtml5: function ($field) {
      return (
        "number" === $field.attr("type") &&
        $field.attr("step") !== undefined &&
        $field.attr("step") % 1 !== 0
      );
    },

    /**
     * Validate decimal number
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Consist of key:
     * - message: The invalid message
     * - thousandsSeparator: The thousands separator. It's empty by default
     * - separator, decimalSeparator: The decimal separator. It's '.' by default
     * The separator option is deprecated and should be replaced with decimalSeparator
     * @returns {Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      if (
        this.enableByHtml5($field) &&
        $field.get(0).validity &&
        $field.get(0).validity.badInput === true
      ) {
        return false;
      }

      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      var decimalSeparator =
          options.separator || options.decimalSeparator || ".",
        thousandsSeparator = options.thousandsSeparator || "";

      // Support preceding zero numbers such as .5, -.5
      if (value.substr(0, 1) === decimalSeparator) {
        value = "0" + decimalSeparator + value.substr(1);
      } else if (value.substr(0, 2) === "-" + decimalSeparator) {
        value = "-0" + decimalSeparator + value.substr(2);
      }

      decimalSeparator = decimalSeparator === "." ? "\\." : decimalSeparator;
      thousandsSeparator =
        thousandsSeparator === "." ? "\\." : thousandsSeparator;

      var testRegexp = new RegExp(
          "^-?[0-9]{1,3}(" +
            thousandsSeparator +
            "[0-9]{3})*(" +
            decimalSeparator +
            "[0-9]+)?$"
        ),
        thousandsReplacer = new RegExp(thousandsSeparator, "g");

      if (!testRegexp.test(value)) {
        return false;
      }

      // Replace thousands separator with blank
      if (thousandsSeparator) {
        value = value.replace(thousandsReplacer, "");
      }
      // Replace decimal separator with a dot
      if (decimalSeparator) {
        value = value.replace(decimalSeparator, ".");
      }

      return !isNaN(parseFloat(value)) && isFinite(value);
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      phone: {
        default: "Please enter a valid phone number",
        country: "Please enter a valid phone number in %s",
        countries: {
          AE: "United Arab Emirates",
          BG: "Bulgaria",
          BR: "Brazil",
          CN: "China",
          CZ: "Czech Republic",
          DE: "Germany",
          DK: "Denmark",
          ES: "Spain",
          FR: "France",
          GB: "United Kingdom",
          IN: "India",
          MA: "Morocco",
          NL: "Netherlands",
          PK: "Pakistan",
          RO: "Romania",
          RU: "Russia",
          SK: "Slovakia",
          TH: "Thailand",
          US: "USA",
          VE: "Venezuela",
        },
      },
    },
  });

  FormValidation.Validator.phone = {
    html5Attributes: {
      message: "message",
      country: "country",
    },

    // The supported countries
    COUNTRY_CODES: [
      "AE",
      "BG",
      "BR",
      "CN",
      "CZ",
      "DE",
      "DK",
      "ES",
      "FR",
      "GB",
      "IN",
      "MA",
      "NL",
      "PK",
      "RO",
      "RU",
      "SK",
      "TH",
      "US",
      "VE",
    ],

    /**
     * Return true if the input value contains a valid phone number for the country
     * selected in the options
     *
     * @param {FormValidation.Base} validator Validate plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Consist of key:
     * - message: The invalid message
     * - country: The ISO-3166 country code. It can be
     *      - A country code
     *      - Name of field which its value defines the country code
     *      - Name of callback function that returns the country code
     *      - A callback function that returns the country code
     *
     * @returns {Boolean|Object}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      var locale = validator.getLocale(),
        country = options.country;
      if (
        typeof country !== "string" ||
        $.inArray(country, this.COUNTRY_CODES) === -1
      ) {
        // Try to determine the country
        country = validator.getDynamicOption($field, country);
      }

      if (
        !country ||
        $.inArray(country.toUpperCase(), this.COUNTRY_CODES) === -1
      ) {
        return true;
      }

      var isValid = true;
      switch (country.toUpperCase()) {
        case "AE":
          // http://regexr.com/39tak
          value = $.trim(value);
          isValid =
            /^(((\+|00)?971[\s\.-]?(\(0\)[\s\.-]?)?|0)(\(5(0|2|5|6)\)|5(0|2|5|6)|2|3|4|6|7|9)|60)([\s\.-]?[0-9]){7}$/.test(
              value
            );
          break;

        case "BG":
          // https://regex101.com/r/yE6vN4/1
          // See http://en.wikipedia.org/wiki/Telephone_numbers_in_Bulgaria
          value = value.replace(/\+|\s|-|\/|\(|\)/gi, "");
          isValid =
            /^(0|359|00)(((700|900)[0-9]{5}|((800)[0-9]{5}|(800)[0-9]{4}))|(87|88|89)([0-9]{7})|((2[0-9]{7})|(([3-9][0-9])(([0-9]{6})|([0-9]{5})))))$/.test(
              value
            );
          break;

        case "BR":
          // http://regexr.com/399m1
          value = $.trim(value);
          isValid =
            /^(([\d]{4}[-.\s]{1}[\d]{2,3}[-.\s]{1}[\d]{2}[-.\s]{1}[\d]{2})|([\d]{4}[-.\s]{1}[\d]{3}[-.\s]{1}[\d]{4})|((\(?\+?[0-9]{2}\)?\s?)?(\(?\d{2}\)?\s?)?\d{4,5}[-.\s]?\d{4}))$/.test(
              value
            );
          break;

        case "CN":
          // http://regexr.com/39dq4
          value = $.trim(value);
          isValid =
            /^((00|\+)?(86(?:-| )))?((\d{11})|(\d{3}[- ]{1}\d{4}[- ]{1}\d{4})|((\d{2,4}[- ]){1}(\d{7,8}|(\d{3,4}[- ]{1}\d{4}))([- ]{1}\d{1,4})?))$/.test(
              value
            );
          break;

        case "CZ":
          // http://regexr.com/39hhl
          isValid =
            /^(((00)([- ]?)|\+)(420)([- ]?))?((\d{3})([- ]?)){2}(\d{3})$/.test(
              value
            );
          break;

        case "DE":
          // http://regexr.com/39pkg
          value = $.trim(value);
          isValid =
            /^(((((((00|\+)49[ \-/]?)|0)[1-9][0-9]{1,4})[ \-/]?)|((((00|\+)49\()|\(0)[1-9][0-9]{1,4}\)[ \-/]?))[0-9]{1,7}([ \-/]?[0-9]{1,5})?)$/.test(
              value
            );
          break;

        case "DK":
          // Mathing DK phone numbers with country code in 1 of 3 formats and an
          // 8 digit phone number not starting with a 0 or 1. Can have 1 space
          // between each character except inside the country code.
          // http://regex101.com/r/sS8fO4/1
          value = $.trim(value);
          isValid = /^(\+45|0045|\(45\))?\s?[2-9](\s?\d){7}$/.test(value);
          break;

        case "ES":
          // http://regex101.com/r/rB9mA9/1
          // Telephone numbers in Spain go like this:
          //     9: Landline phones and special prefixes.
          //     6, 7: Mobile phones.
          //     5: VoIP lines.
          //     8: Premium-rate services.
          // There are also special 5-digit and 3-digit numbers, but
          // maybe it would be overkill to include them all.
          value = $.trim(value);
          isValid = /^(?:(?:(?:\+|00)34\D?))?(?:5|6|7|8|9)(?:\d\D?){8}$/.test(
            value
          );
          break;

        case "FR":
          // http://regexr.com/39a2p
          value = $.trim(value);
          isValid =
            /^(?:(?:(?:\+|00)33[ ]?(?:\(0\)[ ]?)?)|0){1}[1-9]{1}([ .-]?)(?:\d{2}\1?){3}\d{2}$/.test(
              value
            );
          break;

        case "GB":
          // http://aa-asterisk.org.uk/index.php/Regular_Expressions_for_Validating_and_Formatting_GB_Telephone_Numbers#Match_GB_telephone_number_in_any_format
          // http://regexr.com/38uhv
          value = $.trim(value);
          isValid =
            /^\(?(?:(?:0(?:0|11)\)?[\s-]?\(?|\+)44\)?[\s-]?\(?(?:0\)?[\s-]?\(?)?|0)(?:\d{2}\)?[\s-]?\d{4}[\s-]?\d{4}|\d{3}\)?[\s-]?\d{3}[\s-]?\d{3,4}|\d{4}\)?[\s-]?(?:\d{5}|\d{3}[\s-]?\d{3})|\d{5}\)?[\s-]?\d{4,5}|8(?:00[\s-]?11[\s-]?11|45[\s-]?46[\s-]?4\d))(?:(?:[\s-]?(?:x|ext\.?\s?|\#)\d+)?)$/.test(
              value
            );
          break;

        case "IN":
          // http://stackoverflow.com/questions/18351553/regular-expression-validation-for-indian-phone-number-and-mobile-number
          // http://regex101.com/r/qL6eZ5/1
          // May begin with +91. Supports mobile and land line numbers
          value = $.trim(value);
          isValid =
            /((\+?)((0[ -]+)*|(91 )*)(\d{12}|\d{10}))|\d{5}([- ]*)\d{6}/.test(
              value
            );
          break;

        case "MA":
          // http://en.wikipedia.org/wiki/Telephone_numbers_in_Morocco
          // http://regexr.com/399n8
          value = $.trim(value);
          isValid =
            /^(?:(?:(?:\+|00)212[\s]?(?:[\s]?\(0\)[\s]?)?)|0){1}(?:5[\s.-]?[2-3]|6[\s.-]?[13-9]){1}[0-9]{1}(?:[\s.-]?\d{2}){3}$/.test(
              value
            );
          break;

        case "NL":
          // http://en.wikipedia.org/wiki/Telephone_numbers_in_the_Netherlands
          // http://regexr.com/3aevr
          value = $.trim(value);
          isValid =
            /^((\+|00(\s|\s?\-\s?)?)31(\s|\s?\-\s?)?(\(0\)[\-\s]?)?|0)[1-9]((\s|\s?\-\s?)?[0-9])((\s|\s?-\s?)?[0-9])((\s|\s?-\s?)?[0-9])\s?[0-9]\s?[0-9]\s?[0-9]\s?[0-9]\s?[0-9]$/gm.test(
              value
            );
          break;

        case "PK":
          // http://regex101.com/r/yH8aV9/2
          value = $.trim(value);
          isValid = /^0?3[0-9]{2}[0-9]{7}$/.test(value);
          break;

        case "RO":
          // All mobile network and land line
          // http://regexr.com/39fv1
          isValid =
            /^(\+4|)?(07[0-8]{1}[0-9]{1}|02[0-9]{2}|03[0-9]{2}){1}?(\s|\.|\-)?([0-9]{3}(\s|\.|\-|)){2}$/g.test(
              value
            );
          break;

        case "RU":
          // http://regex101.com/r/gW7yT5/5
          isValid =
            /^((8|\+7|007)[\-\.\/ ]?)?([\(\/\.]?\d{3}[\)\/\.]?[\-\.\/ ]?)?[\d\-\.\/ ]{7,10}$/g.test(
              value
            );
          break;

        case "SK":
          // http://regexr.com/3a95f
          isValid =
            /^(((00)([- ]?)|\+)(421)([- ]?))?((\d{3})([- ]?)){2}(\d{3})$/.test(
              value
            );
          break;

        case "TH":
          // http://regex101.com/r/vM5mZ4/2
          isValid = /^0\(?([6|8-9]{2})*-([0-9]{3})*-([0-9]{4})$/.test(value);
          break;

        case "VE":
          // http://regex101.com/r/eM2yY0/6
          value = $.trim(value);
          isValid =
            /^0(?:2(?:12|4[0-9]|5[1-9]|6[0-9]|7[0-8]|8[1-35-8]|9[1-5]|3[45789])|4(?:1[246]|2[46]))\d{7}$/.test(
              value
            );
          break;

        case "US":
        /* falls through */
        default:
          // Make sure US phone numbers have 10 digits
          // May start with 1, +1, or 1-; should discard
          // Area code may be delimited with (), & sections may be delimited with . or -
          // http://regexr.com/38mqi
          isValid =
            /^(?:(1\-?)|(\+1 ?))?\(?\d{3}\)?[\-\.\s]?\d{3}[\-\.\s]?\d{4}$/.test(
              value
            );
          break;
      }

      return {
        valid: isValid,
        message: FormValidation.Helper.format(
          options.message || FormValidation.I18n[locale].phone.country,
          FormValidation.I18n[locale].phone.countries[country]
        ),
      };
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      promise: {
        default: "Please enter a valid value",
      },
    },
  });

  FormValidation.Validator.promise = {
    priority: 999,

    html5Attributes: {
      message: "message",
      promise: "promise",
    },

    /**
     * Return result from a jQuery's Deferred object
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following keys:
     * - promise: The method that passes parameters:
     *      promise: function(fieldValue, validator, $field) {
     *          // fieldValue is the value of field
     *          // validator is instance of FormValidation.Base
     *          // $field is the field element
     *
     *          var dfd = new $.Deferred();
     *
     *          // Do something ...
     *
     *          // Resolve when particular task is done
     *          dfd.resolve({
     *              valid: true or false,       // Required
     *              message: 'Other message',   // Optional
     *              key: value                  // You can attach more data to reuse later
     *          });
     *
     *          // You can reject if there's error
     *          dfd.reject({
     *              message: 'Other message',   // Optional
     *              key: value                  // You can attach more data to reuse later
     *          });
     *
     *          return dfd.promise();
     *      }
     * - message: The invalid message
     * @returns {Deferred}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName),
        dfd = new $.Deferred(),
        promise = FormValidation.Helper.call(options.promise, [
          value,
          validator,
          $field,
        ]);

      promise
        .done(function (result) {
          dfd.resolve($field, validatorName, result);
        })
        .fail(function (result) {
          result = result || {};
          result.valid = false;
          dfd.resolve($field, validatorName, result);
        });

      return dfd;
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      regexp: {
        default: "Please enter a value matching the pattern",
      },
    },
  });

  FormValidation.Validator.regexp = {
    html5Attributes: {
      message: "message",
      flags: "flags",
      regexp: "regexp",
    },

    enableByHtml5: function ($field) {
      var pattern = $field.attr("pattern");
      if (pattern) {
        return {
          regexp: pattern,
        };
      }

      return false;
    },

    /**
     * Check if the element value matches given regular expression
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Consists of the following key:
     * - regexp: The regular expression you need to check
     * - flags: If specified, flags can have any combination of Javascript regular expression flags such as:
     *      g: global match
     *      i: ignore case
     *      m: multiple line
     * @returns {Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      var regexp =
        "string" === typeof options.regexp
          ? options.flags
            ? new RegExp(options.regexp, options.flags)
            : new RegExp(options.regexp)
          : options.regexp;
      return regexp.test(value);
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      remote: {
        default: "Please enter a valid value",
      },
    },
  });

  FormValidation.Validator.remote = {
    priority: 1000,

    html5Attributes: {
      async: "async",
      crossdomain: "crossDomain",
      data: "data",
      datatype: "dataType",
      delay: "delay",
      message: "message",
      name: "name",
      type: "type",
      url: "url",
      validkey: "validKey",
    },

    /**
     * Destroy the timer when destroying the FormValidation (using validator.destroy() method)
     */
    destroy: function (validator, $field, options, validatorName) {
      var ns = validator.getNamespace(),
        timer = $field.data(ns + "." + validatorName + ".timer");
      if (timer) {
        clearTimeout(timer);
        $field.removeData(ns + "." + validatorName + ".timer");
      }
    },

    /**
     * Request a remote server to check the input value
     *
     * @param {FormValidation.Base} validator Plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following keys:
     * - async {Boolean} [optional] Indicate the Ajax request will be asynchronous or not. It's true by default
     * - crossDomain {Boolean} [optional]
     * - data {Object|Function} [optional]: By default, it will take the value
     *  {
     *      <fieldName>: <fieldValue>
     *  }
     * - dataType {String} [optional]: The type of data which is returned by remote server.
     * It can be json (default), text, script
     * - delay {Number} [optional]
     * - headers {String[]} [optional]: Additional headers
     * - message {String} [optional]: The invalid message
     * - name {String} [optional]: Override the field name for the request.
     * - type {String} [optional] Can be GET or POST (default)
     * - url {String|Function}
     * - validKey {String} [optional]: The valid key. It's "valid" by default
     * This is useful when connecting to external remote server or APIs provided by 3rd parties
     * @returns {Deferred}
     */
    validate: function (validator, $field, options, validatorName) {
      var ns = validator.getNamespace(),
        value = validator.getFieldValue($field, validatorName),
        dfd = new $.Deferred();
      if (value === "") {
        dfd.resolve($field, validatorName, { valid: true });
        return dfd;
      }
      var name = $field.attr("data-" + ns + "-field"),
        data = options.data || {},
        url = options.url,
        validKey = options.validKey || "valid";

      // Support dynamic data
      if ("function" === typeof data) {
        data = data.call(this, validator, $field, value);
      }

      // Parse string data from HTML5 attribute
      if ("string" === typeof data) {
        data = JSON.parse(data);
      }

      // Support dynamic url
      if ("function" === typeof url) {
        url = url.call(this, validator, $field, value);
      }

      data[options.name || name] = value;

      var ajaxOptions = {
        async:
          options.async === null ||
          options.async === true ||
          options.async === "true",
        data: data,
        dataType: options.dataType || "json",
        headers: options.headers || {},
        type: options.type || "GET",
        url: url,
      };
      if (options.crossDomain !== null) {
        ajaxOptions.crossDomain =
          options.crossDomain === true || options.crossDomain === "true";
      }

      function runCallback() {
        var xhr = $.ajax(ajaxOptions);

        xhr
          .success(function (response) {
            response.valid =
              response[validKey] === true || response[validKey] === "true"
                ? true
                : response[validKey] === false || response[validKey] === "false"
                ? false
                : null;
            dfd.resolve($field, validatorName, response);
          })
          .error(function (response) {
            dfd.resolve($field, validatorName, {
              valid: false,
            });
          });

        dfd.fail(function () {
          xhr.abort();
        });

        return dfd;
      }

      if (options.delay) {
        // Since the form might have multiple fields with the same name
        // I have to attach the timer to the field element
        if ($field.data(ns + "." + validatorName + ".timer")) {
          clearTimeout($field.data(ns + "." + validatorName + ".timer"));
        }

        $field.data(
          ns + "." + validatorName + ".timer",
          setTimeout(runCallback, options.delay)
        );
        return dfd;
      } else {
        return runCallback();
      }
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      rtn: {
        default: "Please enter a valid RTN number",
      },
    },
  });

  FormValidation.Validator.rtn = {
    /**
     * Validate a RTN (Routing transit number)
     *
     * @see http://en.wikipedia.org/wiki/Routing_transit_number
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following keys:
     * - message: The invalid message
     * @returns {Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      if (!/^\d{9}$/.test(value)) {
        return false;
      }

      var sum = 0;
      for (var i = 0; i < value.length; i += 3) {
        sum +=
          parseInt(value.charAt(i), 10) * 3 +
          parseInt(value.charAt(i + 1), 10) * 7 +
          parseInt(value.charAt(i + 2), 10);
      }
      return sum !== 0 && sum % 10 === 0;
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      sedol: {
        default: "Please enter a valid SEDOL number",
      },
    },
  });

  FormValidation.Validator.sedol = {
    /**
     * Validate a SEDOL (Stock Exchange Daily Official List)
     *
     * @see http://en.wikipedia.org/wiki/SEDOL
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following keys:
     * - message: The invalid message
     * @returns {Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      value = value.toUpperCase();
      if (!/^[0-9A-Z]{7}$/.test(value)) {
        return false;
      }

      var sum = 0,
        weight = [1, 3, 1, 7, 3, 9, 1],
        length = value.length;
      for (var i = 0; i < length - 1; i++) {
        sum += weight[i] * parseInt(value.charAt(i), 36);
      }
      sum = (10 - (sum % 10)) % 10;
      return sum + "" === value.charAt(length - 1);
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      siren: {
        default: "Please enter a valid SIREN number",
      },
    },
  });

  FormValidation.Validator.siren = {
    /**
     * Check if a string is a siren number
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Consist of key:
     * - message: The invalid message
     * @returns {Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      if (!/^\d{9}$/.test(value)) {
        return false;
      }
      return FormValidation.Helper.luhn(value);
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      siret: {
        default: "Please enter a valid SIRET number",
      },
    },
  });

  FormValidation.Validator.siret = {
    /**
     * Check if a string is a siret number
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Consist of key:
     * - message: The invalid message
     * @returns {Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      var sum = 0,
        length = value.length,
        tmp;
      for (var i = 0; i < length; i++) {
        tmp = parseInt(value.charAt(i), 10);
        if (i % 2 === 0) {
          tmp = tmp * 2;
          if (tmp > 9) {
            tmp -= 9;
          }
        }
        sum += tmp;
      }
      return sum % 10 === 0;
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      step: {
        default: "Please enter a valid step of %s",
      },
    },
  });

  FormValidation.Validator.step = {
    html5Attributes: {
      message: "message",
      base: "baseValue",
      step: "step",
    },

    /**
     * Return true if the input value is valid step one
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Can consist of the following keys:
     * - baseValue: The base value
     * - step: The step
     * - message: The invalid message
     * @returns {Boolean|Object}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      options = $.extend({}, { baseValue: 0, step: 1 }, options);
      value = parseFloat(value);
      if (!$.isNumeric(value)) {
        return false;
      }

      var round = function (x, precision) {
          var m = Math.pow(10, precision);
          x = x * m;
          var sign = (x > 0) | -(x < 0),
            isHalf = x % 1 === 0.5 * sign;
          if (isHalf) {
            return (Math.floor(x) + (sign > 0)) / m;
          } else {
            return Math.round(x) / m;
          }
        },
        floatMod = function (x, y) {
          if (y === 0.0) {
            return 1.0;
          }
          var dotX = (x + "").split("."),
            dotY = (y + "").split("."),
            precision =
              (dotX.length === 1 ? 0 : dotX[1].length) +
              (dotY.length === 1 ? 0 : dotY[1].length);
          return round(x - y * Math.floor(x / y), precision);
        };

      var locale = validator.getLocale(),
        mod = floatMod(value - options.baseValue, options.step);
      return {
        valid: mod === 0.0 || mod === options.step,
        message: FormValidation.Helper.format(
          options.message || FormValidation.I18n[locale].step["default"],
          [options.step]
        ),
      };
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      stringCase: {
        default: "Please enter only lowercase characters",
        upper: "Please enter only uppercase characters",
      },
    },
  });

  FormValidation.Validator.stringCase = {
    html5Attributes: {
      message: "message",
      case: "case",
    },

    /**
     * Check if a string is a lower or upper case one
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Consist of key:
     * - message: The invalid message
     * - case: Can be 'lower' (default) or 'upper'
     * @returns {Object}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      var locale = validator.getLocale(),
        stringCase = (options["case"] || "lower").toLowerCase();
      return {
        valid:
          "upper" === stringCase
            ? value === value.toUpperCase()
            : value === value.toLowerCase(),
        message:
          options.message ||
          ("upper" === stringCase
            ? FormValidation.I18n[locale].stringCase.upper
            : FormValidation.I18n[locale].stringCase["default"]),
      };
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      stringLength: {
        default: "Please enter a value with valid length",
        less: "Please enter less than %s characters",
        more: "Please enter more than %s characters",
        between: "Please enter value between %s and %s characters long",
      },
    },
  });

  FormValidation.Validator.stringLength = {
    html5Attributes: {
      message: "message",
      min: "min",
      max: "max",
      trim: "trim",
      utf8bytes: "utf8Bytes",
    },

    enableByHtml5: function ($field) {
      var options = {},
        maxLength = $field.attr("maxlength"),
        minLength = $field.attr("minlength");
      if (maxLength) {
        options.max = parseInt(maxLength, 10);
      }
      if (minLength) {
        options.min = parseInt(minLength, 10);
      }

      return $.isEmptyObject(options) ? false : options;
    },

    /**
     * Check if the length of element value is less or more than given number
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Consists of following keys:
     * - min
     * - max
     * At least one of two keys is required
     * The min, max keys define the number which the field value compares to. min, max can be
     *      - A number
     *      - Name of field which its value defines the number
     *      - Name of callback function that returns the number
     *      - A callback function that returns the number
     *
     * - message: The invalid message
     * - trim: Indicate the length will be calculated after trimming the value or not. It is false, by default
     * - utf8bytes: Evaluate string length in UTF-8 bytes, default to false
     * @returns {Object}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (options.trim === true || options.trim === "true") {
        value = $.trim(value);
      }

      if (value === "") {
        return true;
      }

      var locale = validator.getLocale(),
        min = $.isNumeric(options.min)
          ? options.min
          : validator.getDynamicOption($field, options.min),
        max = $.isNumeric(options.max)
          ? options.max
          : validator.getDynamicOption($field, options.max),
        // Credit to http://stackoverflow.com/a/23329386 (@lovasoa) for UTF-8 byte length code
        utf8Length = function (str) {
          var s = str.length;
          for (var i = str.length - 1; i >= 0; i--) {
            var code = str.charCodeAt(i);
            if (code > 0x7f && code <= 0x7ff) {
              s++;
            } else if (code > 0x7ff && code <= 0xffff) {
              s += 2;
            }
            if (code >= 0xdc00 && code <= 0xdfff) {
              i--;
            }
          }
          return s;
        },
        length = options.utf8Bytes ? utf8Length(value) : value.length,
        isValid = true,
        message =
          options.message ||
          FormValidation.I18n[locale].stringLength["default"];

      if (
        (min && length < parseInt(min, 10)) ||
        (max && length > parseInt(max, 10))
      ) {
        isValid = false;
      }

      switch (true) {
        case !!min && !!max:
          message = FormValidation.Helper.format(
            options.message || FormValidation.I18n[locale].stringLength.between,
            [parseInt(min, 10), parseInt(max, 10)]
          );
          break;

        case !!min:
          message = FormValidation.Helper.format(
            options.message || FormValidation.I18n[locale].stringLength.more,
            parseInt(min, 10) - 1
          );
          break;

        case !!max:
          message = FormValidation.Helper.format(
            options.message || FormValidation.I18n[locale].stringLength.less,
            parseInt(max, 10) + 1
          );
          break;

        default:
          break;
      }

      return {
        valid: isValid,
        message: message,
      };
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      uri: {
        default: "Please enter a valid URI",
      },
    },
  });

  FormValidation.Validator.uri = {
    html5Attributes: {
      message: "message",
      allowlocal: "allowLocal",
      allowemptyprotocol: "allowEmptyProtocol",
      protocol: "protocol",
    },

    enableByHtml5: function ($field) {
      return "url" === $field.attr("type");
    },

    /**
     * Return true if the input value is a valid URL
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options
     * - message: The error message
     * - allowLocal: Allow the private and local network IP. Default to false
     * - allowEmptyProtocol: Allow the URI without protocol. Default to false
     * - protocol: The protocols, separated by a comma. Default to "http, https, ftp"
     * @returns {Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      // Credit to https://gist.github.com/dperini/729294
      //
      // Regular Expression for URL validation
      //
      // Author: Diego Perini
      // Updated: 2010/12/05
      //
      // the regular expression composed & commented
      // could be easily tweaked for RFC compliance,
      // it was expressly modified to fit & satisfy
      // these test for an URL shortener:
      //
      //   http://mathiasbynens.be/demo/url-regex
      //
      // Notes on possible differences from a standard/generic validation:
      //
      // - utf-8 char class take in consideration the full Unicode range
      // - TLDs are mandatory unless `allowLocal` is true
      // - protocols have been restricted to ftp, http and https only as requested
      //
      // Changes:
      //
      // - IP address dotted notation validation, range: 1.0.0.0 - 223.255.255.255
      //   first and last IP address of each class is considered invalid
      //   (since they are broadcast/network addresses)
      //
      // - Added exclusion of private, reserved and/or local networks ranges
      //   unless `allowLocal` is true
      //
      // - Added possibility of choosing a custom protocol
      //
      // - Add option to validate without protocol
      //
      var allowLocal =
          options.allowLocal === true || options.allowLocal === "true",
        allowEmptyProtocol =
          options.allowEmptyProtocol === true ||
          options.allowEmptyProtocol === "true",
        protocol = (options.protocol || "http, https, ftp")
          .split(",")
          .join("|")
          .replace(/\s/g, ""),
        urlExp = new RegExp(
          "^" +
            // protocol identifier
            "(?:(?:" +
            protocol +
            ")://)" +
            // allow empty protocol
            (allowEmptyProtocol ? "?" : "") +
            // user:pass authentication
            "(?:\\S+(?::\\S*)?@)?" +
            "(?:" +
            // IP address exclusion
            // private & local networks
            (allowLocal
              ? ""
              : "(?!(?:10|127)(?:\\.\\d{1,3}){3})" +
                "(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})" +
                "(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})") +
            // IP address dotted notation octets
            // excludes loopback network 0.0.0.0
            // excludes reserved space >= 224.0.0.0
            // excludes network & broadcast addresses
            // (first & last IP address of each class)
            "(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])" +
            "(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}" +
            "(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))" +
            "|" +
            // host name
            "(?:(?:[a-z\\u00a1-\\uffff0-9]-?)*[a-z\\u00a1-\\uffff0-9]+)" +
            // domain name
            "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-?)*[a-z\\u00a1-\\uffff0-9])*" +
            // TLD identifier
            "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))" +
            // Allow intranet sites (no TLD) if `allowLocal` is true
            (allowLocal ? "?" : "") +
            ")" +
            // port number
            "(?::\\d{2,5})?" +
            // resource path
            "(?:/[^\\s]*)?" +
            "$",
          "i"
        );

      return urlExp.test(value);
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      uuid: {
        default: "Please enter a valid UUID number",
        version: "Please enter a valid UUID version %s number",
      },
    },
  });

  FormValidation.Validator.uuid = {
    html5Attributes: {
      message: "message",
      version: "version",
    },

    /**
     * Return true if and only if the input value is a valid UUID string
     *
     * @see http://en.wikipedia.org/wiki/Universally_unique_identifier
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Consist of key:
     * - message: The invalid message
     * - version: Can be 3, 4, 5, null
     * @returns {Boolean|Object}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      // See the format at http://en.wikipedia.org/wiki/Universally_unique_identifier#Variants_and_versions
      var locale = validator.getLocale(),
        patterns = {
          3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
          4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
          5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
          all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
        },
        version = options.version ? options.version + "" : "all";
      return {
        valid:
          null === patterns[version] ? true : patterns[version].test(value),
        message: options.version
          ? FormValidation.Helper.format(
              options.message || FormValidation.I18n[locale].uuid.version,
              options.version
            )
          : options.message || FormValidation.I18n[locale].uuid["default"],
      };
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      vat: {
        default: "Please enter a valid VAT number",
        country: "Please enter a valid VAT number in %s",
        countries: {
          AT: "Austria",
          BE: "Belgium",
          BG: "Bulgaria",
          BR: "Brazil",
          CH: "Switzerland",
          CY: "Cyprus",
          CZ: "Czech Republic",
          DE: "Germany",
          DK: "Denmark",
          EE: "Estonia",
          ES: "Spain",
          FI: "Finland",
          FR: "France",
          GB: "United Kingdom",
          GR: "Greek",
          EL: "Greek",
          HU: "Hungary",
          HR: "Croatia",
          IE: "Ireland",
          IS: "Iceland",
          IT: "Italy",
          LT: "Lithuania",
          LU: "Luxembourg",
          LV: "Latvia",
          MT: "Malta",
          NL: "Netherlands",
          NO: "Norway",
          PL: "Poland",
          PT: "Portugal",
          RO: "Romania",
          RU: "Russia",
          RS: "Serbia",
          SE: "Sweden",
          SI: "Slovenia",
          SK: "Slovakia",
          VE: "Venezuela",
          ZA: "South Africa",
        },
      },
    },
  });

  FormValidation.Validator.vat = {
    html5Attributes: {
      message: "message",
      country: "country",
    },

    // Supported country codes
    COUNTRY_CODES: [
      "AT",
      "BE",
      "BG",
      "BR",
      "CH",
      "CY",
      "CZ",
      "DE",
      "DK",
      "EE",
      "EL",
      "ES",
      "FI",
      "FR",
      "GB",
      "GR",
      "HR",
      "HU",
      "IE",
      "IS",
      "IT",
      "LT",
      "LU",
      "LV",
      "MT",
      "NL",
      "NO",
      "PL",
      "PT",
      "RO",
      "RU",
      "RS",
      "SE",
      "SK",
      "SI",
      "VE",
      "ZA",
    ],

    /**
     * Validate an European VAT number
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Consist of key:
     * - message: The invalid message
     * - country: The ISO 3166-1 country code. It can be
     *      - One of country code defined in COUNTRY_CODES
     *      - Name of field which its value defines the country code
     *      - Name of callback function that returns the country code
     *      - A callback function that returns the country code
     * @returns {Object}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      var locale = validator.getLocale(),
        country = options.country;
      if (!country) {
        country = value.substr(0, 2);
      } else if (
        typeof country !== "string" ||
        $.inArray(country.toUpperCase(), this.COUNTRY_CODES) === -1
      ) {
        // Determine the country code
        country = validator.getDynamicOption($field, country);
      }

      if ($.inArray(country, this.COUNTRY_CODES) === -1) {
        return true;
      }

      var method = ["_", country.toLowerCase()].join(""),
        result = this[method](value);
      result = result === true || result === false ? { valid: result } : result;
      result.message = FormValidation.Helper.format(
        options.message || FormValidation.I18n[locale].vat.country,
        FormValidation.I18n[locale].vat.countries[country.toUpperCase()]
      );

      return result;
    },

    // VAT validators

    /**
     * Validate Austrian VAT number
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _at: function (value) {
      if (/^ATU[0-9]{8}$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^U[0-9]{8}$/.test(value)) {
        return false;
      }

      value = value.substr(1);
      var sum = 0,
        weight = [1, 2, 1, 2, 1, 2, 1],
        temp = 0;
      for (var i = 0; i < 7; i++) {
        temp = parseInt(value.charAt(i), 10) * weight[i];
        if (temp > 9) {
          temp = Math.floor(temp / 10) + (temp % 10);
        }
        sum += temp;
      }

      sum = 10 - ((sum + 4) % 10);
      if (sum === 10) {
        sum = 0;
      }

      return sum + "" === value.substr(7, 1);
    },

    /**
     * Validate Belgian VAT number
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _be: function (value) {
      if (/^BE[0]{0,1}[0-9]{9}$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^[0]{0,1}[0-9]{9}$/.test(value)) {
        return false;
      }

      if (value.length === 9) {
        value = "0" + value;
      }
      if (value.substr(1, 1) === "0") {
        return false;
      }

      var sum =
        parseInt(value.substr(0, 8), 10) + parseInt(value.substr(8, 2), 10);
      return sum % 97 === 0;
    },

    /**
     * Validate Bulgarian VAT number
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _bg: function (value) {
      if (/^BG[0-9]{9,10}$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^[0-9]{9,10}$/.test(value)) {
        return false;
      }

      var sum = 0,
        i = 0;

      // Legal entities
      if (value.length === 9) {
        for (i = 0; i < 8; i++) {
          sum += parseInt(value.charAt(i), 10) * (i + 1);
        }
        sum = sum % 11;
        if (sum === 10) {
          sum = 0;
          for (i = 0; i < 8; i++) {
            sum += parseInt(value.charAt(i), 10) * (i + 3);
          }
        }
        sum = sum % 10;
        return sum + "" === value.substr(8);
      }
      // Physical persons, foreigners and others
      else if (value.length === 10) {
        // Validate Bulgarian national identification numbers
        var egn = function (value) {
            // Check the birth date
            var year = parseInt(value.substr(0, 2), 10) + 1900,
              month = parseInt(value.substr(2, 2), 10),
              day = parseInt(value.substr(4, 2), 10);
            if (month > 40) {
              year += 100;
              month -= 40;
            } else if (month > 20) {
              year -= 100;
              month -= 20;
            }

            if (!FormValidation.Helper.date(year, month, day)) {
              return false;
            }

            var sum = 0,
              weight = [2, 4, 8, 5, 10, 9, 7, 3, 6];
            for (var i = 0; i < 9; i++) {
              sum += parseInt(value.charAt(i), 10) * weight[i];
            }
            sum = (sum % 11) % 10;
            return sum + "" === value.substr(9, 1);
          },
          // Validate Bulgarian personal number of a foreigner
          pnf = function (value) {
            var sum = 0,
              weight = [21, 19, 17, 13, 11, 9, 7, 3, 1];
            for (var i = 0; i < 9; i++) {
              sum += parseInt(value.charAt(i), 10) * weight[i];
            }
            sum = sum % 10;
            return sum + "" === value.substr(9, 1);
          },
          // Finally, consider it as a VAT number
          vat = function (value) {
            var sum = 0,
              weight = [4, 3, 2, 7, 6, 5, 4, 3, 2];
            for (var i = 0; i < 9; i++) {
              sum += parseInt(value.charAt(i), 10) * weight[i];
            }
            sum = 11 - (sum % 11);
            if (sum === 10) {
              return false;
            }
            if (sum === 11) {
              sum = 0;
            }
            return sum + "" === value.substr(9, 1);
          };
        return egn(value) || pnf(value) || vat(value);
      }

      return false;
    },

    /**
     * Validate Brazilian VAT number (CNPJ)
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _br: function (value) {
      if (value === "") {
        return true;
      }
      var cnpj = value.replace(/[^\d]+/g, "");
      if (cnpj === "" || cnpj.length !== 14) {
        return false;
      }

      // Remove invalids CNPJs
      if (
        cnpj === "00000000000000" ||
        cnpj === "11111111111111" ||
        cnpj === "22222222222222" ||
        cnpj === "33333333333333" ||
        cnpj === "44444444444444" ||
        cnpj === "55555555555555" ||
        cnpj === "66666666666666" ||
        cnpj === "77777777777777" ||
        cnpj === "88888888888888" ||
        cnpj === "99999999999999"
      ) {
        return false;
      }

      // Validate verification digits
      var length = cnpj.length - 2,
        numbers = cnpj.substring(0, length),
        digits = cnpj.substring(length),
        sum = 0,
        pos = length - 7;

      for (var i = length; i >= 1; i--) {
        sum += parseInt(numbers.charAt(length - i), 10) * pos--;
        if (pos < 2) {
          pos = 9;
        }
      }

      var result = sum % 11 < 2 ? 0 : 11 - (sum % 11);
      if (result !== parseInt(digits.charAt(0), 10)) {
        return false;
      }

      length = length + 1;
      numbers = cnpj.substring(0, length);
      sum = 0;
      pos = length - 7;
      for (i = length; i >= 1; i--) {
        sum += parseInt(numbers.charAt(length - i), 10) * pos--;
        if (pos < 2) {
          pos = 9;
        }
      }

      result = sum % 11 < 2 ? 0 : 11 - (sum % 11);
      return result === parseInt(digits.charAt(1), 10);
    },

    /**
     * Validate Swiss VAT number
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _ch: function (value) {
      if (/^CHE[0-9]{9}(MWST)?$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^E[0-9]{9}(MWST)?$/.test(value)) {
        return false;
      }

      value = value.substr(1);
      var sum = 0,
        weight = [5, 4, 3, 2, 7, 6, 5, 4];
      for (var i = 0; i < 8; i++) {
        sum += parseInt(value.charAt(i), 10) * weight[i];
      }

      sum = 11 - (sum % 11);
      if (sum === 10) {
        return false;
      }
      if (sum === 11) {
        sum = 0;
      }

      return sum + "" === value.substr(8, 1);
    },

    /**
     * Validate Cypriot VAT number
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _cy: function (value) {
      if (/^CY[0-5|9]{1}[0-9]{7}[A-Z]{1}$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^[0-5|9]{1}[0-9]{7}[A-Z]{1}$/.test(value)) {
        return false;
      }

      // Do not allow to start with "12"
      if (value.substr(0, 2) === "12") {
        return false;
      }

      // Extract the next digit and multiply by the counter.
      var sum = 0,
        translation = {
          0: 1,
          1: 0,
          2: 5,
          3: 7,
          4: 9,
          5: 13,
          6: 15,
          7: 17,
          8: 19,
          9: 21,
        };
      for (var i = 0; i < 8; i++) {
        var temp = parseInt(value.charAt(i), 10);
        if (i % 2 === 0) {
          temp = translation[temp + ""];
        }
        sum += temp;
      }

      sum = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[sum % 26];
      return sum + "" === value.substr(8, 1);
    },

    /**
     * Validate Czech Republic VAT number
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _cz: function (value) {
      if (/^CZ[0-9]{8,10}$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^[0-9]{8,10}$/.test(value)) {
        return false;
      }

      var sum = 0,
        i = 0;
      if (value.length === 8) {
        // Do not allow to start with '9'
        if (value.charAt(0) + "" === "9") {
          return false;
        }

        sum = 0;
        for (i = 0; i < 7; i++) {
          sum += parseInt(value.charAt(i), 10) * (8 - i);
        }
        sum = 11 - (sum % 11);
        if (sum === 10) {
          sum = 0;
        }
        if (sum === 11) {
          sum = 1;
        }

        return sum + "" === value.substr(7, 1);
      } else if (value.length === 9 && value.charAt(0) + "" === "6") {
        sum = 0;
        // Skip the first (which is 6)
        for (i = 0; i < 7; i++) {
          sum += parseInt(value.charAt(i + 1), 10) * (8 - i);
        }
        sum = 11 - (sum % 11);
        if (sum === 10) {
          sum = 0;
        }
        if (sum === 11) {
          sum = 1;
        }
        sum = [8, 7, 6, 5, 4, 3, 2, 1, 0, 9, 10][sum - 1];
        return sum + "" === value.substr(8, 1);
      } else if (value.length === 9 || value.length === 10) {
        // Validate Czech birth number (Rodné číslo), which is also national identifier
        var year = 1900 + parseInt(value.substr(0, 2), 10),
          month = (parseInt(value.substr(2, 2), 10) % 50) % 20,
          day = parseInt(value.substr(4, 2), 10);
        if (value.length === 9) {
          if (year >= 1980) {
            year -= 100;
          }
          if (year > 1953) {
            return false;
          }
        } else if (year < 1954) {
          year += 100;
        }

        if (!FormValidation.Helper.date(year, month, day)) {
          return false;
        }

        // Check that the birth date is not in the future
        if (value.length === 10) {
          var check = parseInt(value.substr(0, 9), 10) % 11;
          if (year < 1985) {
            check = check % 10;
          }
          return check + "" === value.substr(9, 1);
        }

        return true;
      }

      return false;
    },

    /**
     * Validate German VAT number
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _de: function (value) {
      if (/^DE[0-9]{9}$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^[0-9]{9}$/.test(value)) {
        return false;
      }

      return FormValidation.Helper.mod11And10(value);
    },

    /**
     * Validate Danish VAT number
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _dk: function (value) {
      if (/^DK[0-9]{8}$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^[0-9]{8}$/.test(value)) {
        return false;
      }

      var sum = 0,
        weight = [2, 7, 6, 5, 4, 3, 2, 1];
      for (var i = 0; i < 8; i++) {
        sum += parseInt(value.charAt(i), 10) * weight[i];
      }

      return sum % 11 === 0;
    },

    /**
     * Validate Estonian VAT number
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _ee: function (value) {
      if (/^EE[0-9]{9}$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^[0-9]{9}$/.test(value)) {
        return false;
      }

      var sum = 0,
        weight = [3, 7, 1, 3, 7, 1, 3, 7, 1];
      for (var i = 0; i < 9; i++) {
        sum += parseInt(value.charAt(i), 10) * weight[i];
      }

      return sum % 10 === 0;
    },

    /**
     * Validate Spanish VAT number (NIF - Número de Identificación Fiscal)
     * Can be:
     * i) DNI (Documento nacional de identidad), for Spaniards
     * ii) NIE (Número de Identificación de Extranjeros), for foreigners
     * iii) CIF (Certificado de Identificación Fiscal), for legal entities and others
     *
     * @param {String} value VAT number
     * @returns {Boolean|Object}
     */
    _es: function (value) {
      if (/^ES[0-9A-Z][0-9]{7}[0-9A-Z]$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^[0-9A-Z][0-9]{7}[0-9A-Z]$/.test(value)) {
        return false;
      }

      var dni = function (value) {
          var check = parseInt(value.substr(0, 8), 10);
          check = "TRWAGMYFPDXBNJZSQVHLCKE"[check % 23];
          return check + "" === value.substr(8, 1);
        },
        nie = function (value) {
          var check = ["XYZ".indexOf(value.charAt(0)), value.substr(1)].join(
            ""
          );
          check = parseInt(check, 10);
          check = "TRWAGMYFPDXBNJZSQVHLCKE"[check % 23];
          return check + "" === value.substr(8, 1);
        },
        cif = function (value) {
          var first = value.charAt(0),
            check;
          if ("KLM".indexOf(first) !== -1) {
            // K: Spanish younger than 14 year old
            // L: Spanish living outside Spain without DNI
            // M: Granted the tax to foreigners who have no NIE
            check = parseInt(value.substr(1, 8), 10);
            check = "TRWAGMYFPDXBNJZSQVHLCKE"[check % 23];
            return check + "" === value.substr(8, 1);
          } else if ("ABCDEFGHJNPQRSUVW".indexOf(first) !== -1) {
            var sum = 0,
              weight = [2, 1, 2, 1, 2, 1, 2],
              temp = 0;

            for (var i = 0; i < 7; i++) {
              temp = parseInt(value.charAt(i + 1), 10) * weight[i];
              if (temp > 9) {
                temp = Math.floor(temp / 10) + (temp % 10);
              }
              sum += temp;
            }
            sum = 10 - (sum % 10);
            if (sum === 10) {
              sum = 0;
            }
            return (
              sum + "" === value.substr(8, 1) ||
              "JABCDEFGHI"[sum] === value.substr(8, 1)
            );
          }

          return false;
        };

      var first = value.charAt(0);
      if (/^[0-9]$/.test(first)) {
        return {
          valid: dni(value),
          type: "DNI",
        };
      } else if (/^[XYZ]$/.test(first)) {
        return {
          valid: nie(value),
          type: "NIE",
        };
      } else {
        return {
          valid: cif(value),
          type: "CIF",
        };
      }
    },

    /**
     * Validate Finnish VAT number
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _fi: function (value) {
      if (/^FI[0-9]{8}$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^[0-9]{8}$/.test(value)) {
        return false;
      }

      var sum = 0,
        weight = [7, 9, 10, 5, 8, 4, 2, 1];
      for (var i = 0; i < 8; i++) {
        sum += parseInt(value.charAt(i), 10) * weight[i];
      }

      return sum % 11 === 0;
    },

    /**
     * Validate French VAT number (TVA - taxe sur la valeur ajoutée)
     * It's constructed by a SIREN number, prefixed by two characters.
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _fr: function (value) {
      if (/^FR[0-9A-Z]{2}[0-9]{9}$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^[0-9A-Z]{2}[0-9]{9}$/.test(value)) {
        return false;
      }

      if (!FormValidation.Helper.luhn(value.substr(2))) {
        return false;
      }

      if (/^[0-9]{2}$/.test(value.substr(0, 2))) {
        // First two characters are digits
        return (
          value.substr(0, 2) ===
          (parseInt(value.substr(2) + "12", 10) % 97) + ""
        );
      } else {
        // The first characters cann't be O and I
        var alphabet = "0123456789ABCDEFGHJKLMNPQRSTUVWXYZ",
          check;
        // First one is digit
        if (/^[0-9]{1}$/.test(value.charAt(0))) {
          check =
            alphabet.indexOf(value.charAt(0)) * 24 +
            alphabet.indexOf(value.charAt(1)) -
            10;
        } else {
          check =
            alphabet.indexOf(value.charAt(0)) * 34 +
            alphabet.indexOf(value.charAt(1)) -
            100;
        }
        return (
          (parseInt(value.substr(2), 10) + 1 + Math.floor(check / 11)) % 11 ===
          check % 11
        );
      }
    },

    /**
     * Validate United Kingdom VAT number
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _gb: function (value) {
      if (
        /^GB[0-9]{9}$/.test(value) /* Standard */ ||
        /^GB[0-9]{12}$/.test(value) /* Branches */ ||
        /^GBGD[0-9]{3}$/.test(value) /* Government department */ ||
        /^GBHA[0-9]{3}$/.test(value) /* Health authority */ ||
        /^GB(GD|HA)8888[0-9]{5}$/.test(value)
      ) {
        value = value.substr(2);
      }
      if (
        !/^[0-9]{9}$/.test(value) &&
        !/^[0-9]{12}$/.test(value) &&
        !/^GD[0-9]{3}$/.test(value) &&
        !/^HA[0-9]{3}$/.test(value) &&
        !/^(GD|HA)8888[0-9]{5}$/.test(value)
      ) {
        return false;
      }

      var length = value.length;
      if (length === 5) {
        var firstTwo = value.substr(0, 2),
          lastThree = parseInt(value.substr(2), 10);
        return (
          ("GD" === firstTwo && lastThree < 500) ||
          ("HA" === firstTwo && lastThree >= 500)
        );
      } else if (
        length === 11 &&
        ("GD8888" === value.substr(0, 6) || "HA8888" === value.substr(0, 6))
      ) {
        if (
          ("GD" === value.substr(0, 2) &&
            parseInt(value.substr(6, 3), 10) >= 500) ||
          ("HA" === value.substr(0, 2) &&
            parseInt(value.substr(6, 3), 10) < 500)
        ) {
          return false;
        }
        return (
          parseInt(value.substr(6, 3), 10) % 97 ===
          parseInt(value.substr(9, 2), 10)
        );
      } else if (length === 9 || length === 12) {
        var sum = 0,
          weight = [8, 7, 6, 5, 4, 3, 2, 10, 1];
        for (var i = 0; i < 9; i++) {
          sum += parseInt(value.charAt(i), 10) * weight[i];
        }
        sum = sum % 97;

        if (parseInt(value.substr(0, 3), 10) >= 100) {
          return sum === 0 || sum === 42 || sum === 55;
        } else {
          return sum === 0;
        }
      }

      return true;
    },

    /**
     * Validate Greek VAT number
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _gr: function (value) {
      if (/^(GR|EL)[0-9]{9}$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^[0-9]{9}$/.test(value)) {
        return false;
      }

      if (value.length === 8) {
        value = "0" + value;
      }

      var sum = 0,
        weight = [256, 128, 64, 32, 16, 8, 4, 2];
      for (var i = 0; i < 8; i++) {
        sum += parseInt(value.charAt(i), 10) * weight[i];
      }
      sum = (sum % 11) % 10;

      return sum + "" === value.substr(8, 1);
    },

    // EL is traditionally prefix of Greek VAT numbers
    _el: function (value) {
      return this._gr(value);
    },

    /**
     * Validate Hungarian VAT number
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _hu: function (value) {
      if (/^HU[0-9]{8}$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^[0-9]{8}$/.test(value)) {
        return false;
      }

      var sum = 0,
        weight = [9, 7, 3, 1, 9, 7, 3, 1];

      for (var i = 0; i < 8; i++) {
        sum += parseInt(value.charAt(i), 10) * weight[i];
      }

      return sum % 10 === 0;
    },

    /**
     * Validate Croatian VAT number
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _hr: function (value) {
      if (/^HR[0-9]{11}$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^[0-9]{11}$/.test(value)) {
        return false;
      }

      return FormValidation.Helper.mod11And10(value);
    },

    /**
     * Validate Irish VAT number
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _ie: function (value) {
      if (/^IE[0-9]{1}[0-9A-Z\*\+]{1}[0-9]{5}[A-Z]{1,2}$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^[0-9]{1}[0-9A-Z\*\+]{1}[0-9]{5}[A-Z]{1,2}$/.test(value)) {
        return false;
      }

      var getCheckDigit = function (value) {
        while (value.length < 7) {
          value = "0" + value;
        }
        var alphabet = "WABCDEFGHIJKLMNOPQRSTUV",
          sum = 0;
        for (var i = 0; i < 7; i++) {
          sum += parseInt(value.charAt(i), 10) * (8 - i);
        }
        sum += 9 * alphabet.indexOf(value.substr(7));
        return alphabet[sum % 23];
      };

      // The first 7 characters are digits
      if (/^[0-9]+$/.test(value.substr(0, 7))) {
        // New system
        return (
          value.charAt(7) ===
          getCheckDigit(value.substr(0, 7) + value.substr(8) + "")
        );
      } else if (
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ+*".indexOf(value.charAt(1)) !== -1
      ) {
        // Old system
        return (
          value.charAt(7) ===
          getCheckDigit(value.substr(2, 5) + value.substr(0, 1) + "")
        );
      }

      return true;
    },

    /**
     * Validate Icelandic VAT (VSK) number
     *
     * @params {String} value VAT number
     * @returns {Boolean}
     */
    _is: function (value) {
      if (/^IS[0-9]{5,6}$/.test(value)) {
        value = value.substr(2);
      }
      return /^[0-9]{5,6}$/.test(value);
    },

    /**
     * Validate Italian VAT number, which consists of 11 digits.
     * - First 7 digits are a company identifier
     * - Next 3 are the province of residence
     * - The last one is a check digit
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _it: function (value) {
      if (/^IT[0-9]{11}$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^[0-9]{11}$/.test(value)) {
        return false;
      }

      if (parseInt(value.substr(0, 7), 10) === 0) {
        return false;
      }

      var lastThree = parseInt(value.substr(7, 3), 10);
      if (
        lastThree < 1 ||
        (lastThree > 201 && lastThree !== 999 && lastThree !== 888)
      ) {
        return false;
      }

      return FormValidation.Helper.luhn(value);
    },

    /**
     * Validate Lithuanian VAT number
     * It can be:
     * - 9 digits, for legal entities
     * - 12 digits, for temporarily registered taxpayers
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _lt: function (value) {
      if (/^LT([0-9]{7}1[0-9]{1}|[0-9]{10}1[0-9]{1})$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^([0-9]{7}1[0-9]{1}|[0-9]{10}1[0-9]{1})$/.test(value)) {
        return false;
      }

      var length = value.length,
        sum = 0,
        i;
      for (i = 0; i < length - 1; i++) {
        sum += parseInt(value.charAt(i), 10) * (1 + (i % 9));
      }
      var check = sum % 11;
      if (check === 10) {
        sum = 0;
        for (i = 0; i < length - 1; i++) {
          sum += parseInt(value.charAt(i), 10) * (1 + ((i + 2) % 9));
        }
      }
      check = (check % 11) % 10;
      return check + "" === value.charAt(length - 1);
    },

    /**
     * Validate Luxembourg VAT number
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _lu: function (value) {
      if (/^LU[0-9]{8}$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^[0-9]{8}$/.test(value)) {
        return false;
      }

      return (
        (parseInt(value.substr(0, 6), 10) % 89) + "" === value.substr(6, 2)
      );
    },

    /**
     * Validate Latvian VAT number
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _lv: function (value) {
      if (/^LV[0-9]{11}$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^[0-9]{11}$/.test(value)) {
        return false;
      }

      var first = parseInt(value.charAt(0), 10),
        sum = 0,
        weight = [],
        i,
        length = value.length;
      if (first > 3) {
        // Legal entity
        sum = 0;
        weight = [9, 1, 4, 8, 3, 10, 2, 5, 7, 6, 1];
        for (i = 0; i < length; i++) {
          sum += parseInt(value.charAt(i), 10) * weight[i];
        }
        sum = sum % 11;
        return sum === 3;
      } else {
        // Check birth date
        var day = parseInt(value.substr(0, 2), 10),
          month = parseInt(value.substr(2, 2), 10),
          year = parseInt(value.substr(4, 2), 10);
        year = year + 1800 + parseInt(value.charAt(6), 10) * 100;

        if (!FormValidation.Helper.date(year, month, day)) {
          return false;
        }

        // Check personal code
        sum = 0;
        weight = [10, 5, 8, 4, 2, 1, 6, 3, 7, 9];
        for (i = 0; i < length - 1; i++) {
          sum += parseInt(value.charAt(i), 10) * weight[i];
        }
        sum = ((sum + 1) % 11) % 10;
        return sum + "" === value.charAt(length - 1);
      }
    },

    /**
     * Validate Maltese VAT number
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _mt: function (value) {
      if (/^MT[0-9]{8}$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^[0-9]{8}$/.test(value)) {
        return false;
      }

      var sum = 0,
        weight = [3, 4, 6, 7, 8, 9, 10, 1];

      for (var i = 0; i < 8; i++) {
        sum += parseInt(value.charAt(i), 10) * weight[i];
      }

      return sum % 37 === 0;
    },

    /**
     * Validate Dutch VAT number
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _nl: function (value) {
      if (/^NL[0-9]{9}B[0-9]{2}$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^[0-9]{9}B[0-9]{2}$/.test(value)) {
        return false;
      }

      var sum = 0,
        weight = [9, 8, 7, 6, 5, 4, 3, 2];
      for (var i = 0; i < 8; i++) {
        sum += parseInt(value.charAt(i), 10) * weight[i];
      }

      sum = sum % 11;
      if (sum > 9) {
        sum = 0;
      }
      return sum + "" === value.substr(8, 1);
    },

    /**
     * Validate Norwegian VAT number
     *
     * @see http://www.brreg.no/english/coordination/number.html
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _no: function (value) {
      if (/^NO[0-9]{9}$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^[0-9]{9}$/.test(value)) {
        return false;
      }

      var sum = 0,
        weight = [3, 2, 7, 6, 5, 4, 3, 2];
      for (var i = 0; i < 8; i++) {
        sum += parseInt(value.charAt(i), 10) * weight[i];
      }

      sum = 11 - (sum % 11);
      if (sum === 11) {
        sum = 0;
      }
      return sum + "" === value.substr(8, 1);
    },

    /**
     * Validate Polish VAT number
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _pl: function (value) {
      if (/^PL[0-9]{10}$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^[0-9]{10}$/.test(value)) {
        return false;
      }

      var sum = 0,
        weight = [6, 5, 7, 2, 3, 4, 5, 6, 7, -1];

      for (var i = 0; i < 10; i++) {
        sum += parseInt(value.charAt(i), 10) * weight[i];
      }

      return sum % 11 === 0;
    },

    /**
     * Validate Portuguese VAT number
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _pt: function (value) {
      if (/^PT[0-9]{9}$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^[0-9]{9}$/.test(value)) {
        return false;
      }

      var sum = 0,
        weight = [9, 8, 7, 6, 5, 4, 3, 2];

      for (var i = 0; i < 8; i++) {
        sum += parseInt(value.charAt(i), 10) * weight[i];
      }
      sum = 11 - (sum % 11);
      if (sum > 9) {
        sum = 0;
      }
      return sum + "" === value.substr(8, 1);
    },

    /**
     * Validate Romanian VAT number
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _ro: function (value) {
      if (/^RO[1-9][0-9]{1,9}$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^[1-9][0-9]{1,9}$/.test(value)) {
        return false;
      }

      var length = value.length,
        weight = [7, 5, 3, 2, 1, 7, 5, 3, 2].slice(10 - length),
        sum = 0;
      for (var i = 0; i < length - 1; i++) {
        sum += parseInt(value.charAt(i), 10) * weight[i];
      }

      sum = ((10 * sum) % 11) % 10;
      return sum + "" === value.substr(length - 1, 1);
    },

    /**
     * Validate Russian VAT number (Taxpayer Identification Number - INN)
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _ru: function (value) {
      if (/^RU([0-9]{10}|[0-9]{12})$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^([0-9]{10}|[0-9]{12})$/.test(value)) {
        return false;
      }

      var i = 0;
      if (value.length === 10) {
        var sum = 0,
          weight = [2, 4, 10, 3, 5, 9, 4, 6, 8, 0];
        for (i = 0; i < 10; i++) {
          sum += parseInt(value.charAt(i), 10) * weight[i];
        }
        sum = sum % 11;
        if (sum > 9) {
          sum = sum % 10;
        }

        return sum + "" === value.substr(9, 1);
      } else if (value.length === 12) {
        var sum1 = 0,
          weight1 = [7, 2, 4, 10, 3, 5, 9, 4, 6, 8, 0],
          sum2 = 0,
          weight2 = [3, 7, 2, 4, 10, 3, 5, 9, 4, 6, 8, 0];

        for (i = 0; i < 11; i++) {
          sum1 += parseInt(value.charAt(i), 10) * weight1[i];
          sum2 += parseInt(value.charAt(i), 10) * weight2[i];
        }
        sum1 = sum1 % 11;
        if (sum1 > 9) {
          sum1 = sum1 % 10;
        }
        sum2 = sum2 % 11;
        if (sum2 > 9) {
          sum2 = sum2 % 10;
        }

        return (
          sum1 + "" === value.substr(10, 1) && sum2 + "" === value.substr(11, 1)
        );
      }

      return false;
    },

    /**
     * Validate Serbian VAT number
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _rs: function (value) {
      if (/^RS[0-9]{9}$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^[0-9]{9}$/.test(value)) {
        return false;
      }

      var sum = 10,
        temp = 0;
      for (var i = 0; i < 8; i++) {
        temp = (parseInt(value.charAt(i), 10) + sum) % 10;
        if (temp === 0) {
          temp = 10;
        }
        sum = (2 * temp) % 11;
      }

      return (sum + parseInt(value.substr(8, 1), 10)) % 10 === 1;
    },

    /**
     * Validate Swedish VAT number
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _se: function (value) {
      if (/^SE[0-9]{10}01$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^[0-9]{10}01$/.test(value)) {
        return false;
      }

      value = value.substr(0, 10);
      return FormValidation.Helper.luhn(value);
    },

    /**
     * Validate Slovenian VAT number
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _si: function (value) {
      // The Slovenian VAT numbers don't start with zero
      var res = value.match(/^(SI)?([1-9][0-9]{7})$/);
      if (!res) {
        return false;
      }
      if (res[1]) {
        value = value.substr(2);
      }

      var sum = 0,
        weight = [8, 7, 6, 5, 4, 3, 2];

      for (var i = 0; i < 7; i++) {
        sum += parseInt(value.charAt(i), 10) * weight[i];
      }
      sum = 11 - (sum % 11);
      if (sum === 10) {
        sum = 0;
      }
      return sum + "" === value.substr(7, 1);
    },

    /**
     * Validate Slovak VAT number
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _sk: function (value) {
      if (/^SK[1-9][0-9][(2-4)|(6-9)][0-9]{7}$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^[1-9][0-9][(2-4)|(6-9)][0-9]{7}$/.test(value)) {
        return false;
      }

      return parseInt(value, 10) % 11 === 0;
    },

    /**
     * Validate Venezuelan VAT number (RIF)
     *
     * @param {String} value VAT number
     * @returns {Boolean}
     */
    _ve: function (value) {
      if (/^VE[VEJPG][0-9]{9}$/.test(value)) {
        value = value.substr(2);
      }
      if (!/^[VEJPG][0-9]{9}$/.test(value)) {
        return false;
      }

      var types = {
          V: 4,
          E: 8,
          J: 12,
          P: 16,
          G: 20,
        },
        sum = types[value.charAt(0)],
        weight = [3, 2, 7, 6, 5, 4, 3, 2];

      for (var i = 0; i < 8; i++) {
        sum += parseInt(value.charAt(i + 1), 10) * weight[i];
      }

      sum = 11 - (sum % 11);
      if (sum === 11 || sum === 10) {
        sum = 0;
      }
      return sum + "" === value.substr(9, 1);
    },

    /**
     * Validate South African VAT number
     *
     * @params {String} value VAT number
     * @returns {Boolean}
     */
    _za: function (value) {
      if (/^ZA4[0-9]{9}$/.test(value)) {
        value = value.substr(2);
      }

      return /^4[0-9]{9}$/.test(value);
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      vin: {
        default: "Please enter a valid VIN number",
      },
    },
  });

  FormValidation.Validator.vin = {
    /**
     * Validate an US VIN (Vehicle Identification Number)
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Consist of key:
     * - message: The invalid message
     * @returns {Boolean}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "") {
        return true;
      }

      // Don't accept I, O, Q characters
      if (!/^[a-hj-npr-z0-9]{8}[0-9xX][a-hj-npr-z0-9]{8}$/i.test(value)) {
        return false;
      }

      value = value.toUpperCase();
      var chars = {
          A: 1,
          B: 2,
          C: 3,
          D: 4,
          E: 5,
          F: 6,
          G: 7,
          H: 8,
          J: 1,
          K: 2,
          L: 3,
          M: 4,
          N: 5,
          P: 7,
          R: 9,
          S: 2,
          T: 3,
          U: 4,
          V: 5,
          W: 6,
          X: 7,
          Y: 8,
          Z: 9,
          1: 1,
          2: 2,
          3: 3,
          4: 4,
          5: 5,
          6: 6,
          7: 7,
          8: 8,
          9: 9,
          0: 0,
        },
        weights = [8, 7, 6, 5, 4, 3, 2, 10, 0, 9, 8, 7, 6, 5, 4, 3, 2],
        sum = 0,
        length = value.length;
      for (var i = 0; i < length; i++) {
        sum += chars[value.charAt(i) + ""] * weights[i];
      }

      var reminder = sum % 11;
      if (reminder === 10) {
        reminder = "X";
      }

      return reminder + "" === value.charAt(8);
    },
  };
})(jQuery);
(function ($) {
  FormValidation.I18n = $.extend(true, FormValidation.I18n || {}, {
    en_US: {
      zipCode: {
        default: "Please enter a valid postal code",
        country: "Please enter a valid postal code in %s",
        countries: {
          AT: "Austria",
          BG: "Bulgaria",
          BR: "Brazil",
          CA: "Canada",
          CH: "Switzerland",
          CZ: "Czech Republic",
          DE: "Germany",
          DK: "Denmark",
          ES: "Spain",
          FR: "France",
          GB: "United Kingdom",
          IE: "Ireland",
          IN: "India",
          IT: "Italy",
          MA: "Morocco",
          NL: "Netherlands",
          PL: "Poland",
          PT: "Portugal",
          RO: "Romania",
          RU: "Russia",
          SE: "Sweden",
          SG: "Singapore",
          SK: "Slovakia",
          US: "USA",
        },
      },
    },
  });

  FormValidation.Validator.zipCode = {
    html5Attributes: {
      message: "message",
      country: "country",
    },

    COUNTRY_CODES: [
      "AT",
      "BG",
      "BR",
      "CA",
      "CH",
      "CZ",
      "DE",
      "DK",
      "ES",
      "FR",
      "GB",
      "IE",
      "IN",
      "IT",
      "MA",
      "NL",
      "PL",
      "PT",
      "RO",
      "RU",
      "SE",
      "SG",
      "SK",
      "US",
    ],

    /**
     * Return true if and only if the input value is a valid country zip code
     *
     * @param {FormValidation.Base} validator The validator plugin instance
     * @param {jQuery} $field Field element
     * @param {Object} options Consist of key:
     * - message: The invalid message
     * - country: The country
     *
     * The country can be defined by:
     * - An ISO 3166 country code
     * - Name of field which its value defines the country code
     * - Name of callback function that returns the country code
     * - A callback function that returns the country code
     *
     *  callback: function(value, validator, $field) {
     *      // value is the value of field
     *      // validator is the FormValidation.Base instance
     *      // $field is jQuery element representing the field
     *  }
     *
     * @returns {Boolean|Object}
     */
    validate: function (validator, $field, options, validatorName) {
      var value = validator.getFieldValue($field, validatorName);
      if (value === "" || !options.country) {
        return true;
      }

      var locale = validator.getLocale(),
        country = options.country;
      if (
        typeof country !== "string" ||
        $.inArray(country, this.COUNTRY_CODES) === -1
      ) {
        // Try to determine the country
        country = validator.getDynamicOption($field, country);
      }

      if (
        !country ||
        $.inArray(country.toUpperCase(), this.COUNTRY_CODES) === -1
      ) {
        return true;
      }

      var isValid = false;
      country = country.toUpperCase();
      switch (country) {
        // http://en.wikipedia.org/wiki/List_of_postal_codes_in_Austria
        case "AT":
          isValid = /^([1-9]{1})(\d{3})$/.test(value);
          break;

        case "BG":
          isValid = /^([1-9]{1}[0-9]{3})$/.test($.trim(value));
          break;

        case "BR":
          isValid = /^(\d{2})([\.]?)(\d{3})([\-]?)(\d{3})$/.test(value);
          break;

        case "CA":
          isValid =
            /^(?:A|B|C|E|G|H|J|K|L|M|N|P|R|S|T|V|X|Y){1}[0-9]{1}(?:A|B|C|E|G|H|J|K|L|M|N|P|R|S|T|V|W|X|Y|Z){1}\s?[0-9]{1}(?:A|B|C|E|G|H|J|K|L|M|N|P|R|S|T|V|W|X|Y|Z){1}[0-9]{1}$/i.test(
              value
            );
          break;

        case "CH":
          isValid = /^([1-9]{1})(\d{3})$/.test(value);
          break;

        case "CZ":
          // Test: http://regexr.com/39hhr
          isValid = /^(\d{3})([ ]?)(\d{2})$/.test(value);
          break;

        // http://stackoverflow.com/questions/7926687/regular-expression-german-zip-codes
        case "DE":
          isValid = /^(?!01000|99999)(0[1-9]\d{3}|[1-9]\d{4})$/.test(value);
          break;

        case "DK":
          isValid = /^(DK(-|\s)?)?\d{4}$/i.test(value);
          break;

        // Zip codes in Spain go from 01XXX to 52XXX.
        // Test: http://refiddle.com/1ufo
        case "ES":
          isValid = /^(?:0[1-9]|[1-4][0-9]|5[0-2])\d{3}$/.test(value);
          break;

        // http://en.wikipedia.org/wiki/Postal_codes_in_France
        case "FR":
          isValid = /^[0-9]{5}$/i.test(value);
          break;

        case "GB":
          isValid = this._gb(value);
          break;

        // Indian PIN (Postal Index Number) validation
        // http://en.wikipedia.org/wiki/Postal_Index_Number
        // Test: http://regex101.com/r/kV0vH3/1
        case "IN":
          isValid = /^\d{3}\s?\d{3}$/.test(value);
          break;

        // http://www.eircode.ie/docs/default-source/Common/prepare-your-business-for-eircode---published-v2.pdf?sfvrsn=2
        // Test: http://refiddle.com/1kpl
        case "IE":
          isValid =
            /^(D6W|[ACDEFHKNPRTVWXY]\d{2})\s[0-9ACDEFHKNPRTVWXY]{4}$/.test(
              value
            );
          break;

        // http://en.wikipedia.org/wiki/List_of_postal_codes_in_Italy
        case "IT":
          isValid = /^(I-|IT-)?\d{5}$/i.test(value);
          break;

        // http://en.wikipedia.org/wiki/List_of_postal_codes_in_Morocco
        case "MA":
          isValid = /^[1-9][0-9]{4}$/i.test(value);
          break;

        // http://en.wikipedia.org/wiki/Postal_codes_in_the_Netherlands
        case "NL":
          isValid = /^[1-9][0-9]{3} ?(?!sa|sd|ss)[a-z]{2}$/i.test(value);
          break;

        // http://en.wikipedia.org/wiki/List_of_postal_codes_in_Poland
        case "PL":
          isValid = /^[0-9]{2}\-[0-9]{3}$/.test(value);
          break;

        // Test: http://refiddle.com/1l2t
        case "PT":
          isValid = /^[1-9]\d{3}-\d{3}$/.test(value);
          break;

        case "RO":
          isValid = /^(0[1-8]{1}|[1-9]{1}[0-5]{1})?[0-9]{4}$/i.test(value);
          break;

        case "RU":
          isValid = /^[0-9]{6}$/i.test(value);
          break;

        case "SE":
          isValid = /^(S-)?\d{3}\s?\d{2}$/i.test(value);
          break;

        case "SG":
          isValid =
            /^([0][1-9]|[1-6][0-9]|[7]([0-3]|[5-9])|[8][0-2])(\d{4})$/i.test(
              value
            );
          break;

        case "SK":
          // Test: http://regexr.com/39hhr
          isValid = /^(\d{3})([ ]?)(\d{2})$/.test(value);
          break;

        case "US":
        /* falls through */
        default:
          isValid = /^\d{4,5}([\-]?\d{4})?$/.test(value);
          break;
      }

      return {
        valid: isValid,
        message: FormValidation.Helper.format(
          options.message || FormValidation.I18n[locale].zipCode.country,
          FormValidation.I18n[locale].zipCode.countries[country]
        ),
      };
    },

    /**
     * Validate United Kingdom postcode
     *
     * @see http://en.wikipedia.org/wiki/Postcodes_in_the_United_Kingdom
     * @param {String} value The postcode
     * @returns {Boolean}
     */
    _gb: function (value) {
      var firstChar = "[ABCDEFGHIJKLMNOPRSTUWYZ]", // Does not accept QVX
        secondChar = "[ABCDEFGHKLMNOPQRSTUVWXY]", // Does not accept IJZ
        thirdChar = "[ABCDEFGHJKPMNRSTUVWXY]",
        fourthChar = "[ABEHMNPRVWXY]",
        fifthChar = "[ABDEFGHJLNPQRSTUWXYZ]",
        regexps = [
          // AN NAA, ANN NAA, AAN NAA, AANN NAA format
          new RegExp(
            "^(" +
              firstChar +
              "{1}" +
              secondChar +
              "?[0-9]{1,2})(\\s*)([0-9]{1}" +
              fifthChar +
              "{2})$",
            "i"
          ),
          // ANA NAA
          new RegExp(
            "^(" +
              firstChar +
              "{1}[0-9]{1}" +
              thirdChar +
              "{1})(\\s*)([0-9]{1}" +
              fifthChar +
              "{2})$",
            "i"
          ),
          // AANA NAA
          new RegExp(
            "^(" +
              firstChar +
              "{1}" +
              secondChar +
              "{1}?[0-9]{1}" +
              fourthChar +
              "{1})(\\s*)([0-9]{1}" +
              fifthChar +
              "{2})$",
            "i"
          ),

          new RegExp(
            "^(BF1)(\\s*)([0-6]{1}[ABDEFGHJLNPQRST]{1}[ABDEFGHJLNPQRSTUWZYZ]{1})$",
            "i"
          ), // BFPO postcodes
          /^(GIR)(\s*)(0AA)$/i, // Special postcode GIR 0AA
          /^(BFPO)(\s*)([0-9]{1,4})$/i, // Standard BFPO numbers
          /^(BFPO)(\s*)(c\/o\s*[0-9]{1,3})$/i, // c/o BFPO numbers
          /^([A-Z]{4})(\s*)(1ZZ)$/i, // Overseas Territories
          /^(AI-2640)$/i, // Anguilla
        ];
      for (var i = 0; i < regexps.length; i++) {
        if (regexps[i].test(value)) {
          return true;
        }
      }

      return false;
    },
  };
})(jQuery);

/**
 * FormValidation (http://formvalidation.io)
 * The best jQuery plugin to validate form fields. Support Bootstrap, Foundation, Pure, SemanticUI, UIKit and custom frameworks
 *
 * @author      https://twitter.com/formvalidation
 * @copyright   (c) 2013 - 2016 Nguyen Huu Phuoc
 * @license     http://formvalidation.io/license/
 */

/**
 * This class supports validating Bootstrap form (http://getbootstrap.com/)
 */
(function ($) {
  FormValidation.Framework.Bootstrap = function (element, options, namespace) {
    options = $.extend(
      true,
      {
        button: {
          selector: '[type="submit"]:not([formnovalidate])',
          // The class of disabled button
          // http://getbootstrap.com/css/#buttons-disabled
          disabled: "disabled",
        },
        err: {
          // http://getbootstrap.com/css/#forms-help-text
          clazz: "help-block",
          parent: "^(.*)col-(xs|sm|md|lg)-(offset-){0,1}[0-9]+(.*)$",
        },
        // This feature requires Bootstrap v3.1.0 or later (http://getbootstrap.com/css/#forms-control-validation).
        // Since Bootstrap doesn't provide any methods to know its version, this option cannot be on/off automatically.
        // In other word, to use this feature you have to upgrade your Bootstrap to v3.1.0 or later.
        //
        // Examples:
        // - Use Glyphicons icons:
        //  icon: {
        //      valid: 'glyphicon glyphicon-ok',
        //      invalid: 'glyphicon glyphicon-remove',
        //      validating: 'glyphicon glyphicon-refresh',
        //      feedback: 'form-control-feedback'
        //  }
        // - Use FontAwesome icons:
        //  icon: {
        //      valid: 'fa fa-check',
        //      invalid: 'fa fa-times',
        //      validating: 'fa fa-refresh',
        //      feedback: 'form-control-feedback'
        //  }
        icon: {
          valid: null,
          invalid: null,
          validating: null,
          feedback: "form-control-feedback",
        },
        row: {
          // By default, each field is placed inside the <div class="form-group"></div>
          // http://getbootstrap.com/css/#forms
          selector: ".form-group",
          valid: "has-success",
          invalid: "has-error",
          feedback: "has-feedback",
        },
      },
      options
    );

    FormValidation.Base.apply(this, [element, options, namespace]);
  };

  FormValidation.Framework.Bootstrap.prototype = $.extend(
    {},
    FormValidation.Base.prototype,
    {
      /**
       * Specific framework might need to adjust the icon position
       *
       * @param {jQuery} $field The field element
       * @param {jQuery} $icon The icon element
       */
      _fixIcon: function ($field, $icon) {
        var ns = this._namespace,
          type = $field.attr("type"),
          field = $field.attr("data-" + ns + "-field"),
          row = this.options.fields[field].row || this.options.row.selector,
          $parent = $field.closest(row);

        // Place it after the container of checkbox/radio
        // so when clicking the icon, it doesn't effect to the checkbox/radio element
        if ("checkbox" === type || "radio" === type) {
          var $fieldParent = $field.parent();
          if ($fieldParent.hasClass(type)) {
            $icon.insertAfter($fieldParent);
          } else if ($fieldParent.parent().hasClass(type)) {
            $icon.insertAfter($fieldParent.parent());
          }
        }

        // Fix feedback icons in input-group
        if ($parent.find(".input-group").length !== 0) {
          $icon
            .addClass("fv-bootstrap-icon-input-group")
            .insertAfter($parent.find(".input-group").eq(0));
        }
      },

      /**
       * Create a tooltip or popover
       * It will be shown when focusing on the field
       *
       * @param {jQuery} $field The field element
       * @param {String} message The message
       * @param {String} type Can be 'tooltip' or 'popover'
       */
      _createTooltip: function ($field, message, type) {
        var ns = this._namespace,
          $icon = $field.data(ns + ".icon");
        if ($icon) {
          switch (type) {
            case "popover":
              $icon
                .css({
                  cursor: "pointer",
                  "pointer-events": "auto",
                })
                .popover("destroy")
                .popover({
                  container: "body",
                  content: message,
                  html: true,
                  placement: "auto top",
                  trigger: "hover click",
                });
              break;

            case "tooltip":
            /* falls through */
            default:
              $icon
                .css({
                  cursor: "pointer",
                  "pointer-events": "auto",
                })
                .tooltip("destroy")
                .tooltip({
                  container: "body",
                  html: true,
                  placement: "auto top",
                  title: message,
                });
              break;
          }
        }
      },

      /**
       * Destroy the tooltip or popover
       *
       * @param {jQuery} $field The field element
       * @param {String} type Can be 'tooltip' or 'popover'
       */
      _destroyTooltip: function ($field, type) {
        var ns = this._namespace,
          $icon = $field.data(ns + ".icon");
        if ($icon) {
          switch (type) {
            case "popover":
              $icon
                .css({
                  cursor: "",
                  "pointer-events": "none",
                })
                .popover("destroy");
              break;

            case "tooltip":
            /* falls through */
            default:
              $icon
                .css({
                  cursor: "",
                  "pointer-events": "none",
                })
                .tooltip("destroy");
              break;
          }
        }
      },

      /**
       * Hide a tooltip or popover
       *
       * @param {jQuery} $field The field element
       * @param {String} type Can be 'tooltip' or 'popover'
       */
      _hideTooltip: function ($field, type) {
        var ns = this._namespace,
          $icon = $field.data(ns + ".icon");
        if ($icon) {
          switch (type) {
            case "popover":
              $icon.popover("hide");
              break;

            case "tooltip":
            /* falls through */
            default:
              $icon.tooltip("hide");
              break;
          }
        }
      },

      /**
       * Show a tooltip or popover
       *
       * @param {jQuery} $field The field element
       * @param {String} type Can be 'tooltip' or 'popover'
       */
      _showTooltip: function ($field, type) {
        var ns = this._namespace,
          $icon = $field.data(ns + ".icon");
        if ($icon) {
          switch (type) {
            case "popover":
              $icon.popover("show");
              break;

            case "tooltip":
            /* falls through */
            default:
              $icon.tooltip("show");
              break;
          }
        }
      },
    }
  );

  /**
   * Plugin definition
   * Support backward
   * @deprecated It will be removed soon. Instead of using $(form).bootstrapValidator(), use
   *  $(form).formValidation({
   *      framework: 'bootstrap'  // It's equivalent to use data-fv-framework="bootstrap" for <form>
   *  });
   */
  $.fn.bootstrapValidator = function (option) {
    var params = arguments;
    return this.each(function () {
      var $this = $(this),
        data = $this.data("formValidation") || $this.data("bootstrapValidator"),
        options = "object" === typeof option && option;
      if (!data) {
        data = new FormValidation.Framework.Bootstrap(
          this,
          $.extend(
            {},
            {
              events: {
                // Support backward
                formInit: "init.form.bv",
                formPreValidate: "prevalidate.form.bv",
                formError: "error.form.bv",
                formSuccess: "success.form.bv",
                fieldAdded: "added.field.bv",
                fieldRemoved: "removed.field.bv",
                fieldInit: "init.field.bv",
                fieldError: "error.field.bv",
                fieldSuccess: "success.field.bv",
                fieldStatus: "status.field.bv",
                localeChanged: "changed.locale.bv",
                validatorError: "error.validator.bv",
                validatorSuccess: "success.validator.bv",
              },
            },
            options
          ),
          "bv"
        );

        $this
          .addClass("fv-form-bootstrap")
          .data("formValidation", data)
          .data("bootstrapValidator", data);
      }

      // Allow to call plugin method
      if ("string" === typeof option) {
        data[option].apply(data, Array.prototype.slice.call(params, 1));
      }
    });
  };

  $.fn.bootstrapValidator.Constructor = FormValidation.Framework.Bootstrap;
})(jQuery);

/**
 * jQuery Browser Plugin
 * -------------------------------
 * A jQuery plugin for browser detection. jQuery removed support for browser detection on 1.9.1 so it was abstracted into a jQuery plugin
 * https://github.com/gabceb/jquery-browser-plugin
 */

(function (jQuery, window, undefined) {
  "use strict";

  var matched, browser;

  jQuery.uaMatch = function (ua) {
    ua = ua.toLowerCase();

    var match =
      /(chrome)[ \/]([\w.]+)/.exec(ua) ||
      /(webkit)[ \/]([\w.]+)/.exec(ua) ||
      /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
      /(msie) ([\w.]+)/.exec(ua) ||
      (ua.indexOf("compatible") < 0 &&
        /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua)) ||
      [];

    var platform_match =
      /(ipad)/.exec(ua) || /(iphone)/.exec(ua) || /(android)/.exec(ua) || [];

    return {
      browser: match[1] || "",
      version: match[2] || "0",
      platform: platform_match[0] || "",
    };
  };

  matched = jQuery.uaMatch(window.navigator.userAgent);
  browser = {};

  if (matched.browser) {
    browser[matched.browser] = true;
    browser.version = matched.version;
  }

  if (matched.platform) {
    browser[matched.platform] = true;
  }

  // Chrome is Webkit, but Webkit is also Safari.
  if (browser.chrome) {
    browser.webkit = true;
  } else if (browser.webkit) {
    browser.safari = true;
  }

  jQuery.browser = browser;
})(jQuery, window);
/*
     _ _      _       _
 ___| (_) ___| | __  (_)___
/ __| | |/ __| |/ /  | / __|
\__ \ | | (__|   < _ | \__ \
|___/_|_|\___|_|\_(_)/ |___/
                   |__/

 Version: 1.8.0
  Author: Ken Wheeler
 Website: http://kenwheeler.github.io
    Docs: http://kenwheeler.github.io/slick
    Repo: http://github.com/kenwheeler/slick
  Issues: http://github.com/kenwheeler/slick/issues

 */
/* global window, document, define, jQuery, setInterval, clearInterval */
(function (factory) {
  "use strict";
  // if (typeof define === 'function' && define.amd) {
  //     define(['jquery'], factory);
  // } else if (typeof exports !== 'undefined') {
  //     module.exports = factory(require('jquery'));
  // } else {
  factory(jQuery);
  // }
})(function ($) {
  "use strict";
  var Slick = window.Slick || {};

  Slick = (function () {
    var instanceUid = 0;

    function Slick(element, settings) {
      var _ = this,
        dataSettings;

      _.defaults = {
        accessibility: true,
        adaptiveHeight: false,
        appendArrows: $(element),
        appendDots: $(element),
        arrows: true,
        asNavFor: null,
        prevArrow:
          '<button class="slick-prev" aria-label="Previous" type="button">Previous</button>',
        nextArrow:
          '<button class="slick-next" aria-label="Next" type="button">Next</button>',
        autoplay: false,
        autoplaySpeed: 3000,
        centerMode: false,
        centerPadding: "50px",
        cssEase: "ease",
        customPaging: function (slider, i) {
          return $('<button type="button" />').text(i + 1);
        },
        dots: false,
        dotsClass: "slick-dots",
        draggable: true,
        easing: "linear",
        edgeFriction: 0.35,
        fade: false,
        focusOnSelect: false,
        focusOnChange: false,
        infinite: true,
        initialSlide: 0,
        lazyLoad: "ondemand",
        mobileFirst: false,
        pauseOnHover: true,
        pauseOnFocus: true,
        pauseOnDotsHover: false,
        respondTo: "window",
        responsive: null,
        rows: 1,
        rtl: false,
        slide: "",
        slidesPerRow: 1,
        slidesToShow: 1,
        slidesToScroll: 1,
        speed: 500,
        swipe: true,
        swipeToSlide: false,
        touchMove: true,
        touchThreshold: 5,
        useCSS: true,
        useTransform: true,
        variableWidth: false,
        vertical: false,
        verticalSwiping: false,
        waitForAnimate: true,
        zIndex: 1000,
      };

      _.initials = {
        animating: false,
        dragging: false,
        autoPlayTimer: null,
        currentDirection: 0,
        currentLeft: null,
        currentSlide: 0,
        direction: 1,
        $dots: null,
        listWidth: null,
        listHeight: null,
        loadIndex: 0,
        $nextArrow: null,
        $prevArrow: null,
        scrolling: false,
        slideCount: null,
        slideWidth: null,
        $slideTrack: null,
        $slides: null,
        sliding: false,
        slideOffset: 0,
        swipeLeft: null,
        swiping: false,
        $list: null,
        touchObject: {},
        transformsEnabled: false,
        unslicked: false,
      };

      $.extend(_, _.initials);

      _.activeBreakpoint = null;
      _.animType = null;
      _.animProp = null;
      _.breakpoints = [];
      _.breakpointSettings = [];
      _.cssTransitions = false;
      _.focussed = false;
      _.interrupted = false;
      _.hidden = "hidden";
      _.paused = true;
      _.positionProp = null;
      _.respondTo = null;
      _.rowCount = 1;
      _.shouldClick = true;
      _.$slider = $(element);
      _.$slidesCache = null;
      _.transformType = null;
      _.transitionType = null;
      _.visibilityChange = "visibilitychange";
      _.windowWidth = 0;
      _.windowTimer = null;

      dataSettings = $(element).data("slick") || {};

      _.options = $.extend({}, _.defaults, settings, dataSettings);

      _.currentSlide = _.options.initialSlide;

      _.originalSettings = _.options;

      if (typeof document.mozHidden !== "undefined") {
        _.hidden = "mozHidden";
        _.visibilityChange = "mozvisibilitychange";
      } else if (typeof document.webkitHidden !== "undefined") {
        _.hidden = "webkitHidden";
        _.visibilityChange = "webkitvisibilitychange";
      }

      _.autoPlay = $.proxy(_.autoPlay, _);
      _.autoPlayClear = $.proxy(_.autoPlayClear, _);
      _.autoPlayIterator = $.proxy(_.autoPlayIterator, _);
      _.changeSlide = $.proxy(_.changeSlide, _);
      _.clickHandler = $.proxy(_.clickHandler, _);
      _.selectHandler = $.proxy(_.selectHandler, _);
      _.setPosition = $.proxy(_.setPosition, _);
      _.swipeHandler = $.proxy(_.swipeHandler, _);
      _.dragHandler = $.proxy(_.dragHandler, _);
      _.keyHandler = $.proxy(_.keyHandler, _);

      _.instanceUid = instanceUid++;

      // A simple way to check for HTML strings
      // Strict HTML recognition (must start with <)
      // Extracted from jQuery v1.11 source
      _.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/;

      _.registerBreakpoints();
      _.init(true);
    }

    return Slick;
  })();

  Slick.prototype.activateADA = function () {
    var _ = this;

    _.$slideTrack
      .find(".slick-active")
      .attr({
        "aria-hidden": "false",
      })
      .find("a, input, button, select")
      .attr({
        tabindex: "0",
      });
  };

  Slick.prototype.addSlide = Slick.prototype.slickAdd = function (
    markup,
    index,
    addBefore
  ) {
    var _ = this;

    if (typeof index === "boolean") {
      addBefore = index;
      index = null;
    } else if (index < 0 || index >= _.slideCount) {
      return false;
    }

    _.unload();

    if (typeof index === "number") {
      if (index === 0 && _.$slides.length === 0) {
        $(markup).appendTo(_.$slideTrack);
      } else if (addBefore) {
        $(markup).insertBefore(_.$slides.eq(index));
      } else {
        $(markup).insertAfter(_.$slides.eq(index));
      }
    } else {
      if (addBefore === true) {
        $(markup).prependTo(_.$slideTrack);
      } else {
        $(markup).appendTo(_.$slideTrack);
      }
    }

    _.$slides = _.$slideTrack.children(this.options.slide);

    _.$slideTrack.children(this.options.slide).detach();

    _.$slideTrack.append(_.$slides);

    _.$slides.each(function (index, element) {
      $(element).attr("data-slick-index", index);
    });

    _.$slidesCache = _.$slides;

    _.reinit();
  };

  Slick.prototype.animateHeight = function () {
    var _ = this;
    if (
      _.options.slidesToShow === 1 &&
      _.options.adaptiveHeight === true &&
      _.options.vertical === false
    ) {
      var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
      _.$list.animate(
        {
          height: targetHeight,
        },
        _.options.speed
      );
    }
  };

  Slick.prototype.animateSlide = function (targetLeft, callback) {
    var animProps = {},
      _ = this;

    _.animateHeight();

    if (_.options.rtl === true && _.options.vertical === false) {
      targetLeft = -targetLeft;
    }
    if (_.transformsEnabled === false) {
      if (_.options.vertical === false) {
        _.$slideTrack.animate(
          {
            left: targetLeft,
          },
          _.options.speed,
          _.options.easing,
          callback
        );
      } else {
        _.$slideTrack.animate(
          {
            top: targetLeft,
          },
          _.options.speed,
          _.options.easing,
          callback
        );
      }
    } else {
      if (_.cssTransitions === false) {
        if (_.options.rtl === true) {
          _.currentLeft = -_.currentLeft;
        }
        $({
          animStart: _.currentLeft,
        }).animate(
          {
            animStart: targetLeft,
          },
          {
            duration: _.options.speed,
            easing: _.options.easing,
            step: function (now) {
              now = Math.ceil(now);
              if (_.options.vertical === false) {
                animProps[_.animType] = "translate(" + now + "px, 0px)";
                _.$slideTrack.css(animProps);
              } else {
                animProps[_.animType] = "translate(0px," + now + "px)";
                _.$slideTrack.css(animProps);
              }
            },
            complete: function () {
              if (callback) {
                callback.call();
              }
            },
          }
        );
      } else {
        _.applyTransition();
        targetLeft = Math.ceil(targetLeft);

        if (_.options.vertical === false) {
          animProps[_.animType] = "translate3d(" + targetLeft + "px, 0px, 0px)";
        } else {
          animProps[_.animType] = "translate3d(0px," + targetLeft + "px, 0px)";
        }
        _.$slideTrack.css(animProps);

        if (callback) {
          setTimeout(function () {
            _.disableTransition();

            callback.call();
          }, _.options.speed);
        }
      }
    }
  };

  Slick.prototype.getNavTarget = function () {
    var _ = this,
      asNavFor = _.options.asNavFor;

    if (asNavFor && asNavFor !== null) {
      asNavFor = $(asNavFor).not(_.$slider);
    }

    return asNavFor;
  };

  Slick.prototype.asNavFor = function (index) {
    var _ = this,
      asNavFor = _.getNavTarget();

    if (asNavFor !== null && typeof asNavFor === "object") {
      asNavFor.each(function () {
        var target = $(this).slick("getSlick");
        if (!target.unslicked) {
          target.slideHandler(index, true);
        }
      });
    }
  };

  Slick.prototype.applyTransition = function (slide) {
    var _ = this,
      transition = {};

    if (_.options.fade === false) {
      transition[_.transitionType] =
        _.transformType + " " + _.options.speed + "ms " + _.options.cssEase;
    } else {
      transition[_.transitionType] =
        "opacity " + _.options.speed + "ms " + _.options.cssEase;
    }

    if (_.options.fade === false) {
      _.$slideTrack.css(transition);
    } else {
      _.$slides.eq(slide).css(transition);
    }
  };

  Slick.prototype.autoPlay = function () {
    var _ = this;

    _.autoPlayClear();

    if (_.slideCount > _.options.slidesToShow) {
      _.autoPlayTimer = setInterval(
        _.autoPlayIterator,
        _.options.autoplaySpeed
      );
    }
  };

  Slick.prototype.autoPlayClear = function () {
    var _ = this;

    if (_.autoPlayTimer) {
      clearInterval(_.autoPlayTimer);
    }
  };

  Slick.prototype.autoPlayIterator = function () {
    var _ = this,
      slideTo = _.currentSlide + _.options.slidesToScroll;

    if (!_.paused && !_.interrupted && !_.focussed) {
      if (_.options.infinite === false) {
        if (_.direction === 1 && _.currentSlide + 1 === _.slideCount - 1) {
          _.direction = 0;
        } else if (_.direction === 0) {
          slideTo = _.currentSlide - _.options.slidesToScroll;

          if (_.currentSlide - 1 === 0) {
            _.direction = 1;
          }
        }
      }

      _.slideHandler(slideTo);
    }
  };

  Slick.prototype.buildArrows = function () {
    var _ = this;

    if (_.options.arrows === true) {
      _.$prevArrow = $(_.options.prevArrow).addClass("slick-arrow");
      _.$nextArrow = $(_.options.nextArrow).addClass("slick-arrow");

      if (_.slideCount > _.options.slidesToShow) {
        _.$prevArrow
          .removeClass("slick-hidden")
          .removeAttr("aria-hidden tabindex");
        _.$nextArrow
          .removeClass("slick-hidden")
          .removeAttr("aria-hidden tabindex");

        if (_.htmlExpr.test(_.options.prevArrow)) {
          _.$prevArrow.prependTo(_.options.appendArrows);
        }

        if (_.htmlExpr.test(_.options.nextArrow)) {
          _.$nextArrow.appendTo(_.options.appendArrows);
        }

        if (_.options.infinite !== true) {
          _.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true");
        }
      } else {
        _.$prevArrow
          .add(_.$nextArrow)

          .addClass("slick-hidden")
          .attr({
            "aria-disabled": "true",
            tabindex: "-1",
          });
      }
    }
  };

  Slick.prototype.buildDots = function () {
    var _ = this,
      i,
      dot;

    if (_.options.dots === true) {
      _.$slider.addClass("slick-dotted");

      dot = $("<ul />").addClass(_.options.dotsClass);

      for (i = 0; i <= _.getDotCount(); i += 1) {
        dot.append($("<li />").append(_.options.customPaging.call(this, _, i)));
      }

      _.$dots = dot.appendTo(_.options.appendDots);

      _.$dots.find("li").first().addClass("slick-active");
    }
  };

  Slick.prototype.buildOut = function () {
    var _ = this;

    _.$slides = _.$slider
      .children(_.options.slide + ":not(.slick-cloned)")
      .addClass("slick-slide");

    _.slideCount = _.$slides.length;

    _.$slides.each(function (index, element) {
      $(element)
        .attr("data-slick-index", index)
        .data("originalStyling", $(element).attr("style") || "");
    });

    _.$slider.addClass("slick-slider");

    _.$slideTrack =
      _.slideCount === 0
        ? $('<div class="slick-track"/>').appendTo(_.$slider)
        : _.$slides.wrapAll('<div class="slick-track"/>').parent();

    _.$list = _.$slideTrack.wrap('<div class="slick-list"/>').parent();
    _.$slideTrack.css("opacity", 0);

    if (_.options.centerMode === true || _.options.swipeToSlide === true) {
      _.options.slidesToScroll = 1;
    }

    $("img[data-lazy]", _.$slider).not("[src]").addClass("slick-loading");

    _.setupInfinite();

    _.buildArrows();

    _.buildDots();

    _.updateDots();

    _.setSlideClasses(typeof _.currentSlide === "number" ? _.currentSlide : 0);

    if (_.options.draggable === true) {
      _.$list.addClass("draggable");
    }
  };

  Slick.prototype.buildRows = function () {
    var _ = this,
      a,
      b,
      c,
      newSlides,
      numOfSlides,
      originalSlides,
      slidesPerSection;

    newSlides = document.createDocumentFragment();
    originalSlides = _.$slider.children();

    if (_.options.rows > 1) {
      slidesPerSection = _.options.slidesPerRow * _.options.rows;
      numOfSlides = Math.ceil(originalSlides.length / slidesPerSection);

      for (a = 0; a < numOfSlides; a++) {
        var slide = document.createElement("div");
        for (b = 0; b < _.options.rows; b++) {
          var row = document.createElement("div");
          for (c = 0; c < _.options.slidesPerRow; c++) {
            var target =
              a * slidesPerSection + (b * _.options.slidesPerRow + c);
            if (originalSlides.get(target)) {
              row.appendChild(originalSlides.get(target));
            }
          }
          slide.appendChild(row);
        }
        newSlides.appendChild(slide);
      }

      _.$slider.empty().append(newSlides);
      _.$slider
        .children()
        .children()
        .children()
        .css({
          width: 100 / _.options.slidesPerRow + "%",
          display: "inline-block",
        });
    }
  };

  Slick.prototype.checkResponsive = function (initial, forceUpdate) {
    var _ = this,
      breakpoint,
      targetBreakpoint,
      respondToWidth,
      triggerBreakpoint = false;
    var sliderWidth = _.$slider.width();
    var windowWidth = window.innerWidth || $(window).width();

    if (_.respondTo === "window") {
      respondToWidth = windowWidth;
    } else if (_.respondTo === "slider") {
      respondToWidth = sliderWidth;
    } else if (_.respondTo === "min") {
      respondToWidth = Math.min(windowWidth, sliderWidth);
    }

    if (
      _.options.responsive &&
      _.options.responsive.length &&
      _.options.responsive !== null
    ) {
      targetBreakpoint = null;

      for (breakpoint in _.breakpoints) {
        if (_.breakpoints.hasOwnProperty(breakpoint)) {
          if (_.originalSettings.mobileFirst === false) {
            if (respondToWidth < _.breakpoints[breakpoint]) {
              targetBreakpoint = _.breakpoints[breakpoint];
            }
          } else {
            if (respondToWidth > _.breakpoints[breakpoint]) {
              targetBreakpoint = _.breakpoints[breakpoint];
            }
          }
        }
      }

      if (targetBreakpoint !== null) {
        if (_.activeBreakpoint !== null) {
          if (targetBreakpoint !== _.activeBreakpoint || forceUpdate) {
            _.activeBreakpoint = targetBreakpoint;
            if (_.breakpointSettings[targetBreakpoint] === "unslick") {
              _.unslick(targetBreakpoint);
            } else {
              _.options = $.extend(
                {},
                _.originalSettings,
                _.breakpointSettings[targetBreakpoint]
              );
              if (initial === true) {
                _.currentSlide = _.options.initialSlide;
              }
              _.refresh(initial);
            }
            triggerBreakpoint = targetBreakpoint;
          }
        } else {
          _.activeBreakpoint = targetBreakpoint;
          if (_.breakpointSettings[targetBreakpoint] === "unslick") {
            _.unslick(targetBreakpoint);
          } else {
            _.options = $.extend(
              {},
              _.originalSettings,
              _.breakpointSettings[targetBreakpoint]
            );
            if (initial === true) {
              _.currentSlide = _.options.initialSlide;
            }
            _.refresh(initial);
          }
          triggerBreakpoint = targetBreakpoint;
        }
      } else {
        if (_.activeBreakpoint !== null) {
          _.activeBreakpoint = null;
          _.options = _.originalSettings;
          if (initial === true) {
            _.currentSlide = _.options.initialSlide;
          }
          _.refresh(initial);
          triggerBreakpoint = targetBreakpoint;
        }
      }

      // only trigger breakpoints during an actual break. not on initialize.
      if (!initial && triggerBreakpoint !== false) {
        _.$slider.trigger("breakpoint", [_, triggerBreakpoint]);
      }
    }
  };

  Slick.prototype.changeSlide = function (event, dontAnimate) {
    var _ = this,
      $target = $(event.currentTarget),
      indexOffset,
      slideOffset,
      unevenOffset;

    // If target is a link, prevent default action.
    if ($target.is("a")) {
      event.preventDefault();
    }

    // If target is not the <li> element (ie: a child), find the <li>.
    if (!$target.is("li")) {
      $target = $target.closest("li");
    }

    unevenOffset = _.slideCount % _.options.slidesToScroll !== 0;
    indexOffset = unevenOffset
      ? 0
      : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;

    switch (event.data.message) {
      case "previous":
        slideOffset =
          indexOffset === 0
            ? _.options.slidesToScroll
            : _.options.slidesToShow - indexOffset;
        if (_.slideCount > _.options.slidesToShow) {
          _.slideHandler(_.currentSlide - slideOffset, false, dontAnimate);
        }
        break;

      case "next":
        slideOffset =
          indexOffset === 0 ? _.options.slidesToScroll : indexOffset;
        if (_.slideCount > _.options.slidesToShow) {
          _.slideHandler(_.currentSlide + slideOffset, false, dontAnimate);
        }
        break;

      case "index":
        var index =
          event.data.index === 0
            ? 0
            : event.data.index || $target.index() * _.options.slidesToScroll;

        _.slideHandler(_.checkNavigable(index), false, dontAnimate);
        $target.children().trigger("focus");
        break;

      default:
        return;
    }
  };

  Slick.prototype.checkNavigable = function (index) {
    var _ = this,
      navigables,
      prevNavigable;

    navigables = _.getNavigableIndexes();
    prevNavigable = 0;
    if (index > navigables[navigables.length - 1]) {
      index = navigables[navigables.length - 1];
    } else {
      for (var n in navigables) {
        if (index < navigables[n]) {
          index = prevNavigable;
          break;
        }
        prevNavigable = navigables[n];
      }
    }

    return index;
  };

  Slick.prototype.cleanUpEvents = function () {
    var _ = this;

    if (_.options.dots && _.$dots !== null) {
      $("li", _.$dots)
        .off("click.slick", _.changeSlide)
        .off("mouseenter.slick", $.proxy(_.interrupt, _, true))
        .off("mouseleave.slick", $.proxy(_.interrupt, _, false));

      if (_.options.accessibility === true) {
        _.$dots.off("keydown.slick", _.keyHandler);
      }
    }

    _.$slider.off("focus.slick blur.slick");

    if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
      _.$prevArrow && _.$prevArrow.off("click.slick", _.changeSlide);
      _.$nextArrow && _.$nextArrow.off("click.slick", _.changeSlide);

      if (_.options.accessibility === true) {
        _.$prevArrow && _.$prevArrow.off("keydown.slick", _.keyHandler);
        _.$nextArrow && _.$nextArrow.off("keydown.slick", _.keyHandler);
      }
    }

    _.$list.off("touchstart.slick mousedown.slick", _.swipeHandler);
    _.$list.off("touchmove.slick mousemove.slick", _.swipeHandler);
    _.$list.off("touchend.slick mouseup.slick", _.swipeHandler);
    _.$list.off("touchcancel.slick mouseleave.slick", _.swipeHandler);

    _.$list.off("click.slick", _.clickHandler);

    $(document).off(_.visibilityChange, _.visibility);

    _.cleanUpSlideEvents();

    if (_.options.accessibility === true) {
      _.$list.off("keydown.slick", _.keyHandler);
    }

    if (_.options.focusOnSelect === true) {
      $(_.$slideTrack).children().off("click.slick", _.selectHandler);
    }

    $(window).off(
      "orientationchange.slick.slick-" + _.instanceUid,
      _.orientationChange
    );

    $(window).off("resize.slick.slick-" + _.instanceUid, _.resize);

    $("[draggable!=true]", _.$slideTrack).off("dragstart", _.preventDefault);

    $(window).off("load.slick.slick-" + _.instanceUid, _.setPosition);
  };

  Slick.prototype.cleanUpSlideEvents = function () {
    var _ = this;

    _.$list.off("mouseenter.slick", $.proxy(_.interrupt, _, true));
    _.$list.off("mouseleave.slick", $.proxy(_.interrupt, _, false));
  };

  Slick.prototype.cleanUpRows = function () {
    var _ = this,
      originalSlides;

    if (_.options.rows > 1) {
      originalSlides = _.$slides.children().children();
      originalSlides.removeAttr("style");
      _.$slider.empty().append(originalSlides);
    }
  };

  Slick.prototype.clickHandler = function (event) {
    var _ = this;

    if (_.shouldClick === false) {
      event.stopImmediatePropagation();
      event.stopPropagation();
      event.preventDefault();
    }
  };

  Slick.prototype.destroy = function (refresh) {
    var _ = this;

    _.autoPlayClear();

    _.touchObject = {};

    _.cleanUpEvents();

    $(".slick-cloned", _.$slider).detach();

    if (_.$dots) {
      _.$dots.remove();
    }

    if (_.$prevArrow && _.$prevArrow.length) {
      _.$prevArrow
        .removeClass("slick-disabled slick-arrow slick-hidden")
        .removeAttr("aria-hidden aria-disabled tabindex")
        .css("display", "");

      if (_.htmlExpr.test(_.options.prevArrow)) {
        _.$prevArrow.remove();
      }
    }

    if (_.$nextArrow && _.$nextArrow.length) {
      _.$nextArrow
        .removeClass("slick-disabled slick-arrow slick-hidden")
        .removeAttr("aria-hidden aria-disabled tabindex")
        .css("display", "");

      if (_.htmlExpr.test(_.options.nextArrow)) {
        _.$nextArrow.remove();
      }
    }

    if (_.$slides) {
      _.$slides
        .removeClass(
          "slick-slide slick-active slick-center slick-visible slick-current"
        )
        .removeAttr("aria-hidden")
        .removeAttr("data-slick-index")
        .each(function () {
          $(this).attr("style", $(this).data("originalStyling"));
        });

      _.$slideTrack.children(this.options.slide).detach();

      _.$slideTrack.detach();

      _.$list.detach();

      _.$slider.append(_.$slides);
    }

    _.cleanUpRows();

    _.$slider.removeClass("slick-slider");
    _.$slider.removeClass("slick-initialized");
    _.$slider.removeClass("slick-dotted");

    _.unslicked = true;

    if (!refresh) {
      _.$slider.trigger("destroy", [_]);
    }
  };

  Slick.prototype.disableTransition = function (slide) {
    var _ = this,
      transition = {};

    transition[_.transitionType] = "";

    if (_.options.fade === false) {
      _.$slideTrack.css(transition);
    } else {
      _.$slides.eq(slide).css(transition);
    }
  };

  Slick.prototype.fadeSlide = function (slideIndex, callback) {
    var _ = this;

    if (_.cssTransitions === false) {
      _.$slides.eq(slideIndex).css({
        zIndex: _.options.zIndex,
      });

      _.$slides.eq(slideIndex).animate(
        {
          opacity: 1,
        },
        _.options.speed,
        _.options.easing,
        callback
      );
    } else {
      _.applyTransition(slideIndex);

      _.$slides.eq(slideIndex).css({
        opacity: 1,
        zIndex: _.options.zIndex,
      });

      if (callback) {
        setTimeout(function () {
          _.disableTransition(slideIndex);

          callback.call();
        }, _.options.speed);
      }
    }
  };

  Slick.prototype.fadeSlideOut = function (slideIndex) {
    var _ = this;

    if (_.cssTransitions === false) {
      _.$slides.eq(slideIndex).animate(
        {
          opacity: 0,
          zIndex: _.options.zIndex - 2,
        },
        _.options.speed,
        _.options.easing
      );
    } else {
      _.applyTransition(slideIndex);

      _.$slides.eq(slideIndex).css({
        opacity: 0,
        zIndex: _.options.zIndex - 2,
      });
    }
  };

  Slick.prototype.filterSlides = Slick.prototype.slickFilter = function (
    filter
  ) {
    var _ = this;

    if (filter !== null) {
      _.$slidesCache = _.$slides;

      _.unload();

      _.$slideTrack.children(this.options.slide).detach();

      _.$slidesCache.filter(filter).appendTo(_.$slideTrack);

      _.reinit();
    }
  };

  Slick.prototype.focusHandler = function () {
    var _ = this;

    _.$slider
      .off("focus.slick blur.slick")
      .on("focus.slick blur.slick", "*", function (event) {
        event.stopImmediatePropagation();
        var $sf = $(this);

        setTimeout(function () {
          if (_.options.pauseOnFocus) {
            _.focussed = $sf.is(":focus");
            _.autoPlay();
          }
        }, 0);
      });
  };

  Slick.prototype.getCurrent = Slick.prototype.slickCurrentSlide = function () {
    var _ = this;
    return _.currentSlide;
  };

  Slick.prototype.getDotCount = function () {
    var _ = this;

    var breakPoint = 0;
    var counter = 0;
    var pagerQty = 0;

    if (_.options.infinite === true) {
      if (_.slideCount <= _.options.slidesToShow) {
        ++pagerQty;
      } else {
        while (breakPoint < _.slideCount) {
          ++pagerQty;
          breakPoint = counter + _.options.slidesToScroll;
          counter +=
            _.options.slidesToScroll <= _.options.slidesToShow
              ? _.options.slidesToScroll
              : _.options.slidesToShow;
        }
      }
    } else if (_.options.centerMode === true) {
      pagerQty = _.slideCount;
    } else if (!_.options.asNavFor) {
      pagerQty =
        1 +
        Math.ceil(
          (_.slideCount - _.options.slidesToShow) / _.options.slidesToScroll
        );
    } else {
      while (breakPoint < _.slideCount) {
        ++pagerQty;
        breakPoint = counter + _.options.slidesToScroll;
        counter +=
          _.options.slidesToScroll <= _.options.slidesToShow
            ? _.options.slidesToScroll
            : _.options.slidesToShow;
      }
    }

    return pagerQty - 1;
  };

  Slick.prototype.getLeft = function (slideIndex) {
    var _ = this,
      targetLeft,
      verticalHeight,
      verticalOffset = 0,
      targetSlide,
      coef;

    _.slideOffset = 0;
    verticalHeight = _.$slides.first().outerHeight(true);

    if (_.options.infinite === true) {
      if (_.slideCount > _.options.slidesToShow) {
        _.slideOffset = _.slideWidth * _.options.slidesToShow * -1;
        coef = -1;

        if (_.options.vertical === true && _.options.centerMode === true) {
          if (_.options.slidesToShow === 2) {
            coef = -1.5;
          } else if (_.options.slidesToShow === 1) {
            coef = -2;
          }
        }
        verticalOffset = verticalHeight * _.options.slidesToShow * coef;
      }
      if (_.slideCount % _.options.slidesToScroll !== 0) {
        if (
          slideIndex + _.options.slidesToScroll > _.slideCount &&
          _.slideCount > _.options.slidesToShow
        ) {
          if (slideIndex > _.slideCount) {
            _.slideOffset =
              (_.options.slidesToShow - (slideIndex - _.slideCount)) *
              _.slideWidth *
              -1;
            verticalOffset =
              (_.options.slidesToShow - (slideIndex - _.slideCount)) *
              verticalHeight *
              -1;
          } else {
            _.slideOffset =
              (_.slideCount % _.options.slidesToScroll) * _.slideWidth * -1;
            verticalOffset =
              (_.slideCount % _.options.slidesToScroll) * verticalHeight * -1;
          }
        }
      }
    } else {
      if (slideIndex + _.options.slidesToShow > _.slideCount) {
        _.slideOffset =
          (slideIndex + _.options.slidesToShow - _.slideCount) * _.slideWidth;
        verticalOffset =
          (slideIndex + _.options.slidesToShow - _.slideCount) * verticalHeight;
      }
    }

    if (_.slideCount <= _.options.slidesToShow) {
      _.slideOffset = 0;
      verticalOffset = 0;
    }

    if (
      _.options.centerMode === true &&
      _.slideCount <= _.options.slidesToShow
    ) {
      _.slideOffset =
        (_.slideWidth * Math.floor(_.options.slidesToShow)) / 2 -
        (_.slideWidth * _.slideCount) / 2;
    } else if (_.options.centerMode === true && _.options.infinite === true) {
      _.slideOffset +=
        _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth;
    } else if (_.options.centerMode === true) {
      _.slideOffset = 0;
      _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);
    }

    if (_.options.vertical === false) {
      targetLeft = slideIndex * _.slideWidth * -1 + _.slideOffset;
    } else {
      targetLeft = slideIndex * verticalHeight * -1 + verticalOffset;
    }

    if (_.options.variableWidth === true) {
      if (
        _.slideCount <= _.options.slidesToShow ||
        _.options.infinite === false
      ) {
        targetSlide = _.$slideTrack.children(".slick-slide").eq(slideIndex);
      } else {
        targetSlide = _.$slideTrack
          .children(".slick-slide")
          .eq(slideIndex + _.options.slidesToShow);
      }

      if (_.options.rtl === true) {
        if (targetSlide[0]) {
          targetLeft =
            (_.$slideTrack.width() -
              targetSlide[0].offsetLeft -
              targetSlide.width()) *
            -1;
        } else {
          targetLeft = 0;
        }
      } else {
        targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
      }

      if (_.options.centerMode === true) {
        if (
          _.slideCount <= _.options.slidesToShow ||
          _.options.infinite === false
        ) {
          targetSlide = _.$slideTrack.children(".slick-slide").eq(slideIndex);
        } else {
          targetSlide = _.$slideTrack
            .children(".slick-slide")
            .eq(slideIndex + _.options.slidesToShow + 1);
        }

        if (_.options.rtl === true) {
          if (targetSlide[0]) {
            targetLeft =
              (_.$slideTrack.width() -
                targetSlide[0].offsetLeft -
                targetSlide.width()) *
              -1;
          } else {
            targetLeft = 0;
          }
        } else {
          targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
        }

        targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;
      }
    }

    return targetLeft;
  };

  Slick.prototype.getOption = Slick.prototype.slickGetOption = function (
    option
  ) {
    var _ = this;

    return _.options[option];
  };

  Slick.prototype.getNavigableIndexes = function () {
    var _ = this,
      breakPoint = 0,
      counter = 0,
      indexes = [],
      max;

    if (_.options.infinite === false) {
      max = _.slideCount;
    } else {
      breakPoint = _.options.slidesToScroll * -1;
      counter = _.options.slidesToScroll * -1;
      max = _.slideCount * 2;
    }

    while (breakPoint < max) {
      indexes.push(breakPoint);
      breakPoint = counter + _.options.slidesToScroll;
      counter +=
        _.options.slidesToScroll <= _.options.slidesToShow
          ? _.options.slidesToScroll
          : _.options.slidesToShow;
    }

    return indexes;
  };

  Slick.prototype.getSlick = function () {
    return this;
  };

  Slick.prototype.getSlideCount = function () {
    var _ = this,
      slidesTraversed,
      swipedSlide,
      centerOffset;

    centerOffset =
      _.options.centerMode === true
        ? _.slideWidth * Math.floor(_.options.slidesToShow / 2)
        : 0;

    if (_.options.swipeToSlide === true) {
      _.$slideTrack.find(".slick-slide").each(function (index, slide) {
        if (
          slide.offsetLeft - centerOffset + $(slide).outerWidth() / 2 >
          _.swipeLeft * -1
        ) {
          swipedSlide = slide;
          return false;
        }
      });

      slidesTraversed =
        Math.abs($(swipedSlide).attr("data-slick-index") - _.currentSlide) || 1;

      return slidesTraversed;
    } else {
      return _.options.slidesToScroll;
    }
  };

  Slick.prototype.goTo = Slick.prototype.slickGoTo = function (
    slide,
    dontAnimate
  ) {
    var _ = this;

    _.changeSlide(
      {
        data: {
          message: "index",
          index: parseInt(slide),
        },
      },
      dontAnimate
    );
  };

  Slick.prototype.init = function (creation) {
    var _ = this;

    if (!$(_.$slider).hasClass("slick-initialized")) {
      $(_.$slider).addClass("slick-initialized");

      _.buildRows();
      _.buildOut();
      _.setProps();
      _.startLoad();
      _.loadSlider();
      _.initializeEvents();
      _.updateArrows();
      _.updateDots();
      _.checkResponsive(true);
      _.focusHandler();
    }

    if (creation) {
      _.$slider.trigger("init", [_]);
    }

    if (_.options.accessibility === true) {
      _.initADA();
    }

    if (_.options.autoplay) {
      _.paused = false;
      _.autoPlay();
    }
  };

  Slick.prototype.initADA = function () {
    var _ = this,
      numDotGroups = Math.ceil(_.slideCount / _.options.slidesToShow),
      tabControlIndexes = _.getNavigableIndexes().filter(function (val) {
        return val >= 0 && val < _.slideCount;
      });

    _.$slides
      .add(_.$slideTrack.find(".slick-cloned"))
      .attr({
        "aria-hidden": "true",
        tabindex: "-1",
      })
      .find("a, input, button, select")
      .attr({
        tabindex: "-1",
      });

    if (_.$dots !== null) {
      _.$slides.not(_.$slideTrack.find(".slick-cloned")).each(function (i) {
        var slideControlIndex = tabControlIndexes.indexOf(i);

        $(this).attr({
          role: "tabpanel",
          id: "slick-slide" + _.instanceUid + i,
          tabindex: -1,
        });

        if (slideControlIndex !== -1) {
          $(this).attr({
            "aria-describedby":
              "slick-slide-control" + _.instanceUid + slideControlIndex,
          });
        }
      });

      _.$dots
        .attr("role", "tablist")
        .find("li")
        .each(function (i) {
          var mappedSlideIndex = tabControlIndexes[i];

          $(this).attr({
            role: "presentation",
          });

          $(this)
            .find("button")
            .first()
            .attr({
              role: "tab",
              id: "slick-slide-control" + _.instanceUid + i,
              "aria-controls": "slick-slide" + _.instanceUid + mappedSlideIndex,
              "aria-label": i + 1 + " of " + numDotGroups,
              "aria-selected": null,
              tabindex: "-1",
            });
        })
        .eq(_.currentSlide)
        .find("button")
        .attr({
          "aria-selected": "true",
          tabindex: "0",
        })
        .end();
    }

    for (
      var i = _.currentSlide, max = i + _.options.slidesToShow;
      i < max;
      i++
    ) {
      _.$slides.eq(i).attr("tabindex", 0);
    }

    _.activateADA();
  };

  Slick.prototype.initArrowEvents = function () {
    var _ = this;

    if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
      _.$prevArrow.off("click.slick").on(
        "click.slick",
        {
          message: "previous",
        },
        _.changeSlide
      );
      _.$nextArrow.off("click.slick").on(
        "click.slick",
        {
          message: "next",
        },
        _.changeSlide
      );

      if (_.options.accessibility === true) {
        _.$prevArrow.on("keydown.slick", _.keyHandler);
        _.$nextArrow.on("keydown.slick", _.keyHandler);
      }
    }
  };

  Slick.prototype.initDotEvents = function () {
    var _ = this;

    if (_.options.dots === true) {
      $("li", _.$dots).on(
        "click.slick",
        {
          message: "index",
        },
        _.changeSlide
      );

      if (_.options.accessibility === true) {
        _.$dots.on("keydown.slick", _.keyHandler);
      }
    }

    if (_.options.dots === true && _.options.pauseOnDotsHover === true) {
      $("li", _.$dots)
        .on("mouseenter.slick", $.proxy(_.interrupt, _, true))
        .on("mouseleave.slick", $.proxy(_.interrupt, _, false));
    }
  };

  Slick.prototype.initSlideEvents = function () {
    var _ = this;

    if (_.options.pauseOnHover) {
      _.$list.on("mouseenter.slick", $.proxy(_.interrupt, _, true));
      _.$list.on("mouseleave.slick", $.proxy(_.interrupt, _, false));
    }
  };

  Slick.prototype.initializeEvents = function () {
    var _ = this;

    _.initArrowEvents();

    _.initDotEvents();
    _.initSlideEvents();

    _.$list.on(
      "touchstart.slick mousedown.slick",
      {
        action: "start",
      },
      _.swipeHandler
    );
    _.$list.on(
      "touchmove.slick mousemove.slick",
      {
        action: "move",
      },
      _.swipeHandler
    );
    _.$list.on(
      "touchend.slick mouseup.slick",
      {
        action: "end",
      },
      _.swipeHandler
    );
    _.$list.on(
      "touchcancel.slick mouseleave.slick",
      {
        action: "end",
      },
      _.swipeHandler
    );

    _.$list.on("click.slick", _.clickHandler);

    $(document).on(_.visibilityChange, $.proxy(_.visibility, _));

    if (_.options.accessibility === true) {
      _.$list.on("keydown.slick", _.keyHandler);
    }

    if (_.options.focusOnSelect === true) {
      $(_.$slideTrack).children().on("click.slick", _.selectHandler);
    }

    $(window).on(
      "orientationchange.slick.slick-" + _.instanceUid,
      $.proxy(_.orientationChange, _)
    );

    $(window).on("resize.slick.slick-" + _.instanceUid, $.proxy(_.resize, _));

    $("[draggable!=true]", _.$slideTrack).on("dragstart", _.preventDefault);

    $(window).on("load.slick.slick-" + _.instanceUid, _.setPosition);
    $(_.setPosition);
  };

  Slick.prototype.initUI = function () {
    var _ = this;

    if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
      _.$prevArrow.show();
      _.$nextArrow.show();
    }

    if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
      _.$dots.show();
    }
  };

  Slick.prototype.keyHandler = function (event) {
    var _ = this;
    //Dont slide if the cursor is inside the form fields and arrow keys are pressed
    if (!event.target.tagName.match("TEXTAREA|INPUT|SELECT")) {
      if (event.keyCode === 37 && _.options.accessibility === true) {
        _.changeSlide({
          data: {
            message: _.options.rtl === true ? "next" : "previous",
          },
        });
      } else if (event.keyCode === 39 && _.options.accessibility === true) {
        _.changeSlide({
          data: {
            message: _.options.rtl === true ? "previous" : "next",
          },
        });
      }
    }
  };

  Slick.prototype.lazyLoad = function () {
    var _ = this,
      loadRange,
      cloneRange,
      rangeStart,
      rangeEnd;

    function loadImages(imagesScope) {
      $("img[data-lazy]", imagesScope).each(function () {
        var image = $(this),
          imageSource = $(this).attr("data-lazy"),
          imageSrcSet = $(this).attr("data-srcset"),
          imageSizes =
            $(this).attr("data-sizes") || _.$slider.attr("data-sizes"),
          imageToLoad = document.createElement("img");

        imageToLoad.onload = function () {
          image.animate({ opacity: 0 }, 100, function () {
            if (imageSrcSet) {
              image.attr("srcset", imageSrcSet);

              if (imageSizes) {
                image.attr("sizes", imageSizes);
              }
            }

            image
              .attr("src", imageSource)
              .animate({ opacity: 1 }, 200, function () {
                image
                  .removeAttr("data-lazy data-srcset data-sizes")
                  .removeClass("slick-loading");
              });
            _.$slider.trigger("lazyLoaded", [_, image, imageSource]);
          });
        };

        imageToLoad.onerror = function () {
          image
            .removeAttr("data-lazy")
            .removeClass("slick-loading")
            .addClass("slick-lazyload-error");

          _.$slider.trigger("lazyLoadError", [_, image, imageSource]);
        };

        imageToLoad.src = imageSource;
      });
    }

    if (_.options.centerMode === true) {
      if (_.options.infinite === true) {
        rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);
        rangeEnd = rangeStart + _.options.slidesToShow + 2;
      } else {
        rangeStart = Math.max(
          0,
          _.currentSlide - (_.options.slidesToShow / 2 + 1)
        );
        rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;
      }
    } else {
      rangeStart = _.options.infinite
        ? _.options.slidesToShow + _.currentSlide
        : _.currentSlide;
      rangeEnd = Math.ceil(rangeStart + _.options.slidesToShow);
      if (_.options.fade === true) {
        if (rangeStart > 0) rangeStart--;
        if (rangeEnd <= _.slideCount) rangeEnd++;
      }
    }

    loadRange = _.$slider.find(".slick-slide").slice(rangeStart, rangeEnd);

    if (_.options.lazyLoad === "anticipated") {
      var prevSlide = rangeStart - 1,
        nextSlide = rangeEnd,
        $slides = _.$slider.find(".slick-slide");

      for (var i = 0; i < _.options.slidesToScroll; i++) {
        if (prevSlide < 0) prevSlide = _.slideCount - 1;
        loadRange = loadRange.add($slides.eq(prevSlide));
        loadRange = loadRange.add($slides.eq(nextSlide));
        prevSlide--;
        nextSlide++;
      }
    }

    loadImages(loadRange);

    if (_.slideCount <= _.options.slidesToShow) {
      cloneRange = _.$slider.find(".slick-slide");
      loadImages(cloneRange);
    } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {
      cloneRange = _.$slider
        .find(".slick-cloned")
        .slice(0, _.options.slidesToShow);
      loadImages(cloneRange);
    } else if (_.currentSlide === 0) {
      cloneRange = _.$slider
        .find(".slick-cloned")
        .slice(_.options.slidesToShow * -1);
      loadImages(cloneRange);
    }
  };

  Slick.prototype.loadSlider = function () {
    var _ = this;

    _.setPosition();

    _.$slideTrack.css({
      opacity: 1,
    });

    _.$slider.removeClass("slick-loading");

    _.initUI();

    if (_.options.lazyLoad === "progressive") {
      _.progressiveLazyLoad();
    }
  };

  Slick.prototype.next = Slick.prototype.slickNext = function () {
    var _ = this;

    _.changeSlide({
      data: {
        message: "next",
      },
    });
  };

  Slick.prototype.orientationChange = function () {
    var _ = this;

    _.checkResponsive();
    _.setPosition();
  };

  Slick.prototype.pause = Slick.prototype.slickPause = function () {
    var _ = this;

    _.autoPlayClear();
    _.paused = true;
  };

  Slick.prototype.play = Slick.prototype.slickPlay = function () {
    var _ = this;

    _.autoPlay();
    _.options.autoplay = true;
    _.paused = false;
    _.focussed = false;
    _.interrupted = false;
  };

  Slick.prototype.postSlide = function (index) {
    var _ = this;

    if (!_.unslicked) {
      _.$slider.trigger("afterChange", [_, index]);

      _.animating = false;

      if (_.slideCount > _.options.slidesToShow) {
        _.setPosition();
      }

      _.swipeLeft = null;

      if (_.options.autoplay) {
        _.autoPlay();
      }

      if (_.options.accessibility === true) {
        _.initADA();

        if (_.options.focusOnChange) {
          var $currentSlide = $(_.$slides.get(_.currentSlide));
          $currentSlide.attr("tabindex", 0).focus();
        }
      }
    }
  };

  Slick.prototype.prev = Slick.prototype.slickPrev = function () {
    var _ = this;

    _.changeSlide({
      data: {
        message: "previous",
      },
    });
  };

  Slick.prototype.preventDefault = function (event) {
    event.preventDefault();
  };

  Slick.prototype.progressiveLazyLoad = function (tryCount) {
    tryCount = tryCount || 1;

    var _ = this,
      $imgsToLoad = $("img[data-lazy]", _.$slider),
      image,
      imageSource,
      imageSrcSet,
      imageSizes,
      imageToLoad;

    if ($imgsToLoad.length) {
      image = $imgsToLoad.first();
      imageSource = image.attr("data-lazy");
      imageSrcSet = image.attr("data-srcset");
      imageSizes = image.attr("data-sizes") || _.$slider.attr("data-sizes");
      imageToLoad = document.createElement("img");

      imageToLoad.onload = function () {
        if (imageSrcSet) {
          image.attr("srcset", imageSrcSet);

          if (imageSizes) {
            image.attr("sizes", imageSizes);
          }
        }

        image
          .attr("src", imageSource)
          .removeAttr("data-lazy data-srcset data-sizes")
          .removeClass("slick-loading");

        if (_.options.adaptiveHeight === true) {
          _.setPosition();
        }

        _.$slider.trigger("lazyLoaded", [_, image, imageSource]);
        _.progressiveLazyLoad();
      };

      imageToLoad.onerror = function () {
        if (tryCount < 3) {
          /**
           * try to load the image 3 times,
           * leave a slight delay so we don't get
           * servers blocking the request.
           */
          setTimeout(function () {
            _.progressiveLazyLoad(tryCount + 1);
          }, 500);
        } else {
          image
            .removeAttr("data-lazy")
            .removeClass("slick-loading")
            .addClass("slick-lazyload-error");

          _.$slider.trigger("lazyLoadError", [_, image, imageSource]);

          _.progressiveLazyLoad();
        }
      };

      imageToLoad.src = imageSource;
    } else {
      _.$slider.trigger("allImagesLoaded", [_]);
    }
  };

  Slick.prototype.refresh = function (initializing) {
    var _ = this,
      currentSlide,
      lastVisibleIndex;

    lastVisibleIndex = _.slideCount - _.options.slidesToShow;

    // in non-infinite sliders, we don't want to go past the
    // last visible index.
    if (!_.options.infinite && _.currentSlide > lastVisibleIndex) {
      _.currentSlide = lastVisibleIndex;
    }

    // if less slides than to show, go to start.
    if (_.slideCount <= _.options.slidesToShow) {
      _.currentSlide = 0;
    }

    currentSlide = _.currentSlide;

    _.destroy(true);

    $.extend(_, _.initials, { currentSlide: currentSlide });

    _.init();

    if (!initializing) {
      _.changeSlide(
        {
          data: {
            message: "index",
            index: currentSlide,
          },
        },
        false
      );
    }
  };

  Slick.prototype.registerBreakpoints = function () {
    var _ = this,
      breakpoint,
      currentBreakpoint,
      l,
      responsiveSettings = _.options.responsive || null;

    if ($.type(responsiveSettings) === "array" && responsiveSettings.length) {
      _.respondTo = _.options.respondTo || "window";

      for (breakpoint in responsiveSettings) {
        l = _.breakpoints.length - 1;

        if (responsiveSettings.hasOwnProperty(breakpoint)) {
          currentBreakpoint = responsiveSettings[breakpoint].breakpoint;

          // loop through the breakpoints and cut out any existing
          // ones with the same breakpoint number, we don't want dupes.
          while (l >= 0) {
            if (_.breakpoints[l] && _.breakpoints[l] === currentBreakpoint) {
              _.breakpoints.splice(l, 1);
            }
            l--;
          }

          _.breakpoints.push(currentBreakpoint);
          _.breakpointSettings[currentBreakpoint] =
            responsiveSettings[breakpoint].settings;
        }
      }

      _.breakpoints.sort(function (a, b) {
        return _.options.mobileFirst ? a - b : b - a;
      });
    }
  };

  Slick.prototype.reinit = function () {
    var _ = this;

    _.$slides = _.$slideTrack.children(_.options.slide).addClass("slick-slide");

    _.slideCount = _.$slides.length;

    if (_.currentSlide >= _.slideCount && _.currentSlide !== 0) {
      _.currentSlide = _.currentSlide - _.options.slidesToScroll;
    }

    if (_.slideCount <= _.options.slidesToShow) {
      _.currentSlide = 0;
    }

    _.registerBreakpoints();

    _.setProps();
    _.setupInfinite();
    _.buildArrows();
    _.updateArrows();
    _.initArrowEvents();
    _.buildDots();
    _.updateDots();
    _.initDotEvents();
    _.cleanUpSlideEvents();
    _.initSlideEvents();

    _.checkResponsive(false, true);

    if (_.options.focusOnSelect === true) {
      $(_.$slideTrack).children().on("click.slick", _.selectHandler);
    }

    _.setSlideClasses(typeof _.currentSlide === "number" ? _.currentSlide : 0);

    _.setPosition();
    _.focusHandler();

    _.paused = !_.options.autoplay;
    _.autoPlay();

    _.$slider.trigger("reInit", [_]);
  };

  Slick.prototype.resize = function () {
    var _ = this;

    if ($(window).width() !== _.windowWidth) {
      clearTimeout(_.windowDelay);
      _.windowDelay = window.setTimeout(function () {
        _.windowWidth = $(window).width();
        _.checkResponsive();
        if (!_.unslicked) {
          _.setPosition();
        }
      }, 50);
    }
  };

  Slick.prototype.removeSlide = Slick.prototype.slickRemove = function (
    index,
    removeBefore,
    removeAll
  ) {
    var _ = this;

    if (typeof index === "boolean") {
      removeBefore = index;
      index = removeBefore === true ? 0 : _.slideCount - 1;
    } else {
      index = removeBefore === true ? --index : index;
    }

    if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) {
      return false;
    }

    _.unload();

    if (removeAll === true) {
      _.$slideTrack.children().remove();
    } else {
      _.$slideTrack.children(this.options.slide).eq(index).remove();
    }

    _.$slides = _.$slideTrack.children(this.options.slide);

    _.$slideTrack.children(this.options.slide).detach();

    _.$slideTrack.append(_.$slides);

    _.$slidesCache = _.$slides;

    _.reinit();
  };

  Slick.prototype.setCSS = function (position) {
    var _ = this,
      positionProps = {},
      x,
      y;

    if (_.options.rtl === true) {
      position = -position;
    }
    x = _.positionProp == "left" ? Math.ceil(position) + "px" : "0px";
    y = _.positionProp == "top" ? Math.ceil(position) + "px" : "0px";

    positionProps[_.positionProp] = position;

    if (_.transformsEnabled === false) {
      _.$slideTrack.css(positionProps);
    } else {
      positionProps = {};
      if (_.cssTransitions === false) {
        positionProps[_.animType] = "translate(" + x + ", " + y + ")";
        _.$slideTrack.css(positionProps);
      } else {
        positionProps[_.animType] = "translate3d(" + x + ", " + y + ", 0px)";
        _.$slideTrack.css(positionProps);
      }
    }
  };

  Slick.prototype.setDimensions = function () {
    var _ = this;

    if (_.options.vertical === false) {
      if (_.options.centerMode === true) {
        _.$list.css({
          padding: "0px " + _.options.centerPadding,
        });
      }
    } else {
      _.$list.height(
        _.$slides.first().outerHeight(true) * _.options.slidesToShow
      );
      if (_.options.centerMode === true) {
        _.$list.css({
          padding: _.options.centerPadding + " 0px",
        });
      }
    }

    _.listWidth = _.$list.width();
    _.listHeight = _.$list.height();

    if (_.options.vertical === false && _.options.variableWidth === false) {
      _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);
      _.$slideTrack.width(
        Math.ceil(_.slideWidth * _.$slideTrack.children(".slick-slide").length)
      );
    } else if (_.options.variableWidth === true) {
      _.$slideTrack.width(5000 * _.slideCount);
    } else {
      _.slideWidth = Math.ceil(_.listWidth);
      _.$slideTrack.height(
        Math.ceil(
          _.$slides.first().outerHeight(true) *
            _.$slideTrack.children(".slick-slide").length
        )
      );
    }

    var offset = _.$slides.first().outerWidth(true) - _.$slides.first().width();
    if (_.options.variableWidth === false)
      _.$slideTrack.children(".slick-slide").width(_.slideWidth - offset);
  };

  Slick.prototype.setFade = function () {
    var _ = this,
      targetLeft;

    _.$slides.each(function (index, element) {
      targetLeft = _.slideWidth * index * -1;
      if (_.options.rtl === true) {
        $(element).css({
          position: "relative",
          right: targetLeft,
          top: 0,
          zIndex: _.options.zIndex - 2,
          opacity: 0,
        });
      } else {
        $(element).css({
          position: "relative",
          left: targetLeft,
          top: 0,
          zIndex: _.options.zIndex - 2,
          opacity: 0,
        });
      }
    });

    _.$slides.eq(_.currentSlide).css({
      zIndex: _.options.zIndex - 1,
      opacity: 1,
    });
  };

  Slick.prototype.setHeight = function () {
    var _ = this;

    if (
      _.options.slidesToShow === 1 &&
      _.options.adaptiveHeight === true &&
      _.options.vertical === false
    ) {
      var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
      _.$list.css("height", targetHeight);
    }
  };

  Slick.prototype.setOption = Slick.prototype.slickSetOption = function () {
    /**
     * accepts arguments in format of:
     *
     *  - for changing a single option's value:
     *     .slick("setOption", option, value, refresh )
     *
     *  - for changing a set of responsive options:
     *     .slick("setOption", 'responsive', [{}, ...], refresh )
     *
     *  - for updating multiple values at once (not responsive)
     *     .slick("setOption", { 'option': value, ... }, refresh )
     */

    var _ = this,
      l,
      item,
      option,
      value,
      refresh = false,
      type;

    if ($.type(arguments[0]) === "object") {
      option = arguments[0];
      refresh = arguments[1];
      type = "multiple";
    } else if ($.type(arguments[0]) === "string") {
      option = arguments[0];
      value = arguments[1];
      refresh = arguments[2];

      if (arguments[0] === "responsive" && $.type(arguments[1]) === "array") {
        type = "responsive";
      } else if (typeof arguments[1] !== "undefined") {
        type = "single";
      }
    }

    if (type === "single") {
      _.options[option] = value;
    } else if (type === "multiple") {
      $.each(option, function (opt, val) {
        _.options[opt] = val;
      });
    } else if (type === "responsive") {
      for (item in value) {
        if ($.type(_.options.responsive) !== "array") {
          _.options.responsive = [value[item]];
        } else {
          l = _.options.responsive.length - 1;

          // loop through the responsive object and splice out duplicates.
          while (l >= 0) {
            if (_.options.responsive[l].breakpoint === value[item].breakpoint) {
              _.options.responsive.splice(l, 1);
            }

            l--;
          }

          _.options.responsive.push(value[item]);
        }
      }
    }

    if (refresh) {
      _.unload();
      _.reinit();
    }
  };

  Slick.prototype.setPosition = function () {
    var _ = this;

    _.setDimensions();

    _.setHeight();

    if (_.options.fade === false) {
      _.setCSS(_.getLeft(_.currentSlide));
    } else {
      _.setFade();
    }

    _.$slider.trigger("setPosition", [_]);
  };

  Slick.prototype.setProps = function () {
    var _ = this,
      bodyStyle = document.body.style;

    _.positionProp = _.options.vertical === true ? "top" : "left";

    if (_.positionProp === "top") {
      _.$slider.addClass("slick-vertical");
    } else {
      _.$slider.removeClass("slick-vertical");
    }

    if (
      bodyStyle.WebkitTransition !== undefined ||
      bodyStyle.MozTransition !== undefined ||
      bodyStyle.msTransition !== undefined
    ) {
      if (_.options.useCSS === true) {
        _.cssTransitions = true;
      }
    }

    if (_.options.fade) {
      if (typeof _.options.zIndex === "number") {
        if (_.options.zIndex < 3) {
          _.options.zIndex = 3;
        }
      } else {
        _.options.zIndex = _.defaults.zIndex;
      }
    }

    if (bodyStyle.OTransform !== undefined) {
      _.animType = "OTransform";
      _.transformType = "-o-transform";
      _.transitionType = "OTransition";
      if (
        bodyStyle.perspectiveProperty === undefined &&
        bodyStyle.webkitPerspective === undefined
      )
        _.animType = false;
    }
    if (bodyStyle.MozTransform !== undefined) {
      _.animType = "MozTransform";
      _.transformType = "-moz-transform";
      _.transitionType = "MozTransition";
      if (
        bodyStyle.perspectiveProperty === undefined &&
        bodyStyle.MozPerspective === undefined
      )
        _.animType = false;
    }
    if (bodyStyle.webkitTransform !== undefined) {
      _.animType = "webkitTransform";
      _.transformType = "-webkit-transform";
      _.transitionType = "webkitTransition";
      if (
        bodyStyle.perspectiveProperty === undefined &&
        bodyStyle.webkitPerspective === undefined
      )
        _.animType = false;
    }
    if (bodyStyle.msTransform !== undefined) {
      _.animType = "msTransform";
      _.transformType = "-ms-transform";
      _.transitionType = "msTransition";
      if (bodyStyle.msTransform === undefined) _.animType = false;
    }
    if (bodyStyle.transform !== undefined && _.animType !== false) {
      _.animType = "transform";
      _.transformType = "transform";
      _.transitionType = "transition";
    }
    _.transformsEnabled =
      _.options.useTransform && _.animType !== null && _.animType !== false;
  };

  Slick.prototype.setSlideClasses = function (index) {
    var _ = this,
      centerOffset,
      allSlides,
      indexOffset,
      remainder;

    allSlides = _.$slider
      .find(".slick-slide")
      .removeClass("slick-active slick-center slick-current")
      .attr("aria-hidden", "true");

    _.$slides.eq(index).addClass("slick-current");

    if (_.options.centerMode === true) {
      var evenCoef = _.options.slidesToShow % 2 === 0 ? 1 : 0;

      centerOffset = Math.floor(_.options.slidesToShow / 2);

      if (_.options.infinite === true) {
        if (index >= centerOffset && index <= _.slideCount - 1 - centerOffset) {
          _.$slides
            .slice(index - centerOffset + evenCoef, index + centerOffset + 1)
            .addClass("slick-active")
            .attr("aria-hidden", "false");
        } else {
          indexOffset = _.options.slidesToShow + index;
          allSlides
            .slice(
              indexOffset - centerOffset + 1 + evenCoef,
              indexOffset + centerOffset + 2
            )
            .addClass("slick-active")
            .attr("aria-hidden", "false");
        }

        if (index === 0) {
          allSlides
            .eq(allSlides.length - 1 - _.options.slidesToShow)
            .addClass("slick-center");
        } else if (index === _.slideCount - 1) {
          allSlides.eq(_.options.slidesToShow).addClass("slick-center");
        }
      }

      _.$slides.eq(index).addClass("slick-center");
    } else {
      if (index >= 0 && index <= _.slideCount - _.options.slidesToShow) {
        _.$slides
          .slice(index, index + _.options.slidesToShow)
          .addClass("slick-active")
          .attr("aria-hidden", "false");
      } else if (allSlides.length <= _.options.slidesToShow) {
        allSlides.addClass("slick-active").attr("aria-hidden", "false");
      } else {
        remainder = _.slideCount % _.options.slidesToShow;
        indexOffset =
          _.options.infinite === true ? _.options.slidesToShow + index : index;

        if (
          _.options.slidesToShow == _.options.slidesToScroll &&
          _.slideCount - index < _.options.slidesToShow
        ) {
          allSlides
            .slice(
              indexOffset - (_.options.slidesToShow - remainder),
              indexOffset + remainder
            )
            .addClass("slick-active")
            .attr("aria-hidden", "false");
        } else {
          allSlides
            .slice(indexOffset, indexOffset + _.options.slidesToShow)
            .addClass("slick-active")
            .attr("aria-hidden", "false");
        }
      }
    }

    if (
      _.options.lazyLoad === "ondemand" ||
      _.options.lazyLoad === "anticipated"
    ) {
      _.lazyLoad();
    }
  };

  Slick.prototype.setupInfinite = function () {
    var _ = this,
      i,
      slideIndex,
      infiniteCount;

    if (_.options.fade === true) {
      _.options.centerMode = false;
    }

    if (_.options.infinite === true && _.options.fade === false) {
      slideIndex = null;

      if (_.slideCount > _.options.slidesToShow) {
        if (_.options.centerMode === true) {
          infiniteCount = _.options.slidesToShow + 1;
        } else {
          infiniteCount = _.options.slidesToShow;
        }

        for (i = _.slideCount; i > _.slideCount - infiniteCount; i -= 1) {
          slideIndex = i - 1;
          $(_.$slides[slideIndex])
            .clone(true)
            .attr("id", "")
            .attr("data-slick-index", slideIndex - _.slideCount)
            .prependTo(_.$slideTrack)
            .addClass("slick-cloned");
        }
        for (i = 0; i < infiniteCount + _.slideCount; i += 1) {
          slideIndex = i;
          $(_.$slides[slideIndex])
            .clone(true)
            .attr("id", "")
            .attr("data-slick-index", slideIndex + _.slideCount)
            .appendTo(_.$slideTrack)
            .addClass("slick-cloned");
        }
        _.$slideTrack
          .find(".slick-cloned")
          .find("[id]")
          .each(function () {
            $(this).attr("id", "");
          });
      }
    }
  };

  Slick.prototype.interrupt = function (toggle) {
    var _ = this;

    if (!toggle) {
      _.autoPlay();
    }
    _.interrupted = toggle;
  };

  Slick.prototype.selectHandler = function (event) {
    var _ = this;

    var targetElement = $(event.target).is(".slick-slide")
      ? $(event.target)
      : $(event.target).parents(".slick-slide");

    var index = parseInt(targetElement.attr("data-slick-index"));

    if (!index) index = 0;

    if (_.slideCount <= _.options.slidesToShow) {
      _.slideHandler(index, false, true);
      return;
    }

    _.slideHandler(index);
  };

  Slick.prototype.slideHandler = function (index, sync, dontAnimate) {
    var targetSlide,
      animSlide,
      oldSlide,
      slideLeft,
      targetLeft = null,
      _ = this,
      navTarget;

    sync = sync || false;

    if (_.animating === true && _.options.waitForAnimate === true) {
      return;
    }

    if (_.options.fade === true && _.currentSlide === index) {
      return;
    }

    if (sync === false) {
      _.asNavFor(index);
    }

    targetSlide = index;
    targetLeft = _.getLeft(targetSlide);
    slideLeft = _.getLeft(_.currentSlide);

    _.currentLeft = _.swipeLeft === null ? slideLeft : _.swipeLeft;

    if (
      _.options.infinite === false &&
      _.options.centerMode === false &&
      (index < 0 || index > _.getDotCount() * _.options.slidesToScroll)
    ) {
      if (_.options.fade === false) {
        targetSlide = _.currentSlide;
        if (dontAnimate !== true) {
          _.animateSlide(slideLeft, function () {
            _.postSlide(targetSlide);
          });
        } else {
          _.postSlide(targetSlide);
        }
      }
      return;
    } else if (
      _.options.infinite === false &&
      _.options.centerMode === true &&
      (index < 0 || index > _.slideCount - _.options.slidesToScroll)
    ) {
      if (_.options.fade === false) {
        targetSlide = _.currentSlide;
        if (dontAnimate !== true) {
          _.animateSlide(slideLeft, function () {
            _.postSlide(targetSlide);
          });
        } else {
          _.postSlide(targetSlide);
        }
      }
      return;
    }

    if (_.options.autoplay) {
      clearInterval(_.autoPlayTimer);
    }

    if (targetSlide < 0) {
      if (_.slideCount % _.options.slidesToScroll !== 0) {
        animSlide = _.slideCount - (_.slideCount % _.options.slidesToScroll);
      } else {
        animSlide = _.slideCount + targetSlide;
      }
    } else if (targetSlide >= _.slideCount) {
      if (_.slideCount % _.options.slidesToScroll !== 0) {
        animSlide = 0;
      } else {
        animSlide = targetSlide - _.slideCount;
      }
    } else {
      animSlide = targetSlide;
    }

    _.animating = true;

    _.$slider.trigger("beforeChange", [_, _.currentSlide, animSlide]);

    oldSlide = _.currentSlide;
    _.currentSlide = animSlide;

    _.setSlideClasses(_.currentSlide);

    if (_.options.asNavFor) {
      navTarget = _.getNavTarget();
      navTarget = navTarget.slick("getSlick");

      if (navTarget.slideCount <= navTarget.options.slidesToShow) {
        navTarget.setSlideClasses(_.currentSlide);
      }
    }

    _.updateDots();
    _.updateArrows();

    if (_.options.fade === true) {
      if (dontAnimate !== true) {
        _.fadeSlideOut(oldSlide);

        _.fadeSlide(animSlide, function () {
          _.postSlide(animSlide);
        });
      } else {
        _.postSlide(animSlide);
      }
      _.animateHeight();
      return;
    }

    if (dontAnimate !== true) {
      _.animateSlide(targetLeft, function () {
        _.postSlide(animSlide);
      });
    } else {
      _.postSlide(animSlide);
    }
  };

  Slick.prototype.startLoad = function () {
    var _ = this;

    if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
      _.$prevArrow.hide();
      _.$nextArrow.hide();
    }

    if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
      _.$dots.hide();
    }

    _.$slider.addClass("slick-loading");
  };

  Slick.prototype.swipeDirection = function () {
    var xDist,
      yDist,
      r,
      swipeAngle,
      _ = this;

    xDist = _.touchObject.startX - _.touchObject.curX;
    yDist = _.touchObject.startY - _.touchObject.curY;
    r = Math.atan2(yDist, xDist);

    swipeAngle = Math.round((r * 180) / Math.PI);
    if (swipeAngle < 0) {
      swipeAngle = 360 - Math.abs(swipeAngle);
    }

    if (swipeAngle <= 45 && swipeAngle >= 0) {
      return _.options.rtl === false ? "left" : "right";
    }
    if (swipeAngle <= 360 && swipeAngle >= 315) {
      return _.options.rtl === false ? "left" : "right";
    }
    if (swipeAngle >= 135 && swipeAngle <= 225) {
      return _.options.rtl === false ? "right" : "left";
    }
    if (_.options.verticalSwiping === true) {
      if (swipeAngle >= 35 && swipeAngle <= 135) {
        return "down";
      } else {
        return "up";
      }
    }

    return "vertical";
  };

  Slick.prototype.swipeEnd = function (event) {
    var _ = this,
      slideCount,
      direction;

    _.dragging = false;
    _.swiping = false;

    if (_.scrolling) {
      _.scrolling = false;
      return false;
    }

    _.interrupted = false;
    _.shouldClick = _.touchObject.swipeLength > 10 ? false : true;

    if (_.touchObject.curX === undefined) {
      return false;
    }

    if (_.touchObject.edgeHit === true) {
      _.$slider.trigger("edge", [_, _.swipeDirection()]);
    }

    if (_.touchObject.swipeLength >= _.touchObject.minSwipe) {
      direction = _.swipeDirection();

      switch (direction) {
        case "left":
        case "down":
          slideCount = _.options.swipeToSlide
            ? _.checkNavigable(_.currentSlide + _.getSlideCount())
            : _.currentSlide + _.getSlideCount();

          _.currentDirection = 0;

          break;

        case "right":
        case "up":
          slideCount = _.options.swipeToSlide
            ? _.checkNavigable(_.currentSlide - _.getSlideCount())
            : _.currentSlide - _.getSlideCount();

          _.currentDirection = 1;

          break;

        default:
      }

      if (direction != "vertical") {
        _.slideHandler(slideCount);
        _.touchObject = {};
        _.$slider.trigger("swipe", [_, direction]);
      }
    } else {
      if (_.touchObject.startX !== _.touchObject.curX) {
        _.slideHandler(_.currentSlide);
        _.touchObject = {};
      }
    }
  };

  Slick.prototype.swipeHandler = function (event) {
    var _ = this;

    if (
      _.options.swipe === false ||
      ("ontouchend" in document && _.options.swipe === false)
    ) {
      return;
    } else if (
      _.options.draggable === false &&
      event.type.indexOf("mouse") !== -1
    ) {
      return;
    }

    _.touchObject.fingerCount =
      event.originalEvent && event.originalEvent.touches !== undefined
        ? event.originalEvent.touches.length
        : 1;

    _.touchObject.minSwipe = _.listWidth / _.options.touchThreshold;

    if (_.options.verticalSwiping === true) {
      _.touchObject.minSwipe = _.listHeight / _.options.touchThreshold;
    }

    switch (event.data.action) {
      case "start":
        _.swipeStart(event);
        break;

      case "move":
        _.swipeMove(event);
        break;

      case "end":
        _.swipeEnd(event);
        break;
    }
  };

  Slick.prototype.swipeMove = function (event) {
    var _ = this,
      edgeWasHit = false,
      curLeft,
      swipeDirection,
      swipeLength,
      positionOffset,
      touches,
      verticalSwipeLength;

    touches =
      event.originalEvent !== undefined ? event.originalEvent.touches : null;

    if (!_.dragging || _.scrolling || (touches && touches.length !== 1)) {
      return false;
    }

    curLeft = _.getLeft(_.currentSlide);

    _.touchObject.curX =
      touches !== undefined ? touches[0].pageX : event.clientX;
    _.touchObject.curY =
      touches !== undefined ? touches[0].pageY : event.clientY;

    _.touchObject.swipeLength = Math.round(
      Math.sqrt(Math.pow(_.touchObject.curX - _.touchObject.startX, 2))
    );

    verticalSwipeLength = Math.round(
      Math.sqrt(Math.pow(_.touchObject.curY - _.touchObject.startY, 2))
    );

    if (!_.options.verticalSwiping && !_.swiping && verticalSwipeLength > 4) {
      _.scrolling = true;
      return false;
    }

    if (_.options.verticalSwiping === true) {
      _.touchObject.swipeLength = verticalSwipeLength;
    }

    swipeDirection = _.swipeDirection();

    if (event.originalEvent !== undefined && _.touchObject.swipeLength > 4) {
      _.swiping = true;
      event.preventDefault();
    }

    positionOffset =
      (_.options.rtl === false ? 1 : -1) *
      (_.touchObject.curX > _.touchObject.startX ? 1 : -1);
    if (_.options.verticalSwiping === true) {
      positionOffset = _.touchObject.curY > _.touchObject.startY ? 1 : -1;
    }

    swipeLength = _.touchObject.swipeLength;

    _.touchObject.edgeHit = false;

    if (_.options.infinite === false) {
      if (
        (_.currentSlide === 0 && swipeDirection === "right") ||
        (_.currentSlide >= _.getDotCount() && swipeDirection === "left")
      ) {
        swipeLength = _.touchObject.swipeLength * _.options.edgeFriction;
        _.touchObject.edgeHit = true;
      }
    }

    if (_.options.vertical === false) {
      _.swipeLeft = curLeft + swipeLength * positionOffset;
    } else {
      _.swipeLeft =
        curLeft +
        swipeLength * (_.$list.height() / _.listWidth) * positionOffset;
    }
    if (_.options.verticalSwiping === true) {
      _.swipeLeft = curLeft + swipeLength * positionOffset;
    }

    if (_.options.fade === true || _.options.touchMove === false) {
      return false;
    }

    if (_.animating === true) {
      _.swipeLeft = null;
      return false;
    }

    _.setCSS(_.swipeLeft);
  };

  Slick.prototype.swipeStart = function (event) {
    var _ = this,
      touches;

    _.interrupted = true;

    if (
      _.touchObject.fingerCount !== 1 ||
      _.slideCount <= _.options.slidesToShow
    ) {
      _.touchObject = {};
      return false;
    }

    if (
      event.originalEvent !== undefined &&
      event.originalEvent.touches !== undefined
    ) {
      touches = event.originalEvent.touches[0];
    }

    _.touchObject.startX = _.touchObject.curX =
      touches !== undefined ? touches.pageX : event.clientX;
    _.touchObject.startY = _.touchObject.curY =
      touches !== undefined ? touches.pageY : event.clientY;

    _.dragging = true;
  };

  Slick.prototype.unfilterSlides = Slick.prototype.slickUnfilter = function () {
    var _ = this;

    if (_.$slidesCache !== null) {
      _.unload();

      _.$slideTrack.children(this.options.slide).detach();

      _.$slidesCache.appendTo(_.$slideTrack);

      _.reinit();
    }
  };

  Slick.prototype.unload = function () {
    var _ = this;

    $(".slick-cloned", _.$slider).remove();

    if (_.$dots) {
      _.$dots.remove();
    }

    if (_.$prevArrow && _.htmlExpr.test(_.options.prevArrow)) {
      _.$prevArrow.remove();
    }

    if (_.$nextArrow && _.htmlExpr.test(_.options.nextArrow)) {
      _.$nextArrow.remove();
    }

    _.$slides
      .removeClass("slick-slide slick-active slick-visible slick-current")
      .attr("aria-hidden", "true")
      .css("width", "");
  };

  Slick.prototype.unslick = function (fromBreakpoint) {

    /**  
     * Unloading the carousel instead of destroying it will allow 
     * the carousel to be constructed again on orientation change
     */

    var _ = this;
    _.$slider.trigger("unslick", [_, fromBreakpoint]);
    //_.destroy();
    _.unload();
  };

  Slick.prototype.updateArrows = function () {
    var _ = this,
      centerOffset;

    centerOffset = Math.floor(_.options.slidesToShow / 2);

    if (
      _.options.arrows === true &&
      _.slideCount > _.options.slidesToShow &&
      !_.options.infinite
    ) {
      _.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false");
      _.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false");

      if (_.currentSlide === 0) {
        _.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true");
        _.$nextArrow
          .removeClass("slick-disabled")
          .attr("aria-disabled", "false");
      } else if (
        _.currentSlide >= _.slideCount - _.options.slidesToShow &&
        _.options.centerMode === false
      ) {
        _.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true");
        _.$prevArrow
          .removeClass("slick-disabled")
          .attr("aria-disabled", "false");
      } else if (
        _.currentSlide >= _.slideCount - 1 &&
        _.options.centerMode === true
      ) {
        _.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true");
        _.$prevArrow
          .removeClass("slick-disabled")
          .attr("aria-disabled", "false");
      }
    }
  };

  Slick.prototype.updateDots = function () {
    var _ = this;

    if (_.$dots !== null) {
      _.$dots.find("li").removeClass("slick-active").end();

      _.$dots
        .find("li")
        .eq(Math.floor(_.currentSlide / _.options.slidesToScroll))
        .addClass("slick-active");
    }
  };

  Slick.prototype.visibility = function () {
    var _ = this;

    if (_.options.autoplay) {
      if (document[_.hidden]) {
        _.interrupted = true;
      } else {
        _.interrupted = false;
      }
    }
  };

  $.fn.slick = function () {
    var _ = this,
      opt = arguments[0],
      args = Array.prototype.slice.call(arguments, 1),
      l = _.length,
      i,
      ret;
    for (i = 0; i < l; i++) {
      if (typeof opt == "object" || typeof opt == "undefined")
        _[i].slick = new Slick(_[i], opt);
      else ret = _[i].slick[opt].apply(_[i].slick, args);
      if (typeof ret != "undefined") return ret;
    }
    return _;
  };
});

/*! https://mths.be/he v1.1.1 by @mathias | MIT license */
(function (root) {
  // Detect free variables `exports`.
  var freeExports = typeof exports == "object" && exports;

  // Detect free variable `module`.
  var freeModule =
    typeof module == "object" &&
    module &&
    module.exports == freeExports &&
    module;

  // Detect free variable `global`, from Node.js or Browserified code,
  // and use it as `root`.
  var freeGlobal = typeof global == "object" && global;
  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  // All astral symbols.
  var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  // All ASCII symbols (not just printable ASCII) except those listed in the
  // first column of the overrides table.
  // https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides
  var regexAsciiWhitelist = /[\x01-\x7F]/g;
  // All BMP symbols that are not ASCII newlines, printable ASCII symbols, or
  // code points listed in the first column of the overrides table on
  // https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides.
  var regexBmpWhitelist =
    /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;

  var regexEncodeNonAscii =
    /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
  var encodeMap = {
    "\xAD": "shy",
    "\u200C": "zwnj",
    "\u200D": "zwj",
    "\u200E": "lrm",
    "\u2063": "ic",
    "\u2062": "it",
    "\u2061": "af",
    "\u200F": "rlm",
    "\u200B": "ZeroWidthSpace",
    "\u2060": "NoBreak",
    "\u0311": "DownBreve",
    "\u20DB": "tdot",
    "\u20DC": "DotDot",
    "\t": "Tab",
    "\n": "NewLine",
    "\u2008": "puncsp",
    "\u205F": "MediumSpace",
    "\u2009": "thinsp",
    "\u200A": "hairsp",
    "\u2004": "emsp13",
    "\u2002": "ensp",
    "\u2005": "emsp14",
    "\u2003": "emsp",
    "\u2007": "numsp",
    "\xA0": "nbsp",
    "\u205F\u200A": "ThickSpace",
    "\u203E": "oline",
    _: "lowbar",
    "\u2010": "dash",
    "\u2013": "ndash",
    "\u2014": "mdash",
    "\u2015": "horbar",
    ",": "comma",
    ";": "semi",
    "\u204F": "bsemi",
    ":": "colon",
    "\u2A74": "Colone",
    "!": "excl",
    "\xA1": "iexcl",
    "?": "quest",
    "\xBF": "iquest",
    ".": "period",
    "\u2025": "nldr",
    "\u2026": "mldr",
    "\xB7": "middot",
    "'": "apos",
    "\u2018": "lsquo",
    "\u2019": "rsquo",
    "\u201A": "sbquo",
    "\u2039": "lsaquo",
    "\u203A": "rsaquo",
    '"': "quot",
    "\u201C": "ldquo",
    "\u201D": "rdquo",
    "\u201E": "bdquo",
    "\xAB": "laquo",
    "\xBB": "raquo",
    "(": "lpar",
    ")": "rpar",
    "[": "lsqb",
    "]": "rsqb",
    "{": "lcub",
    "}": "rcub",
    "\u2308": "lceil",
    "\u2309": "rceil",
    "\u230A": "lfloor",
    "\u230B": "rfloor",
    "\u2985": "lopar",
    "\u2986": "ropar",
    "\u298B": "lbrke",
    "\u298C": "rbrke",
    "\u298D": "lbrkslu",
    "\u298E": "rbrksld",
    "\u298F": "lbrksld",
    "\u2990": "rbrkslu",
    "\u2991": "langd",
    "\u2992": "rangd",
    "\u2993": "lparlt",
    "\u2994": "rpargt",
    "\u2995": "gtlPar",
    "\u2996": "ltrPar",
    "\u27E6": "lobrk",
    "\u27E7": "robrk",
    "\u27E8": "lang",
    "\u27E9": "rang",
    "\u27EA": "Lang",
    "\u27EB": "Rang",
    "\u27EC": "loang",
    "\u27ED": "roang",
    "\u2772": "lbbrk",
    "\u2773": "rbbrk",
    "\u2016": "Vert",
    "\xA7": "sect",
    "\xB6": "para",
    "@": "commat",
    "*": "ast",
    "/": "sol",
    undefined: null,
    "&": "amp",
    "#": "num",
    "%": "percnt",
    "\u2030": "permil",
    "\u2031": "pertenk",
    "\u2020": "dagger",
    "\u2021": "Dagger",
    "\u2022": "bull",
    "\u2043": "hybull",
    "\u2032": "prime",
    "\u2033": "Prime",
    "\u2034": "tprime",
    "\u2057": "qprime",
    "\u2035": "bprime",
    "\u2041": "caret",
    "`": "grave",
    "\xB4": "acute",
    "\u02DC": "tilde",
    "^": "Hat",
    "\xAF": "macr",
    "\u02D8": "breve",
    "\u02D9": "dot",
    "\xA8": "die",
    "\u02DA": "ring",
    "\u02DD": "dblac",
    "\xB8": "cedil",
    "\u02DB": "ogon",
    "\u02C6": "circ",
    "\u02C7": "caron",
    "\xB0": "deg",
    "\xA9": "copy",
    "\xAE": "reg",
    "\u2117": "copysr",
    "\u2118": "wp",
    "\u211E": "rx",
    "\u2127": "mho",
    "\u2129": "iiota",
    "\u2190": "larr",
    "\u219A": "nlarr",
    "\u2192": "rarr",
    "\u219B": "nrarr",
    "\u2191": "uarr",
    "\u2193": "darr",
    "\u2194": "harr",
    "\u21AE": "nharr",
    "\u2195": "varr",
    "\u2196": "nwarr",
    "\u2197": "nearr",
    "\u2198": "searr",
    "\u2199": "swarr",
    "\u219D": "rarrw",
    "\u219D\u0338": "nrarrw",
    "\u219E": "Larr",
    "\u219F": "Uarr",
    "\u21A0": "Rarr",
    "\u21A1": "Darr",
    "\u21A2": "larrtl",
    "\u21A3": "rarrtl",
    "\u21A4": "mapstoleft",
    "\u21A5": "mapstoup",
    "\u21A6": "map",
    "\u21A7": "mapstodown",
    "\u21A9": "larrhk",
    "\u21AA": "rarrhk",
    "\u21AB": "larrlp",
    "\u21AC": "rarrlp",
    "\u21AD": "harrw",
    "\u21B0": "lsh",
    "\u21B1": "rsh",
    "\u21B2": "ldsh",
    "\u21B3": "rdsh",
    "\u21B5": "crarr",
    "\u21B6": "cularr",
    "\u21B7": "curarr",
    "\u21BA": "olarr",
    "\u21BB": "orarr",
    "\u21BC": "lharu",
    "\u21BD": "lhard",
    "\u21BE": "uharr",
    "\u21BF": "uharl",
    "\u21C0": "rharu",
    "\u21C1": "rhard",
    "\u21C2": "dharr",
    "\u21C3": "dharl",
    "\u21C4": "rlarr",
    "\u21C5": "udarr",
    "\u21C6": "lrarr",
    "\u21C7": "llarr",
    "\u21C8": "uuarr",
    "\u21C9": "rrarr",
    "\u21CA": "ddarr",
    "\u21CB": "lrhar",
    "\u21CC": "rlhar",
    "\u21D0": "lArr",
    "\u21CD": "nlArr",
    "\u21D1": "uArr",
    "\u21D2": "rArr",
    "\u21CF": "nrArr",
    "\u21D3": "dArr",
    "\u21D4": "iff",
    "\u21CE": "nhArr",
    "\u21D5": "vArr",
    "\u21D6": "nwArr",
    "\u21D7": "neArr",
    "\u21D8": "seArr",
    "\u21D9": "swArr",
    "\u21DA": "lAarr",
    "\u21DB": "rAarr",
    "\u21DD": "zigrarr",
    "\u21E4": "larrb",
    "\u21E5": "rarrb",
    "\u21F5": "duarr",
    "\u21FD": "loarr",
    "\u21FE": "roarr",
    "\u21FF": "hoarr",
    "\u2200": "forall",
    "\u2201": "comp",
    "\u2202": "part",
    "\u2202\u0338": "npart",
    "\u2203": "exist",
    "\u2204": "nexist",
    "\u2205": "empty",
    "\u2207": "Del",
    "\u2208": "in",
    "\u2209": "notin",
    "\u220B": "ni",
    "\u220C": "notni",
    "\u03F6": "bepsi",
    "\u220F": "prod",
    "\u2210": "coprod",
    "\u2211": "sum",
    "+": "plus",
    "\xB1": "pm",
    "\xF7": "div",
    "\xD7": "times",
    "<": "lt",
    "\u226E": "nlt",
    "<\u20D2": "nvlt",
    "=": "equals",
    "\u2260": "ne",
    "=\u20E5": "bne",
    "\u2A75": "Equal",
    ">": "gt",
    "\u226F": "ngt",
    ">\u20D2": "nvgt",
    "\xAC": "not",
    "|": "vert",
    "\xA6": "brvbar",
    "\u2212": "minus",
    "\u2213": "mp",
    "\u2214": "plusdo",
    "\u2044": "frasl",
    "\u2216": "setmn",
    "\u2217": "lowast",
    "\u2218": "compfn",
    "\u221A": "Sqrt",
    "\u221D": "prop",
    "\u221E": "infin",
    "\u221F": "angrt",
    "\u2220": "ang",
    "\u2220\u20D2": "nang",
    "\u2221": "angmsd",
    "\u2222": "angsph",
    "\u2223": "mid",
    "\u2224": "nmid",
    "\u2225": "par",
    "\u2226": "npar",
    "\u2227": "and",
    "\u2228": "or",
    "\u2229": "cap",
    "\u2229\uFE00": "caps",
    "\u222A": "cup",
    "\u222A\uFE00": "cups",
    "\u222B": "int",
    "\u222C": "Int",
    "\u222D": "tint",
    "\u2A0C": "qint",
    "\u222E": "oint",
    "\u222F": "Conint",
    "\u2230": "Cconint",
    "\u2231": "cwint",
    "\u2232": "cwconint",
    "\u2233": "awconint",
    "\u2234": "there4",
    "\u2235": "becaus",
    "\u2236": "ratio",
    "\u2237": "Colon",
    "\u2238": "minusd",
    "\u223A": "mDDot",
    "\u223B": "homtht",
    "\u223C": "sim",
    "\u2241": "nsim",
    "\u223C\u20D2": "nvsim",
    "\u223D": "bsim",
    "\u223D\u0331": "race",
    "\u223E": "ac",
    "\u223E\u0333": "acE",
    "\u223F": "acd",
    "\u2240": "wr",
    "\u2242": "esim",
    "\u2242\u0338": "nesim",
    "\u2243": "sime",
    "\u2244": "nsime",
    "\u2245": "cong",
    "\u2247": "ncong",
    "\u2246": "simne",
    "\u2248": "ap",
    "\u2249": "nap",
    "\u224A": "ape",
    "\u224B": "apid",
    "\u224B\u0338": "napid",
    "\u224C": "bcong",
    "\u224D": "CupCap",
    "\u226D": "NotCupCap",
    "\u224D\u20D2": "nvap",
    "\u224E": "bump",
    "\u224E\u0338": "nbump",
    "\u224F": "bumpe",
    "\u224F\u0338": "nbumpe",
    "\u2250": "doteq",
    "\u2250\u0338": "nedot",
    "\u2251": "eDot",
    "\u2252": "efDot",
    "\u2253": "erDot",
    "\u2254": "colone",
    "\u2255": "ecolon",
    "\u2256": "ecir",
    "\u2257": "cire",
    "\u2259": "wedgeq",
    "\u225A": "veeeq",
    "\u225C": "trie",
    "\u225F": "equest",
    "\u2261": "equiv",
    "\u2262": "nequiv",
    "\u2261\u20E5": "bnequiv",
    "\u2264": "le",
    "\u2270": "nle",
    "\u2264\u20D2": "nvle",
    "\u2265": "ge",
    "\u2271": "nge",
    "\u2265\u20D2": "nvge",
    "\u2266": "lE",
    "\u2266\u0338": "nlE",
    "\u2267": "gE",
    "\u2267\u0338": "ngE",
    "\u2268\uFE00": "lvnE",
    "\u2268": "lnE",
    "\u2269": "gnE",
    "\u2269\uFE00": "gvnE",
    "\u226A": "ll",
    "\u226A\u0338": "nLtv",
    "\u226A\u20D2": "nLt",
    "\u226B": "gg",
    "\u226B\u0338": "nGtv",
    "\u226B\u20D2": "nGt",
    "\u226C": "twixt",
    "\u2272": "lsim",
    "\u2274": "nlsim",
    "\u2273": "gsim",
    "\u2275": "ngsim",
    "\u2276": "lg",
    "\u2278": "ntlg",
    "\u2277": "gl",
    "\u2279": "ntgl",
    "\u227A": "pr",
    "\u2280": "npr",
    "\u227B": "sc",
    "\u2281": "nsc",
    "\u227C": "prcue",
    "\u22E0": "nprcue",
    "\u227D": "sccue",
    "\u22E1": "nsccue",
    "\u227E": "prsim",
    "\u227F": "scsim",
    "\u227F\u0338": "NotSucceedsTilde",
    "\u2282": "sub",
    "\u2284": "nsub",
    "\u2282\u20D2": "vnsub",
    "\u2283": "sup",
    "\u2285": "nsup",
    "\u2283\u20D2": "vnsup",
    "\u2286": "sube",
    "\u2288": "nsube",
    "\u2287": "supe",
    "\u2289": "nsupe",
    "\u228A\uFE00": "vsubne",
    "\u228A": "subne",
    "\u228B\uFE00": "vsupne",
    "\u228B": "supne",
    "\u228D": "cupdot",
    "\u228E": "uplus",
    "\u228F": "sqsub",
    "\u228F\u0338": "NotSquareSubset",
    "\u2290": "sqsup",
    "\u2290\u0338": "NotSquareSuperset",
    "\u2291": "sqsube",
    "\u22E2": "nsqsube",
    "\u2292": "sqsupe",
    "\u22E3": "nsqsupe",
    "\u2293": "sqcap",
    "\u2293\uFE00": "sqcaps",
    "\u2294": "sqcup",
    "\u2294\uFE00": "sqcups",
    "\u2295": "oplus",
    "\u2296": "ominus",
    "\u2297": "otimes",
    "\u2298": "osol",
    "\u2299": "odot",
    "\u229A": "ocir",
    "\u229B": "oast",
    "\u229D": "odash",
    "\u229E": "plusb",
    "\u229F": "minusb",
    "\u22A0": "timesb",
    "\u22A1": "sdotb",
    "\u22A2": "vdash",
    "\u22AC": "nvdash",
    "\u22A3": "dashv",
    "\u22A4": "top",
    "\u22A5": "bot",
    "\u22A7": "models",
    "\u22A8": "vDash",
    "\u22AD": "nvDash",
    "\u22A9": "Vdash",
    "\u22AE": "nVdash",
    "\u22AA": "Vvdash",
    "\u22AB": "VDash",
    "\u22AF": "nVDash",
    "\u22B0": "prurel",
    "\u22B2": "vltri",
    "\u22EA": "nltri",
    "\u22B3": "vrtri",
    "\u22EB": "nrtri",
    "\u22B4": "ltrie",
    "\u22EC": "nltrie",
    "\u22B4\u20D2": "nvltrie",
    "\u22B5": "rtrie",
    "\u22ED": "nrtrie",
    "\u22B5\u20D2": "nvrtrie",
    "\u22B6": "origof",
    "\u22B7": "imof",
    "\u22B8": "mumap",
    "\u22B9": "hercon",
    "\u22BA": "intcal",
    "\u22BB": "veebar",
    "\u22BD": "barvee",
    "\u22BE": "angrtvb",
    "\u22BF": "lrtri",
    "\u22C0": "Wedge",
    "\u22C1": "Vee",
    "\u22C2": "xcap",
    "\u22C3": "xcup",
    "\u22C4": "diam",
    "\u22C5": "sdot",
    "\u22C6": "Star",
    "\u22C7": "divonx",
    "\u22C8": "bowtie",
    "\u22C9": "ltimes",
    "\u22CA": "rtimes",
    "\u22CB": "lthree",
    "\u22CC": "rthree",
    "\u22CD": "bsime",
    "\u22CE": "cuvee",
    "\u22CF": "cuwed",
    "\u22D0": "Sub",
    "\u22D1": "Sup",
    "\u22D2": "Cap",
    "\u22D3": "Cup",
    "\u22D4": "fork",
    "\u22D5": "epar",
    "\u22D6": "ltdot",
    "\u22D7": "gtdot",
    "\u22D8": "Ll",
    "\u22D8\u0338": "nLl",
    "\u22D9": "Gg",
    "\u22D9\u0338": "nGg",
    "\u22DA\uFE00": "lesg",
    "\u22DA": "leg",
    "\u22DB": "gel",
    "\u22DB\uFE00": "gesl",
    "\u22DE": "cuepr",
    "\u22DF": "cuesc",
    "\u22E6": "lnsim",
    "\u22E7": "gnsim",
    "\u22E8": "prnsim",
    "\u22E9": "scnsim",
    "\u22EE": "vellip",
    "\u22EF": "ctdot",
    "\u22F0": "utdot",
    "\u22F1": "dtdot",
    "\u22F2": "disin",
    "\u22F3": "isinsv",
    "\u22F4": "isins",
    "\u22F5": "isindot",
    "\u22F5\u0338": "notindot",
    "\u22F6": "notinvc",
    "\u22F7": "notinvb",
    "\u22F9": "isinE",
    "\u22F9\u0338": "notinE",
    "\u22FA": "nisd",
    "\u22FB": "xnis",
    "\u22FC": "nis",
    "\u22FD": "notnivc",
    "\u22FE": "notnivb",
    "\u2305": "barwed",
    "\u2306": "Barwed",
    "\u230C": "drcrop",
    "\u230D": "dlcrop",
    "\u230E": "urcrop",
    "\u230F": "ulcrop",
    "\u2310": "bnot",
    "\u2312": "profline",
    "\u2313": "profsurf",
    "\u2315": "telrec",
    "\u2316": "target",
    "\u231C": "ulcorn",
    "\u231D": "urcorn",
    "\u231E": "dlcorn",
    "\u231F": "drcorn",
    "\u2322": "frown",
    "\u2323": "smile",
    "\u232D": "cylcty",
    "\u232E": "profalar",
    "\u2336": "topbot",
    "\u233D": "ovbar",
    "\u233F": "solbar",
    "\u237C": "angzarr",
    "\u23B0": "lmoust",
    "\u23B1": "rmoust",
    "\u23B4": "tbrk",
    "\u23B5": "bbrk",
    "\u23B6": "bbrktbrk",
    "\u23DC": "OverParenthesis",
    "\u23DD": "UnderParenthesis",
    "\u23DE": "OverBrace",
    "\u23DF": "UnderBrace",
    "\u23E2": "trpezium",
    "\u23E7": "elinters",
    "\u2423": "blank",
    "\u2500": "boxh",
    "\u2502": "boxv",
    "\u250C": "boxdr",
    "\u2510": "boxdl",
    "\u2514": "boxur",
    "\u2518": "boxul",
    "\u251C": "boxvr",
    "\u2524": "boxvl",
    "\u252C": "boxhd",
    "\u2534": "boxhu",
    "\u253C": "boxvh",
    "\u2550": "boxH",
    "\u2551": "boxV",
    "\u2552": "boxdR",
    "\u2553": "boxDr",
    "\u2554": "boxDR",
    "\u2555": "boxdL",
    "\u2556": "boxDl",
    "\u2557": "boxDL",
    "\u2558": "boxuR",
    "\u2559": "boxUr",
    "\u255A": "boxUR",
    "\u255B": "boxuL",
    "\u255C": "boxUl",
    "\u255D": "boxUL",
    "\u255E": "boxvR",
    "\u255F": "boxVr",
    "\u2560": "boxVR",
    "\u2561": "boxvL",
    "\u2562": "boxVl",
    "\u2563": "boxVL",
    "\u2564": "boxHd",
    "\u2565": "boxhD",
    "\u2566": "boxHD",
    "\u2567": "boxHu",
    "\u2568": "boxhU",
    "\u2569": "boxHU",
    "\u256A": "boxvH",
    "\u256B": "boxVh",
    "\u256C": "boxVH",
    "\u2580": "uhblk",
    "\u2584": "lhblk",
    "\u2588": "block",
    "\u2591": "blk14",
    "\u2592": "blk12",
    "\u2593": "blk34",
    "\u25A1": "squ",
    "\u25AA": "squf",
    "\u25AB": "EmptyVerySmallSquare",
    "\u25AD": "rect",
    "\u25AE": "marker",
    "\u25B1": "fltns",
    "\u25B3": "xutri",
    "\u25B4": "utrif",
    "\u25B5": "utri",
    "\u25B8": "rtrif",
    "\u25B9": "rtri",
    "\u25BD": "xdtri",
    "\u25BE": "dtrif",
    "\u25BF": "dtri",
    "\u25C2": "ltrif",
    "\u25C3": "ltri",
    "\u25CA": "loz",
    "\u25CB": "cir",
    "\u25EC": "tridot",
    "\u25EF": "xcirc",
    "\u25F8": "ultri",
    "\u25F9": "urtri",
    "\u25FA": "lltri",
    "\u25FB": "EmptySmallSquare",
    "\u25FC": "FilledSmallSquare",
    "\u2605": "starf",
    "\u2606": "star",
    "\u260E": "phone",
    "\u2640": "female",
    "\u2642": "male",
    "\u2660": "spades",
    "\u2663": "clubs",
    "\u2665": "hearts",
    "\u2666": "diams",
    "\u266A": "sung",
    "\u2713": "check",
    "\u2717": "cross",
    "\u2720": "malt",
    "\u2736": "sext",
    "\u2758": "VerticalSeparator",
    "\u27C8": "bsolhsub",
    "\u27C9": "suphsol",
    "\u27F5": "xlarr",
    "\u27F6": "xrarr",
    "\u27F7": "xharr",
    "\u27F8": "xlArr",
    "\u27F9": "xrArr",
    "\u27FA": "xhArr",
    "\u27FC": "xmap",
    "\u27FF": "dzigrarr",
    "\u2902": "nvlArr",
    "\u2903": "nvrArr",
    "\u2904": "nvHarr",
    "\u2905": "Map",
    "\u290C": "lbarr",
    "\u290D": "rbarr",
    "\u290E": "lBarr",
    "\u290F": "rBarr",
    "\u2910": "RBarr",
    "\u2911": "DDotrahd",
    "\u2912": "UpArrowBar",
    "\u2913": "DownArrowBar",
    "\u2916": "Rarrtl",
    "\u2919": "latail",
    "\u291A": "ratail",
    "\u291B": "lAtail",
    "\u291C": "rAtail",
    "\u291D": "larrfs",
    "\u291E": "rarrfs",
    "\u291F": "larrbfs",
    "\u2920": "rarrbfs",
    "\u2923": "nwarhk",
    "\u2924": "nearhk",
    "\u2925": "searhk",
    "\u2926": "swarhk",
    "\u2927": "nwnear",
    "\u2928": "toea",
    "\u2929": "tosa",
    "\u292A": "swnwar",
    "\u2933": "rarrc",
    "\u2933\u0338": "nrarrc",
    "\u2935": "cudarrr",
    "\u2936": "ldca",
    "\u2937": "rdca",
    "\u2938": "cudarrl",
    "\u2939": "larrpl",
    "\u293C": "curarrm",
    "\u293D": "cularrp",
    "\u2945": "rarrpl",
    "\u2948": "harrcir",
    "\u2949": "Uarrocir",
    "\u294A": "lurdshar",
    "\u294B": "ldrushar",
    "\u294E": "LeftRightVector",
    "\u294F": "RightUpDownVector",
    "\u2950": "DownLeftRightVector",
    "\u2951": "LeftUpDownVector",
    "\u2952": "LeftVectorBar",
    "\u2953": "RightVectorBar",
    "\u2954": "RightUpVectorBar",
    "\u2955": "RightDownVectorBar",
    "\u2956": "DownLeftVectorBar",
    "\u2957": "DownRightVectorBar",
    "\u2958": "LeftUpVectorBar",
    "\u2959": "LeftDownVectorBar",
    "\u295A": "LeftTeeVector",
    "\u295B": "RightTeeVector",
    "\u295C": "RightUpTeeVector",
    "\u295D": "RightDownTeeVector",
    "\u295E": "DownLeftTeeVector",
    "\u295F": "DownRightTeeVector",
    "\u2960": "LeftUpTeeVector",
    "\u2961": "LeftDownTeeVector",
    "\u2962": "lHar",
    "\u2963": "uHar",
    "\u2964": "rHar",
    "\u2965": "dHar",
    "\u2966": "luruhar",
    "\u2967": "ldrdhar",
    "\u2968": "ruluhar",
    "\u2969": "rdldhar",
    "\u296A": "lharul",
    "\u296B": "llhard",
    "\u296C": "rharul",
    "\u296D": "lrhard",
    "\u296E": "udhar",
    "\u296F": "duhar",
    "\u2970": "RoundImplies",
    "\u2971": "erarr",
    "\u2972": "simrarr",
    "\u2973": "larrsim",
    "\u2974": "rarrsim",
    "\u2975": "rarrap",
    "\u2976": "ltlarr",
    "\u2978": "gtrarr",
    "\u2979": "subrarr",
    "\u297B": "suplarr",
    "\u297C": "lfisht",
    "\u297D": "rfisht",
    "\u297E": "ufisht",
    "\u297F": "dfisht",
    "\u299A": "vzigzag",
    "\u299C": "vangrt",
    "\u299D": "angrtvbd",
    "\u29A4": "ange",
    "\u29A5": "range",
    "\u29A6": "dwangle",
    "\u29A7": "uwangle",
    "\u29A8": "angmsdaa",
    "\u29A9": "angmsdab",
    "\u29AA": "angmsdac",
    "\u29AB": "angmsdad",
    "\u29AC": "angmsdae",
    "\u29AD": "angmsdaf",
    "\u29AE": "angmsdag",
    "\u29AF": "angmsdah",
    "\u29B0": "bemptyv",
    "\u29B1": "demptyv",
    "\u29B2": "cemptyv",
    "\u29B3": "raemptyv",
    "\u29B4": "laemptyv",
    "\u29B5": "ohbar",
    "\u29B6": "omid",
    "\u29B7": "opar",
    "\u29B9": "operp",
    "\u29BB": "olcross",
    "\u29BC": "odsold",
    "\u29BE": "olcir",
    "\u29BF": "ofcir",
    "\u29C0": "olt",
    "\u29C1": "ogt",
    "\u29C2": "cirscir",
    "\u29C3": "cirE",
    "\u29C4": "solb",
    "\u29C5": "bsolb",
    "\u29C9": "boxbox",
    "\u29CD": "trisb",
    "\u29CE": "rtriltri",
    "\u29CF": "LeftTriangleBar",
    "\u29CF\u0338": "NotLeftTriangleBar",
    "\u29D0": "RightTriangleBar",
    "\u29D0\u0338": "NotRightTriangleBar",
    "\u29DC": "iinfin",
    "\u29DD": "infintie",
    "\u29DE": "nvinfin",
    "\u29E3": "eparsl",
    "\u29E4": "smeparsl",
    "\u29E5": "eqvparsl",
    "\u29EB": "lozf",
    "\u29F4": "RuleDelayed",
    "\u29F6": "dsol",
    "\u2A00": "xodot",
    "\u2A01": "xoplus",
    "\u2A02": "xotime",
    "\u2A04": "xuplus",
    "\u2A06": "xsqcup",
    "\u2A0D": "fpartint",
    "\u2A10": "cirfnint",
    "\u2A11": "awint",
    "\u2A12": "rppolint",
    "\u2A13": "scpolint",
    "\u2A14": "npolint",
    "\u2A15": "pointint",
    "\u2A16": "quatint",
    "\u2A17": "intlarhk",
    "\u2A22": "pluscir",
    "\u2A23": "plusacir",
    "\u2A24": "simplus",
    "\u2A25": "plusdu",
    "\u2A26": "plussim",
    "\u2A27": "plustwo",
    "\u2A29": "mcomma",
    "\u2A2A": "minusdu",
    "\u2A2D": "loplus",
    "\u2A2E": "roplus",
    "\u2A2F": "Cross",
    "\u2A30": "timesd",
    "\u2A31": "timesbar",
    "\u2A33": "smashp",
    "\u2A34": "lotimes",
    "\u2A35": "rotimes",
    "\u2A36": "otimesas",
    "\u2A37": "Otimes",
    "\u2A38": "odiv",
    "\u2A39": "triplus",
    "\u2A3A": "triminus",
    "\u2A3B": "tritime",
    "\u2A3C": "iprod",
    "\u2A3F": "amalg",
    "\u2A40": "capdot",
    "\u2A42": "ncup",
    "\u2A43": "ncap",
    "\u2A44": "capand",
    "\u2A45": "cupor",
    "\u2A46": "cupcap",
    "\u2A47": "capcup",
    "\u2A48": "cupbrcap",
    "\u2A49": "capbrcup",
    "\u2A4A": "cupcup",
    "\u2A4B": "capcap",
    "\u2A4C": "ccups",
    "\u2A4D": "ccaps",
    "\u2A50": "ccupssm",
    "\u2A53": "And",
    "\u2A54": "Or",
    "\u2A55": "andand",
    "\u2A56": "oror",
    "\u2A57": "orslope",
    "\u2A58": "andslope",
    "\u2A5A": "andv",
    "\u2A5B": "orv",
    "\u2A5C": "andd",
    "\u2A5D": "ord",
    "\u2A5F": "wedbar",
    "\u2A66": "sdote",
    "\u2A6A": "simdot",
    "\u2A6D": "congdot",
    "\u2A6D\u0338": "ncongdot",
    "\u2A6E": "easter",
    "\u2A6F": "apacir",
    "\u2A70": "apE",
    "\u2A70\u0338": "napE",
    "\u2A71": "eplus",
    "\u2A72": "pluse",
    "\u2A73": "Esim",
    "\u2A77": "eDDot",
    "\u2A78": "equivDD",
    "\u2A79": "ltcir",
    "\u2A7A": "gtcir",
    "\u2A7B": "ltquest",
    "\u2A7C": "gtquest",
    "\u2A7D": "les",
    "\u2A7D\u0338": "nles",
    "\u2A7E": "ges",
    "\u2A7E\u0338": "nges",
    "\u2A7F": "lesdot",
    "\u2A80": "gesdot",
    "\u2A81": "lesdoto",
    "\u2A82": "gesdoto",
    "\u2A83": "lesdotor",
    "\u2A84": "gesdotol",
    "\u2A85": "lap",
    "\u2A86": "gap",
    "\u2A87": "lne",
    "\u2A88": "gne",
    "\u2A89": "lnap",
    "\u2A8A": "gnap",
    "\u2A8B": "lEg",
    "\u2A8C": "gEl",
    "\u2A8D": "lsime",
    "\u2A8E": "gsime",
    "\u2A8F": "lsimg",
    "\u2A90": "gsiml",
    "\u2A91": "lgE",
    "\u2A92": "glE",
    "\u2A93": "lesges",
    "\u2A94": "gesles",
    "\u2A95": "els",
    "\u2A96": "egs",
    "\u2A97": "elsdot",
    "\u2A98": "egsdot",
    "\u2A99": "el",
    "\u2A9A": "eg",
    "\u2A9D": "siml",
    "\u2A9E": "simg",
    "\u2A9F": "simlE",
    "\u2AA0": "simgE",
    "\u2AA1": "LessLess",
    "\u2AA1\u0338": "NotNestedLessLess",
    "\u2AA2": "GreaterGreater",
    "\u2AA2\u0338": "NotNestedGreaterGreater",
    "\u2AA4": "glj",
    "\u2AA5": "gla",
    "\u2AA6": "ltcc",
    "\u2AA7": "gtcc",
    "\u2AA8": "lescc",
    "\u2AA9": "gescc",
    "\u2AAA": "smt",
    "\u2AAB": "lat",
    "\u2AAC": "smte",
    "\u2AAC\uFE00": "smtes",
    "\u2AAD": "late",
    "\u2AAD\uFE00": "lates",
    "\u2AAE": "bumpE",
    "\u2AAF": "pre",
    "\u2AAF\u0338": "npre",
    "\u2AB0": "sce",
    "\u2AB0\u0338": "nsce",
    "\u2AB3": "prE",
    "\u2AB4": "scE",
    "\u2AB5": "prnE",
    "\u2AB6": "scnE",
    "\u2AB7": "prap",
    "\u2AB8": "scap",
    "\u2AB9": "prnap",
    "\u2ABA": "scnap",
    "\u2ABB": "Pr",
    "\u2ABC": "Sc",
    "\u2ABD": "subdot",
    "\u2ABE": "supdot",
    "\u2ABF": "subplus",
    "\u2AC0": "supplus",
    "\u2AC1": "submult",
    "\u2AC2": "supmult",
    "\u2AC3": "subedot",
    "\u2AC4": "supedot",
    "\u2AC5": "subE",
    "\u2AC5\u0338": "nsubE",
    "\u2AC6": "supE",
    "\u2AC6\u0338": "nsupE",
    "\u2AC7": "subsim",
    "\u2AC8": "supsim",
    "\u2ACB\uFE00": "vsubnE",
    "\u2ACB": "subnE",
    "\u2ACC\uFE00": "vsupnE",
    "\u2ACC": "supnE",
    "\u2ACF": "csub",
    "\u2AD0": "csup",
    "\u2AD1": "csube",
    "\u2AD2": "csupe",
    "\u2AD3": "subsup",
    "\u2AD4": "supsub",
    "\u2AD5": "subsub",
    "\u2AD6": "supsup",
    "\u2AD7": "suphsub",
    "\u2AD8": "supdsub",
    "\u2AD9": "forkv",
    "\u2ADA": "topfork",
    "\u2ADB": "mlcp",
    "\u2AE4": "Dashv",
    "\u2AE6": "Vdashl",
    "\u2AE7": "Barv",
    "\u2AE8": "vBar",
    "\u2AE9": "vBarv",
    "\u2AEB": "Vbar",
    "\u2AEC": "Not",
    "\u2AED": "bNot",
    "\u2AEE": "rnmid",
    "\u2AEF": "cirmid",
    "\u2AF0": "midcir",
    "\u2AF1": "topcir",
    "\u2AF2": "nhpar",
    "\u2AF3": "parsim",
    "\u2AFD": "parsl",
    "\u2AFD\u20E5": "nparsl",
    "\u266D": "flat",
    "\u266E": "natur",
    "\u266F": "sharp",
    "\xA4": "curren",
    "\xA2": "cent",
    $: "dollar",
    "\xA3": "pound",
    "\xA5": "yen",
    "\u20AC": "euro",
    "\xB9": "sup1",
    "\xBD": "half",
    "\u2153": "frac13",
    "\xBC": "frac14",
    "\u2155": "frac15",
    "\u2159": "frac16",
    "\u215B": "frac18",
    "\xB2": "sup2",
    "\u2154": "frac23",
    "\u2156": "frac25",
    "\xB3": "sup3",
    "\xBE": "frac34",
    "\u2157": "frac35",
    "\u215C": "frac38",
    "\u2158": "frac45",
    "\u215A": "frac56",
    "\u215D": "frac58",
    "\u215E": "frac78",
    "\uD835\uDCB6": "ascr",
    "\uD835\uDD52": "aopf",
    "\uD835\uDD1E": "afr",
    "\uD835\uDD38": "Aopf",
    "\uD835\uDD04": "Afr",
    "\uD835\uDC9C": "Ascr",
    "\xAA": "ordf",
    "\xE1": "aacute",
    "\xC1": "Aacute",
    "\xE0": "agrave",
    "\xC0": "Agrave",
    "\u0103": "abreve",
    "\u0102": "Abreve",
    "\xE2": "acirc",
    "\xC2": "Acirc",
    "\xE5": "aring",
    "\xC5": "angst",
    "\xE4": "auml",
    "\xC4": "Auml",
    "\xE3": "atilde",
    "\xC3": "Atilde",
    "\u0105": "aogon",
    "\u0104": "Aogon",
    "\u0101": "amacr",
    "\u0100": "Amacr",
    "\xE6": "aelig",
    "\xC6": "AElig",
    "\uD835\uDCB7": "bscr",
    "\uD835\uDD53": "bopf",
    "\uD835\uDD1F": "bfr",
    "\uD835\uDD39": "Bopf",
    "\u212C": "Bscr",
    "\uD835\uDD05": "Bfr",
    "\uD835\uDD20": "cfr",
    "\uD835\uDCB8": "cscr",
    "\uD835\uDD54": "copf",
    "\u212D": "Cfr",
    "\uD835\uDC9E": "Cscr",
    "\u2102": "Copf",
    "\u0107": "cacute",
    "\u0106": "Cacute",
    "\u0109": "ccirc",
    "\u0108": "Ccirc",
    "\u010D": "ccaron",
    "\u010C": "Ccaron",
    "\u010B": "cdot",
    "\u010A": "Cdot",
    "\xE7": "ccedil",
    "\xC7": "Ccedil",
    "\u2105": "incare",
    "\uD835\uDD21": "dfr",
    "\u2146": "dd",
    "\uD835\uDD55": "dopf",
    "\uD835\uDCB9": "dscr",
    "\uD835\uDC9F": "Dscr",
    "\uD835\uDD07": "Dfr",
    "\u2145": "DD",
    "\uD835\uDD3B": "Dopf",
    "\u010F": "dcaron",
    "\u010E": "Dcaron",
    "\u0111": "dstrok",
    "\u0110": "Dstrok",
    "\xF0": "eth",
    "\xD0": "ETH",
    "\u2147": "ee",
    "\u212F": "escr",
    "\uD835\uDD22": "efr",
    "\uD835\uDD56": "eopf",
    "\u2130": "Escr",
    "\uD835\uDD08": "Efr",
    "\uD835\uDD3C": "Eopf",
    "\xE9": "eacute",
    "\xC9": "Eacute",
    "\xE8": "egrave",
    "\xC8": "Egrave",
    "\xEA": "ecirc",
    "\xCA": "Ecirc",
    "\u011B": "ecaron",
    "\u011A": "Ecaron",
    "\xEB": "euml",
    "\xCB": "Euml",
    "\u0117": "edot",
    "\u0116": "Edot",
    "\u0119": "eogon",
    "\u0118": "Eogon",
    "\u0113": "emacr",
    "\u0112": "Emacr",
    "\uD835\uDD23": "ffr",
    "\uD835\uDD57": "fopf",
    "\uD835\uDCBB": "fscr",
    "\uD835\uDD09": "Ffr",
    "\uD835\uDD3D": "Fopf",
    "\u2131": "Fscr",
    "\uFB00": "fflig",
    "\uFB03": "ffilig",
    "\uFB04": "ffllig",
    "\uFB01": "filig",
    fj: "fjlig",
    "\uFB02": "fllig",
    "\u0192": "fnof",
    "\u210A": "gscr",
    "\uD835\uDD58": "gopf",
    "\uD835\uDD24": "gfr",
    "\uD835\uDCA2": "Gscr",
    "\uD835\uDD3E": "Gopf",
    "\uD835\uDD0A": "Gfr",
    "\u01F5": "gacute",
    "\u011F": "gbreve",
    "\u011E": "Gbreve",
    "\u011D": "gcirc",
    "\u011C": "Gcirc",
    "\u0121": "gdot",
    "\u0120": "Gdot",
    "\u0122": "Gcedil",
    "\uD835\uDD25": "hfr",
    "\u210E": "planckh",
    "\uD835\uDCBD": "hscr",
    "\uD835\uDD59": "hopf",
    "\u210B": "Hscr",
    "\u210C": "Hfr",
    "\u210D": "Hopf",
    "\u0125": "hcirc",
    "\u0124": "Hcirc",
    "\u210F": "hbar",
    "\u0127": "hstrok",
    "\u0126": "Hstrok",
    "\uD835\uDD5A": "iopf",
    "\uD835\uDD26": "ifr",
    "\uD835\uDCBE": "iscr",
    "\u2148": "ii",
    "\uD835\uDD40": "Iopf",
    "\u2110": "Iscr",
    "\u2111": "Im",
    "\xED": "iacute",
    "\xCD": "Iacute",
    "\xEC": "igrave",
    "\xCC": "Igrave",
    "\xEE": "icirc",
    "\xCE": "Icirc",
    "\xEF": "iuml",
    "\xCF": "Iuml",
    "\u0129": "itilde",
    "\u0128": "Itilde",
    "\u0130": "Idot",
    "\u012F": "iogon",
    "\u012E": "Iogon",
    "\u012B": "imacr",
    "\u012A": "Imacr",
    "\u0133": "ijlig",
    "\u0132": "IJlig",
    "\u0131": "imath",
    "\uD835\uDCBF": "jscr",
    "\uD835\uDD5B": "jopf",
    "\uD835\uDD27": "jfr",
    "\uD835\uDCA5": "Jscr",
    "\uD835\uDD0D": "Jfr",
    "\uD835\uDD41": "Jopf",
    "\u0135": "jcirc",
    "\u0134": "Jcirc",
    "\u0237": "jmath",
    "\uD835\uDD5C": "kopf",
    "\uD835\uDCC0": "kscr",
    "\uD835\uDD28": "kfr",
    "\uD835\uDCA6": "Kscr",
    "\uD835\uDD42": "Kopf",
    "\uD835\uDD0E": "Kfr",
    "\u0137": "kcedil",
    "\u0136": "Kcedil",
    "\uD835\uDD29": "lfr",
    "\uD835\uDCC1": "lscr",
    "\u2113": "ell",
    "\uD835\uDD5D": "lopf",
    "\u2112": "Lscr",
    "\uD835\uDD0F": "Lfr",
    "\uD835\uDD43": "Lopf",
    "\u013A": "lacute",
    "\u0139": "Lacute",
    "\u013E": "lcaron",
    "\u013D": "Lcaron",
    "\u013C": "lcedil",
    "\u013B": "Lcedil",
    "\u0142": "lstrok",
    "\u0141": "Lstrok",
    "\u0140": "lmidot",
    "\u013F": "Lmidot",
    "\uD835\uDD2A": "mfr",
    "\uD835\uDD5E": "mopf",
    "\uD835\uDCC2": "mscr",
    "\uD835\uDD10": "Mfr",
    "\uD835\uDD44": "Mopf",
    "\u2133": "Mscr",
    "\uD835\uDD2B": "nfr",
    "\uD835\uDD5F": "nopf",
    "\uD835\uDCC3": "nscr",
    "\u2115": "Nopf",
    "\uD835\uDCA9": "Nscr",
    "\uD835\uDD11": "Nfr",
    "\u0144": "nacute",
    "\u0143": "Nacute",
    "\u0148": "ncaron",
    "\u0147": "Ncaron",
    "\xF1": "ntilde",
    "\xD1": "Ntilde",
    "\u0146": "ncedil",
    "\u0145": "Ncedil",
    "\u2116": "numero",
    "\u014B": "eng",
    "\u014A": "ENG",
    "\uD835\uDD60": "oopf",
    "\uD835\uDD2C": "ofr",
    "\u2134": "oscr",
    "\uD835\uDCAA": "Oscr",
    "\uD835\uDD12": "Ofr",
    "\uD835\uDD46": "Oopf",
    "\xBA": "ordm",
    "\xF3": "oacute",
    "\xD3": "Oacute",
    "\xF2": "ograve",
    "\xD2": "Ograve",
    "\xF4": "ocirc",
    "\xD4": "Ocirc",
    "\xF6": "ouml",
    "\xD6": "Ouml",
    "\u0151": "odblac",
    "\u0150": "Odblac",
    "\xF5": "otilde",
    "\xD5": "Otilde",
    "\xF8": "oslash",
    "\xD8": "Oslash",
    "\u014D": "omacr",
    "\u014C": "Omacr",
    "\u0153": "oelig",
    "\u0152": "OElig",
    "\uD835\uDD2D": "pfr",
    "\uD835\uDCC5": "pscr",
    "\uD835\uDD61": "popf",
    "\u2119": "Popf",
    "\uD835\uDD13": "Pfr",
    "\uD835\uDCAB": "Pscr",
    "\uD835\uDD62": "qopf",
    "\uD835\uDD2E": "qfr",
    "\uD835\uDCC6": "qscr",
    "\uD835\uDCAC": "Qscr",
    "\uD835\uDD14": "Qfr",
    "\u211A": "Qopf",
    "\u0138": "kgreen",
    "\uD835\uDD2F": "rfr",
    "\uD835\uDD63": "ropf",
    "\uD835\uDCC7": "rscr",
    "\u211B": "Rscr",
    "\u211C": "Re",
    "\u211D": "Ropf",
    "\u0155": "racute",
    "\u0154": "Racute",
    "\u0159": "rcaron",
    "\u0158": "Rcaron",
    "\u0157": "rcedil",
    "\u0156": "Rcedil",
    "\uD835\uDD64": "sopf",
    "\uD835\uDCC8": "sscr",
    "\uD835\uDD30": "sfr",
    "\uD835\uDD4A": "Sopf",
    "\uD835\uDD16": "Sfr",
    "\uD835\uDCAE": "Sscr",
    "\u24C8": "oS",
    "\u015B": "sacute",
    "\u015A": "Sacute",
    "\u015D": "scirc",
    "\u015C": "Scirc",
    "\u0161": "scaron",
    "\u0160": "Scaron",
    "\u015F": "scedil",
    "\u015E": "Scedil",
    "\xDF": "szlig",
    "\uD835\uDD31": "tfr",
    "\uD835\uDCC9": "tscr",
    "\uD835\uDD65": "topf",
    "\uD835\uDCAF": "Tscr",
    "\uD835\uDD17": "Tfr",
    "\uD835\uDD4B": "Topf",
    "\u0165": "tcaron",
    "\u0164": "Tcaron",
    "\u0163": "tcedil",
    "\u0162": "Tcedil",
    "\u2122": "trade",
    "\u0167": "tstrok",
    "\u0166": "Tstrok",
    "\uD835\uDCCA": "uscr",
    "\uD835\uDD66": "uopf",
    "\uD835\uDD32": "ufr",
    "\uD835\uDD4C": "Uopf",
    "\uD835\uDD18": "Ufr",
    "\uD835\uDCB0": "Uscr",
    "\xFA": "uacute",
    "\xDA": "Uacute",
    "\xF9": "ugrave",
    "\xD9": "Ugrave",
    "\u016D": "ubreve",
    "\u016C": "Ubreve",
    "\xFB": "ucirc",
    "\xDB": "Ucirc",
    "\u016F": "uring",
    "\u016E": "Uring",
    "\xFC": "uuml",
    "\xDC": "Uuml",
    "\u0171": "udblac",
    "\u0170": "Udblac",
    "\u0169": "utilde",
    "\u0168": "Utilde",
    "\u0173": "uogon",
    "\u0172": "Uogon",
    "\u016B": "umacr",
    "\u016A": "Umacr",
    "\uD835\uDD33": "vfr",
    "\uD835\uDD67": "vopf",
    "\uD835\uDCCB": "vscr",
    "\uD835\uDD19": "Vfr",
    "\uD835\uDD4D": "Vopf",
    "\uD835\uDCB1": "Vscr",
    "\uD835\uDD68": "wopf",
    "\uD835\uDCCC": "wscr",
    "\uD835\uDD34": "wfr",
    "\uD835\uDCB2": "Wscr",
    "\uD835\uDD4E": "Wopf",
    "\uD835\uDD1A": "Wfr",
    "\u0175": "wcirc",
    "\u0174": "Wcirc",
    "\uD835\uDD35": "xfr",
    "\uD835\uDCCD": "xscr",
    "\uD835\uDD69": "xopf",
    "\uD835\uDD4F": "Xopf",
    "\uD835\uDD1B": "Xfr",
    "\uD835\uDCB3": "Xscr",
    "\uD835\uDD36": "yfr",
    "\uD835\uDCCE": "yscr",
    "\uD835\uDD6A": "yopf",
    "\uD835\uDCB4": "Yscr",
    "\uD835\uDD1C": "Yfr",
    "\uD835\uDD50": "Yopf",
    "\xFD": "yacute",
    "\xDD": "Yacute",
    "\u0177": "ycirc",
    "\u0176": "Ycirc",
    "\xFF": "yuml",
    "\u0178": "Yuml",
    "\uD835\uDCCF": "zscr",
    "\uD835\uDD37": "zfr",
    "\uD835\uDD6B": "zopf",
    "\u2128": "Zfr",
    "\u2124": "Zopf",
    "\uD835\uDCB5": "Zscr",
    "\u017A": "zacute",
    "\u0179": "Zacute",
    "\u017E": "zcaron",
    "\u017D": "Zcaron",
    "\u017C": "zdot",
    "\u017B": "Zdot",
    "\u01B5": "imped",
    "\xFE": "thorn",
    "\xDE": "THORN",
    "\u0149": "napos",
    "\u03B1": "alpha",
    "\u0391": "Alpha",
    "\u03B2": "beta",
    "\u0392": "Beta",
    "\u03B3": "gamma",
    "\u0393": "Gamma",
    "\u03B4": "delta",
    "\u0394": "Delta",
    "\u03B5": "epsi",
    "\u03F5": "epsiv",
    "\u0395": "Epsilon",
    "\u03DD": "gammad",
    "\u03DC": "Gammad",
    "\u03B6": "zeta",
    "\u0396": "Zeta",
    "\u03B7": "eta",
    "\u0397": "Eta",
    "\u03B8": "theta",
    "\u03D1": "thetav",
    "\u0398": "Theta",
    "\u03B9": "iota",
    "\u0399": "Iota",
    "\u03BA": "kappa",
    "\u03F0": "kappav",
    "\u039A": "Kappa",
    "\u03BB": "lambda",
    "\u039B": "Lambda",
    "\u03BC": "mu",
    "\xB5": "micro",
    "\u039C": "Mu",
    "\u03BD": "nu",
    "\u039D": "Nu",
    "\u03BE": "xi",
    "\u039E": "Xi",
    "\u03BF": "omicron",
    "\u039F": "Omicron",
    "\u03C0": "pi",
    "\u03D6": "piv",
    "\u03A0": "Pi",
    "\u03C1": "rho",
    "\u03F1": "rhov",
    "\u03A1": "Rho",
    "\u03C3": "sigma",
    "\u03A3": "Sigma",
    "\u03C2": "sigmaf",
    "\u03C4": "tau",
    "\u03A4": "Tau",
    "\u03C5": "upsi",
    "\u03A5": "Upsilon",
    "\u03D2": "Upsi",
    "\u03C6": "phi",
    "\u03D5": "phiv",
    "\u03A6": "Phi",
    "\u03C7": "chi",
    "\u03A7": "Chi",
    "\u03C8": "psi",
    "\u03A8": "Psi",
    "\u03C9": "omega",
    "\u03A9": "ohm",
    "\u0430": "acy",
    "\u0410": "Acy",
    "\u0431": "bcy",
    "\u0411": "Bcy",
    "\u0432": "vcy",
    "\u0412": "Vcy",
    "\u0433": "gcy",
    "\u0413": "Gcy",
    "\u0453": "gjcy",
    "\u0403": "GJcy",
    "\u0434": "dcy",
    "\u0414": "Dcy",
    "\u0452": "djcy",
    "\u0402": "DJcy",
    "\u0435": "iecy",
    "\u0415": "IEcy",
    "\u0451": "iocy",
    "\u0401": "IOcy",
    "\u0454": "jukcy",
    "\u0404": "Jukcy",
    "\u0436": "zhcy",
    "\u0416": "ZHcy",
    "\u0437": "zcy",
    "\u0417": "Zcy",
    "\u0455": "dscy",
    "\u0405": "DScy",
    "\u0438": "icy",
    "\u0418": "Icy",
    "\u0456": "iukcy",
    "\u0406": "Iukcy",
    "\u0457": "yicy",
    "\u0407": "YIcy",
    "\u0439": "jcy",
    "\u0419": "Jcy",
    "\u0458": "jsercy",
    "\u0408": "Jsercy",
    "\u043A": "kcy",
    "\u041A": "Kcy",
    "\u045C": "kjcy",
    "\u040C": "KJcy",
    "\u043B": "lcy",
    "\u041B": "Lcy",
    "\u0459": "ljcy",
    "\u0409": "LJcy",
    "\u043C": "mcy",
    "\u041C": "Mcy",
    "\u043D": "ncy",
    "\u041D": "Ncy",
    "\u045A": "njcy",
    "\u040A": "NJcy",
    "\u043E": "ocy",
    "\u041E": "Ocy",
    "\u043F": "pcy",
    "\u041F": "Pcy",
    "\u0440": "rcy",
    "\u0420": "Rcy",
    "\u0441": "scy",
    "\u0421": "Scy",
    "\u0442": "tcy",
    "\u0422": "Tcy",
    "\u045B": "tshcy",
    "\u040B": "TSHcy",
    "\u0443": "ucy",
    "\u0423": "Ucy",
    "\u045E": "ubrcy",
    "\u040E": "Ubrcy",
    "\u0444": "fcy",
    "\u0424": "Fcy",
    "\u0445": "khcy",
    "\u0425": "KHcy",
    "\u0446": "tscy",
    "\u0426": "TScy",
    "\u0447": "chcy",
    "\u0427": "CHcy",
    "\u045F": "dzcy",
    "\u040F": "DZcy",
    "\u0448": "shcy",
    "\u0428": "SHcy",
    "\u0449": "shchcy",
    "\u0429": "SHCHcy",
    "\u044A": "hardcy",
    "\u042A": "HARDcy",
    "\u044B": "ycy",
    "\u042B": "Ycy",
    "\u044C": "softcy",
    "\u042C": "SOFTcy",
    "\u044D": "ecy",
    "\u042D": "Ecy",
    "\u044E": "yucy",
    "\u042E": "YUcy",
    "\u044F": "yacy",
    "\u042F": "YAcy",
    "\u2135": "aleph",
    "\u2136": "beth",
    "\u2137": "gimel",
    "\u2138": "daleth",
  };

  var regexEscape = /["&'<>`]/g;
  var escapeMap = {
    '"': "&quot;",
    "&": "&amp;",
    "'": "&#x27;",
    "<": "&lt;",
    // See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
    // following is not strictly necessary unless it’s part of a tag or an
    // unquoted attribute value. We’re only escaping it to support those
    // situations, and for XML support.
    ">": "&gt;",
    // In Internet Explorer ≤ 8, the backtick character can be used
    // to break out of (un)quoted attribute values or HTML comments.
    // See http://html5sec.org/#102, http://html5sec.org/#108, and
    // http://html5sec.org/#133.
    "`": "&#x60;",
  };

  var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
  var regexInvalidRawCodePoint =
    /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var regexDecode =
    /&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)([=a-zA-Z0-9])?/g;
  var decodeMap = {
    aacute: "\xE1",
    Aacute: "\xC1",
    abreve: "\u0103",
    Abreve: "\u0102",
    ac: "\u223E",
    acd: "\u223F",
    acE: "\u223E\u0333",
    acirc: "\xE2",
    Acirc: "\xC2",
    acute: "\xB4",
    acy: "\u0430",
    Acy: "\u0410",
    aelig: "\xE6",
    AElig: "\xC6",
    af: "\u2061",
    afr: "\uD835\uDD1E",
    Afr: "\uD835\uDD04",
    agrave: "\xE0",
    Agrave: "\xC0",
    alefsym: "\u2135",
    aleph: "\u2135",
    alpha: "\u03B1",
    Alpha: "\u0391",
    amacr: "\u0101",
    Amacr: "\u0100",
    amalg: "\u2A3F",
    amp: "&",
    AMP: "&",
    and: "\u2227",
    And: "\u2A53",
    andand: "\u2A55",
    andd: "\u2A5C",
    andslope: "\u2A58",
    andv: "\u2A5A",
    ang: "\u2220",
    ange: "\u29A4",
    angle: "\u2220",
    angmsd: "\u2221",
    angmsdaa: "\u29A8",
    angmsdab: "\u29A9",
    angmsdac: "\u29AA",
    angmsdad: "\u29AB",
    angmsdae: "\u29AC",
    angmsdaf: "\u29AD",
    angmsdag: "\u29AE",
    angmsdah: "\u29AF",
    angrt: "\u221F",
    angrtvb: "\u22BE",
    angrtvbd: "\u299D",
    angsph: "\u2222",
    angst: "\xC5",
    angzarr: "\u237C",
    aogon: "\u0105",
    Aogon: "\u0104",
    aopf: "\uD835\uDD52",
    Aopf: "\uD835\uDD38",
    ap: "\u2248",
    apacir: "\u2A6F",
    ape: "\u224A",
    apE: "\u2A70",
    apid: "\u224B",
    apos: "'",
    ApplyFunction: "\u2061",
    approx: "\u2248",
    approxeq: "\u224A",
    aring: "\xE5",
    Aring: "\xC5",
    ascr: "\uD835\uDCB6",
    Ascr: "\uD835\uDC9C",
    Assign: "\u2254",
    ast: "*",
    asymp: "\u2248",
    asympeq: "\u224D",
    atilde: "\xE3",
    Atilde: "\xC3",
    auml: "\xE4",
    Auml: "\xC4",
    awconint: "\u2233",
    awint: "\u2A11",
    backcong: "\u224C",
    backepsilon: "\u03F6",
    backprime: "\u2035",
    backsim: "\u223D",
    backsimeq: "\u22CD",
    Backslash: "\u2216",
    Barv: "\u2AE7",
    barvee: "\u22BD",
    barwed: "\u2305",
    Barwed: "\u2306",
    barwedge: "\u2305",
    bbrk: "\u23B5",
    bbrktbrk: "\u23B6",
    bcong: "\u224C",
    bcy: "\u0431",
    Bcy: "\u0411",
    bdquo: "\u201E",
    becaus: "\u2235",
    because: "\u2235",
    Because: "\u2235",
    bemptyv: "\u29B0",
    bepsi: "\u03F6",
    bernou: "\u212C",
    Bernoullis: "\u212C",
    beta: "\u03B2",
    Beta: "\u0392",
    beth: "\u2136",
    between: "\u226C",
    bfr: "\uD835\uDD1F",
    Bfr: "\uD835\uDD05",
    bigcap: "\u22C2",
    bigcirc: "\u25EF",
    bigcup: "\u22C3",
    bigodot: "\u2A00",
    bigoplus: "\u2A01",
    bigotimes: "\u2A02",
    bigsqcup: "\u2A06",
    bigstar: "\u2605",
    bigtriangledown: "\u25BD",
    bigtriangleup: "\u25B3",
    biguplus: "\u2A04",
    bigvee: "\u22C1",
    bigwedge: "\u22C0",
    bkarow: "\u290D",
    blacklozenge: "\u29EB",
    blacksquare: "\u25AA",
    blacktriangle: "\u25B4",
    blacktriangledown: "\u25BE",
    blacktriangleleft: "\u25C2",
    blacktriangleright: "\u25B8",
    blank: "\u2423",
    blk12: "\u2592",
    blk14: "\u2591",
    blk34: "\u2593",
    block: "\u2588",
    bne: "=\u20E5",
    bnequiv: "\u2261\u20E5",
    bnot: "\u2310",
    bNot: "\u2AED",
    bopf: "\uD835\uDD53",
    Bopf: "\uD835\uDD39",
    bot: "\u22A5",
    bottom: "\u22A5",
    bowtie: "\u22C8",
    boxbox: "\u29C9",
    boxdl: "\u2510",
    boxdL: "\u2555",
    boxDl: "\u2556",
    boxDL: "\u2557",
    boxdr: "\u250C",
    boxdR: "\u2552",
    boxDr: "\u2553",
    boxDR: "\u2554",
    boxh: "\u2500",
    boxH: "\u2550",
    boxhd: "\u252C",
    boxhD: "\u2565",
    boxHd: "\u2564",
    boxHD: "\u2566",
    boxhu: "\u2534",
    boxhU: "\u2568",
    boxHu: "\u2567",
    boxHU: "\u2569",
    boxminus: "\u229F",
    boxplus: "\u229E",
    boxtimes: "\u22A0",
    boxul: "\u2518",
    boxuL: "\u255B",
    boxUl: "\u255C",
    boxUL: "\u255D",
    boxur: "\u2514",
    boxuR: "\u2558",
    boxUr: "\u2559",
    boxUR: "\u255A",
    boxv: "\u2502",
    boxV: "\u2551",
    boxvh: "\u253C",
    boxvH: "\u256A",
    boxVh: "\u256B",
    boxVH: "\u256C",
    boxvl: "\u2524",
    boxvL: "\u2561",
    boxVl: "\u2562",
    boxVL: "\u2563",
    boxvr: "\u251C",
    boxvR: "\u255E",
    boxVr: "\u255F",
    boxVR: "\u2560",
    bprime: "\u2035",
    breve: "\u02D8",
    Breve: "\u02D8",
    brvbar: "\xA6",
    bscr: "\uD835\uDCB7",
    Bscr: "\u212C",
    bsemi: "\u204F",
    bsim: "\u223D",
    bsime: "\u22CD",
    bsol: "\\",
    bsolb: "\u29C5",
    bsolhsub: "\u27C8",
    bull: "\u2022",
    bullet: "\u2022",
    bump: "\u224E",
    bumpe: "\u224F",
    bumpE: "\u2AAE",
    bumpeq: "\u224F",
    Bumpeq: "\u224E",
    cacute: "\u0107",
    Cacute: "\u0106",
    cap: "\u2229",
    Cap: "\u22D2",
    capand: "\u2A44",
    capbrcup: "\u2A49",
    capcap: "\u2A4B",
    capcup: "\u2A47",
    capdot: "\u2A40",
    CapitalDifferentialD: "\u2145",
    caps: "\u2229\uFE00",
    caret: "\u2041",
    caron: "\u02C7",
    Cayleys: "\u212D",
    ccaps: "\u2A4D",
    ccaron: "\u010D",
    Ccaron: "\u010C",
    ccedil: "\xE7",
    Ccedil: "\xC7",
    ccirc: "\u0109",
    Ccirc: "\u0108",
    Cconint: "\u2230",
    ccups: "\u2A4C",
    ccupssm: "\u2A50",
    cdot: "\u010B",
    Cdot: "\u010A",
    cedil: "\xB8",
    Cedilla: "\xB8",
    cemptyv: "\u29B2",
    cent: "\xA2",
    centerdot: "\xB7",
    CenterDot: "\xB7",
    cfr: "\uD835\uDD20",
    Cfr: "\u212D",
    chcy: "\u0447",
    CHcy: "\u0427",
    check: "\u2713",
    checkmark: "\u2713",
    chi: "\u03C7",
    Chi: "\u03A7",
    cir: "\u25CB",
    circ: "\u02C6",
    circeq: "\u2257",
    circlearrowleft: "\u21BA",
    circlearrowright: "\u21BB",
    circledast: "\u229B",
    circledcirc: "\u229A",
    circleddash: "\u229D",
    CircleDot: "\u2299",
    circledR: "\xAE",
    circledS: "\u24C8",
    CircleMinus: "\u2296",
    CirclePlus: "\u2295",
    CircleTimes: "\u2297",
    cire: "\u2257",
    cirE: "\u29C3",
    cirfnint: "\u2A10",
    cirmid: "\u2AEF",
    cirscir: "\u29C2",
    ClockwiseContourIntegral: "\u2232",
    CloseCurlyDoubleQuote: "\u201D",
    CloseCurlyQuote: "\u2019",
    clubs: "\u2663",
    clubsuit: "\u2663",
    colon: ":",
    Colon: "\u2237",
    colone: "\u2254",
    Colone: "\u2A74",
    coloneq: "\u2254",
    comma: ",",
    commat: "@",
    comp: "\u2201",
    compfn: "\u2218",
    complement: "\u2201",
    complexes: "\u2102",
    cong: "\u2245",
    congdot: "\u2A6D",
    Congruent: "\u2261",
    conint: "\u222E",
    Conint: "\u222F",
    ContourIntegral: "\u222E",
    copf: "\uD835\uDD54",
    Copf: "\u2102",
    coprod: "\u2210",
    Coproduct: "\u2210",
    copy: "\xA9",
    COPY: "\xA9",
    copysr: "\u2117",
    CounterClockwiseContourIntegral: "\u2233",
    crarr: "\u21B5",
    cross: "\u2717",
    Cross: "\u2A2F",
    cscr: "\uD835\uDCB8",
    Cscr: "\uD835\uDC9E",
    csub: "\u2ACF",
    csube: "\u2AD1",
    csup: "\u2AD0",
    csupe: "\u2AD2",
    ctdot: "\u22EF",
    cudarrl: "\u2938",
    cudarrr: "\u2935",
    cuepr: "\u22DE",
    cuesc: "\u22DF",
    cularr: "\u21B6",
    cularrp: "\u293D",
    cup: "\u222A",
    Cup: "\u22D3",
    cupbrcap: "\u2A48",
    cupcap: "\u2A46",
    CupCap: "\u224D",
    cupcup: "\u2A4A",
    cupdot: "\u228D",
    cupor: "\u2A45",
    cups: "\u222A\uFE00",
    curarr: "\u21B7",
    curarrm: "\u293C",
    curlyeqprec: "\u22DE",
    curlyeqsucc: "\u22DF",
    curlyvee: "\u22CE",
    curlywedge: "\u22CF",
    curren: "\xA4",
    curvearrowleft: "\u21B6",
    curvearrowright: "\u21B7",
    cuvee: "\u22CE",
    cuwed: "\u22CF",
    cwconint: "\u2232",
    cwint: "\u2231",
    cylcty: "\u232D",
    dagger: "\u2020",
    Dagger: "\u2021",
    daleth: "\u2138",
    darr: "\u2193",
    dArr: "\u21D3",
    Darr: "\u21A1",
    dash: "\u2010",
    dashv: "\u22A3",
    Dashv: "\u2AE4",
    dbkarow: "\u290F",
    dblac: "\u02DD",
    dcaron: "\u010F",
    Dcaron: "\u010E",
    dcy: "\u0434",
    Dcy: "\u0414",
    dd: "\u2146",
    DD: "\u2145",
    ddagger: "\u2021",
    ddarr: "\u21CA",
    DDotrahd: "\u2911",
    ddotseq: "\u2A77",
    deg: "\xB0",
    Del: "\u2207",
    delta: "\u03B4",
    Delta: "\u0394",
    demptyv: "\u29B1",
    dfisht: "\u297F",
    dfr: "\uD835\uDD21",
    Dfr: "\uD835\uDD07",
    dHar: "\u2965",
    dharl: "\u21C3",
    dharr: "\u21C2",
    DiacriticalAcute: "\xB4",
    DiacriticalDot: "\u02D9",
    DiacriticalDoubleAcute: "\u02DD",
    DiacriticalGrave: "`",
    DiacriticalTilde: "\u02DC",
    diam: "\u22C4",
    diamond: "\u22C4",
    Diamond: "\u22C4",
    diamondsuit: "\u2666",
    diams: "\u2666",
    die: "\xA8",
    DifferentialD: "\u2146",
    digamma: "\u03DD",
    disin: "\u22F2",
    div: "\xF7",
    divide: "\xF7",
    divideontimes: "\u22C7",
    divonx: "\u22C7",
    djcy: "\u0452",
    DJcy: "\u0402",
    dlcorn: "\u231E",
    dlcrop: "\u230D",
    dollar: "$",
    dopf: "\uD835\uDD55",
    Dopf: "\uD835\uDD3B",
    dot: "\u02D9",
    Dot: "\xA8",
    DotDot: "\u20DC",
    doteq: "\u2250",
    doteqdot: "\u2251",
    DotEqual: "\u2250",
    dotminus: "\u2238",
    dotplus: "\u2214",
    dotsquare: "\u22A1",
    doublebarwedge: "\u2306",
    DoubleContourIntegral: "\u222F",
    DoubleDot: "\xA8",
    DoubleDownArrow: "\u21D3",
    DoubleLeftArrow: "\u21D0",
    DoubleLeftRightArrow: "\u21D4",
    DoubleLeftTee: "\u2AE4",
    DoubleLongLeftArrow: "\u27F8",
    DoubleLongLeftRightArrow: "\u27FA",
    DoubleLongRightArrow: "\u27F9",
    DoubleRightArrow: "\u21D2",
    DoubleRightTee: "\u22A8",
    DoubleUpArrow: "\u21D1",
    DoubleUpDownArrow: "\u21D5",
    DoubleVerticalBar: "\u2225",
    downarrow: "\u2193",
    Downarrow: "\u21D3",
    DownArrow: "\u2193",
    DownArrowBar: "\u2913",
    DownArrowUpArrow: "\u21F5",
    DownBreve: "\u0311",
    downdownarrows: "\u21CA",
    downharpoonleft: "\u21C3",
    downharpoonright: "\u21C2",
    DownLeftRightVector: "\u2950",
    DownLeftTeeVector: "\u295E",
    DownLeftVector: "\u21BD",
    DownLeftVectorBar: "\u2956",
    DownRightTeeVector: "\u295F",
    DownRightVector: "\u21C1",
    DownRightVectorBar: "\u2957",
    DownTee: "\u22A4",
    DownTeeArrow: "\u21A7",
    drbkarow: "\u2910",
    drcorn: "\u231F",
    drcrop: "\u230C",
    dscr: "\uD835\uDCB9",
    Dscr: "\uD835\uDC9F",
    dscy: "\u0455",
    DScy: "\u0405",
    dsol: "\u29F6",
    dstrok: "\u0111",
    Dstrok: "\u0110",
    dtdot: "\u22F1",
    dtri: "\u25BF",
    dtrif: "\u25BE",
    duarr: "\u21F5",
    duhar: "\u296F",
    dwangle: "\u29A6",
    dzcy: "\u045F",
    DZcy: "\u040F",
    dzigrarr: "\u27FF",
    eacute: "\xE9",
    Eacute: "\xC9",
    easter: "\u2A6E",
    ecaron: "\u011B",
    Ecaron: "\u011A",
    ecir: "\u2256",
    ecirc: "\xEA",
    Ecirc: "\xCA",
    ecolon: "\u2255",
    ecy: "\u044D",
    Ecy: "\u042D",
    eDDot: "\u2A77",
    edot: "\u0117",
    eDot: "\u2251",
    Edot: "\u0116",
    ee: "\u2147",
    efDot: "\u2252",
    efr: "\uD835\uDD22",
    Efr: "\uD835\uDD08",
    eg: "\u2A9A",
    egrave: "\xE8",
    Egrave: "\xC8",
    egs: "\u2A96",
    egsdot: "\u2A98",
    el: "\u2A99",
    Element: "\u2208",
    elinters: "\u23E7",
    ell: "\u2113",
    els: "\u2A95",
    elsdot: "\u2A97",
    emacr: "\u0113",
    Emacr: "\u0112",
    empty: "\u2205",
    emptyset: "\u2205",
    EmptySmallSquare: "\u25FB",
    emptyv: "\u2205",
    EmptyVerySmallSquare: "\u25AB",
    emsp: "\u2003",
    emsp13: "\u2004",
    emsp14: "\u2005",
    eng: "\u014B",
    ENG: "\u014A",
    ensp: "\u2002",
    eogon: "\u0119",
    Eogon: "\u0118",
    eopf: "\uD835\uDD56",
    Eopf: "\uD835\uDD3C",
    epar: "\u22D5",
    eparsl: "\u29E3",
    eplus: "\u2A71",
    epsi: "\u03B5",
    epsilon: "\u03B5",
    Epsilon: "\u0395",
    epsiv: "\u03F5",
    eqcirc: "\u2256",
    eqcolon: "\u2255",
    eqsim: "\u2242",
    eqslantgtr: "\u2A96",
    eqslantless: "\u2A95",
    Equal: "\u2A75",
    equals: "=",
    EqualTilde: "\u2242",
    equest: "\u225F",
    Equilibrium: "\u21CC",
    equiv: "\u2261",
    equivDD: "\u2A78",
    eqvparsl: "\u29E5",
    erarr: "\u2971",
    erDot: "\u2253",
    escr: "\u212F",
    Escr: "\u2130",
    esdot: "\u2250",
    esim: "\u2242",
    Esim: "\u2A73",
    eta: "\u03B7",
    Eta: "\u0397",
    eth: "\xF0",
    ETH: "\xD0",
    euml: "\xEB",
    Euml: "\xCB",
    euro: "\u20AC",
    excl: "!",
    exist: "\u2203",
    Exists: "\u2203",
    expectation: "\u2130",
    exponentiale: "\u2147",
    ExponentialE: "\u2147",
    fallingdotseq: "\u2252",
    fcy: "\u0444",
    Fcy: "\u0424",
    female: "\u2640",
    ffilig: "\uFB03",
    fflig: "\uFB00",
    ffllig: "\uFB04",
    ffr: "\uD835\uDD23",
    Ffr: "\uD835\uDD09",
    filig: "\uFB01",
    FilledSmallSquare: "\u25FC",
    FilledVerySmallSquare: "\u25AA",
    fjlig: "fj",
    flat: "\u266D",
    fllig: "\uFB02",
    fltns: "\u25B1",
    fnof: "\u0192",
    fopf: "\uD835\uDD57",
    Fopf: "\uD835\uDD3D",
    forall: "\u2200",
    ForAll: "\u2200",
    fork: "\u22D4",
    forkv: "\u2AD9",
    Fouriertrf: "\u2131",
    fpartint: "\u2A0D",
    frac12: "\xBD",
    frac13: "\u2153",
    frac14: "\xBC",
    frac15: "\u2155",
    frac16: "\u2159",
    frac18: "\u215B",
    frac23: "\u2154",
    frac25: "\u2156",
    frac34: "\xBE",
    frac35: "\u2157",
    frac38: "\u215C",
    frac45: "\u2158",
    frac56: "\u215A",
    frac58: "\u215D",
    frac78: "\u215E",
    frasl: "\u2044",
    frown: "\u2322",
    fscr: "\uD835\uDCBB",
    Fscr: "\u2131",
    gacute: "\u01F5",
    gamma: "\u03B3",
    Gamma: "\u0393",
    gammad: "\u03DD",
    Gammad: "\u03DC",
    gap: "\u2A86",
    gbreve: "\u011F",
    Gbreve: "\u011E",
    Gcedil: "\u0122",
    gcirc: "\u011D",
    Gcirc: "\u011C",
    gcy: "\u0433",
    Gcy: "\u0413",
    gdot: "\u0121",
    Gdot: "\u0120",
    ge: "\u2265",
    gE: "\u2267",
    gel: "\u22DB",
    gEl: "\u2A8C",
    geq: "\u2265",
    geqq: "\u2267",
    geqslant: "\u2A7E",
    ges: "\u2A7E",
    gescc: "\u2AA9",
    gesdot: "\u2A80",
    gesdoto: "\u2A82",
    gesdotol: "\u2A84",
    gesl: "\u22DB\uFE00",
    gesles: "\u2A94",
    gfr: "\uD835\uDD24",
    Gfr: "\uD835\uDD0A",
    gg: "\u226B",
    Gg: "\u22D9",
    ggg: "\u22D9",
    gimel: "\u2137",
    gjcy: "\u0453",
    GJcy: "\u0403",
    gl: "\u2277",
    gla: "\u2AA5",
    glE: "\u2A92",
    glj: "\u2AA4",
    gnap: "\u2A8A",
    gnapprox: "\u2A8A",
    gne: "\u2A88",
    gnE: "\u2269",
    gneq: "\u2A88",
    gneqq: "\u2269",
    gnsim: "\u22E7",
    gopf: "\uD835\uDD58",
    Gopf: "\uD835\uDD3E",
    grave: "`",
    GreaterEqual: "\u2265",
    GreaterEqualLess: "\u22DB",
    GreaterFullEqual: "\u2267",
    GreaterGreater: "\u2AA2",
    GreaterLess: "\u2277",
    GreaterSlantEqual: "\u2A7E",
    GreaterTilde: "\u2273",
    gscr: "\u210A",
    Gscr: "\uD835\uDCA2",
    gsim: "\u2273",
    gsime: "\u2A8E",
    gsiml: "\u2A90",
    gt: ">",
    Gt: "\u226B",
    GT: ">",
    gtcc: "\u2AA7",
    gtcir: "\u2A7A",
    gtdot: "\u22D7",
    gtlPar: "\u2995",
    gtquest: "\u2A7C",
    gtrapprox: "\u2A86",
    gtrarr: "\u2978",
    gtrdot: "\u22D7",
    gtreqless: "\u22DB",
    gtreqqless: "\u2A8C",
    gtrless: "\u2277",
    gtrsim: "\u2273",
    gvertneqq: "\u2269\uFE00",
    gvnE: "\u2269\uFE00",
    Hacek: "\u02C7",
    hairsp: "\u200A",
    half: "\xBD",
    hamilt: "\u210B",
    hardcy: "\u044A",
    HARDcy: "\u042A",
    harr: "\u2194",
    hArr: "\u21D4",
    harrcir: "\u2948",
    harrw: "\u21AD",
    Hat: "^",
    hbar: "\u210F",
    hcirc: "\u0125",
    Hcirc: "\u0124",
    hearts: "\u2665",
    heartsuit: "\u2665",
    hellip: "\u2026",
    hercon: "\u22B9",
    hfr: "\uD835\uDD25",
    Hfr: "\u210C",
    HilbertSpace: "\u210B",
    hksearow: "\u2925",
    hkswarow: "\u2926",
    hoarr: "\u21FF",
    homtht: "\u223B",
    hookleftarrow: "\u21A9",
    hookrightarrow: "\u21AA",
    hopf: "\uD835\uDD59",
    Hopf: "\u210D",
    horbar: "\u2015",
    HorizontalLine: "\u2500",
    hscr: "\uD835\uDCBD",
    Hscr: "\u210B",
    hslash: "\u210F",
    hstrok: "\u0127",
    Hstrok: "\u0126",
    HumpDownHump: "\u224E",
    HumpEqual: "\u224F",
    hybull: "\u2043",
    hyphen: "\u2010",
    iacute: "\xED",
    Iacute: "\xCD",
    ic: "\u2063",
    icirc: "\xEE",
    Icirc: "\xCE",
    icy: "\u0438",
    Icy: "\u0418",
    Idot: "\u0130",
    iecy: "\u0435",
    IEcy: "\u0415",
    iexcl: "\xA1",
    iff: "\u21D4",
    ifr: "\uD835\uDD26",
    Ifr: "\u2111",
    igrave: "\xEC",
    Igrave: "\xCC",
    ii: "\u2148",
    iiiint: "\u2A0C",
    iiint: "\u222D",
    iinfin: "\u29DC",
    iiota: "\u2129",
    ijlig: "\u0133",
    IJlig: "\u0132",
    Im: "\u2111",
    imacr: "\u012B",
    Imacr: "\u012A",
    image: "\u2111",
    ImaginaryI: "\u2148",
    imagline: "\u2110",
    imagpart: "\u2111",
    imath: "\u0131",
    imof: "\u22B7",
    imped: "\u01B5",
    Implies: "\u21D2",
    in: "\u2208",
    incare: "\u2105",
    infin: "\u221E",
    infintie: "\u29DD",
    inodot: "\u0131",
    int: "\u222B",
    Int: "\u222C",
    intcal: "\u22BA",
    integers: "\u2124",
    Integral: "\u222B",
    intercal: "\u22BA",
    Intersection: "\u22C2",
    intlarhk: "\u2A17",
    intprod: "\u2A3C",
    InvisibleComma: "\u2063",
    InvisibleTimes: "\u2062",
    iocy: "\u0451",
    IOcy: "\u0401",
    iogon: "\u012F",
    Iogon: "\u012E",
    iopf: "\uD835\uDD5A",
    Iopf: "\uD835\uDD40",
    iota: "\u03B9",
    Iota: "\u0399",
    iprod: "\u2A3C",
    iquest: "\xBF",
    iscr: "\uD835\uDCBE",
    Iscr: "\u2110",
    isin: "\u2208",
    isindot: "\u22F5",
    isinE: "\u22F9",
    isins: "\u22F4",
    isinsv: "\u22F3",
    isinv: "\u2208",
    it: "\u2062",
    itilde: "\u0129",
    Itilde: "\u0128",
    iukcy: "\u0456",
    Iukcy: "\u0406",
    iuml: "\xEF",
    Iuml: "\xCF",
    jcirc: "\u0135",
    Jcirc: "\u0134",
    jcy: "\u0439",
    Jcy: "\u0419",
    jfr: "\uD835\uDD27",
    Jfr: "\uD835\uDD0D",
    jmath: "\u0237",
    jopf: "\uD835\uDD5B",
    Jopf: "\uD835\uDD41",
    jscr: "\uD835\uDCBF",
    Jscr: "\uD835\uDCA5",
    jsercy: "\u0458",
    Jsercy: "\u0408",
    jukcy: "\u0454",
    Jukcy: "\u0404",
    kappa: "\u03BA",
    Kappa: "\u039A",
    kappav: "\u03F0",
    kcedil: "\u0137",
    Kcedil: "\u0136",
    kcy: "\u043A",
    Kcy: "\u041A",
    kfr: "\uD835\uDD28",
    Kfr: "\uD835\uDD0E",
    kgreen: "\u0138",
    khcy: "\u0445",
    KHcy: "\u0425",
    kjcy: "\u045C",
    KJcy: "\u040C",
    kopf: "\uD835\uDD5C",
    Kopf: "\uD835\uDD42",
    kscr: "\uD835\uDCC0",
    Kscr: "\uD835\uDCA6",
    lAarr: "\u21DA",
    lacute: "\u013A",
    Lacute: "\u0139",
    laemptyv: "\u29B4",
    lagran: "\u2112",
    lambda: "\u03BB",
    Lambda: "\u039B",
    lang: "\u27E8",
    Lang: "\u27EA",
    langd: "\u2991",
    langle: "\u27E8",
    lap: "\u2A85",
    Laplacetrf: "\u2112",
    laquo: "\xAB",
    larr: "\u2190",
    lArr: "\u21D0",
    Larr: "\u219E",
    larrb: "\u21E4",
    larrbfs: "\u291F",
    larrfs: "\u291D",
    larrhk: "\u21A9",
    larrlp: "\u21AB",
    larrpl: "\u2939",
    larrsim: "\u2973",
    larrtl: "\u21A2",
    lat: "\u2AAB",
    latail: "\u2919",
    lAtail: "\u291B",
    late: "\u2AAD",
    lates: "\u2AAD\uFE00",
    lbarr: "\u290C",
    lBarr: "\u290E",
    lbbrk: "\u2772",
    lbrace: "{",
    lbrack: "[",
    lbrke: "\u298B",
    lbrksld: "\u298F",
    lbrkslu: "\u298D",
    lcaron: "\u013E",
    Lcaron: "\u013D",
    lcedil: "\u013C",
    Lcedil: "\u013B",
    lceil: "\u2308",
    lcub: "{",
    lcy: "\u043B",
    Lcy: "\u041B",
    ldca: "\u2936",
    ldquo: "\u201C",
    ldquor: "\u201E",
    ldrdhar: "\u2967",
    ldrushar: "\u294B",
    ldsh: "\u21B2",
    le: "\u2264",
    lE: "\u2266",
    LeftAngleBracket: "\u27E8",
    leftarrow: "\u2190",
    Leftarrow: "\u21D0",
    LeftArrow: "\u2190",
    LeftArrowBar: "\u21E4",
    LeftArrowRightArrow: "\u21C6",
    leftarrowtail: "\u21A2",
    LeftCeiling: "\u2308",
    LeftDoubleBracket: "\u27E6",
    LeftDownTeeVector: "\u2961",
    LeftDownVector: "\u21C3",
    LeftDownVectorBar: "\u2959",
    LeftFloor: "\u230A",
    leftharpoondown: "\u21BD",
    leftharpoonup: "\u21BC",
    leftleftarrows: "\u21C7",
    leftrightarrow: "\u2194",
    Leftrightarrow: "\u21D4",
    LeftRightArrow: "\u2194",
    leftrightarrows: "\u21C6",
    leftrightharpoons: "\u21CB",
    leftrightsquigarrow: "\u21AD",
    LeftRightVector: "\u294E",
    LeftTee: "\u22A3",
    LeftTeeArrow: "\u21A4",
    LeftTeeVector: "\u295A",
    leftthreetimes: "\u22CB",
    LeftTriangle: "\u22B2",
    LeftTriangleBar: "\u29CF",
    LeftTriangleEqual: "\u22B4",
    LeftUpDownVector: "\u2951",
    LeftUpTeeVector: "\u2960",
    LeftUpVector: "\u21BF",
    LeftUpVectorBar: "\u2958",
    LeftVector: "\u21BC",
    LeftVectorBar: "\u2952",
    leg: "\u22DA",
    lEg: "\u2A8B",
    leq: "\u2264",
    leqq: "\u2266",
    leqslant: "\u2A7D",
    les: "\u2A7D",
    lescc: "\u2AA8",
    lesdot: "\u2A7F",
    lesdoto: "\u2A81",
    lesdotor: "\u2A83",
    lesg: "\u22DA\uFE00",
    lesges: "\u2A93",
    lessapprox: "\u2A85",
    lessdot: "\u22D6",
    lesseqgtr: "\u22DA",
    lesseqqgtr: "\u2A8B",
    LessEqualGreater: "\u22DA",
    LessFullEqual: "\u2266",
    LessGreater: "\u2276",
    lessgtr: "\u2276",
    LessLess: "\u2AA1",
    lesssim: "\u2272",
    LessSlantEqual: "\u2A7D",
    LessTilde: "\u2272",
    lfisht: "\u297C",
    lfloor: "\u230A",
    lfr: "\uD835\uDD29",
    Lfr: "\uD835\uDD0F",
    lg: "\u2276",
    lgE: "\u2A91",
    lHar: "\u2962",
    lhard: "\u21BD",
    lharu: "\u21BC",
    lharul: "\u296A",
    lhblk: "\u2584",
    ljcy: "\u0459",
    LJcy: "\u0409",
    ll: "\u226A",
    Ll: "\u22D8",
    llarr: "\u21C7",
    llcorner: "\u231E",
    Lleftarrow: "\u21DA",
    llhard: "\u296B",
    lltri: "\u25FA",
    lmidot: "\u0140",
    Lmidot: "\u013F",
    lmoust: "\u23B0",
    lmoustache: "\u23B0",
    lnap: "\u2A89",
    lnapprox: "\u2A89",
    lne: "\u2A87",
    lnE: "\u2268",
    lneq: "\u2A87",
    lneqq: "\u2268",
    lnsim: "\u22E6",
    loang: "\u27EC",
    loarr: "\u21FD",
    lobrk: "\u27E6",
    longleftarrow: "\u27F5",
    Longleftarrow: "\u27F8",
    LongLeftArrow: "\u27F5",
    longleftrightarrow: "\u27F7",
    Longleftrightarrow: "\u27FA",
    LongLeftRightArrow: "\u27F7",
    longmapsto: "\u27FC",
    longrightarrow: "\u27F6",
    Longrightarrow: "\u27F9",
    LongRightArrow: "\u27F6",
    looparrowleft: "\u21AB",
    looparrowright: "\u21AC",
    lopar: "\u2985",
    lopf: "\uD835\uDD5D",
    Lopf: "\uD835\uDD43",
    loplus: "\u2A2D",
    lotimes: "\u2A34",
    lowast: "\u2217",
    lowbar: "_",
    LowerLeftArrow: "\u2199",
    LowerRightArrow: "\u2198",
    loz: "\u25CA",
    lozenge: "\u25CA",
    lozf: "\u29EB",
    lpar: "(",
    lparlt: "\u2993",
    lrarr: "\u21C6",
    lrcorner: "\u231F",
    lrhar: "\u21CB",
    lrhard: "\u296D",
    lrm: "\u200E",
    lrtri: "\u22BF",
    lsaquo: "\u2039",
    lscr: "\uD835\uDCC1",
    Lscr: "\u2112",
    lsh: "\u21B0",
    Lsh: "\u21B0",
    lsim: "\u2272",
    lsime: "\u2A8D",
    lsimg: "\u2A8F",
    lsqb: "[",
    lsquo: "\u2018",
    lsquor: "\u201A",
    lstrok: "\u0142",
    Lstrok: "\u0141",
    lt: "<",
    Lt: "\u226A",
    LT: "<",
    ltcc: "\u2AA6",
    ltcir: "\u2A79",
    ltdot: "\u22D6",
    lthree: "\u22CB",
    ltimes: "\u22C9",
    ltlarr: "\u2976",
    ltquest: "\u2A7B",
    ltri: "\u25C3",
    ltrie: "\u22B4",
    ltrif: "\u25C2",
    ltrPar: "\u2996",
    lurdshar: "\u294A",
    luruhar: "\u2966",
    lvertneqq: "\u2268\uFE00",
    lvnE: "\u2268\uFE00",
    macr: "\xAF",
    male: "\u2642",
    malt: "\u2720",
    maltese: "\u2720",
    map: "\u21A6",
    Map: "\u2905",
    mapsto: "\u21A6",
    mapstodown: "\u21A7",
    mapstoleft: "\u21A4",
    mapstoup: "\u21A5",
    marker: "\u25AE",
    mcomma: "\u2A29",
    mcy: "\u043C",
    Mcy: "\u041C",
    mdash: "\u2014",
    mDDot: "\u223A",
    measuredangle: "\u2221",
    MediumSpace: "\u205F",
    Mellintrf: "\u2133",
    mfr: "\uD835\uDD2A",
    Mfr: "\uD835\uDD10",
    mho: "\u2127",
    micro: "\xB5",
    mid: "\u2223",
    midast: "*",
    midcir: "\u2AF0",
    middot: "\xB7",
    minus: "\u2212",
    minusb: "\u229F",
    minusd: "\u2238",
    minusdu: "\u2A2A",
    MinusPlus: "\u2213",
    mlcp: "\u2ADB",
    mldr: "\u2026",
    mnplus: "\u2213",
    models: "\u22A7",
    mopf: "\uD835\uDD5E",
    Mopf: "\uD835\uDD44",
    mp: "\u2213",
    mscr: "\uD835\uDCC2",
    Mscr: "\u2133",
    mstpos: "\u223E",
    mu: "\u03BC",
    Mu: "\u039C",
    multimap: "\u22B8",
    mumap: "\u22B8",
    nabla: "\u2207",
    nacute: "\u0144",
    Nacute: "\u0143",
    nang: "\u2220\u20D2",
    nap: "\u2249",
    napE: "\u2A70\u0338",
    napid: "\u224B\u0338",
    napos: "\u0149",
    napprox: "\u2249",
    natur: "\u266E",
    natural: "\u266E",
    naturals: "\u2115",
    nbsp: "\xA0",
    nbump: "\u224E\u0338",
    nbumpe: "\u224F\u0338",
    ncap: "\u2A43",
    ncaron: "\u0148",
    Ncaron: "\u0147",
    ncedil: "\u0146",
    Ncedil: "\u0145",
    ncong: "\u2247",
    ncongdot: "\u2A6D\u0338",
    ncup: "\u2A42",
    ncy: "\u043D",
    Ncy: "\u041D",
    ndash: "\u2013",
    ne: "\u2260",
    nearhk: "\u2924",
    nearr: "\u2197",
    neArr: "\u21D7",
    nearrow: "\u2197",
    nedot: "\u2250\u0338",
    NegativeMediumSpace: "\u200B",
    NegativeThickSpace: "\u200B",
    NegativeThinSpace: "\u200B",
    NegativeVeryThinSpace: "\u200B",
    nequiv: "\u2262",
    nesear: "\u2928",
    nesim: "\u2242\u0338",
    NestedGreaterGreater: "\u226B",
    NestedLessLess: "\u226A",
    NewLine: "\n",
    nexist: "\u2204",
    nexists: "\u2204",
    nfr: "\uD835\uDD2B",
    Nfr: "\uD835\uDD11",
    nge: "\u2271",
    ngE: "\u2267\u0338",
    ngeq: "\u2271",
    ngeqq: "\u2267\u0338",
    ngeqslant: "\u2A7E\u0338",
    nges: "\u2A7E\u0338",
    nGg: "\u22D9\u0338",
    ngsim: "\u2275",
    ngt: "\u226F",
    nGt: "\u226B\u20D2",
    ngtr: "\u226F",
    nGtv: "\u226B\u0338",
    nharr: "\u21AE",
    nhArr: "\u21CE",
    nhpar: "\u2AF2",
    ni: "\u220B",
    nis: "\u22FC",
    nisd: "\u22FA",
    niv: "\u220B",
    njcy: "\u045A",
    NJcy: "\u040A",
    nlarr: "\u219A",
    nlArr: "\u21CD",
    nldr: "\u2025",
    nle: "\u2270",
    nlE: "\u2266\u0338",
    nleftarrow: "\u219A",
    nLeftarrow: "\u21CD",
    nleftrightarrow: "\u21AE",
    nLeftrightarrow: "\u21CE",
    nleq: "\u2270",
    nleqq: "\u2266\u0338",
    nleqslant: "\u2A7D\u0338",
    nles: "\u2A7D\u0338",
    nless: "\u226E",
    nLl: "\u22D8\u0338",
    nlsim: "\u2274",
    nlt: "\u226E",
    nLt: "\u226A\u20D2",
    nltri: "\u22EA",
    nltrie: "\u22EC",
    nLtv: "\u226A\u0338",
    nmid: "\u2224",
    NoBreak: "\u2060",
    NonBreakingSpace: "\xA0",
    nopf: "\uD835\uDD5F",
    Nopf: "\u2115",
    not: "\xAC",
    Not: "\u2AEC",
    NotCongruent: "\u2262",
    NotCupCap: "\u226D",
    NotDoubleVerticalBar: "\u2226",
    NotElement: "\u2209",
    NotEqual: "\u2260",
    NotEqualTilde: "\u2242\u0338",
    NotExists: "\u2204",
    NotGreater: "\u226F",
    NotGreaterEqual: "\u2271",
    NotGreaterFullEqual: "\u2267\u0338",
    NotGreaterGreater: "\u226B\u0338",
    NotGreaterLess: "\u2279",
    NotGreaterSlantEqual: "\u2A7E\u0338",
    NotGreaterTilde: "\u2275",
    NotHumpDownHump: "\u224E\u0338",
    NotHumpEqual: "\u224F\u0338",
    notin: "\u2209",
    notindot: "\u22F5\u0338",
    notinE: "\u22F9\u0338",
    notinva: "\u2209",
    notinvb: "\u22F7",
    notinvc: "\u22F6",
    NotLeftTriangle: "\u22EA",
    NotLeftTriangleBar: "\u29CF\u0338",
    NotLeftTriangleEqual: "\u22EC",
    NotLess: "\u226E",
    NotLessEqual: "\u2270",
    NotLessGreater: "\u2278",
    NotLessLess: "\u226A\u0338",
    NotLessSlantEqual: "\u2A7D\u0338",
    NotLessTilde: "\u2274",
    NotNestedGreaterGreater: "\u2AA2\u0338",
    NotNestedLessLess: "\u2AA1\u0338",
    notni: "\u220C",
    notniva: "\u220C",
    notnivb: "\u22FE",
    notnivc: "\u22FD",
    NotPrecedes: "\u2280",
    NotPrecedesEqual: "\u2AAF\u0338",
    NotPrecedesSlantEqual: "\u22E0",
    NotReverseElement: "\u220C",
    NotRightTriangle: "\u22EB",
    NotRightTriangleBar: "\u29D0\u0338",
    NotRightTriangleEqual: "\u22ED",
    NotSquareSubset: "\u228F\u0338",
    NotSquareSubsetEqual: "\u22E2",
    NotSquareSuperset: "\u2290\u0338",
    NotSquareSupersetEqual: "\u22E3",
    NotSubset: "\u2282\u20D2",
    NotSubsetEqual: "\u2288",
    NotSucceeds: "\u2281",
    NotSucceedsEqual: "\u2AB0\u0338",
    NotSucceedsSlantEqual: "\u22E1",
    NotSucceedsTilde: "\u227F\u0338",
    NotSuperset: "\u2283\u20D2",
    NotSupersetEqual: "\u2289",
    NotTilde: "\u2241",
    NotTildeEqual: "\u2244",
    NotTildeFullEqual: "\u2247",
    NotTildeTilde: "\u2249",
    NotVerticalBar: "\u2224",
    npar: "\u2226",
    nparallel: "\u2226",
    nparsl: "\u2AFD\u20E5",
    npart: "\u2202\u0338",
    npolint: "\u2A14",
    npr: "\u2280",
    nprcue: "\u22E0",
    npre: "\u2AAF\u0338",
    nprec: "\u2280",
    npreceq: "\u2AAF\u0338",
    nrarr: "\u219B",
    nrArr: "\u21CF",
    nrarrc: "\u2933\u0338",
    nrarrw: "\u219D\u0338",
    nrightarrow: "\u219B",
    nRightarrow: "\u21CF",
    nrtri: "\u22EB",
    nrtrie: "\u22ED",
    nsc: "\u2281",
    nsccue: "\u22E1",
    nsce: "\u2AB0\u0338",
    nscr: "\uD835\uDCC3",
    Nscr: "\uD835\uDCA9",
    nshortmid: "\u2224",
    nshortparallel: "\u2226",
    nsim: "\u2241",
    nsime: "\u2244",
    nsimeq: "\u2244",
    nsmid: "\u2224",
    nspar: "\u2226",
    nsqsube: "\u22E2",
    nsqsupe: "\u22E3",
    nsub: "\u2284",
    nsube: "\u2288",
    nsubE: "\u2AC5\u0338",
    nsubset: "\u2282\u20D2",
    nsubseteq: "\u2288",
    nsubseteqq: "\u2AC5\u0338",
    nsucc: "\u2281",
    nsucceq: "\u2AB0\u0338",
    nsup: "\u2285",
    nsupe: "\u2289",
    nsupE: "\u2AC6\u0338",
    nsupset: "\u2283\u20D2",
    nsupseteq: "\u2289",
    nsupseteqq: "\u2AC6\u0338",
    ntgl: "\u2279",
    ntilde: "\xF1",
    Ntilde: "\xD1",
    ntlg: "\u2278",
    ntriangleleft: "\u22EA",
    ntrianglelefteq: "\u22EC",
    ntriangleright: "\u22EB",
    ntrianglerighteq: "\u22ED",
    nu: "\u03BD",
    Nu: "\u039D",
    num: "#",
    numero: "\u2116",
    numsp: "\u2007",
    nvap: "\u224D\u20D2",
    nvdash: "\u22AC",
    nvDash: "\u22AD",
    nVdash: "\u22AE",
    nVDash: "\u22AF",
    nvge: "\u2265\u20D2",
    nvgt: ">\u20D2",
    nvHarr: "\u2904",
    nvinfin: "\u29DE",
    nvlArr: "\u2902",
    nvle: "\u2264\u20D2",
    nvlt: "<\u20D2",
    nvltrie: "\u22B4\u20D2",
    nvrArr: "\u2903",
    nvrtrie: "\u22B5\u20D2",
    nvsim: "\u223C\u20D2",
    nwarhk: "\u2923",
    nwarr: "\u2196",
    nwArr: "\u21D6",
    nwarrow: "\u2196",
    nwnear: "\u2927",
    oacute: "\xF3",
    Oacute: "\xD3",
    oast: "\u229B",
    ocir: "\u229A",
    ocirc: "\xF4",
    Ocirc: "\xD4",
    ocy: "\u043E",
    Ocy: "\u041E",
    odash: "\u229D",
    odblac: "\u0151",
    Odblac: "\u0150",
    odiv: "\u2A38",
    odot: "\u2299",
    odsold: "\u29BC",
    oelig: "\u0153",
    OElig: "\u0152",
    ofcir: "\u29BF",
    ofr: "\uD835\uDD2C",
    Ofr: "\uD835\uDD12",
    ogon: "\u02DB",
    ograve: "\xF2",
    Ograve: "\xD2",
    ogt: "\u29C1",
    ohbar: "\u29B5",
    ohm: "\u03A9",
    oint: "\u222E",
    olarr: "\u21BA",
    olcir: "\u29BE",
    olcross: "\u29BB",
    oline: "\u203E",
    olt: "\u29C0",
    omacr: "\u014D",
    Omacr: "\u014C",
    omega: "\u03C9",
    Omega: "\u03A9",
    omicron: "\u03BF",
    Omicron: "\u039F",
    omid: "\u29B6",
    ominus: "\u2296",
    oopf: "\uD835\uDD60",
    Oopf: "\uD835\uDD46",
    opar: "\u29B7",
    OpenCurlyDoubleQuote: "\u201C",
    OpenCurlyQuote: "\u2018",
    operp: "\u29B9",
    oplus: "\u2295",
    or: "\u2228",
    Or: "\u2A54",
    orarr: "\u21BB",
    ord: "\u2A5D",
    order: "\u2134",
    orderof: "\u2134",
    ordf: "\xAA",
    ordm: "\xBA",
    origof: "\u22B6",
    oror: "\u2A56",
    orslope: "\u2A57",
    orv: "\u2A5B",
    oS: "\u24C8",
    oscr: "\u2134",
    Oscr: "\uD835\uDCAA",
    oslash: "\xF8",
    Oslash: "\xD8",
    osol: "\u2298",
    otilde: "\xF5",
    Otilde: "\xD5",
    otimes: "\u2297",
    Otimes: "\u2A37",
    otimesas: "\u2A36",
    ouml: "\xF6",
    Ouml: "\xD6",
    ovbar: "\u233D",
    OverBar: "\u203E",
    OverBrace: "\u23DE",
    OverBracket: "\u23B4",
    OverParenthesis: "\u23DC",
    par: "\u2225",
    para: "\xB6",
    parallel: "\u2225",
    parsim: "\u2AF3",
    parsl: "\u2AFD",
    part: "\u2202",
    PartialD: "\u2202",
    pcy: "\u043F",
    Pcy: "\u041F",
    percnt: "%",
    period: ".",
    permil: "\u2030",
    perp: "\u22A5",
    pertenk: "\u2031",
    pfr: "\uD835\uDD2D",
    Pfr: "\uD835\uDD13",
    phi: "\u03C6",
    Phi: "\u03A6",
    phiv: "\u03D5",
    phmmat: "\u2133",
    phone: "\u260E",
    pi: "\u03C0",
    Pi: "\u03A0",
    pitchfork: "\u22D4",
    piv: "\u03D6",
    planck: "\u210F",
    planckh: "\u210E",
    plankv: "\u210F",
    plus: "+",
    plusacir: "\u2A23",
    plusb: "\u229E",
    pluscir: "\u2A22",
    plusdo: "\u2214",
    plusdu: "\u2A25",
    pluse: "\u2A72",
    PlusMinus: "\xB1",
    plusmn: "\xB1",
    plussim: "\u2A26",
    plustwo: "\u2A27",
    pm: "\xB1",
    Poincareplane: "\u210C",
    pointint: "\u2A15",
    popf: "\uD835\uDD61",
    Popf: "\u2119",
    pound: "\xA3",
    pr: "\u227A",
    Pr: "\u2ABB",
    prap: "\u2AB7",
    prcue: "\u227C",
    pre: "\u2AAF",
    prE: "\u2AB3",
    prec: "\u227A",
    precapprox: "\u2AB7",
    preccurlyeq: "\u227C",
    Precedes: "\u227A",
    PrecedesEqual: "\u2AAF",
    PrecedesSlantEqual: "\u227C",
    PrecedesTilde: "\u227E",
    preceq: "\u2AAF",
    precnapprox: "\u2AB9",
    precneqq: "\u2AB5",
    precnsim: "\u22E8",
    precsim: "\u227E",
    prime: "\u2032",
    Prime: "\u2033",
    primes: "\u2119",
    prnap: "\u2AB9",
    prnE: "\u2AB5",
    prnsim: "\u22E8",
    prod: "\u220F",
    Product: "\u220F",
    profalar: "\u232E",
    profline: "\u2312",
    profsurf: "\u2313",
    prop: "\u221D",
    Proportion: "\u2237",
    Proportional: "\u221D",
    propto: "\u221D",
    prsim: "\u227E",
    prurel: "\u22B0",
    pscr: "\uD835\uDCC5",
    Pscr: "\uD835\uDCAB",
    psi: "\u03C8",
    Psi: "\u03A8",
    puncsp: "\u2008",
    qfr: "\uD835\uDD2E",
    Qfr: "\uD835\uDD14",
    qint: "\u2A0C",
    qopf: "\uD835\uDD62",
    Qopf: "\u211A",
    qprime: "\u2057",
    qscr: "\uD835\uDCC6",
    Qscr: "\uD835\uDCAC",
    quaternions: "\u210D",
    quatint: "\u2A16",
    quest: "?",
    questeq: "\u225F",
    quot: '"',
    QUOT: '"',
    rAarr: "\u21DB",
    race: "\u223D\u0331",
    racute: "\u0155",
    Racute: "\u0154",
    radic: "\u221A",
    raemptyv: "\u29B3",
    rang: "\u27E9",
    Rang: "\u27EB",
    rangd: "\u2992",
    range: "\u29A5",
    rangle: "\u27E9",
    raquo: "\xBB",
    rarr: "\u2192",
    rArr: "\u21D2",
    Rarr: "\u21A0",
    rarrap: "\u2975",
    rarrb: "\u21E5",
    rarrbfs: "\u2920",
    rarrc: "\u2933",
    rarrfs: "\u291E",
    rarrhk: "\u21AA",
    rarrlp: "\u21AC",
    rarrpl: "\u2945",
    rarrsim: "\u2974",
    rarrtl: "\u21A3",
    Rarrtl: "\u2916",
    rarrw: "\u219D",
    ratail: "\u291A",
    rAtail: "\u291C",
    ratio: "\u2236",
    rationals: "\u211A",
    rbarr: "\u290D",
    rBarr: "\u290F",
    RBarr: "\u2910",
    rbbrk: "\u2773",
    rbrace: "}",
    rbrack: "]",
    rbrke: "\u298C",
    rbrksld: "\u298E",
    rbrkslu: "\u2990",
    rcaron: "\u0159",
    Rcaron: "\u0158",
    rcedil: "\u0157",
    Rcedil: "\u0156",
    rceil: "\u2309",
    rcub: "}",
    rcy: "\u0440",
    Rcy: "\u0420",
    rdca: "\u2937",
    rdldhar: "\u2969",
    rdquo: "\u201D",
    rdquor: "\u201D",
    rdsh: "\u21B3",
    Re: "\u211C",
    real: "\u211C",
    realine: "\u211B",
    realpart: "\u211C",
    reals: "\u211D",
    rect: "\u25AD",
    reg: "\xAE",
    REG: "\xAE",
    ReverseElement: "\u220B",
    ReverseEquilibrium: "\u21CB",
    ReverseUpEquilibrium: "\u296F",
    rfisht: "\u297D",
    rfloor: "\u230B",
    rfr: "\uD835\uDD2F",
    Rfr: "\u211C",
    rHar: "\u2964",
    rhard: "\u21C1",
    rharu: "\u21C0",
    rharul: "\u296C",
    rho: "\u03C1",
    Rho: "\u03A1",
    rhov: "\u03F1",
    RightAngleBracket: "\u27E9",
    rightarrow: "\u2192",
    Rightarrow: "\u21D2",
    RightArrow: "\u2192",
    RightArrowBar: "\u21E5",
    RightArrowLeftArrow: "\u21C4",
    rightarrowtail: "\u21A3",
    RightCeiling: "\u2309",
    RightDoubleBracket: "\u27E7",
    RightDownTeeVector: "\u295D",
    RightDownVector: "\u21C2",
    RightDownVectorBar: "\u2955",
    RightFloor: "\u230B",
    rightharpoondown: "\u21C1",
    rightharpoonup: "\u21C0",
    rightleftarrows: "\u21C4",
    rightleftharpoons: "\u21CC",
    rightrightarrows: "\u21C9",
    rightsquigarrow: "\u219D",
    RightTee: "\u22A2",
    RightTeeArrow: "\u21A6",
    RightTeeVector: "\u295B",
    rightthreetimes: "\u22CC",
    RightTriangle: "\u22B3",
    RightTriangleBar: "\u29D0",
    RightTriangleEqual: "\u22B5",
    RightUpDownVector: "\u294F",
    RightUpTeeVector: "\u295C",
    RightUpVector: "\u21BE",
    RightUpVectorBar: "\u2954",
    RightVector: "\u21C0",
    RightVectorBar: "\u2953",
    ring: "\u02DA",
    risingdotseq: "\u2253",
    rlarr: "\u21C4",
    rlhar: "\u21CC",
    rlm: "\u200F",
    rmoust: "\u23B1",
    rmoustache: "\u23B1",
    rnmid: "\u2AEE",
    roang: "\u27ED",
    roarr: "\u21FE",
    robrk: "\u27E7",
    ropar: "\u2986",
    ropf: "\uD835\uDD63",
    Ropf: "\u211D",
    roplus: "\u2A2E",
    rotimes: "\u2A35",
    RoundImplies: "\u2970",
    rpar: ")",
    rpargt: "\u2994",
    rppolint: "\u2A12",
    rrarr: "\u21C9",
    Rrightarrow: "\u21DB",
    rsaquo: "\u203A",
    rscr: "\uD835\uDCC7",
    Rscr: "\u211B",
    rsh: "\u21B1",
    Rsh: "\u21B1",
    rsqb: "]",
    rsquo: "\u2019",
    rsquor: "\u2019",
    rthree: "\u22CC",
    rtimes: "\u22CA",
    rtri: "\u25B9",
    rtrie: "\u22B5",
    rtrif: "\u25B8",
    rtriltri: "\u29CE",
    RuleDelayed: "\u29F4",
    ruluhar: "\u2968",
    rx: "\u211E",
    sacute: "\u015B",
    Sacute: "\u015A",
    sbquo: "\u201A",
    sc: "\u227B",
    Sc: "\u2ABC",
    scap: "\u2AB8",
    scaron: "\u0161",
    Scaron: "\u0160",
    sccue: "\u227D",
    sce: "\u2AB0",
    scE: "\u2AB4",
    scedil: "\u015F",
    Scedil: "\u015E",
    scirc: "\u015D",
    Scirc: "\u015C",
    scnap: "\u2ABA",
    scnE: "\u2AB6",
    scnsim: "\u22E9",
    scpolint: "\u2A13",
    scsim: "\u227F",
    scy: "\u0441",
    Scy: "\u0421",
    sdot: "\u22C5",
    sdotb: "\u22A1",
    sdote: "\u2A66",
    searhk: "\u2925",
    searr: "\u2198",
    seArr: "\u21D8",
    searrow: "\u2198",
    sect: "\xA7",
    semi: ";",
    seswar: "\u2929",
    setminus: "\u2216",
    setmn: "\u2216",
    sext: "\u2736",
    sfr: "\uD835\uDD30",
    Sfr: "\uD835\uDD16",
    sfrown: "\u2322",
    sharp: "\u266F",
    shchcy: "\u0449",
    SHCHcy: "\u0429",
    shcy: "\u0448",
    SHcy: "\u0428",
    ShortDownArrow: "\u2193",
    ShortLeftArrow: "\u2190",
    shortmid: "\u2223",
    shortparallel: "\u2225",
    ShortRightArrow: "\u2192",
    ShortUpArrow: "\u2191",
    shy: "\xAD",
    sigma: "\u03C3",
    Sigma: "\u03A3",
    sigmaf: "\u03C2",
    sigmav: "\u03C2",
    sim: "\u223C",
    simdot: "\u2A6A",
    sime: "\u2243",
    simeq: "\u2243",
    simg: "\u2A9E",
    simgE: "\u2AA0",
    siml: "\u2A9D",
    simlE: "\u2A9F",
    simne: "\u2246",
    simplus: "\u2A24",
    simrarr: "\u2972",
    slarr: "\u2190",
    SmallCircle: "\u2218",
    smallsetminus: "\u2216",
    smashp: "\u2A33",
    smeparsl: "\u29E4",
    smid: "\u2223",
    smile: "\u2323",
    smt: "\u2AAA",
    smte: "\u2AAC",
    smtes: "\u2AAC\uFE00",
    softcy: "\u044C",
    SOFTcy: "\u042C",
    sol: "/",
    solb: "\u29C4",
    solbar: "\u233F",
    sopf: "\uD835\uDD64",
    Sopf: "\uD835\uDD4A",
    spades: "\u2660",
    spadesuit: "\u2660",
    spar: "\u2225",
    sqcap: "\u2293",
    sqcaps: "\u2293\uFE00",
    sqcup: "\u2294",
    sqcups: "\u2294\uFE00",
    Sqrt: "\u221A",
    sqsub: "\u228F",
    sqsube: "\u2291",
    sqsubset: "\u228F",
    sqsubseteq: "\u2291",
    sqsup: "\u2290",
    sqsupe: "\u2292",
    sqsupset: "\u2290",
    sqsupseteq: "\u2292",
    squ: "\u25A1",
    square: "\u25A1",
    Square: "\u25A1",
    SquareIntersection: "\u2293",
    SquareSubset: "\u228F",
    SquareSubsetEqual: "\u2291",
    SquareSuperset: "\u2290",
    SquareSupersetEqual: "\u2292",
    SquareUnion: "\u2294",
    squarf: "\u25AA",
    squf: "\u25AA",
    srarr: "\u2192",
    sscr: "\uD835\uDCC8",
    Sscr: "\uD835\uDCAE",
    ssetmn: "\u2216",
    ssmile: "\u2323",
    sstarf: "\u22C6",
    star: "\u2606",
    Star: "\u22C6",
    starf: "\u2605",
    straightepsilon: "\u03F5",
    straightphi: "\u03D5",
    strns: "\xAF",
    sub: "\u2282",
    Sub: "\u22D0",
    subdot: "\u2ABD",
    sube: "\u2286",
    subE: "\u2AC5",
    subedot: "\u2AC3",
    submult: "\u2AC1",
    subne: "\u228A",
    subnE: "\u2ACB",
    subplus: "\u2ABF",
    subrarr: "\u2979",
    subset: "\u2282",
    Subset: "\u22D0",
    subseteq: "\u2286",
    subseteqq: "\u2AC5",
    SubsetEqual: "\u2286",
    subsetneq: "\u228A",
    subsetneqq: "\u2ACB",
    subsim: "\u2AC7",
    subsub: "\u2AD5",
    subsup: "\u2AD3",
    succ: "\u227B",
    succapprox: "\u2AB8",
    succcurlyeq: "\u227D",
    Succeeds: "\u227B",
    SucceedsEqual: "\u2AB0",
    SucceedsSlantEqual: "\u227D",
    SucceedsTilde: "\u227F",
    succeq: "\u2AB0",
    succnapprox: "\u2ABA",
    succneqq: "\u2AB6",
    succnsim: "\u22E9",
    succsim: "\u227F",
    SuchThat: "\u220B",
    sum: "\u2211",
    Sum: "\u2211",
    sung: "\u266A",
    sup: "\u2283",
    Sup: "\u22D1",
    sup1: "\xB9",
    sup2: "\xB2",
    sup3: "\xB3",
    supdot: "\u2ABE",
    supdsub: "\u2AD8",
    supe: "\u2287",
    supE: "\u2AC6",
    supedot: "\u2AC4",
    Superset: "\u2283",
    SupersetEqual: "\u2287",
    suphsol: "\u27C9",
    suphsub: "\u2AD7",
    suplarr: "\u297B",
    supmult: "\u2AC2",
    supne: "\u228B",
    supnE: "\u2ACC",
    supplus: "\u2AC0",
    supset: "\u2283",
    Supset: "\u22D1",
    supseteq: "\u2287",
    supseteqq: "\u2AC6",
    supsetneq: "\u228B",
    supsetneqq: "\u2ACC",
    supsim: "\u2AC8",
    supsub: "\u2AD4",
    supsup: "\u2AD6",
    swarhk: "\u2926",
    swarr: "\u2199",
    swArr: "\u21D9",
    swarrow: "\u2199",
    swnwar: "\u292A",
    szlig: "\xDF",
    Tab: "\t",
    target: "\u2316",
    tau: "\u03C4",
    Tau: "\u03A4",
    tbrk: "\u23B4",
    tcaron: "\u0165",
    Tcaron: "\u0164",
    tcedil: "\u0163",
    Tcedil: "\u0162",
    tcy: "\u0442",
    Tcy: "\u0422",
    tdot: "\u20DB",
    telrec: "\u2315",
    tfr: "\uD835\uDD31",
    Tfr: "\uD835\uDD17",
    there4: "\u2234",
    therefore: "\u2234",
    Therefore: "\u2234",
    theta: "\u03B8",
    Theta: "\u0398",
    thetasym: "\u03D1",
    thetav: "\u03D1",
    thickapprox: "\u2248",
    thicksim: "\u223C",
    ThickSpace: "\u205F\u200A",
    thinsp: "\u2009",
    ThinSpace: "\u2009",
    thkap: "\u2248",
    thksim: "\u223C",
    thorn: "\xFE",
    THORN: "\xDE",
    tilde: "\u02DC",
    Tilde: "\u223C",
    TildeEqual: "\u2243",
    TildeFullEqual: "\u2245",
    TildeTilde: "\u2248",
    times: "\xD7",
    timesb: "\u22A0",
    timesbar: "\u2A31",
    timesd: "\u2A30",
    tint: "\u222D",
    toea: "\u2928",
    top: "\u22A4",
    topbot: "\u2336",
    topcir: "\u2AF1",
    topf: "\uD835\uDD65",
    Topf: "\uD835\uDD4B",
    topfork: "\u2ADA",
    tosa: "\u2929",
    tprime: "\u2034",
    trade: "\u2122",
    TRADE: "\u2122",
    triangle: "\u25B5",
    triangledown: "\u25BF",
    triangleleft: "\u25C3",
    trianglelefteq: "\u22B4",
    triangleq: "\u225C",
    triangleright: "\u25B9",
    trianglerighteq: "\u22B5",
    tridot: "\u25EC",
    trie: "\u225C",
    triminus: "\u2A3A",
    TripleDot: "\u20DB",
    triplus: "\u2A39",
    trisb: "\u29CD",
    tritime: "\u2A3B",
    trpezium: "\u23E2",
    tscr: "\uD835\uDCC9",
    Tscr: "\uD835\uDCAF",
    tscy: "\u0446",
    TScy: "\u0426",
    tshcy: "\u045B",
    TSHcy: "\u040B",
    tstrok: "\u0167",
    Tstrok: "\u0166",
    twixt: "\u226C",
    twoheadleftarrow: "\u219E",
    twoheadrightarrow: "\u21A0",
    uacute: "\xFA",
    Uacute: "\xDA",
    uarr: "\u2191",
    uArr: "\u21D1",
    Uarr: "\u219F",
    Uarrocir: "\u2949",
    ubrcy: "\u045E",
    Ubrcy: "\u040E",
    ubreve: "\u016D",
    Ubreve: "\u016C",
    ucirc: "\xFB",
    Ucirc: "\xDB",
    ucy: "\u0443",
    Ucy: "\u0423",
    udarr: "\u21C5",
    udblac: "\u0171",
    Udblac: "\u0170",
    udhar: "\u296E",
    ufisht: "\u297E",
    ufr: "\uD835\uDD32",
    Ufr: "\uD835\uDD18",
    ugrave: "\xF9",
    Ugrave: "\xD9",
    uHar: "\u2963",
    uharl: "\u21BF",
    uharr: "\u21BE",
    uhblk: "\u2580",
    ulcorn: "\u231C",
    ulcorner: "\u231C",
    ulcrop: "\u230F",
    ultri: "\u25F8",
    umacr: "\u016B",
    Umacr: "\u016A",
    uml: "\xA8",
    UnderBar: "_",
    UnderBrace: "\u23DF",
    UnderBracket: "\u23B5",
    UnderParenthesis: "\u23DD",
    Union: "\u22C3",
    UnionPlus: "\u228E",
    uogon: "\u0173",
    Uogon: "\u0172",
    uopf: "\uD835\uDD66",
    Uopf: "\uD835\uDD4C",
    uparrow: "\u2191",
    Uparrow: "\u21D1",
    UpArrow: "\u2191",
    UpArrowBar: "\u2912",
    UpArrowDownArrow: "\u21C5",
    updownarrow: "\u2195",
    Updownarrow: "\u21D5",
    UpDownArrow: "\u2195",
    UpEquilibrium: "\u296E",
    upharpoonleft: "\u21BF",
    upharpoonright: "\u21BE",
    uplus: "\u228E",
    UpperLeftArrow: "\u2196",
    UpperRightArrow: "\u2197",
    upsi: "\u03C5",
    Upsi: "\u03D2",
    upsih: "\u03D2",
    upsilon: "\u03C5",
    Upsilon: "\u03A5",
    UpTee: "\u22A5",
    UpTeeArrow: "\u21A5",
    upuparrows: "\u21C8",
    urcorn: "\u231D",
    urcorner: "\u231D",
    urcrop: "\u230E",
    uring: "\u016F",
    Uring: "\u016E",
    urtri: "\u25F9",
    uscr: "\uD835\uDCCA",
    Uscr: "\uD835\uDCB0",
    utdot: "\u22F0",
    utilde: "\u0169",
    Utilde: "\u0168",
    utri: "\u25B5",
    utrif: "\u25B4",
    uuarr: "\u21C8",
    uuml: "\xFC",
    Uuml: "\xDC",
    uwangle: "\u29A7",
    vangrt: "\u299C",
    varepsilon: "\u03F5",
    varkappa: "\u03F0",
    varnothing: "\u2205",
    varphi: "\u03D5",
    varpi: "\u03D6",
    varpropto: "\u221D",
    varr: "\u2195",
    vArr: "\u21D5",
    varrho: "\u03F1",
    varsigma: "\u03C2",
    varsubsetneq: "\u228A\uFE00",
    varsubsetneqq: "\u2ACB\uFE00",
    varsupsetneq: "\u228B\uFE00",
    varsupsetneqq: "\u2ACC\uFE00",
    vartheta: "\u03D1",
    vartriangleleft: "\u22B2",
    vartriangleright: "\u22B3",
    vBar: "\u2AE8",
    Vbar: "\u2AEB",
    vBarv: "\u2AE9",
    vcy: "\u0432",
    Vcy: "\u0412",
    vdash: "\u22A2",
    vDash: "\u22A8",
    Vdash: "\u22A9",
    VDash: "\u22AB",
    Vdashl: "\u2AE6",
    vee: "\u2228",
    Vee: "\u22C1",
    veebar: "\u22BB",
    veeeq: "\u225A",
    vellip: "\u22EE",
    verbar: "|",
    Verbar: "\u2016",
    vert: "|",
    Vert: "\u2016",
    VerticalBar: "\u2223",
    VerticalLine: "|",
    VerticalSeparator: "\u2758",
    VerticalTilde: "\u2240",
    VeryThinSpace: "\u200A",
    vfr: "\uD835\uDD33",
    Vfr: "\uD835\uDD19",
    vltri: "\u22B2",
    vnsub: "\u2282\u20D2",
    vnsup: "\u2283\u20D2",
    vopf: "\uD835\uDD67",
    Vopf: "\uD835\uDD4D",
    vprop: "\u221D",
    vrtri: "\u22B3",
    vscr: "\uD835\uDCCB",
    Vscr: "\uD835\uDCB1",
    vsubne: "\u228A\uFE00",
    vsubnE: "\u2ACB\uFE00",
    vsupne: "\u228B\uFE00",
    vsupnE: "\u2ACC\uFE00",
    Vvdash: "\u22AA",
    vzigzag: "\u299A",
    wcirc: "\u0175",
    Wcirc: "\u0174",
    wedbar: "\u2A5F",
    wedge: "\u2227",
    Wedge: "\u22C0",
    wedgeq: "\u2259",
    weierp: "\u2118",
    wfr: "\uD835\uDD34",
    Wfr: "\uD835\uDD1A",
    wopf: "\uD835\uDD68",
    Wopf: "\uD835\uDD4E",
    wp: "\u2118",
    wr: "\u2240",
    wreath: "\u2240",
    wscr: "\uD835\uDCCC",
    Wscr: "\uD835\uDCB2",
    xcap: "\u22C2",
    xcirc: "\u25EF",
    xcup: "\u22C3",
    xdtri: "\u25BD",
    xfr: "\uD835\uDD35",
    Xfr: "\uD835\uDD1B",
    xharr: "\u27F7",
    xhArr: "\u27FA",
    xi: "\u03BE",
    Xi: "\u039E",
    xlarr: "\u27F5",
    xlArr: "\u27F8",
    xmap: "\u27FC",
    xnis: "\u22FB",
    xodot: "\u2A00",
    xopf: "\uD835\uDD69",
    Xopf: "\uD835\uDD4F",
    xoplus: "\u2A01",
    xotime: "\u2A02",
    xrarr: "\u27F6",
    xrArr: "\u27F9",
    xscr: "\uD835\uDCCD",
    Xscr: "\uD835\uDCB3",
    xsqcup: "\u2A06",
    xuplus: "\u2A04",
    xutri: "\u25B3",
    xvee: "\u22C1",
    xwedge: "\u22C0",
    yacute: "\xFD",
    Yacute: "\xDD",
    yacy: "\u044F",
    YAcy: "\u042F",
    ycirc: "\u0177",
    Ycirc: "\u0176",
    ycy: "\u044B",
    Ycy: "\u042B",
    yen: "\xA5",
    yfr: "\uD835\uDD36",
    Yfr: "\uD835\uDD1C",
    yicy: "\u0457",
    YIcy: "\u0407",
    yopf: "\uD835\uDD6A",
    Yopf: "\uD835\uDD50",
    yscr: "\uD835\uDCCE",
    Yscr: "\uD835\uDCB4",
    yucy: "\u044E",
    YUcy: "\u042E",
    yuml: "\xFF",
    Yuml: "\u0178",
    zacute: "\u017A",
    Zacute: "\u0179",
    zcaron: "\u017E",
    Zcaron: "\u017D",
    zcy: "\u0437",
    Zcy: "\u0417",
    zdot: "\u017C",
    Zdot: "\u017B",
    zeetrf: "\u2128",
    ZeroWidthSpace: "\u200B",
    zeta: "\u03B6",
    Zeta: "\u0396",
    zfr: "\uD835\uDD37",
    Zfr: "\u2128",
    zhcy: "\u0436",
    ZHcy: "\u0416",
    zigrarr: "\u21DD",
    zopf: "\uD835\uDD6B",
    Zopf: "\u2124",
    zscr: "\uD835\uDCCF",
    Zscr: "\uD835\uDCB5",
    zwj: "\u200D",
    zwnj: "\u200C",
  };
  var decodeMapLegacy = {
    aacute: "\xE1",
    Aacute: "\xC1",
    acirc: "\xE2",
    Acirc: "\xC2",
    acute: "\xB4",
    aelig: "\xE6",
    AElig: "\xC6",
    agrave: "\xE0",
    Agrave: "\xC0",
    amp: "&",
    AMP: "&",
    aring: "\xE5",
    Aring: "\xC5",
    atilde: "\xE3",
    Atilde: "\xC3",
    auml: "\xE4",
    Auml: "\xC4",
    brvbar: "\xA6",
    ccedil: "\xE7",
    Ccedil: "\xC7",
    cedil: "\xB8",
    cent: "\xA2",
    copy: "\xA9",
    COPY: "\xA9",
    curren: "\xA4",
    deg: "\xB0",
    divide: "\xF7",
    eacute: "\xE9",
    Eacute: "\xC9",
    ecirc: "\xEA",
    Ecirc: "\xCA",
    egrave: "\xE8",
    Egrave: "\xC8",
    eth: "\xF0",
    ETH: "\xD0",
    euml: "\xEB",
    Euml: "\xCB",
    frac12: "\xBD",
    frac14: "\xBC",
    frac34: "\xBE",
    gt: ">",
    GT: ">",
    iacute: "\xED",
    Iacute: "\xCD",
    icirc: "\xEE",
    Icirc: "\xCE",
    iexcl: "\xA1",
    igrave: "\xEC",
    Igrave: "\xCC",
    iquest: "\xBF",
    iuml: "\xEF",
    Iuml: "\xCF",
    laquo: "\xAB",
    lt: "<",
    LT: "<",
    macr: "\xAF",
    micro: "\xB5",
    middot: "\xB7",
    nbsp: "\xA0",
    not: "\xAC",
    ntilde: "\xF1",
    Ntilde: "\xD1",
    oacute: "\xF3",
    Oacute: "\xD3",
    ocirc: "\xF4",
    Ocirc: "\xD4",
    ograve: "\xF2",
    Ograve: "\xD2",
    ordf: "\xAA",
    ordm: "\xBA",
    oslash: "\xF8",
    Oslash: "\xD8",
    otilde: "\xF5",
    Otilde: "\xD5",
    ouml: "\xF6",
    Ouml: "\xD6",
    para: "\xB6",
    plusmn: "\xB1",
    pound: "\xA3",
    quot: '"',
    QUOT: '"',
    raquo: "\xBB",
    reg: "\xAE",
    REG: "\xAE",
    sect: "\xA7",
    shy: "\xAD",
    sup1: "\xB9",
    sup2: "\xB2",
    sup3: "\xB3",
    szlig: "\xDF",
    thorn: "\xFE",
    THORN: "\xDE",
    times: "\xD7",
    uacute: "\xFA",
    Uacute: "\xDA",
    ucirc: "\xFB",
    Ucirc: "\xDB",
    ugrave: "\xF9",
    Ugrave: "\xD9",
    uml: "\xA8",
    uuml: "\xFC",
    Uuml: "\xDC",
    yacute: "\xFD",
    Yacute: "\xDD",
    yen: "\xA5",
    yuml: "\xFF",
  };
  var decodeMapNumeric = {
    0: "\uFFFD",
    128: "\u20AC",
    130: "\u201A",
    131: "\u0192",
    132: "\u201E",
    133: "\u2026",
    134: "\u2020",
    135: "\u2021",
    136: "\u02C6",
    137: "\u2030",
    138: "\u0160",
    139: "\u2039",
    140: "\u0152",
    142: "\u017D",
    145: "\u2018",
    146: "\u2019",
    147: "\u201C",
    148: "\u201D",
    149: "\u2022",
    150: "\u2013",
    151: "\u2014",
    152: "\u02DC",
    153: "\u2122",
    154: "\u0161",
    155: "\u203A",
    156: "\u0153",
    158: "\u017E",
    159: "\u0178",
  };
  var invalidReferenceCodePoints = [
    1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
    25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135,
    136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150,
    151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979,
    64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990,
    64991, 64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65000, 65001,
    65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071,
    196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750,
    458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895,
    786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574,
    1048575, 1114110, 1114111,
  ];

  /*--------------------------------------------------------------------------*/

  var stringFromCharCode = String.fromCharCode;

  var object = {};
  var hasOwnProperty = object.hasOwnProperty;
  var has = function (object, propertyName) {
    return hasOwnProperty.call(object, propertyName);
  };

  var contains = function (array, value) {
    var index = -1;
    var length = array.length;
    while (++index < length) {
      if (array[index] == value) {
        return true;
      }
    }
    return false;
  };

  var merge = function (options, defaults) {
    if (!options) {
      return defaults;
    }
    var result = {};
    var key;
    for (key in defaults) {
      // A `hasOwnProperty` check is not needed here, since only recognized
      // option names are used anyway. Any others are ignored.
      result[key] = has(options, key) ? options[key] : defaults[key];
    }
    return result;
  };

  // Modified version of `ucs2encode`; see https://mths.be/punycode.
  var codePointToSymbol = function (codePoint, strict) {
    var output = "";
    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
      // See issue #4:
      // “Otherwise, if the number is in the range 0xD800 to 0xDFFF or is
      // greater than 0x10FFFF, then this is a parse error. Return a U+FFFD
      // REPLACEMENT CHARACTER.”
      if (strict) {
        parseError("character reference outside the permissible Unicode range");
      }
      return "\uFFFD";
    }
    if (has(decodeMapNumeric, codePoint)) {
      if (strict) {
        parseError("disallowed character reference");
      }
      return decodeMapNumeric[codePoint];
    }
    if (strict && contains(invalidReferenceCodePoints, codePoint)) {
      parseError("disallowed character reference");
    }
    if (codePoint > 0xffff) {
      codePoint -= 0x10000;
      output += stringFromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
      codePoint = 0xdc00 | (codePoint & 0x3ff);
    }
    output += stringFromCharCode(codePoint);
    return output;
  };

  var hexEscape = function (codePoint) {
    return "&#x" + codePoint.toString(16).toUpperCase() + ";";
  };

  var decEscape = function (codePoint) {
    return "&#" + codePoint + ";";
  };

  var parseError = function (message) {
    throw Error("Parse error: " + message);
  };

  /*--------------------------------------------------------------------------*/

  var encode = function (string, options) {
    options = merge(options, encode.options);
    var strict = options.strict;
    if (strict && regexInvalidRawCodePoint.test(string)) {
      parseError("forbidden code point");
    }
    var encodeEverything = options.encodeEverything;
    var useNamedReferences = options.useNamedReferences;
    var allowUnsafeSymbols = options.allowUnsafeSymbols;
    var escapeCodePoint = options.decimal ? decEscape : hexEscape;

    var escapeBmpSymbol = function (symbol) {
      return escapeCodePoint(symbol.charCodeAt(0));
    };

    if (encodeEverything) {
      // Encode ASCII symbols.
      string = string.replace(regexAsciiWhitelist, function (symbol) {
        // Use named references if requested & possible.
        if (useNamedReferences && has(encodeMap, symbol)) {
          return "&" + encodeMap[symbol] + ";";
        }
        return escapeBmpSymbol(symbol);
      });
      // Shorten a few escapes that represent two symbols, of which at least one
      // is within the ASCII range.
      if (useNamedReferences) {
        string = string
          .replace(/&gt;\u20D2/g, "&nvgt;")
          .replace(/&lt;\u20D2/g, "&nvlt;")
          .replace(/&#x66;&#x6A;/g, "&fjlig;");
      }
      // Encode non-ASCII symbols.
      if (useNamedReferences) {
        // Encode non-ASCII symbols that can be replaced with a named reference.
        string = string.replace(regexEncodeNonAscii, function (string) {
          // Note: there is no need to check `has(encodeMap, string)` here.
          return "&" + encodeMap[string] + ";";
        });
      }
      // Note: any remaining non-ASCII symbols are handled outside of the `if`.
    } else if (useNamedReferences) {
      // Apply named character references.
      // Encode `<>"'&` using named character references.
      if (!allowUnsafeSymbols) {
        string = string.replace(regexEscape, function (string) {
          return "&" + encodeMap[string] + ";"; // no need to check `has()` here
        });
      }
      // Shorten escapes that represent two symbols, of which at least one is
      // `<>"'&`.
      string = string
        .replace(/&gt;\u20D2/g, "&nvgt;")
        .replace(/&lt;\u20D2/g, "&nvlt;");
      // Encode non-ASCII symbols that can be replaced with a named reference.
      string = string.replace(regexEncodeNonAscii, function (string) {
        // Note: there is no need to check `has(encodeMap, string)` here.
        return "&" + encodeMap[string] + ";";
      });
    } else if (!allowUnsafeSymbols) {
      // Encode `<>"'&` using hexadecimal escapes, now that they’re not handled
      // using named character references.
      string = string.replace(regexEscape, escapeBmpSymbol);
    }
    return (
      string
        // Encode astral symbols.
        .replace(regexAstralSymbols, function ($0) {
          // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
          var high = $0.charCodeAt(0);
          var low = $0.charCodeAt(1);
          var codePoint = (high - 0xd800) * 0x400 + low - 0xdc00 + 0x10000;
          return escapeCodePoint(codePoint);
        })
        // Encode any remaining BMP symbols that are not printable ASCII symbols
        // using a hexadecimal escape.
        .replace(regexBmpWhitelist, escapeBmpSymbol)
    );
  };
  // Expose default options (so they can be overridden globally).
  encode.options = {
    allowUnsafeSymbols: false,
    encodeEverything: false,
    strict: false,
    useNamedReferences: false,
    decimal: false,
  };

  var decode = function (html, options) {
    options = merge(options, decode.options);
    var strict = options.strict;
    if (strict && regexInvalidEntity.test(html)) {
      parseError("malformed character reference");
    }
    return html.replace(regexDecode, function ($0, $1, $2, $3, $4, $5, $6, $7) {
      var codePoint;
      var semicolon;
      var decDigits;
      var hexDigits;
      var reference;
      var next;
      if ($1) {
        // Decode decimal escapes, e.g. `&#119558;`.
        decDigits = $1;
        semicolon = $2;
        if (strict && !semicolon) {
          parseError("character reference was not terminated by a semicolon");
        }
        codePoint = parseInt(decDigits, 10);
        return codePointToSymbol(codePoint, strict);
      }
      if ($3) {
        // Decode hexadecimal escapes, e.g. `&#x1D306;`.
        hexDigits = $3;
        semicolon = $4;
        if (strict && !semicolon) {
          parseError("character reference was not terminated by a semicolon");
        }
        codePoint = parseInt(hexDigits, 16);
        return codePointToSymbol(codePoint, strict);
      }
      if ($5) {
        // Decode named character references with trailing `;`, e.g. `&copy;`.
        reference = $5;
        if (has(decodeMap, reference)) {
          return decodeMap[reference];
        } else {
          // Ambiguous ampersand. https://mths.be/notes/ambiguous-ampersands
          if (strict) {
            parseError(
              "named character reference was not terminated by a semicolon"
            );
          }
          return $0;
        }
      }
      // If we’re still here, it’s a legacy reference for sure. No need for an
      // extra `if` check.
      // Decode named character references without trailing `;`, e.g. `&amp`
      // This is only a parse error if it gets converted to `&`, or if it is
      // followed by `=` in an attribute context.
      reference = $6;
      next = $7;
      if (next && options.isAttributeValue) {
        if (strict && next == "=") {
          parseError("`&` did not start a character reference");
        }
        return $0;
      } else {
        if (strict) {
          parseError(
            "named character reference was not terminated by a semicolon"
          );
        }
        // Note: there is no need to check `has(decodeMapLegacy, reference)`.
        return decodeMapLegacy[reference] + (next || "");
      }
    });
  };
  // Expose default options (so they can be overridden globally).
  decode.options = {
    isAttributeValue: false,
    strict: false,
  };

  var escape = function (string) {
    return string.replace(regexEscape, function ($0) {
      // Note: there is no need to check `has(escapeMap, $0)` here.
      return escapeMap[$0];
    });
  };

  /*--------------------------------------------------------------------------*/

  var he = {
    version: "1.1.1",
    encode: encode,
    decode: decode,
    escape: escape,
    unescape: decode,
  };

  // Some AMD build optimizers, like r.js, check for specific condition patterns
  // like the following:
  // if (
  // 	typeof define == 'function' &&
  // 	typeof define.amd == 'object' &&
  // 	define.amd
  // ) {
  // 	define(function() {
  // 		return he;
  // 	});
  // }	else if (freeExports && !freeExports.nodeType) {
  // 	if (freeModule) { // in Node.js, io.js, or RingoJS v0.8.0+
  // 		freeModule.exports = he;
  // 	} else { // in Narwhal or RingoJS v0.7.0-
  // 		for (var key in he) {
  // 			has(he, key) && (freeExports[key] = he[key]);
  // 		}
  // 	}
  // } else { // in Rhino or a web browser
  root.he = he;
  // }
})(this);

/*!
 * jQuery pagination plugin v1.4.1
 * http://esimakin.github.io/twbs-pagination/
 *
 * Copyright 2014-2016, Eugene Simakin
 * Released under Apache 2.0 license
 * http://apache.org/licenses/LICENSE-2.0.html
 */
(function ($, window, document, undefined) {
  "use strict";

  var old = $.fn.twbsPagination;

  // PROTOTYPE AND CONSTRUCTOR

  var TwbsPagination = function (element, options) {
    this.$element = $(element);
    this.options = $.extend({}, $.fn.twbsPagination.defaults, options);

    if (
      this.options.startPage < 1 ||
      this.options.startPage > this.options.totalPages
    ) {
      throw new Error("Start page option is incorrect");
    }

    this.options.totalPages = parseInt(this.options.totalPages);
    if (isNaN(this.options.totalPages)) {
      throw new Error("Total pages option is not correct!");
    }

    this.options.visiblePages = parseInt(this.options.visiblePages);
    if (isNaN(this.options.visiblePages)) {
      throw new Error("Visible pages option is not correct!");
    }

    if (this.options.onPageClick instanceof Function) {
      this.$element.first().on("page", this.options.onPageClick);
    }

    // hide if only one page exists
    if (this.options.hideOnlyOnePage && this.options.totalPages == 1) {
      this.$element.trigger("page", 1);
      return this;
    }

    if (this.options.totalPages < this.options.visiblePages) {
      this.options.visiblePages = this.options.totalPages;
    }

    if (this.options.href) {
      this.options.startPage = this.getPageFromQueryString();
      if (!this.options.startPage) {
        this.options.startPage = 1;
      }
    }

    var tagName =
      typeof this.$element.prop === "function"
        ? this.$element.prop("tagName")
        : this.$element.attr("tagName");

    if (tagName === "UL") {
      this.$listContainer = this.$element;
    } else {
      this.$listContainer = $("<ul></ul>");
    }

    this.$listContainer.addClass(this.options.paginationClass);

    if (tagName !== "UL") {
      this.$element.append(this.$listContainer);
    }

    if (this.options.initiateStartPageClick) {
      this.show(this.options.startPage);
    } else {
      this.currentPage = this.options.startPage;
      this.render(this.getPages(this.options.startPage));
      this.setupEvents();
    }

    return this;
  };

  TwbsPagination.prototype = {
    constructor: TwbsPagination,

    destroy: function () {
      this.$element.empty();
      this.$element.removeData("twbs-pagination");
      this.$element.off("page");

      return this;
    },

    show: function (page) {
      if (page < 1 || page > this.options.totalPages) {
        throw new Error("Page is incorrect.");
      }
      this.currentPage = page;

      this.render(this.getPages(page));
      this.setupEvents();

      this.$element.trigger("page", page);

      return this;
    },

    enable: function () {
      this.show(this.currentPage);
    },

    disable: function () {
      var _this = this;
      this.$listContainer.off("click").on("click", "li", function (evt) {
        evt.preventDefault();
      });
      this.$listContainer.children().each(function () {
        var $this = $(this);
        if (!$this.hasClass(_this.options.activeClass)) {
          $(this).addClass(_this.options.disabledClass);
        }
      });
    },

    buildListItems: function (pages) {
      var listItems = [];

      if (this.options.first) {
        listItems.push(this.buildItem("first", 1));
      }

      if (this.options.prev) {
        var prev =
          pages.currentPage > 1
            ? pages.currentPage - 1
            : this.options.loop
            ? this.options.totalPages
            : 1;
        listItems.push(this.buildItem("prev", prev));
      }

      for (var i = 0; i < pages.numeric.length; i++) {
        listItems.push(this.buildItem("page", pages.numeric[i]));
      }

      if (this.options.next) {
        var next =
          pages.currentPage < this.options.totalPages
            ? pages.currentPage + 1
            : this.options.loop
            ? 1
            : this.options.totalPages;
        listItems.push(this.buildItem("next", next));
      }

      if (this.options.last) {
        listItems.push(this.buildItem("last", this.options.totalPages));
      }

      return listItems;
    },

    buildItem: function (type, page) {
      var $itemContainer = $("<li></li>"),
        $itemContent = $("<a></a>"),
        itemText = this.options[type]
          ? this.makeText(this.options[type], page)
          : page;

      $itemContainer.addClass(this.options[type + "Class"]);
      $itemContainer.data("page", page);
      $itemContainer.data("page-type", type);
      $itemContainer.append(
        $itemContent
          .attr("href", this.makeHref(page))
          .addClass(this.options.anchorClass)
          .html(itemText)
      );

      return $itemContainer;
    },

    getPages: function (currentPage) {
      var pages = [];

      var half = Math.floor(this.options.visiblePages / 2);
      var start = currentPage - half + 1 - (this.options.visiblePages % 2);
      var end = currentPage + half;

      // handle boundary case
      if (start <= 0) {
        start = 1;
        end = this.options.visiblePages;
      }
      if (end > this.options.totalPages) {
        start = this.options.totalPages - this.options.visiblePages + 1;
        end = this.options.totalPages;
      }

      var itPage = start;
      while (itPage <= end) {
        pages.push(itPage);
        itPage++;
      }

      return { currentPage: currentPage, numeric: pages };
    },

    render: function (pages) {
      var _this = this;
      this.$listContainer.children().remove();
      var items = this.buildListItems(pages);
      $.each(items, function (key, item) {
        _this.$listContainer.append(item);
      });

      this.$listContainer.children().each(function () {
        var $this = $(this),
          pageType = $this.data("page-type");

        switch (pageType) {
          case "page":
            if ($this.data("page") === pages.currentPage) {
              $this.addClass(_this.options.activeClass);
            }
            break;
          case "first":
            $this.toggleClass(
              _this.options.disabledClass,
              pages.currentPage === 1
            );
            break;
          case "last":
            $this.toggleClass(
              _this.options.disabledClass,
              pages.currentPage === _this.options.totalPages
            );
            break;
          case "prev":
            $this.toggleClass(
              _this.options.disabledClass,
              !_this.options.loop && pages.currentPage === 1
            );
            break;
          case "next":
            $this.toggleClass(
              _this.options.disabledClass,
              !_this.options.loop &&
                pages.currentPage === _this.options.totalPages
            );
            break;
          default:
            break;
        }
      });
    },

    setupEvents: function () {
      var _this = this;
      this.$listContainer.off("click").on("click", "li", function (evt) {
        var $this = $(this);
        if (
          $this.hasClass(_this.options.disabledClass) ||
          $this.hasClass(_this.options.activeClass)
        ) {
          return false;
        }
        // Prevent click event if href is not set.
        !_this.options.href && evt.preventDefault();
        _this.show(parseInt($this.data("page")));
      });
    },

    makeHref: function (page) {
      return this.options.href ? this.generateQueryString(page) : "#";
    },

    makeText: function (text, page) {
      return text
        .replace(this.options.pageVariable, page)
        .replace(this.options.totalPagesVariable, this.options.totalPages);
    },
    getPageFromQueryString: function (searchStr) {
      var search = this.getSearchString(searchStr),
        regex = new RegExp(this.options.pageVariable + "(=([^&#]*)|&|#|$)"),
        page = regex.exec(search);
      if (!page || !page[2]) {
        return null;
      }
      page = decodeURIComponent(page[2]);
      page = parseInt(page);
      if (isNaN(page)) {
        return null;
      }
      return page;
    },
    generateQueryString: function (pageNumber, searchStr) {
      var search = this.getSearchString(searchStr),
        regex = new RegExp(this.options.pageVariable + "=*[^&#]*");
      if (!search) return "";
      return (
        "?" +
        search.replace(regex, this.options.pageVariable + "=" + pageNumber)
      );
    },
    getSearchString: function (searchStr) {
      var search = searchStr || window.location.search;
      if (search === "") {
        return null;
      }
      if (search.indexOf("?") === 0) search = search.substr(1);
      return search;
    },
    getCurrentPage: function () {
      return this.currentPage;
    },
  };

  // PLUGIN DEFINITION

  $.fn.twbsPagination = function (option) {
    var args = Array.prototype.slice.call(arguments, 1);
    var methodReturn;

    var $this = $(this);
    var data = $this.data("twbs-pagination");
    var options = typeof option === "object" ? option : {};

    if (!data)
      $this.data("twbs-pagination", (data = new TwbsPagination(this, options)));
    if (typeof option === "string")
      methodReturn = data[option].apply(data, args);

    return methodReturn === undefined ? $this : methodReturn;
  };

  $.fn.twbsPagination.defaults = {
    totalPages: 1,
    startPage: 1,
    visiblePages: 5,
    initiateStartPageClick: true,
    hideOnlyOnePage: false,
    href: false,
    pageVariable: "{{page}}",
    totalPagesVariable: "{{total_pages}}",
    page: null,
    first: "First",
    prev: "Previous",
    next: "Next",
    last: "Last",
    loop: false,
    onPageClick: null,
    paginationClass: "pagination",
    nextClass: "page-item next",
    prevClass: "page-item prev",
    lastClass: "page-item last",
    firstClass: "page-item first",
    pageClass: "page-item",
    activeClass: "active",
    disabledClass: "disabled",
    anchorClass: "page-link",
  };

  $.fn.twbsPagination.Constructor = TwbsPagination;

  $.fn.twbsPagination.noConflict = function () {
    $.fn.twbsPagination = old;
    return this;
  };

  $.fn.twbsPagination.version = "1.4.1";
})(window.jQuery, window, document);

/*!
 * Masonry PACKAGED v4.2.1
 * Cascading grid layout library
 * https://masonry.desandro.com
 * MIT License
 * by David DeSandro
 */

/**
 * Bridget makes jQuery widgets
 * v2.0.1
 * MIT license
 */

/* jshint browser: true, strict: true, undef: true, unused: true */

(function (window, factory) {
  // universal module definition
  /*jshint strict: false */ /* globals define, module, require */
  if (typeof define == "function" && define.amd) {
    // AMD
    define("jquery-bridget/jquery-bridget", ["jquery"], function (jQuery) {
      return factory(window, jQuery);
    });
  } else if (typeof module == "object" && module.exports) {
    // CommonJS
    module.exports = factory(window, require("jquery"));
  } else {
    // browser global
    window.jQueryBridget = factory(window, window.jQuery);
  }
})(window, function factory(window, jQuery) {
  "use strict";

  // ----- utils ----- //

  var arraySlice = Array.prototype.slice;

  // helper function for logging errors
  // $.error breaks jQuery chaining
  var console = window.console;
  var logError =
    typeof console == "undefined"
      ? function () {}
      : function (message) {
          console.error(message);
        };

  // ----- jQueryBridget ----- //

  function jQueryBridget(namespace, PluginClass, $) {
    $ = $ || jQuery || window.jQuery;
    if (!$) {
      return;
    }

    // add option method -> $().plugin('option', {...})
    if (!PluginClass.prototype.option) {
      // option setter
      PluginClass.prototype.option = function (opts) {
        // bail out if not an object
        if (!$.isPlainObject(opts)) {
          return;
        }
        this.options = $.extend(true, this.options, opts);
      };
    }

    // make jQuery plugin
    $.fn[namespace] = function (arg0 /*, arg1 */) {
      if (typeof arg0 == "string") {
        // method call $().plugin( 'methodName', { options } )
        // shift arguments by 1
        var args = arraySlice.call(arguments, 1);
        return methodCall(this, arg0, args);
      }
      // just $().plugin({ options })
      plainCall(this, arg0);
      return this;
    };

    // $().plugin('methodName')
    function methodCall($elems, methodName, args) {
      var returnValue;
      var pluginMethodStr = "$()." + namespace + '("' + methodName + '")';

      $elems.each(function (i, elem) {
        // get instance
        var instance = $.data(elem, namespace);
        if (!instance) {
          logError(
            namespace +
              " not initialized. Cannot call methods, i.e. " +
              pluginMethodStr
          );
          return;
        }

        var method = instance[methodName];
        if (!method || methodName.charAt(0) == "_") {
          logError(pluginMethodStr + " is not a valid method");
          return;
        }

        // apply method, get return value
        var value = method.apply(instance, args);
        // set return value if value is returned, use only first value
        returnValue = returnValue === undefined ? value : returnValue;
      });

      return returnValue !== undefined ? returnValue : $elems;
    }

    function plainCall($elems, options) {
      $elems.each(function (i, elem) {
        var instance = $.data(elem, namespace);
        if (instance) {
          // set options & init
          instance.option(options);
          instance._init();
        } else {
          // initialize new instance
          instance = new PluginClass(elem, options);
          $.data(elem, namespace, instance);
        }
      });
    }

    updateJQuery($);
  }

  // ----- updateJQuery ----- //

  // set $.bridget for v1 backwards compatibility
  function updateJQuery($) {
    if (!$ || ($ && $.bridget)) {
      return;
    }
    $.bridget = jQueryBridget;
  }

  updateJQuery(jQuery || window.jQuery);

  // -----  ----- //

  return jQueryBridget;
});

/**
 * EvEmitter v1.1.0
 * Lil' event emitter
 * MIT License
 */

/* jshint unused: true, undef: true, strict: true */

(function (global, factory) {
  // universal module definition
  /* jshint strict: false */ /* globals define, module, window */
  if (typeof define == "function" && define.amd) {
    // AMD - RequireJS
    define("ev-emitter/ev-emitter", factory);
  } else if (typeof module == "object" && module.exports) {
    // CommonJS - Browserify, Webpack
    module.exports = factory();
  } else {
    // Browser globals
    global.EvEmitter = factory();
  }
})(typeof window != "undefined" ? window : this, function () {
  function EvEmitter() {}

  var proto = EvEmitter.prototype;

  proto.on = function (eventName, listener) {
    if (!eventName || !listener) {
      return;
    }
    // set events hash
    var events = (this._events = this._events || {});
    // set listeners array
    var listeners = (events[eventName] = events[eventName] || []);
    // only add once
    if (listeners.indexOf(listener) == -1) {
      listeners.push(listener);
    }

    return this;
  };

  proto.once = function (eventName, listener) {
    if (!eventName || !listener) {
      return;
    }
    // add event
    this.on(eventName, listener);
    // set once flag
    // set onceEvents hash
    var onceEvents = (this._onceEvents = this._onceEvents || {});
    // set onceListeners object
    var onceListeners = (onceEvents[eventName] = onceEvents[eventName] || {});
    // set flag
    onceListeners[listener] = true;

    return this;
  };

  proto.off = function (eventName, listener) {
    var listeners = this._events && this._events[eventName];
    if (!listeners || !listeners.length) {
      return;
    }
    var index = listeners.indexOf(listener);
    if (index != -1) {
      listeners.splice(index, 1);
    }

    return this;
  };

  proto.emitEvent = function (eventName, args) {
    var listeners = this._events && this._events[eventName];
    if (!listeners || !listeners.length) {
      return;
    }
    // copy over to avoid interference if .off() in listener
    listeners = listeners.slice(0);
    args = args || [];
    // once stuff
    var onceListeners = this._onceEvents && this._onceEvents[eventName];

    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      var isOnce = onceListeners && onceListeners[listener];
      if (isOnce) {
        // remove listener
        // remove before trigger to prevent recursion
        this.off(eventName, listener);
        // unset once flag
        delete onceListeners[listener];
      }
      // trigger listener
      listener.apply(this, args);
    }

    return this;
  };

  proto.allOff = function () {
    delete this._events;
    delete this._onceEvents;
  };

  return EvEmitter;
});

/*!
 * getSize v2.0.2
 * measure size of elements
 * MIT license
 */

/*jshint browser: true, strict: true, undef: true, unused: true */
/*global define: false, module: false, console: false */

(function (window, factory) {
  "use strict";

  if (typeof define == "function" && define.amd) {
    // AMD
    define("get-size/get-size", [], function () {
      return factory();
    });
  } else if (typeof module == "object" && module.exports) {
    // CommonJS
    module.exports = factory();
  } else {
    // browser global
    window.getSize = factory();
  }
})(window, function factory() {
  "use strict";

  // -------------------------- helpers -------------------------- //

  // get a number from a string, not a percentage
  function getStyleSize(value) {
    var num = parseFloat(value);
    // not a percent like '100%', and a number
    var isValid = value.indexOf("%") == -1 && !isNaN(num);
    return isValid && num;
  }

  function noop() {}

  var logError =
    typeof console == "undefined"
      ? noop
      : function (message) {
          console.error(message);
        };

  // -------------------------- measurements -------------------------- //

  var measurements = [
    "paddingLeft",
    "paddingRight",
    "paddingTop",
    "paddingBottom",
    "marginLeft",
    "marginRight",
    "marginTop",
    "marginBottom",
    "borderLeftWidth",
    "borderRightWidth",
    "borderTopWidth",
    "borderBottomWidth",
  ];

  var measurementsLength = measurements.length;

  function getZeroSize() {
    var size = {
      width: 0,
      height: 0,
      innerWidth: 0,
      innerHeight: 0,
      outerWidth: 0,
      outerHeight: 0,
    };
    for (var i = 0; i < measurementsLength; i++) {
      var measurement = measurements[i];
      size[measurement] = 0;
    }
    return size;
  }

  // -------------------------- getStyle -------------------------- //

  /**
   * getStyle, get style of element, check for Firefox bug
   * https://bugzilla.mozilla.org/show_bug.cgi?id=548397
   */
  function getStyle(elem) {
    var style = getComputedStyle(elem);
    if (!style) {
      logError(
        "Style returned " +
          style +
          ". Are you running this code in a hidden iframe on Firefox? " +
          "See http://bit.ly/getsizebug1"
      );
    }
    return style;
  }

  // -------------------------- setup -------------------------- //

  var isSetup = false;

  var isBoxSizeOuter;

  /**
   * setup
   * check isBoxSizerOuter
   * do on first getSize() rather than on page load for Firefox bug
   */
  function setup() {
    // setup once
    if (isSetup) {
      return;
    }
    isSetup = true;

    // -------------------------- box sizing -------------------------- //

    /**
     * WebKit measures the outer-width on style.width on border-box elems
     * IE & Firefox<29 measures the inner-width
     */
    var div = document.createElement("div");
    div.style.width = "200px";
    div.style.padding = "1px 2px 3px 4px";
    div.style.borderStyle = "solid";
    div.style.borderWidth = "1px 2px 3px 4px";
    div.style.boxSizing = "border-box";

    var body = document.body || document.documentElement;
    body.appendChild(div);
    var style = getStyle(div);

    getSize.isBoxSizeOuter = isBoxSizeOuter = getStyleSize(style.width) == 200;
    body.removeChild(div);
  }

  // -------------------------- getSize -------------------------- //

  function getSize(elem) {
    setup();

    // use querySeletor if elem is string
    if (typeof elem == "string") {
      elem = document.querySelector(elem);
    }

    // do not proceed on non-objects
    if (!elem || typeof elem != "object" || !elem.nodeType) {
      return;
    }

    var style = getStyle(elem);

    // if hidden, everything is 0
    if (style.display == "none") {
      return getZeroSize();
    }

    var size = {};
    size.width = elem.offsetWidth;
    size.height = elem.offsetHeight;

    var isBorderBox = (size.isBorderBox = style.boxSizing == "border-box");

    // get all measurements
    for (var i = 0; i < measurementsLength; i++) {
      var measurement = measurements[i];
      var value = style[measurement];
      var num = parseFloat(value);
      // any 'auto', 'medium' value will be 0
      size[measurement] = !isNaN(num) ? num : 0;
    }

    var paddingWidth = size.paddingLeft + size.paddingRight;
    var paddingHeight = size.paddingTop + size.paddingBottom;
    var marginWidth = size.marginLeft + size.marginRight;
    var marginHeight = size.marginTop + size.marginBottom;
    var borderWidth = size.borderLeftWidth + size.borderRightWidth;
    var borderHeight = size.borderTopWidth + size.borderBottomWidth;

    var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;

    // overwrite width and height if we can get it from style
    var styleWidth = getStyleSize(style.width);
    if (styleWidth !== false) {
      size.width =
        styleWidth +
        // add padding and border unless it's already including it
        (isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth);
    }

    var styleHeight = getStyleSize(style.height);
    if (styleHeight !== false) {
      size.height =
        styleHeight +
        // add padding and border unless it's already including it
        (isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight);
    }

    size.innerWidth = size.width - (paddingWidth + borderWidth);
    size.innerHeight = size.height - (paddingHeight + borderHeight);

    size.outerWidth = size.width + marginWidth;
    size.outerHeight = size.height + marginHeight;

    return size;
  }

  return getSize;
});

/**
 * matchesSelector v2.0.2
 * matchesSelector( element, '.selector' )
 * MIT license
 */

/*jshint browser: true, strict: true, undef: true, unused: true */

(function (window, factory) {
  /*global define: false, module: false */
  "use strict";
  // universal module definition
  if (typeof define == "function" && define.amd) {
    // AMD
    define("desandro-matches-selector/matches-selector", factory);
  } else if (typeof module == "object" && module.exports) {
    // CommonJS
    module.exports = factory();
  } else {
    // browser global
    window.matchesSelector = factory();
  }
})(window, function factory() {
  "use strict";

  var matchesMethod = (function () {
    var ElemProto = window.Element.prototype;
    // check for the standard method name first
    if (ElemProto.matches) {
      return "matches";
    }
    // check un-prefixed
    if (ElemProto.matchesSelector) {
      return "matchesSelector";
    }
    // check vendor prefixes
    var prefixes = ["webkit", "moz", "ms", "o"];

    for (var i = 0; i < prefixes.length; i++) {
      var prefix = prefixes[i];
      var method = prefix + "MatchesSelector";
      if (ElemProto[method]) {
        return method;
      }
    }
  })();

  return function matchesSelector(elem, selector) {
    return elem[matchesMethod](selector);
  };
});

/**
 * Fizzy UI utils v2.0.5
 * MIT license
 */

/*jshint browser: true, undef: true, unused: true, strict: true */

(function (window, factory) {
  // universal module definition
  /*jshint strict: false */ /*globals define, module, require */

  if (typeof define == "function" && define.amd) {
    // AMD
    define("fizzy-ui-utils/utils", [
      "desandro-matches-selector/matches-selector",
    ], function (matchesSelector) {
      return factory(window, matchesSelector);
    });
  } else if (typeof module == "object" && module.exports) {
    // CommonJS
    module.exports = factory(window, require("desandro-matches-selector"));
  } else {
    // browser global
    window.fizzyUIUtils = factory(window, window.matchesSelector);
  }
})(window, function factory(window, matchesSelector) {
  var utils = {};

  // ----- extend ----- //

  // extends objects
  utils.extend = function (a, b) {
    for (var prop in b) {
      a[prop] = b[prop];
    }
    return a;
  };

  // ----- modulo ----- //

  utils.modulo = function (num, div) {
    return ((num % div) + div) % div;
  };

  // ----- makeArray ----- //

  // turn element or nodeList into an array
  utils.makeArray = function (obj) {
    var ary = [];
    if (Array.isArray(obj)) {
      // use object if already an array
      ary = obj;
    } else if (obj && typeof obj == "object" && typeof obj.length == "number") {
      // convert nodeList to array
      for (var i = 0; i < obj.length; i++) {
        ary.push(obj[i]);
      }
    } else {
      // array of single index
      ary.push(obj);
    }
    return ary;
  };

  // ----- removeFrom ----- //

  utils.removeFrom = function (ary, obj) {
    var index = ary.indexOf(obj);
    if (index != -1) {
      ary.splice(index, 1);
    }
  };

  // ----- getParent ----- //

  utils.getParent = function (elem, selector) {
    while (elem.parentNode && elem != document.body) {
      elem = elem.parentNode;
      if (matchesSelector(elem, selector)) {
        return elem;
      }
    }
  };

  // ----- getQueryElement ----- //

  // use element as selector string
  utils.getQueryElement = function (elem) {
    if (typeof elem == "string") {
      return document.querySelector(elem);
    }
    return elem;
  };

  // ----- handleEvent ----- //

  // enable .ontype to trigger from .addEventListener( elem, 'type' )
  utils.handleEvent = function (event) {
    var method = "on" + event.type;
    if (this[method]) {
      this[method](event);
    }
  };

  // ----- filterFindElements ----- //

  utils.filterFindElements = function (elems, selector) {
    // make array of elems
    elems = utils.makeArray(elems);
    var ffElems = [];

    elems.forEach(function (elem) {
      // check that elem is an actual element
      if (!(elem instanceof HTMLElement)) {
        return;
      }
      // add elem if no selector
      if (!selector) {
        ffElems.push(elem);
        return;
      }
      // filter & find items if we have a selector
      // filter
      if (matchesSelector(elem, selector)) {
        ffElems.push(elem);
      }
      // find children
      var childElems = elem.querySelectorAll(selector);
      // concat childElems to filterFound array
      for (var i = 0; i < childElems.length; i++) {
        ffElems.push(childElems[i]);
      }
    });

    return ffElems;
  };

  // ----- debounceMethod ----- //

  utils.debounceMethod = function (_class, methodName, threshold) {
    // original method
    var method = _class.prototype[methodName];
    var timeoutName = methodName + "Timeout";

    _class.prototype[methodName] = function () {
      var timeout = this[timeoutName];
      if (timeout) {
        clearTimeout(timeout);
      }
      var args = arguments;

      var _this = this;
      this[timeoutName] = setTimeout(function () {
        method.apply(_this, args);
        delete _this[timeoutName];
      }, threshold || 100);
    };
  };

  // ----- docReady ----- //

  utils.docReady = function (callback) {
    var readyState = document.readyState;
    if (readyState == "complete" || readyState == "interactive") {
      // do async to allow for other scripts to run. metafizzy/flickity#441
      setTimeout(callback);
    } else {
      document.addEventListener("DOMContentLoaded", callback);
    }
  };

  // ----- htmlInit ----- //

  // http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/
  utils.toDashed = function (str) {
    return str
      .replace(/(.)([A-Z])/g, function (match, $1, $2) {
        return $1 + "-" + $2;
      })
      .toLowerCase();
  };

  var console = window.console;
  /**
   * allow user to initialize classes via [data-namespace] or .js-namespace class
   * htmlInit( Widget, 'widgetName' )
   * options are parsed from data-namespace-options
   */
  utils.htmlInit = function (WidgetClass, namespace) {
    utils.docReady(function () {
      var dashedNamespace = utils.toDashed(namespace);
      var dataAttr = "data-" + dashedNamespace;
      var dataAttrElems = document.querySelectorAll("[" + dataAttr + "]");
      var jsDashElems = document.querySelectorAll(".js-" + dashedNamespace);
      var elems = utils
        .makeArray(dataAttrElems)
        .concat(utils.makeArray(jsDashElems));
      var dataOptionsAttr = dataAttr + "-options";
      var jQuery = window.jQuery;

      elems.forEach(function (elem) {
        var attr =
          elem.getAttribute(dataAttr) || elem.getAttribute(dataOptionsAttr);
        var options;
        try {
          options = attr && JSON.parse(attr);
        } catch (error) {
          // log error, do not initialize
          if (console) {
            console.error(
              "Error parsing " +
                dataAttr +
                " on " +
                elem.className +
                ": " +
                error
            );
          }
          return;
        }
        // initialize
        var instance = new WidgetClass(elem, options);
        // make available via $().data('namespace')
        if (jQuery) {
          jQuery.data(elem, namespace, instance);
        }
      });
    });
  };

  // -----  ----- //

  return utils;
});

/**
 * Outlayer Item
 */

(function (window, factory) {
  // universal module definition
  /* jshint strict: false */ /* globals define, module, require */
  if (typeof define == "function" && define.amd) {
    // AMD - RequireJS
    define("outlayer/item", [
      "ev-emitter/ev-emitter",
      "get-size/get-size",
    ], factory);
  } else if (typeof module == "object" && module.exports) {
    // CommonJS - Browserify, Webpack
    module.exports = factory(require("ev-emitter"), require("get-size"));
  } else {
    // browser global
    window.Outlayer = {};
    window.Outlayer.Item = factory(window.EvEmitter, window.getSize);
  }
})(window, function factory(EvEmitter, getSize) {
  "use strict";

  // ----- helpers ----- //

  function isEmptyObj(obj) {
    for (var prop in obj) {
      return false;
    }
    prop = null;
    return true;
  }

  // -------------------------- CSS3 support -------------------------- //

  var docElemStyle = document.documentElement.style;

  var transitionProperty =
    typeof docElemStyle.transition == "string"
      ? "transition"
      : "WebkitTransition";
  var transformProperty =
    typeof docElemStyle.transform == "string" ? "transform" : "WebkitTransform";

  var transitionEndEvent = {
    WebkitTransition: "webkitTransitionEnd",
    transition: "transitionend",
  }[transitionProperty];

  // cache all vendor properties that could have vendor prefix
  var vendorProperties = {
    transform: transformProperty,
    transition: transitionProperty,
    transitionDuration: transitionProperty + "Duration",
    transitionProperty: transitionProperty + "Property",
    transitionDelay: transitionProperty + "Delay",
  };

  // -------------------------- Item -------------------------- //

  function Item(element, layout) {
    if (!element) {
      return;
    }

    this.element = element;
    // parent layout class, i.e. Masonry, Isotope, or Packery
    this.layout = layout;
    this.position = {
      x: 0,
      y: 0,
    };

    this._create();
  }

  // inherit EvEmitter
  var proto = (Item.prototype = Object.create(EvEmitter.prototype));
  proto.constructor = Item;

  proto._create = function () {
    // transition objects
    this._transn = {
      ingProperties: {},
      clean: {},
      onEnd: {},
    };

    this.css({
      position: "absolute",
    });
  };

  // trigger specified handler for event type
  proto.handleEvent = function (event) {
    var method = "on" + event.type;
    if (this[method]) {
      this[method](event);
    }
  };

  proto.getSize = function () {
    this.size = getSize(this.element);
  };

  /**
   * apply CSS styles to element
   * @param {Object} style
   */
  proto.css = function (style) {
    var elemStyle = this.element.style;

    for (var prop in style) {
      // use vendor property if available
      var supportedProp = vendorProperties[prop] || prop;
      elemStyle[supportedProp] = style[prop];
    }
  };

  // measure position, and sets it
  proto.getPosition = function () {
    var style = getComputedStyle(this.element);
    var isOriginLeft = this.layout._getOption("originLeft");
    var isOriginTop = this.layout._getOption("originTop");
    var xValue = style[isOriginLeft ? "left" : "right"];
    var yValue = style[isOriginTop ? "top" : "bottom"];
    // convert percent to pixels
    var layoutSize = this.layout.size;
    var x =
      xValue.indexOf("%") != -1
        ? (parseFloat(xValue) / 100) * layoutSize.width
        : parseInt(xValue, 10);
    var y =
      yValue.indexOf("%") != -1
        ? (parseFloat(yValue) / 100) * layoutSize.height
        : parseInt(yValue, 10);

    // clean up 'auto' or other non-integer values
    x = isNaN(x) ? 0 : x;
    y = isNaN(y) ? 0 : y;
    // remove padding from measurement
    x -= isOriginLeft ? layoutSize.paddingLeft : layoutSize.paddingRight;
    y -= isOriginTop ? layoutSize.paddingTop : layoutSize.paddingBottom;

    this.position.x = x;
    this.position.y = y;
  };

  // set settled position, apply padding
  proto.layoutPosition = function () {
    var layoutSize = this.layout.size;
    var style = {};
    var isOriginLeft = this.layout._getOption("originLeft");
    var isOriginTop = this.layout._getOption("originTop");

    // x
    var xPadding = isOriginLeft ? "paddingLeft" : "paddingRight";
    var xProperty = isOriginLeft ? "left" : "right";
    var xResetProperty = isOriginLeft ? "right" : "left";

    var x = this.position.x + layoutSize[xPadding];
    // set in percentage or pixels
    style[xProperty] = this.getXValue(x);
    // reset other property
    style[xResetProperty] = "";

    // y
    var yPadding = isOriginTop ? "paddingTop" : "paddingBottom";
    var yProperty = isOriginTop ? "top" : "bottom";
    var yResetProperty = isOriginTop ? "bottom" : "top";

    var y = this.position.y + layoutSize[yPadding];
    // set in percentage or pixels
    style[yProperty] = this.getYValue(y);
    // reset other property
    style[yResetProperty] = "";

    this.css(style);
    this.emitEvent("layout", [this]);
  };

  proto.getXValue = function (x) {
    var isHorizontal = this.layout._getOption("horizontal");
    return this.layout.options.percentPosition && !isHorizontal
      ? (x / this.layout.size.width) * 100 + "%"
      : x + "px";
  };

  proto.getYValue = function (y) {
    var isHorizontal = this.layout._getOption("horizontal");
    return this.layout.options.percentPosition && isHorizontal
      ? (y / this.layout.size.height) * 100 + "%"
      : y + "px";
  };

  proto._transitionTo = function (x, y) {
    this.getPosition();
    // get current x & y from top/left
    var curX = this.position.x;
    var curY = this.position.y;

    var compareX = parseInt(x, 10);
    var compareY = parseInt(y, 10);
    var didNotMove =
      compareX === this.position.x && compareY === this.position.y;

    // save end position
    this.setPosition(x, y);

    // if did not move and not transitioning, just go to layout
    if (didNotMove && !this.isTransitioning) {
      this.layoutPosition();
      return;
    }

    var transX = x - curX;
    var transY = y - curY;
    var transitionStyle = {};
    transitionStyle.transform = this.getTranslate(transX, transY);

    this.transition({
      to: transitionStyle,
      onTransitionEnd: {
        transform: this.layoutPosition,
      },
      isCleaning: true,
    });
  };

  proto.getTranslate = function (x, y) {
    // flip cooridinates if origin on right or bottom
    var isOriginLeft = this.layout._getOption("originLeft");
    var isOriginTop = this.layout._getOption("originTop");
    x = isOriginLeft ? x : -x;
    y = isOriginTop ? y : -y;
    return "translate3d(" + x + "px, " + y + "px, 0)";
  };

  // non transition + transform support
  proto.goTo = function (x, y) {
    this.setPosition(x, y);
    this.layoutPosition();
  };

  proto.moveTo = proto._transitionTo;

  proto.setPosition = function (x, y) {
    this.position.x = parseInt(x, 10);
    this.position.y = parseInt(y, 10);
  };

  // ----- transition ----- //

  /**
   * @param {Object} style - CSS
   * @param {Function} onTransitionEnd
   */

  // non transition, just trigger callback
  proto._nonTransition = function (args) {
    this.css(args.to);
    if (args.isCleaning) {
      this._removeStyles(args.to);
    }
    for (var prop in args.onTransitionEnd) {
      args.onTransitionEnd[prop].call(this);
    }
  };

  /**
   * proper transition
   * @param {Object} args - arguments
   *   @param {Object} to - style to transition to
   *   @param {Object} from - style to start transition from
   *   @param {Boolean} isCleaning - removes transition styles after transition
   *   @param {Function} onTransitionEnd - callback
   */
  proto.transition = function (args) {
    // redirect to nonTransition if no transition duration
    if (!parseFloat(this.layout.options.transitionDuration)) {
      this._nonTransition(args);
      return;
    }

    var _transition = this._transn;
    // keep track of onTransitionEnd callback by css property
    for (var prop in args.onTransitionEnd) {
      _transition.onEnd[prop] = args.onTransitionEnd[prop];
    }
    // keep track of properties that are transitioning
    for (prop in args.to) {
      _transition.ingProperties[prop] = true;
      // keep track of properties to clean up when transition is done
      if (args.isCleaning) {
        _transition.clean[prop] = true;
      }
    }

    // set from styles
    if (args.from) {
      this.css(args.from);
      // force redraw. http://blog.alexmaccaw.com/css-transitions
      var h = this.element.offsetHeight;
      // hack for JSHint to hush about unused var
      h = null;
    }
    // enable transition
    this.enableTransition(args.to);
    // set styles that are transitioning
    this.css(args.to);

    this.isTransitioning = true;
  };

  // dash before all cap letters, including first for
  // WebkitTransform => -webkit-transform
  function toDashedAll(str) {
    return str.replace(/([A-Z])/g, function ($1) {
      return "-" + $1.toLowerCase();
    });
  }

  var transitionProps = "opacity," + toDashedAll(transformProperty);

  proto.enableTransition = function (/* style */) {
    // HACK changing transitionProperty during a transition
    // will cause transition to jump
    if (this.isTransitioning) {
      return;
    }

    // make `transition: foo, bar, baz` from style object
    // HACK un-comment this when enableTransition can work
    // while a transition is happening
    // var transitionValues = [];
    // for ( var prop in style ) {
    //   // dash-ify camelCased properties like WebkitTransition
    //   prop = vendorProperties[ prop ] || prop;
    //   transitionValues.push( toDashedAll( prop ) );
    // }
    // munge number to millisecond, to match stagger
    var duration = this.layout.options.transitionDuration;
    duration = typeof duration == "number" ? duration + "ms" : duration;
    // enable transition styles
    this.css({
      transitionProperty: transitionProps,
      transitionDuration: duration,
      transitionDelay: this.staggerDelay || 0,
    });
    // listen for transition end event
    this.element.addEventListener(transitionEndEvent, this, false);
  };

  // ----- events ----- //

  proto.onwebkitTransitionEnd = function (event) {
    this.ontransitionend(event);
  };

  proto.onotransitionend = function (event) {
    this.ontransitionend(event);
  };

  // properties that I munge to make my life easier
  var dashedVendorProperties = {
    "-webkit-transform": "transform",
  };

  proto.ontransitionend = function (event) {
    // disregard bubbled events from children
    if (event.target !== this.element) {
      return;
    }
    var _transition = this._transn;
    // get property name of transitioned property, convert to prefix-free
    var propertyName =
      dashedVendorProperties[event.propertyName] || event.propertyName;

    // remove property that has completed transitioning
    delete _transition.ingProperties[propertyName];
    // check if any properties are still transitioning
    if (isEmptyObj(_transition.ingProperties)) {
      // all properties have completed transitioning
      this.disableTransition();
    }
    // clean style
    if (propertyName in _transition.clean) {
      // clean up style
      this.element.style[event.propertyName] = "";
      delete _transition.clean[propertyName];
    }
    // trigger onTransitionEnd callback
    if (propertyName in _transition.onEnd) {
      var onTransitionEnd = _transition.onEnd[propertyName];
      onTransitionEnd.call(this);
      delete _transition.onEnd[propertyName];
    }

    this.emitEvent("transitionEnd", [this]);
  };

  proto.disableTransition = function () {
    this.removeTransitionStyles();
    this.element.removeEventListener(transitionEndEvent, this, false);
    this.isTransitioning = false;
  };

  /**
   * removes style property from element
   * @param {Object} style
   **/
  proto._removeStyles = function (style) {
    // clean up transition styles
    var cleanStyle = {};
    for (var prop in style) {
      cleanStyle[prop] = "";
    }
    this.css(cleanStyle);
  };

  var cleanTransitionStyle = {
    transitionProperty: "",
    transitionDuration: "",
    transitionDelay: "",
  };

  proto.removeTransitionStyles = function () {
    // remove transition
    this.css(cleanTransitionStyle);
  };

  // ----- stagger ----- //

  proto.stagger = function (delay) {
    delay = isNaN(delay) ? 0 : delay;
    this.staggerDelay = delay + "ms";
  };

  // ----- show/hide/remove ----- //

  // remove element from DOM
  proto.removeElem = function () {
    this.element.parentNode.removeChild(this.element);
    // remove display: none
    this.css({ display: "" });
    this.emitEvent("remove", [this]);
  };

  proto.remove = function () {
    // just remove element if no transition support or no transition
    if (
      !transitionProperty ||
      !parseFloat(this.layout.options.transitionDuration)
    ) {
      this.removeElem();
      return;
    }

    // start transition
    this.once("transitionEnd", function () {
      this.removeElem();
    });
    this.hide();
  };

  proto.reveal = function () {
    delete this.isHidden;
    // remove display: none
    this.css({ display: "" });

    var options = this.layout.options;

    var onTransitionEnd = {};
    var transitionEndProperty =
      this.getHideRevealTransitionEndProperty("visibleStyle");
    onTransitionEnd[transitionEndProperty] = this.onRevealTransitionEnd;

    this.transition({
      from: options.hiddenStyle,
      to: options.visibleStyle,
      isCleaning: true,
      onTransitionEnd: onTransitionEnd,
    });
  };

  proto.onRevealTransitionEnd = function () {
    // check if still visible
    // during transition, item may have been hidden
    if (!this.isHidden) {
      this.emitEvent("reveal");
    }
  };

  /**
   * get style property use for hide/reveal transition end
   * @param {String} styleProperty - hiddenStyle/visibleStyle
   * @returns {String}
   */
  proto.getHideRevealTransitionEndProperty = function (styleProperty) {
    var optionStyle = this.layout.options[styleProperty];
    // use opacity
    if (optionStyle.opacity) {
      return "opacity";
    }
    // get first property
    for (var prop in optionStyle) {
      return prop;
    }
  };

  proto.hide = function () {
    // set flag
    this.isHidden = true;
    // remove display: none
    this.css({ display: "" });

    var options = this.layout.options;

    var onTransitionEnd = {};
    var transitionEndProperty =
      this.getHideRevealTransitionEndProperty("hiddenStyle");
    onTransitionEnd[transitionEndProperty] = this.onHideTransitionEnd;

    this.transition({
      from: options.visibleStyle,
      to: options.hiddenStyle,
      // keep hidden stuff hidden
      isCleaning: true,
      onTransitionEnd: onTransitionEnd,
    });
  };

  proto.onHideTransitionEnd = function () {
    // check if still hidden
    // during transition, item may have been un-hidden
    if (this.isHidden) {
      this.css({ display: "none" });
      this.emitEvent("hide");
    }
  };

  proto.destroy = function () {
    this.css({
      position: "",
      left: "",
      right: "",
      top: "",
      bottom: "",
      transition: "",
      transform: "",
    });
  };

  return Item;
});

/*!
 * Outlayer v2.1.0
 * the brains and guts of a layout library
 * MIT license
 */

(function (window, factory) {
  "use strict";
  // universal module definition
  /* jshint strict: false */ /* globals define, module, require */
  if (typeof define == "function" && define.amd) {
    // AMD - RequireJS
    define("outlayer/outlayer", [
      "ev-emitter/ev-emitter",
      "get-size/get-size",
      "fizzy-ui-utils/utils",
      "./item",
    ], function (EvEmitter, getSize, utils, Item) {
      return factory(window, EvEmitter, getSize, utils, Item);
    });
  } else if (typeof module == "object" && module.exports) {
    // CommonJS - Browserify, Webpack
    module.exports = factory(
      window,
      require("ev-emitter"),
      require("get-size"),
      require("fizzy-ui-utils"),
      require("./item")
    );
  } else {
    // browser global
    window.Outlayer = factory(
      window,
      window.EvEmitter,
      window.getSize,
      window.fizzyUIUtils,
      window.Outlayer.Item
    );
  }
})(window, function factory(window, EvEmitter, getSize, utils, Item) {
  "use strict";

  // ----- vars ----- //

  var console = window.console;
  var jQuery = window.jQuery;
  var noop = function () {};

  // -------------------------- Outlayer -------------------------- //

  // globally unique identifiers
  var GUID = 0;
  // internal store of all Outlayer intances
  var instances = {};

  /**
   * @param {Element, String} element
   * @param {Object} options
   * @constructor
   */
  function Outlayer(element, options) {
    var queryElement = utils.getQueryElement(element);
    if (!queryElement) {
      if (console) {
        console.error(
          "Bad element for " +
            this.constructor.namespace +
            ": " +
            (queryElement || element)
        );
      }
      return;
    }
    this.element = queryElement;
    // add jQuery
    if (jQuery) {
      this.$element = jQuery(this.element);
    }

    // options
    this.options = utils.extend({}, this.constructor.defaults);
    this.option(options);

    // add id for Outlayer.getFromElement
    var id = ++GUID;
    this.element.outlayerGUID = id; // expando
    instances[id] = this; // associate via id

    // kick it off
    this._create();

    var isInitLayout = this._getOption("initLayout");
    if (isInitLayout) {
      this.layout();
    }
  }

  // settings are for internal use only
  Outlayer.namespace = "outlayer";
  Outlayer.Item = Item;

  // default options
  Outlayer.defaults = {
    containerStyle: {
      position: "relative",
    },
    initLayout: true,
    originLeft: true,
    originTop: true,
    resize: true,
    resizeContainer: true,
    // item options
    transitionDuration: "0.4s",
    hiddenStyle: {
      opacity: 0,
      transform: "scale(0.001)",
    },
    visibleStyle: {
      opacity: 1,
      transform: "scale(1)",
    },
  };

  var proto = Outlayer.prototype;
  // inherit EvEmitter
  utils.extend(proto, EvEmitter.prototype);

  /**
   * set options
   * @param {Object} opts
   */
  proto.option = function (opts) {
    utils.extend(this.options, opts);
  };

  /**
   * get backwards compatible option value, check old name
   */
  proto._getOption = function (option) {
    var oldOption = this.constructor.compatOptions[option];
    return oldOption && this.options[oldOption] !== undefined
      ? this.options[oldOption]
      : this.options[option];
  };

  Outlayer.compatOptions = {
    // currentName: oldName
    initLayout: "isInitLayout",
    horizontal: "isHorizontal",
    layoutInstant: "isLayoutInstant",
    originLeft: "isOriginLeft",
    originTop: "isOriginTop",
    resize: "isResizeBound",
    resizeContainer: "isResizingContainer",
  };

  proto._create = function () {
    // get items from children
    this.reloadItems();
    // elements that affect layout, but are not laid out
    this.stamps = [];
    this.stamp(this.options.stamp);
    // set container style
    utils.extend(this.element.style, this.options.containerStyle);

    // bind resize method
    var canBindResize = this._getOption("resize");
    if (canBindResize) {
      this.bindResize();
    }
  };

  // goes through all children again and gets bricks in proper order
  proto.reloadItems = function () {
    // collection of item elements
    this.items = this._itemize(this.element.children);
  };

  /**
   * turn elements into Outlayer.Items to be used in layout
   * @param {Array or NodeList or HTMLElement} elems
   * @returns {Array} items - collection of new Outlayer Items
   */
  proto._itemize = function (elems) {
    var itemElems = this._filterFindItemElements(elems);
    var Item = this.constructor.Item;

    // create new Outlayer Items for collection
    var items = [];
    for (var i = 0; i < itemElems.length; i++) {
      var elem = itemElems[i];
      var item = new Item(elem, this);
      items.push(item);
    }

    return items;
  };

  /**
   * get item elements to be used in layout
   * @param {Array or NodeList or HTMLElement} elems
   * @returns {Array} items - item elements
   */
  proto._filterFindItemElements = function (elems) {
    return utils.filterFindElements(elems, this.options.itemSelector);
  };

  /**
   * getter method for getting item elements
   * @returns {Array} elems - collection of item elements
   */
  proto.getItemElements = function () {
    return this.items.map(function (item) {
      return item.element;
    });
  };

  // ----- init & layout ----- //

  /**
   * lays out all items
   */
  proto.layout = function () {
    this._resetLayout();
    this._manageStamps();

    // don't animate first layout
    var layoutInstant = this._getOption("layoutInstant");
    var isInstant =
      layoutInstant !== undefined ? layoutInstant : !this._isLayoutInited;
    this.layoutItems(this.items, isInstant);

    // flag for initalized
    this._isLayoutInited = true;
  };

  // _init is alias for layout
  proto._init = proto.layout;

  /**
   * logic before any new layout
   */
  proto._resetLayout = function () {
    this.getSize();
  };

  proto.getSize = function () {
    this.size = getSize(this.element);
  };

  /**
   * get measurement from option, for columnWidth, rowHeight, gutter
   * if option is String -> get element from selector string, & get size of element
   * if option is Element -> get size of element
   * else use option as a number
   *
   * @param {String} measurement
   * @param {String} size - width or height
   * @private
   */
  proto._getMeasurement = function (measurement, size) {
    var option = this.options[measurement];
    var elem;
    if (!option) {
      // default to 0
      this[measurement] = 0;
    } else {
      // use option as an element
      if (typeof option == "string") {
        elem = this.element.querySelector(option);
      } else if (option instanceof HTMLElement) {
        elem = option;
      }
      // use size of element, if element
      this[measurement] = elem ? getSize(elem)[size] : option;
    }
  };

  /**
   * layout a collection of item elements
   * @api public
   */
  proto.layoutItems = function (items, isInstant) {
    items = this._getItemsForLayout(items);

    this._layoutItems(items, isInstant);

    this._postLayout();
  };

  /**
   * get the items to be laid out
   * you may want to skip over some items
   * @param {Array} items
   * @returns {Array} items
   */
  proto._getItemsForLayout = function (items) {
    return items.filter(function (item) {
      return !item.isIgnored;
    });
  };

  /**
   * layout items
   * @param {Array} items
   * @param {Boolean} isInstant
   */
  proto._layoutItems = function (items, isInstant) {
    this._emitCompleteOnItems("layout", items);

    if (!items || !items.length) {
      // no items, emit event with empty array
      return;
    }

    var queue = [];

    items.forEach(function (item) {
      // get x/y object from method
      var position = this._getItemLayoutPosition(item);
      // enqueue
      position.item = item;
      position.isInstant = isInstant || item.isLayoutInstant;
      queue.push(position);
    }, this);

    this._processLayoutQueue(queue);
  };

  /**
   * get item layout position
   * @param {Outlayer.Item} item
   * @returns {Object} x and y position
   */
  proto._getItemLayoutPosition = function (/* item */) {
    return {
      x: 0,
      y: 0,
    };
  };

  /**
   * iterate over array and position each item
   * Reason being - separating this logic prevents 'layout invalidation'
   * thx @paul_irish
   * @param {Array} queue
   */
  proto._processLayoutQueue = function (queue) {
    this.updateStagger();
    queue.forEach(function (obj, i) {
      this._positionItem(obj.item, obj.x, obj.y, obj.isInstant, i);
    }, this);
  };

  // set stagger from option in milliseconds number
  proto.updateStagger = function () {
    var stagger = this.options.stagger;
    if (stagger === null || stagger === undefined) {
      this.stagger = 0;
      return;
    }
    this.stagger = getMilliseconds(stagger);
    return this.stagger;
  };

  /**
   * Sets position of item in DOM
   * @param {Outlayer.Item} item
   * @param {Number} x - horizontal position
   * @param {Number} y - vertical position
   * @param {Boolean} isInstant - disables transitions
   */
  proto._positionItem = function (item, x, y, isInstant, i) {
    if (isInstant) {
      // if not transition, just set CSS
      item.goTo(x, y);
    } else {
      item.stagger(i * this.stagger);
      item.moveTo(x, y);
    }
  };

  /**
   * Any logic you want to do after each layout,
   * i.e. size the container
   */
  proto._postLayout = function () {
    this.resizeContainer();
  };

  proto.resizeContainer = function () {
    var isResizingContainer = this._getOption("resizeContainer");
    if (!isResizingContainer) {
      return;
    }
    var size = this._getContainerSize();
    if (size) {
      this._setContainerMeasure(size.width, true);
      this._setContainerMeasure(size.height, false);
    }
  };

  /**
   * Sets width or height of container if returned
   * @returns {Object} size
   *   @param {Number} width
   *   @param {Number} height
   */
  proto._getContainerSize = noop;

  /**
   * @param {Number} measure - size of width or height
   * @param {Boolean} isWidth
   */
  proto._setContainerMeasure = function (measure, isWidth) {
    if (measure === undefined) {
      return;
    }

    var elemSize = this.size;
    // add padding and border width if border box
    if (elemSize.isBorderBox) {
      measure += isWidth
        ? elemSize.paddingLeft +
          elemSize.paddingRight +
          elemSize.borderLeftWidth +
          elemSize.borderRightWidth
        : elemSize.paddingBottom +
          elemSize.paddingTop +
          elemSize.borderTopWidth +
          elemSize.borderBottomWidth;
    }

    measure = Math.max(measure, 0);
    this.element.style[isWidth ? "width" : "height"] = measure + "px";
  };

  /**
   * emit eventComplete on a collection of items events
   * @param {String} eventName
   * @param {Array} items - Outlayer.Items
   */
  proto._emitCompleteOnItems = function (eventName, items) {
    var _this = this;
    function onComplete() {
      _this.dispatchEvent(eventName + "Complete", null, [items]);
    }

    var count = items.length;
    if (!items || !count) {
      onComplete();
      return;
    }

    var doneCount = 0;
    function tick() {
      doneCount++;
      if (doneCount == count) {
        onComplete();
      }
    }

    // bind callback
    items.forEach(function (item) {
      item.once(eventName, tick);
    });
  };

  /**
   * emits events via EvEmitter and jQuery events
   * @param {String} type - name of event
   * @param {Event} event - original event
   * @param {Array} args - extra arguments
   */
  proto.dispatchEvent = function (type, event, args) {
    // add original event to arguments
    var emitArgs = event ? [event].concat(args) : args;
    this.emitEvent(type, emitArgs);

    if (jQuery) {
      // set this.$element
      this.$element = this.$element || jQuery(this.element);
      if (event) {
        // create jQuery event
        var $event = jQuery.Event(event);
        $event.type = type;
        this.$element.trigger($event, args);
      } else {
        // just trigger with type if no event available
        this.$element.trigger(type, args);
      }
    }
  };

  // -------------------------- ignore & stamps -------------------------- //

  /**
   * keep item in collection, but do not lay it out
   * ignored items do not get skipped in layout
   * @param {Element} elem
   */
  proto.ignore = function (elem) {
    var item = this.getItem(elem);
    if (item) {
      item.isIgnored = true;
    }
  };

  /**
   * return item to layout collection
   * @param {Element} elem
   */
  proto.unignore = function (elem) {
    var item = this.getItem(elem);
    if (item) {
      delete item.isIgnored;
    }
  };

  /**
   * adds elements to stamps
   * @param {NodeList, Array, Element, or String} elems
   */
  proto.stamp = function (elems) {
    elems = this._find(elems);
    if (!elems) {
      return;
    }

    this.stamps = this.stamps.concat(elems);
    // ignore
    elems.forEach(this.ignore, this);
  };

  /**
   * removes elements to stamps
   * @param {NodeList, Array, or Element} elems
   */
  proto.unstamp = function (elems) {
    elems = this._find(elems);
    if (!elems) {
      return;
    }

    elems.forEach(function (elem) {
      // filter out removed stamp elements
      utils.removeFrom(this.stamps, elem);
      this.unignore(elem);
    }, this);
  };

  /**
   * finds child elements
   * @param {NodeList, Array, Element, or String} elems
   * @returns {Array} elems
   */
  proto._find = function (elems) {
    if (!elems) {
      return;
    }
    // if string, use argument as selector string
    if (typeof elems == "string") {
      elems = this.element.querySelectorAll(elems);
    }
    elems = utils.makeArray(elems);
    return elems;
  };

  proto._manageStamps = function () {
    if (!this.stamps || !this.stamps.length) {
      return;
    }

    this._getBoundingRect();

    this.stamps.forEach(this._manageStamp, this);
  };

  // update boundingLeft / Top
  proto._getBoundingRect = function () {
    // get bounding rect for container element
    var boundingRect = this.element.getBoundingClientRect();
    var size = this.size;
    this._boundingRect = {
      left: boundingRect.left + size.paddingLeft + size.borderLeftWidth,
      top: boundingRect.top + size.paddingTop + size.borderTopWidth,
      right: boundingRect.right - (size.paddingRight + size.borderRightWidth),
      bottom:
        boundingRect.bottom - (size.paddingBottom + size.borderBottomWidth),
    };
  };

  /**
   * @param {Element} stamp
   **/
  proto._manageStamp = noop;

  /**
   * get x/y position of element relative to container element
   * @param {Element} elem
   * @returns {Object} offset - has left, top, right, bottom
   */
  proto._getElementOffset = function (elem) {
    var boundingRect = elem.getBoundingClientRect();
    var thisRect = this._boundingRect;
    var size = getSize(elem);
    var offset = {
      left: boundingRect.left - thisRect.left - size.marginLeft,
      top: boundingRect.top - thisRect.top - size.marginTop,
      right: thisRect.right - boundingRect.right - size.marginRight,
      bottom: thisRect.bottom - boundingRect.bottom - size.marginBottom,
    };
    return offset;
  };

  // -------------------------- resize -------------------------- //

  // enable event handlers for listeners
  // i.e. resize -> onresize
  proto.handleEvent = utils.handleEvent;

  /**
   * Bind layout to window resizing
   */
  proto.bindResize = function () {
    window.addEventListener("resize", this);
    this.isResizeBound = true;
  };

  /**
   * Unbind layout to window resizing
   */
  proto.unbindResize = function () {
    window.removeEventListener("resize", this);
    this.isResizeBound = false;
  };

  proto.onresize = function () {
    this.resize();
  };

  utils.debounceMethod(Outlayer, "onresize", 100);

  proto.resize = function () {
    // don't trigger if size did not change
    // or if resize was unbound. See #9
    if (!this.isResizeBound || !this.needsResizeLayout()) {
      return;
    }

    this.layout();
  };

  /**
   * check if layout is needed post layout
   * @returns Boolean
   */
  proto.needsResizeLayout = function () {
    var size = getSize(this.element);
    // check that this.size and size are there
    // IE8 triggers resize on body size change, so they might not be
    var hasSizes = this.size && size;
    return hasSizes && size.innerWidth !== this.size.innerWidth;
  };

  // -------------------------- methods -------------------------- //

  /**
   * add items to Outlayer instance
   * @param {Array or NodeList or Element} elems
   * @returns {Array} items - Outlayer.Items
   **/
  proto.addItems = function (elems) {
    var items = this._itemize(elems);
    // add items to collection
    if (items.length) {
      this.items = this.items.concat(items);
    }
    return items;
  };

  /**
   * Layout newly-appended item elements
   * @param {Array or NodeList or Element} elems
   */
  proto.appended = function (elems) {
    var items = this.addItems(elems);
    if (!items.length) {
      return;
    }
    // layout and reveal just the new items
    this.layoutItems(items, true);
    this.reveal(items);
  };

  /**
   * Layout prepended elements
   * @param {Array or NodeList or Element} elems
   */
  proto.prepended = function (elems) {
    var items = this._itemize(elems);
    if (!items.length) {
      return;
    }
    // add items to beginning of collection
    var previousItems = this.items.slice(0);
    this.items = items.concat(previousItems);
    // start new layout
    this._resetLayout();
    this._manageStamps();
    // layout new stuff without transition
    this.layoutItems(items, true);
    this.reveal(items);
    // layout previous items
    this.layoutItems(previousItems);
  };

  /**
   * reveal a collection of items
   * @param {Array of Outlayer.Items} items
   */
  proto.reveal = function (items) {
    this._emitCompleteOnItems("reveal", items);
    if (!items || !items.length) {
      return;
    }
    var stagger = this.updateStagger();
    items.forEach(function (item, i) {
      item.stagger(i * stagger);
      item.reveal();
    });
  };

  /**
   * hide a collection of items
   * @param {Array of Outlayer.Items} items
   */
  proto.hide = function (items) {
    this._emitCompleteOnItems("hide", items);
    if (!items || !items.length) {
      return;
    }
    var stagger = this.updateStagger();
    items.forEach(function (item, i) {
      item.stagger(i * stagger);
      item.hide();
    });
  };

  /**
   * reveal item elements
   * @param {Array}, {Element}, {NodeList} items
   */
  proto.revealItemElements = function (elems) {
    var items = this.getItems(elems);
    this.reveal(items);
  };

  /**
   * hide item elements
   * @param {Array}, {Element}, {NodeList} items
   */
  proto.hideItemElements = function (elems) {
    var items = this.getItems(elems);
    this.hide(items);
  };

  /**
   * get Outlayer.Item, given an Element
   * @param {Element} elem
   * @param {Function} callback
   * @returns {Outlayer.Item} item
   */
  proto.getItem = function (elem) {
    // loop through items to get the one that matches
    for (var i = 0; i < this.items.length; i++) {
      var item = this.items[i];
      if (item.element == elem) {
        // return item
        return item;
      }
    }
  };

  /**
   * get collection of Outlayer.Items, given Elements
   * @param {Array} elems
   * @returns {Array} items - Outlayer.Items
   */
  proto.getItems = function (elems) {
    elems = utils.makeArray(elems);
    var items = [];
    elems.forEach(function (elem) {
      var item = this.getItem(elem);
      if (item) {
        items.push(item);
      }
    }, this);

    return items;
  };

  /**
   * remove element(s) from instance and DOM
   * @param {Array or NodeList or Element} elems
   */
  proto.remove = function (elems) {
    var removeItems = this.getItems(elems);

    this._emitCompleteOnItems("remove", removeItems);

    // bail if no items to remove
    if (!removeItems || !removeItems.length) {
      return;
    }

    removeItems.forEach(function (item) {
      item.remove();
      // remove item from collection
      utils.removeFrom(this.items, item);
    }, this);
  };

  // ----- destroy ----- //

  // remove and disable Outlayer instance
  proto.destroy = function () {
    // clean up dynamic styles
    var style = this.element.style;
    style.height = "";
    style.position = "";
    style.width = "";
    // destroy items
    this.items.forEach(function (item) {
      item.destroy();
    });

    this.unbindResize();

    var id = this.element.outlayerGUID;
    delete instances[id]; // remove reference to instance by id
    delete this.element.outlayerGUID;
    // remove data for jQuery
    if (jQuery) {
      jQuery.removeData(this.element, this.constructor.namespace);
    }
  };

  // -------------------------- data -------------------------- //

  /**
   * get Outlayer instance from element
   * @param {Element} elem
   * @returns {Outlayer}
   */
  Outlayer.data = function (elem) {
    elem = utils.getQueryElement(elem);
    var id = elem && elem.outlayerGUID;
    return id && instances[id];
  };

  // -------------------------- create Outlayer class -------------------------- //

  /**
   * create a layout class
   * @param {String} namespace
   */
  Outlayer.create = function (namespace, options) {
    // sub-class Outlayer
    var Layout = subclass(Outlayer);
    // apply new options and compatOptions
    Layout.defaults = utils.extend({}, Outlayer.defaults);
    utils.extend(Layout.defaults, options);
    Layout.compatOptions = utils.extend({}, Outlayer.compatOptions);

    Layout.namespace = namespace;

    Layout.data = Outlayer.data;

    // sub-class Item
    Layout.Item = subclass(Item);

    // -------------------------- declarative -------------------------- //

    utils.htmlInit(Layout, namespace);

    // -------------------------- jQuery bridge -------------------------- //

    // make into jQuery plugin
    if (jQuery && jQuery.bridget) {
      jQuery.bridget(namespace, Layout);
    }

    return Layout;
  };

  function subclass(Parent) {
    function SubClass() {
      Parent.apply(this, arguments);
    }

    SubClass.prototype = Object.create(Parent.prototype);
    SubClass.prototype.constructor = SubClass;

    return SubClass;
  }

  // ----- helpers ----- //

  // how many milliseconds are in each unit
  var msUnits = {
    ms: 1,
    s: 1000,
  };

  // munge time-like parameter into millisecond number
  // '0.4s' -> 40
  function getMilliseconds(time) {
    if (typeof time == "number") {
      return time;
    }
    var matches = time.match(/(^\d*\.?\d*)(\w*)/);
    var num = matches && matches[1];
    var unit = matches && matches[2];
    if (!num.length) {
      return 0;
    }
    num = parseFloat(num);
    var mult = msUnits[unit] || 1;
    return num * mult;
  }

  // ----- fin ----- //

  // back in global
  Outlayer.Item = Item;

  return Outlayer;
});

/*!
 * Masonry v4.2.1
 * Cascading grid layout library
 * https://masonry.desandro.com
 * MIT License
 * by David DeSandro
 */

(function (window, factory) {
  // universal module definition
  /* jshint strict: false */ /*globals define, module, require */
  if (typeof define == "function" && define.amd) {
    // AMD
    define(["outlayer/outlayer", "get-size/get-size"], factory);
  } else if (typeof module == "object" && module.exports) {
    // CommonJS
    module.exports = factory(require("outlayer"), require("get-size"));
  } else {
    // browser global
    window.Masonry = factory(window.Outlayer, window.getSize);
  }
})(window, function factory(Outlayer, getSize) {
  // -------------------------- masonryDefinition -------------------------- //

  // create an Outlayer layout class
  var Masonry = Outlayer.create("masonry");
  // isFitWidth -> fitWidth
  Masonry.compatOptions.fitWidth = "isFitWidth";

  var proto = Masonry.prototype;

  proto._resetLayout = function () {
    this.getSize();
    this._getMeasurement("columnWidth", "outerWidth");
    this._getMeasurement("gutter", "outerWidth");
    this.measureColumns();

    // reset column Y
    this.colYs = [];
    for (var i = 0; i < this.cols; i++) {
      this.colYs.push(0);
    }

    this.maxY = 0;
    this.horizontalColIndex = 0;
  };

  proto.measureColumns = function () {
    this.getContainerWidth();
    // if columnWidth is 0, default to outerWidth of first item
    if (!this.columnWidth) {
      var firstItem = this.items[0];
      var firstItemElem = firstItem && firstItem.element;
      // columnWidth fall back to item of first element
      this.columnWidth =
        (firstItemElem && getSize(firstItemElem).outerWidth) ||
        // if first elem has no width, default to size of container
        this.containerWidth;
    }

    var columnWidth = (this.columnWidth += this.gutter);

    // calculate columns
    var containerWidth = this.containerWidth + this.gutter;
    var cols = containerWidth / columnWidth;
    // fix rounding errors, typically with gutters
    var excess = columnWidth - (containerWidth % columnWidth);
    // if overshoot is less than a pixel, round up, otherwise floor it
    var mathMethod = excess && excess < 1 ? "round" : "floor";
    cols = Math[mathMethod](cols);
    this.cols = Math.max(cols, 1);
  };

  proto.getContainerWidth = function () {
    // container is parent if fit width
    var isFitWidth = this._getOption("fitWidth");
    var container = isFitWidth ? this.element.parentNode : this.element;
    // check that this.size and size are there
    // IE8 triggers resize on body size change, so they might not be
    var size = getSize(container);
    this.containerWidth = size && size.innerWidth;
  };

  proto._getItemLayoutPosition = function (item) {
    item.getSize();
    // how many columns does this brick span
    var remainder = item.size.outerWidth % this.columnWidth;
    var mathMethod = remainder && remainder < 1 ? "round" : "ceil";
    // round if off by 1 pixel, otherwise use ceil
    var colSpan = Math[mathMethod](item.size.outerWidth / this.columnWidth);
    colSpan = Math.min(colSpan, this.cols);
    // use horizontal or top column position
    var colPosMethod = this.options.horizontalOrder
      ? "_getHorizontalColPosition"
      : "_getTopColPosition";
    var colPosition = this[colPosMethod](colSpan, item);
    // position the brick
    var position = {
      x: this.columnWidth * colPosition.col,
      y: colPosition.y,
    };
    // apply setHeight to necessary columns
    var setHeight = colPosition.y + item.size.outerHeight;
    var setMax = colSpan + colPosition.col;
    for (var i = colPosition.col; i < setMax; i++) {
      this.colYs[i] = setHeight;
    }

    return position;
  };

  proto._getTopColPosition = function (colSpan) {
    var colGroup = this._getTopColGroup(colSpan);
    // get the minimum Y value from the columns
    var minimumY = Math.min.apply(Math, colGroup);

    return {
      col: colGroup.indexOf(minimumY),
      y: minimumY,
    };
  };

  /**
   * @param {Number} colSpan - number of columns the element spans
   * @returns {Array} colGroup
   */
  proto._getTopColGroup = function (colSpan) {
    if (colSpan < 2) {
      // if brick spans only one column, use all the column Ys
      return this.colYs;
    }

    var colGroup = [];
    // how many different places could this brick fit horizontally
    var groupCount = this.cols + 1 - colSpan;
    // for each group potential horizontal position
    for (var i = 0; i < groupCount; i++) {
      colGroup[i] = this._getColGroupY(i, colSpan);
    }
    return colGroup;
  };

  proto._getColGroupY = function (col, colSpan) {
    if (colSpan < 2) {
      return this.colYs[col];
    }
    // make an array of colY values for that one group
    var groupColYs = this.colYs.slice(col, col + colSpan);
    // and get the max value of the array
    return Math.max.apply(Math, groupColYs);
  };

  // get column position based on horizontal index. #873
  proto._getHorizontalColPosition = function (colSpan, item) {
    var col = this.horizontalColIndex % this.cols;
    var isOver = colSpan > 1 && col + colSpan > this.cols;
    // shift to next row if item can't fit on current row
    col = isOver ? 0 : col;
    // don't let zero-size items take up space
    var hasSize = item.size.outerWidth && item.size.outerHeight;
    this.horizontalColIndex = hasSize ? col + colSpan : this.horizontalColIndex;

    return {
      col: col,
      y: this._getColGroupY(col, colSpan),
    };
  };

  proto._manageStamp = function (stamp) {
    var stampSize = getSize(stamp);
    var offset = this._getElementOffset(stamp);
    // get the columns that this stamp affects
    var isOriginLeft = this._getOption("originLeft");
    var firstX = isOriginLeft ? offset.left : offset.right;
    var lastX = firstX + stampSize.outerWidth;
    var firstCol = Math.floor(firstX / this.columnWidth);
    firstCol = Math.max(0, firstCol);
    var lastCol = Math.floor(lastX / this.columnWidth);
    // lastCol should not go over if multiple of columnWidth #425
    lastCol -= lastX % this.columnWidth ? 0 : 1;
    lastCol = Math.min(this.cols - 1, lastCol);
    // set colYs to bottom of the stamp

    var isOriginTop = this._getOption("originTop");
    var stampMaxY =
      (isOriginTop ? offset.top : offset.bottom) + stampSize.outerHeight;
    for (var i = firstCol; i <= lastCol; i++) {
      this.colYs[i] = Math.max(stampMaxY, this.colYs[i]);
    }
  };

  proto._getContainerSize = function () {
    this.maxY = Math.max.apply(Math, this.colYs);
    var size = {
      height: this.maxY,
    };

    if (this._getOption("fitWidth")) {
      size.width = this._getContainerFitWidth();
    }

    return size;
  };

  proto._getContainerFitWidth = function () {
    var unusedCols = 0;
    // count unused columns
    var i = this.cols;
    while (--i) {
      if (this.colYs[i] !== 0) {
        break;
      }
      unusedCols++;
    }
    // fit container to columns that have been used
    return (this.cols - unusedCols) * this.columnWidth - this.gutter;
  };

  proto.needsResizeLayout = function () {
    var previousWidth = this.containerWidth;
    this.getContainerWidth();
    return previousWidth != this.containerWidth;
  };

  return Masonry;
});

/*!
 * Select2 4.0.3
 * https://select2.github.io
 *
 * Released under the MIT license
 * https://github.com/select2/select2/blob/master/LICENSE.md
 */
(function (factory) {
  if (typeof define === "function" && define.amd) {
    // AMD. Register as an anonymous module.
    define(["jquery"], factory);
  } else if (typeof exports === "object") {
    // Node/CommonJS
    factory(require("jquery"));
  } else {
    // Browser globals
    factory(jQuery);
  }
})(function (jQuery) {
  // This is needed so we can catch the AMD loader configuration and use it
  // The inner file should be wrapped (by `banner.start.js`) in a function that
  // returns the AMD loader references.
  var S2 = (function () {
    // Restore the Select2 AMD loader so it can be used
    // Needed mostly in the language files, where the loader is not inserted
    if (jQuery && jQuery.fn && jQuery.fn.select2 && jQuery.fn.select2.amd) {
      var S2 = jQuery.fn.select2.amd;
    }
    var S2;
    (function () {
      if (!S2 || !S2.requirejs) {
        if (!S2) {
          S2 = {};
        } else {
          require = S2;
        }
        /**
         * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
         * Available via the MIT or new BSD license.
         * see: http://github.com/jrburke/almond for details
         */
        //Going sloppy to avoid 'use strict' string cost, but strict practices should
        //be followed.
        /*jslint sloppy: true */
        /*global setTimeout: false */

        var requirejs, require, define;
        (function (undef) {
          var main,
            req,
            makeMap,
            handlers,
            defined = {},
            waiting = {},
            config = {},
            defining = {},
            hasOwn = Object.prototype.hasOwnProperty,
            aps = [].slice,
            jsSuffixRegExp = /\.js$/;

          function hasProp(obj, prop) {
            return hasOwn.call(obj, prop);
          }

          /**
           * Given a relative module name, like ./something, normalize it to
           * a real name that can be mapped to a path.
           * @param {String} name the relative name
           * @param {String} baseName a real name that the name arg is relative
           * to.
           * @returns {String} normalized name
           */
          function normalize(name, baseName) {
            var nameParts,
              nameSegment,
              mapValue,
              foundMap,
              lastIndex,
              foundI,
              foundStarMap,
              starI,
              i,
              j,
              part,
              baseParts = baseName && baseName.split("/"),
              map = config.map,
              starMap = (map && map["*"]) || {};

            //Adjust any relative paths.
            if (name && name.charAt(0) === ".") {
              //If have a base name, try to normalize against it,
              //otherwise, assume it is a top-level require that will
              //be relative to baseUrl in the end.
              if (baseName) {
                name = name.split("/");
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (
                  config.nodeIdCompat &&
                  jsSuffixRegExp.test(name[lastIndex])
                ) {
                  name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, "");
                }

                //Lop off the last part of baseParts, so that . matches the
                //"directory" and not name of the baseName's module. For instance,
                //baseName of "one/two/three", maps to "one/two/three.js", but we
                //want the directory, "one/two" for this normalization.
                name = baseParts.slice(0, baseParts.length - 1).concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                  part = name[i];
                  if (part === ".") {
                    name.splice(i, 1);
                    i -= 1;
                  } else if (part === "..") {
                    if (i === 1 && (name[2] === ".." || name[0] === "..")) {
                      //End of the line. Keep at least one non-dot
                      //path segment at the front so it can be mapped
                      //correctly to disk. Otherwise, there is likely
                      //no path mapping for a path starting with '..'.
                      //This can still fail, but catches the most reasonable
                      //uses of ..
                      break;
                    } else if (i > 0) {
                      name.splice(i - 1, 2);
                      i -= 2;
                    }
                  }
                }
                //end trimDots

                name = name.join("/");
              } else if (name.indexOf("./") === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
              }
            }

            //Apply map config if available.
            if ((baseParts || starMap) && map) {
              nameParts = name.split("/");

              for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                  //Find the longest baseName segment match in the config.
                  //So, do joins on the biggest to smallest lengths of baseParts.
                  for (j = baseParts.length; j > 0; j -= 1) {
                    mapValue = map[baseParts.slice(0, j).join("/")];

                    //baseName segment has  config, find if it has one for
                    //this name.
                    if (mapValue) {
                      mapValue = mapValue[nameSegment];
                      if (mapValue) {
                        //Match, update name to the new value.
                        foundMap = mapValue;
                        foundI = i;
                        break;
                      }
                    }
                  }
                }

                if (foundMap) {
                  break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                  foundStarMap = starMap[nameSegment];
                  starI = i;
                }
              }

              if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
              }

              if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join("/");
              }
            }

            return name;
          }

          function makeRequire(relName, forceSync) {
            return function () {
              //A version of a require function that passes a moduleName
              //value for items that may need to
              //look up paths relative to the moduleName
              var args = aps.call(arguments, 0);

              //If first arg is not require('string'), and there is only
              //one arg, it is the array form without a callback. Insert
              //a null so that the following concat is correct.
              if (typeof args[0] !== "string" && args.length === 1) {
                args.push(null);
              }
              return req.apply(undef, args.concat([relName, forceSync]));
            };
          }

          function makeNormalize(relName) {
            return function (name) {
              return normalize(name, relName);
            };
          }

          function makeLoad(depName) {
            return function (value) {
              defined[depName] = value;
            };
          }

          function callDep(name) {
            if (hasProp(waiting, name)) {
              var args = waiting[name];
              delete waiting[name];
              defining[name] = true;
              main.apply(undef, args);
            }

            if (!hasProp(defined, name) && !hasProp(defining, name)) {
              throw new Error("No " + name);
            }
            return defined[name];
          }

          //Turns a plugin!resource to [plugin, resource]
          //with the plugin being undefined if the name
          //did not have a plugin prefix.
          function splitPrefix(name) {
            var prefix,
              index = name ? name.indexOf("!") : -1;
            if (index > -1) {
              prefix = name.substring(0, index);
              name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
          }

          /**
           * Makes a name map, normalizing the name, and using a plugin
           * for normalization if necessary. Grabs a ref to plugin
           * too, as an optimization.
           */
          makeMap = function (name, relName) {
            var plugin,
              parts = splitPrefix(name),
              prefix = parts[0];

            name = parts[1];

            if (prefix) {
              prefix = normalize(prefix, relName);
              plugin = callDep(prefix);
            }

            //Normalize according
            if (prefix) {
              if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
              } else {
                name = normalize(name, relName);
              }
            } else {
              name = normalize(name, relName);
              parts = splitPrefix(name);
              prefix = parts[0];
              name = parts[1];
              if (prefix) {
                plugin = callDep(prefix);
              }
            }

            //Using ridiculous property names for space reasons
            return {
              f: prefix ? prefix + "!" + name : name, //fullName
              n: name,
              pr: prefix,
              p: plugin,
            };
          };

          function makeConfig(name) {
            return function () {
              return (config && config.config && config.config[name]) || {};
            };
          }

          handlers = {
            require: function (name) {
              return makeRequire(name);
            },
            exports: function (name) {
              var e = defined[name];
              if (typeof e !== "undefined") {
                return e;
              } else {
                return (defined[name] = {});
              }
            },
            module: function (name) {
              return {
                id: name,
                uri: "",
                exports: defined[name],
                config: makeConfig(name),
              };
            },
          };

          main = function (name, deps, callback, relName) {
            var cjsModule,
              depName,
              ret,
              map,
              i,
              args = [],
              callbackType = typeof callback,
              usingExports;

            //Use name if no relName
            relName = relName || name;

            //Call the callback to define the module, if necessary.
            if (callbackType === "undefined" || callbackType === "function") {
              //Pull out the defined dependencies and pass the ordered
              //values to the callback.
              //Default to [require, exports, module] if no deps
              deps =
                !deps.length && callback.length
                  ? ["require", "exports", "module"]
                  : deps;
              for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                  args[i] = handlers.require(name);
                } else if (depName === "exports") {
                  //CommonJS module spec 1.1
                  args[i] = handlers.exports(name);
                  usingExports = true;
                } else if (depName === "module") {
                  //CommonJS module spec 1.1
                  cjsModule = args[i] = handlers.module(name);
                } else if (
                  hasProp(defined, depName) ||
                  hasProp(waiting, depName) ||
                  hasProp(defining, depName)
                ) {
                  args[i] = callDep(depName);
                } else if (map.p) {
                  map.p.load(
                    map.n,
                    makeRequire(relName, true),
                    makeLoad(depName),
                    {}
                  );
                  args[i] = defined[depName];
                } else {
                  throw new Error(name + " missing " + depName);
                }
              }

              ret = callback ? callback.apply(defined[name], args) : undefined;

              if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (
                  cjsModule &&
                  cjsModule.exports !== undef &&
                  cjsModule.exports !== defined[name]
                ) {
                  defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                  //Use the return value from the function.
                  defined[name] = ret;
                }
              }
            } else if (name) {
              //May just be an object definition for the module. Only
              //worry about defining if have a module name.
              defined[name] = callback;
            }
          };

          requirejs =
            require =
            req =
              function (deps, callback, relName, forceSync, alt) {
                if (typeof deps === "string") {
                  if (handlers[deps]) {
                    //callback in this case is really relName
                    return handlers[deps](callback);
                  }
                  //Just return the module wanted. In this scenario, the
                  //deps arg is the module name, and second arg (if passed)
                  //is just the relName.
                  //Normalize module name, if it contains . or ..
                  return callDep(makeMap(deps, callback).f);
                } else if (!deps.splice) {
                  //deps is a config object, not an array.
                  config = deps;
                  if (config.deps) {
                    req(config.deps, config.callback);
                  }
                  if (!callback) {
                    return;
                  }

                  if (callback.splice) {
                    //callback is an array, which means it is a dependency list.
                    //Adjust args if there are dependencies
                    deps = callback;
                    callback = relName;
                    relName = null;
                  } else {
                    deps = undef;
                  }
                }

                //Support require(['a'])
                callback = callback || function () {};

                //If relName is a function, it is an errback handler,
                //so remove it.
                if (typeof relName === "function") {
                  relName = forceSync;
                  forceSync = alt;
                }

                //Simulate async callback;
                if (forceSync) {
                  main(undef, deps, callback, relName);
                } else {
                  //Using a non-zero value because of concern for what old browsers
                  //do, and latest browsers "upgrade" to 4 if lower value is used:
                  //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
                  //If want a value immediately, use require('id') instead -- something
                  //that works in almond on the global level, but not guaranteed and
                  //unlikely to work in other AMD implementations.
                  setTimeout(function () {
                    main(undef, deps, callback, relName);
                  }, 4);
                }

                return req;
              };

          /**
           * Just drops the config on the floor, but returns req in case
           * the config return value is used.
           */
          req.config = function (cfg) {
            return req(cfg);
          };

          /**
           * Expose module registry for debugging and tooling
           */
          requirejs._defined = defined;

          define = function (name, deps, callback) {
            if (typeof name !== "string") {
              throw new Error(
                "See almond README: incorrect module build, no module name"
              );
            }

            //This module may not have dependencies
            if (!deps.splice) {
              //deps is not an array, so probably means
              //an object literal or factory function for
              //the value. Adjust args.
              callback = deps;
              deps = [];
            }

            if (!hasProp(defined, name) && !hasProp(waiting, name)) {
              waiting[name] = [name, deps, callback];
            }
          };

          define.amd = {
            jQuery: true,
          };
        })();

        S2.requirejs = requirejs;
        S2.require = require;
        S2.define = define;
      }
    })();
    S2.define("almond", function () {});

    /* global jQuery:false, $:false */
    S2.define("jquery", [], function () {
      var _$ = jQuery || $;

      if (_$ == null && console && console.error) {
        console.error(
          "Select2: An instance of jQuery or a jQuery-compatible library was not " +
            "found. Make sure that you are including jQuery before Select2 on your " +
            "web page."
        );
      }

      return _$;
    });

    S2.define("select2/utils", ["jquery"], function ($) {
      var Utils = {};

      Utils.Extend = function (ChildClass, SuperClass) {
        var __hasProp = {}.hasOwnProperty;

        function BaseConstructor() {
          this.constructor = ChildClass;
        }

        for (var key in SuperClass) {
          if (__hasProp.call(SuperClass, key)) {
            ChildClass[key] = SuperClass[key];
          }
        }

        BaseConstructor.prototype = SuperClass.prototype;
        ChildClass.prototype = new BaseConstructor();
        ChildClass.__super__ = SuperClass.prototype;

        return ChildClass;
      };

      function getMethods(theClass) {
        var proto = theClass.prototype;

        var methods = [];

        for (var methodName in proto) {
          var m = proto[methodName];

          if (typeof m !== "function") {
            continue;
          }

          if (methodName === "constructor") {
            continue;
          }

          methods.push(methodName);
        }

        return methods;
      }

      Utils.Decorate = function (SuperClass, DecoratorClass) {
        var decoratedMethods = getMethods(DecoratorClass);
        var superMethods = getMethods(SuperClass);

        function DecoratedClass() {
          var unshift = Array.prototype.unshift;

          var argCount = DecoratorClass.prototype.constructor.length;

          var calledConstructor = SuperClass.prototype.constructor;

          if (argCount > 0) {
            unshift.call(arguments, SuperClass.prototype.constructor);

            calledConstructor = DecoratorClass.prototype.constructor;
          }

          calledConstructor.apply(this, arguments);
        }

        DecoratorClass.displayName = SuperClass.displayName;

        function ctr() {
          this.constructor = DecoratedClass;
        }

        DecoratedClass.prototype = new ctr();

        for (var m = 0; m < superMethods.length; m++) {
          var superMethod = superMethods[m];

          DecoratedClass.prototype[superMethod] =
            SuperClass.prototype[superMethod];
        }

        var calledMethod = function (methodName) {
          // Stub out the original method if it's not decorating an actual method
          var originalMethod = function () {};

          if (methodName in DecoratedClass.prototype) {
            originalMethod = DecoratedClass.prototype[methodName];
          }

          var decoratedMethod = DecoratorClass.prototype[methodName];

          return function () {
            var unshift = Array.prototype.unshift;

            unshift.call(arguments, originalMethod);

            return decoratedMethod.apply(this, arguments);
          };
        };

        for (var d = 0; d < decoratedMethods.length; d++) {
          var decoratedMethod = decoratedMethods[d];

          DecoratedClass.prototype[decoratedMethod] =
            calledMethod(decoratedMethod);
        }

        return DecoratedClass;
      };

      var Observable = function () {
        this.listeners = {};
      };

      Observable.prototype.on = function (event, callback) {
        this.listeners = this.listeners || {};

        if (event in this.listeners) {
          this.listeners[event].push(callback);
        } else {
          this.listeners[event] = [callback];
        }
      };

      Observable.prototype.trigger = function (event) {
        var slice = Array.prototype.slice;
        var params = slice.call(arguments, 1);

        this.listeners = this.listeners || {};

        // Params should always come in as an array
        if (params == null) {
          params = [];
        }

        // If there are no arguments to the event, use a temporary object
        if (params.length === 0) {
          params.push({});
        }

        // Set the `_type` of the first object to the event
        params[0]._type = event;

        if (event in this.listeners) {
          this.invoke(this.listeners[event], slice.call(arguments, 1));
        }

        if ("*" in this.listeners) {
          this.invoke(this.listeners["*"], arguments);
        }
      };

      Observable.prototype.invoke = function (listeners, params) {
        for (var i = 0, len = listeners.length; i < len; i++) {
          listeners[i].apply(this, params);
        }
      };

      Utils.Observable = Observable;

      Utils.generateChars = function (length) {
        var chars = "";

        for (var i = 0; i < length; i++) {
          var randomChar = Math.floor(Math.random() * 36);
          chars += randomChar.toString(36);
        }

        return chars;
      };

      Utils.bind = function (func, context) {
        return function () {
          func.apply(context, arguments);
        };
      };

      Utils._convertData = function (data) {
        for (var originalKey in data) {
          var keys = originalKey.split("-");

          var dataLevel = data;

          if (keys.length === 1) {
            continue;
          }

          for (var k = 0; k < keys.length; k++) {
            var key = keys[k];

            // Lowercase the first letter
            // By default, dash-separated becomes camelCase
            key = key.substring(0, 1).toLowerCase() + key.substring(1);

            if (!(key in dataLevel)) {
              dataLevel[key] = {};
            }

            if (k == keys.length - 1) {
              dataLevel[key] = data[originalKey];
            }

            dataLevel = dataLevel[key];
          }

          delete data[originalKey];
        }

        return data;
      };

      Utils.hasScroll = function (index, el) {
        // Adapted from the function created by @ShadowScripter
        // and adapted by @BillBarry on the Stack Exchange Code Review website.
        // The original code can be found at
        // http://codereview.stackexchange.com/q/13338
        // and was designed to be used with the Sizzle selector engine.

        var $el = $(el);
        var overflowX = el.style.overflowX;
        var overflowY = el.style.overflowY;

        //Check both x and y declarations
        if (
          overflowX === overflowY &&
          (overflowY === "hidden" || overflowY === "visible")
        ) {
          return false;
        }

        if (overflowX === "scroll" || overflowY === "scroll") {
          return true;
        }

        return (
          $el.innerHeight() < el.scrollHeight ||
          $el.innerWidth() < el.scrollWidth
        );
      };

      Utils.escapeMarkup = function (markup) {
        var replaceMap = {
          "\\": "&#92;",
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;",
          "/": "&#47;",
        };

        // Do not try to escape the markup if it's not a string
        if (typeof markup !== "string") {
          return markup;
        }

        return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
          return replaceMap[match];
        });
      };

      // Append an array of jQuery nodes to a given element.
      Utils.appendMany = function ($element, $nodes) {
        // jQuery 1.7.x does not support $.fn.append() with an array
        // Fall back to a jQuery object collection using $.fn.add()
        if ($.fn.jquery.substr(0, 3) === "1.7") {
          var $jqNodes = $();

          $.map($nodes, function (node) {
            $jqNodes = $jqNodes.add(node);
          });

          $nodes = $jqNodes;
        }

        $element.append($nodes);
      };

      return Utils;
    });

    S2.define("select2/results", ["jquery", "./utils"], function ($, Utils) {
      function Results($element, options, dataAdapter) {
        this.$element = $element;
        this.data = dataAdapter;
        this.options = options;

        Results.__super__.constructor.call(this);
      }

      Utils.Extend(Results, Utils.Observable);

      Results.prototype.render = function () {
        var $results = $(
          '<ul class="select2-results__options" role="tree"></ul>'
        );

        if (this.options.get("multiple")) {
          $results.attr("aria-multiselectable", "true");
        }

        this.$results = $results;

        return $results;
      };

      Results.prototype.clear = function () {
        this.$results.empty();
      };

      Results.prototype.displayMessage = function (params) {
        var escapeMarkup = this.options.get("escapeMarkup");

        this.clear();
        this.hideLoading();

        var $message = $(
          '<li role="treeitem" aria-live="assertive"' +
            ' class="select2-results__option"></li>'
        );

        var message = this.options.get("translations").get(params.message);

        $message.append(escapeMarkup(message(params.args)));

        $message[0].className += " select2-results__message";

        this.$results.append($message);
      };

      Results.prototype.hideMessages = function () {
        this.$results.find(".select2-results__message").remove();
      };

      Results.prototype.append = function (data) {
        this.hideLoading();

        var $options = [];

        if (data.results == null || data.results.length === 0) {
          if (this.$results.children().length === 0) {
            this.trigger("results:message", {
              message: "noResults",
            });
          }

          return;
        }

        data.results = this.sort(data.results);

        for (var d = 0; d < data.results.length; d++) {
          var item = data.results[d];

          var $option = this.option(item);

          $options.push($option);
        }

        this.$results.append($options);
      };

      Results.prototype.position = function ($results, $dropdown) {
        var $resultsContainer = $dropdown.find(".select2-results");
        $resultsContainer.append($results);
      };

      Results.prototype.sort = function (data) {
        var sorter = this.options.get("sorter");

        return sorter(data);
      };

      Results.prototype.highlightFirstItem = function () {
        var $options = this.$results.find(
          ".select2-results__option[aria-selected]"
        );

        var $selected = $options.filter("[aria-selected=true]");

        // Check if there are any selected options
        if ($selected.length > 0) {
          // If there are selected options, highlight the first
          $selected.first().trigger("mouseenter");
        } else {
          // If there are no selected options, highlight the first option
          // in the dropdown
          $options.first().trigger("mouseenter");
        }

        this.ensureHighlightVisible();
      };

      Results.prototype.setClasses = function () {
        var self = this;

        this.data.current(function (selected) {
          var selectedIds = $.map(selected, function (s) {
            return s.id.toString();
          });

          var $options = self.$results.find(
            ".select2-results__option[aria-selected]"
          );

          $options.each(function () {
            var $option = $(this);

            var item = $.data(this, "data");

            // id needs to be converted to a string when comparing
            var id = "" + item.id;

            if (
              (item.element != null && item.element.selected) ||
              (item.element == null && $.inArray(id, selectedIds) > -1)
            ) {
              $option.attr("aria-selected", "true");
            } else {
              $option.attr("aria-selected", "false");
            }
          });
        });
      };

      Results.prototype.showLoading = function (params) {
        this.hideLoading();

        var loadingMore = this.options.get("translations").get("searching");

        var loading = {
          disabled: true,
          loading: true,
          text: loadingMore(params),
        };
        var $loading = this.option(loading);
        $loading.className += " loading-results";

        this.$results.prepend($loading);
      };

      Results.prototype.hideLoading = function () {
        this.$results.find(".loading-results").remove();
      };

      Results.prototype.option = function (data) {
        var option = document.createElement("li");
        option.className = "select2-results__option";

        var attrs = {
          role: "treeitem",
          "aria-selected": "false",
        };

        if (data.disabled) {
          delete attrs["aria-selected"];
          attrs["aria-disabled"] = "true";
        }

        if (data.id == null) {
          delete attrs["aria-selected"];
        }

        if (data._resultId != null) {
          option.id = data._resultId;
        }

        if (data.title) {
          option.title = data.title;
        }

        if (data.children) {
          attrs.role = "group";
          attrs["aria-label"] = data.text;
          delete attrs["aria-selected"];
        }

        for (var attr in attrs) {
          var val = attrs[attr];

          option.setAttribute(attr, val);
        }

        if (data.children) {
          var $option = $(option);

          var label = document.createElement("strong");
          label.className = "select2-results__group";

          var $label = $(label);
          this.template(data, label);

          var $children = [];

          for (var c = 0; c < data.children.length; c++) {
            var child = data.children[c];

            var $child = this.option(child);

            $children.push($child);
          }

          var $childrenContainer = $("<ul></ul>", {
            class: "select2-results__options select2-results__options--nested",
          });

          $childrenContainer.append($children);

          $option.append(label);
          $option.append($childrenContainer);
        } else {
          this.template(data, option);
        }

        $.data(option, "data", data);

        return option;
      };

      Results.prototype.bind = function (container, $container) {
        var self = this;

        var id = container.id + "-results";

        this.$results.attr("id", id);

        container.on("results:all", function (params) {
          self.clear();
          self.append(params.data);

          if (container.isOpen()) {
            self.setClasses();
            self.highlightFirstItem();
          }
        });

        container.on("results:append", function (params) {
          self.append(params.data);

          if (container.isOpen()) {
            self.setClasses();
          }
        });

        container.on("query", function (params) {
          self.hideMessages();
          self.showLoading(params);
        });

        container.on("select", function () {
          if (!container.isOpen()) {
            return;
          }

          self.setClasses();
          self.highlightFirstItem();
        });

        container.on("unselect", function () {
          if (!container.isOpen()) {
            return;
          }

          self.setClasses();
          self.highlightFirstItem();
        });

        container.on("open", function () {
          // When the dropdown is open, aria-expended="true"
          self.$results.attr("aria-expanded", "true");
          self.$results.attr("aria-hidden", "false");

          self.setClasses();
          self.ensureHighlightVisible();
        });

        container.on("close", function () {
          // When the dropdown is closed, aria-expended="false"
          self.$results.attr("aria-expanded", "false");
          self.$results.attr("aria-hidden", "true");
          self.$results.removeAttr("aria-activedescendant");
        });

        container.on("results:toggle", function () {
          var $highlighted = self.getHighlightedResults();

          if ($highlighted.length === 0) {
            return;
          }

          $highlighted.trigger("mouseup");
        });

        container.on("results:select", function () {
          var $highlighted = self.getHighlightedResults();

          if ($highlighted.length === 0) {
            return;
          }

          var data = $highlighted.data("data");

          if ($highlighted.attr("aria-selected") == "true") {
            self.trigger("close", {});
          } else {
            self.trigger("select", {
              data: data,
            });
          }
        });

        container.on("results:previous", function () {
          var $highlighted = self.getHighlightedResults();

          var $options = self.$results.find("[aria-selected]");

          var currentIndex = $options.index($highlighted);

          // If we are already at te top, don't move further
          if (currentIndex === 0) {
            return;
          }

          var nextIndex = currentIndex - 1;

          // If none are highlighted, highlight the first
          if ($highlighted.length === 0) {
            nextIndex = 0;
          }

          var $next = $options.eq(nextIndex);

          $next.trigger("mouseenter");

          var currentOffset = self.$results.offset().top;
          var nextTop = $next.offset().top;
          var nextOffset =
            self.$results.scrollTop() + (nextTop - currentOffset);

          if (nextIndex === 0) {
            self.$results.scrollTop(0);
          } else if (nextTop - currentOffset < 0) {
            self.$results.scrollTop(nextOffset);
          }
        });

        container.on("results:next", function () {
          var $highlighted = self.getHighlightedResults();

          var $options = self.$results.find("[aria-selected]");

          var currentIndex = $options.index($highlighted);

          var nextIndex = currentIndex + 1;

          // If we are at the last option, stay there
          if (nextIndex >= $options.length) {
            return;
          }

          var $next = $options.eq(nextIndex);

          $next.trigger("mouseenter");

          var currentOffset =
            self.$results.offset().top + self.$results.outerHeight(false);
          var nextBottom = $next.offset().top + $next.outerHeight(false);
          var nextOffset =
            self.$results.scrollTop() + nextBottom - currentOffset;

          if (nextIndex === 0) {
            self.$results.scrollTop(0);
          } else if (nextBottom > currentOffset) {
            self.$results.scrollTop(nextOffset);
          }
        });

        container.on("results:focus", function (params) {
          params.element.addClass("select2-results__option--highlighted");
        });

        container.on("results:message", function (params) {
          self.displayMessage(params);
        });

        if ($.fn.mousewheel) {
          this.$results.on("mousewheel", function (e) {
            var top = self.$results.scrollTop();

            var bottom = self.$results.get(0).scrollHeight - top + e.deltaY;

            var isAtTop = e.deltaY > 0 && top - e.deltaY <= 0;
            var isAtBottom = e.deltaY < 0 && bottom <= self.$results.height();

            if (isAtTop) {
              self.$results.scrollTop(0);

              e.preventDefault();
              e.stopPropagation();
            } else if (isAtBottom) {
              self.$results.scrollTop(
                self.$results.get(0).scrollHeight - self.$results.height()
              );

              e.preventDefault();
              e.stopPropagation();
            }
          });
        }

        this.$results.on(
          "mouseup",
          ".select2-results__option[aria-selected]",
          function (evt) {
            var $this = $(this);

            var data = $this.data("data");

            if ($this.attr("aria-selected") === "true") {
              if (self.options.get("multiple")) {
                self.trigger("unselect", {
                  originalEvent: evt,
                  data: data,
                });
              } else {
                self.trigger("close", {});
              }

              return;
            }

            self.trigger("select", {
              originalEvent: evt,
              data: data,
            });
          }
        );

        this.$results.on(
          "mouseenter",
          ".select2-results__option[aria-selected]",
          function (evt) {
            var data = $(this).data("data");

            self
              .getHighlightedResults()
              .removeClass("select2-results__option--highlighted");

            self.trigger("results:focus", {
              data: data,
              element: $(this),
            });
          }
        );
      };

      Results.prototype.getHighlightedResults = function () {
        var $highlighted = this.$results.find(
          ".select2-results__option--highlighted"
        );

        return $highlighted;
      };

      Results.prototype.destroy = function () {
        this.$results.remove();
      };

      Results.prototype.ensureHighlightVisible = function () {
        var $highlighted = this.getHighlightedResults();

        if ($highlighted.length === 0) {
          return;
        }

        var $options = this.$results.find("[aria-selected]");

        var currentIndex = $options.index($highlighted);

        var currentOffset = this.$results.offset().top;
        var nextTop = $highlighted.offset().top;
        var nextOffset = this.$results.scrollTop() + (nextTop - currentOffset);

        var offsetDelta = nextTop - currentOffset;
        nextOffset -= $highlighted.outerHeight(false) * 2;

        if (currentIndex <= 2) {
          this.$results.scrollTop(0);
        } else if (
          offsetDelta > this.$results.outerHeight() ||
          offsetDelta < 0
        ) {
          this.$results.scrollTop(nextOffset);
        }
      };

      Results.prototype.template = function (result, container) {
        var template = this.options.get("templateResult");
        var escapeMarkup = this.options.get("escapeMarkup");

        var content = template(result, container);

        if (content == null) {
          container.style.display = "none";
        } else if (typeof content === "string") {
          container.innerHTML = escapeMarkup(content);
        } else {
          $(container).append(content);
        }
      };

      return Results;
    });

    S2.define("select2/keys", [], function () {
      var KEYS = {
        BACKSPACE: 8,
        TAB: 9,
        ENTER: 13,
        SHIFT: 16,
        CTRL: 17,
        ALT: 18,
        ESC: 27,
        SPACE: 32,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        END: 35,
        HOME: 36,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        DELETE: 46,
      };

      return KEYS;
    });

    S2.define(
      "select2/selection/base",
      ["jquery", "../utils", "../keys"],
      function ($, Utils, KEYS) {
        function BaseSelection($element, options) {
          this.$element = $element;
          this.options = options;

          BaseSelection.__super__.constructor.call(this);
        }

        Utils.Extend(BaseSelection, Utils.Observable);

        BaseSelection.prototype.render = function () {
          var $selection = $(
            '<span class="select2-selection" role="combobox" ' +
              ' aria-haspopup="true" aria-expanded="false">' +
              "</span>"
          );

          this._tabindex = 0;

          if (this.$element.data("old-tabindex") != null) {
            this._tabindex = this.$element.data("old-tabindex");
          } else if (this.$element.attr("tabindex") != null) {
            this._tabindex = this.$element.attr("tabindex");
          }

          $selection.attr("title", this.$element.attr("title"));
          $selection.attr("tabindex", this._tabindex);

          this.$selection = $selection;

          return $selection;
        };

        BaseSelection.prototype.bind = function (container, $container) {
          var self = this;

          var id = container.id + "-container";
          var resultsId = container.id + "-results";

          this.container = container;

          this.$selection.on("focus", function (evt) {
            self.trigger("focus", evt);
          });

          this.$selection.on("blur", function (evt) {
            self._handleBlur(evt);
          });

          this.$selection.on("keydown", function (evt) {
            self.trigger("keypress", evt);

            if (evt.which === KEYS.SPACE) {
              evt.preventDefault();
            }
          });

          container.on("results:focus", function (params) {
            self.$selection.attr(
              "aria-activedescendant",
              params.data._resultId
            );
          });

          container.on("selection:update", function (params) {
            self.update(params.data);
          });

          container.on("open", function () {
            // When the dropdown is open, aria-expanded="true"
            self.$selection.attr("aria-expanded", "true");
            self.$selection.attr("aria-owns", resultsId);

            self._attachCloseHandler(container);
          });

          container.on("close", function () {
            // When the dropdown is closed, aria-expanded="false"
            self.$selection.attr("aria-expanded", "false");
            self.$selection.removeAttr("aria-activedescendant");
            self.$selection.removeAttr("aria-owns");

            self.$selection.focus();

            self._detachCloseHandler(container);
          });

          container.on("enable", function () {
            self.$selection.attr("tabindex", self._tabindex);
          });

          container.on("disable", function () {
            self.$selection.attr("tabindex", "-1");
          });
        };

        BaseSelection.prototype._handleBlur = function (evt) {
          var self = this;

          // This needs to be delayed as the active element is the body when the tab
          // key is pressed, possibly along with others.
          window.setTimeout(function () {
            // Don't trigger `blur` if the focus is still in the selection
            if (
              document.activeElement == self.$selection[0] ||
              $.contains(self.$selection[0], document.activeElement)
            ) {
              return;
            }

            self.trigger("blur", evt);
          }, 1);
        };

        BaseSelection.prototype._attachCloseHandler = function (container) {
          var self = this;

          $(document.body).on(
            "mousedown.select2." + container.id,
            function (e) {
              var $target = $(e.target);

              var $select = $target.closest(".select2");

              var $all = $(".select2.select2-container--open");

              $all.each(function () {
                var $this = $(this);

                if (this == $select[0]) {
                  return;
                }

                var $element = $this.data("element");

                $element.select2("close");
              });
            }
          );
        };

        BaseSelection.prototype._detachCloseHandler = function (container) {
          $(document.body).off("mousedown.select2." + container.id);
        };

        BaseSelection.prototype.position = function ($selection, $container) {
          var $selectionContainer = $container.find(".selection");
          $selectionContainer.append($selection);
        };

        BaseSelection.prototype.destroy = function () {
          this._detachCloseHandler(this.container);
        };

        BaseSelection.prototype.update = function (data) {
          throw new Error(
            "The `update` method must be defined in child classes."
          );
        };

        return BaseSelection;
      }
    );

    S2.define(
      "select2/selection/single",
      ["jquery", "./base", "../utils", "../keys"],
      function ($, BaseSelection, Utils, KEYS) {
        function SingleSelection() {
          SingleSelection.__super__.constructor.apply(this, arguments);
        }

        Utils.Extend(SingleSelection, BaseSelection);

        SingleSelection.prototype.render = function () {
          var $selection = SingleSelection.__super__.render.call(this);

          $selection.addClass("select2-selection--single");

          $selection.html(
            '<span class="select2-selection__rendered"></span>' +
              '<span class="select2-selection__arrow" role="presentation">' +
              '<b role="presentation"></b>' +
              "</span>"
          );

          return $selection;
        };

        SingleSelection.prototype.bind = function (container, $container) {
          var self = this;

          SingleSelection.__super__.bind.apply(this, arguments);

          var id = container.id + "-container";

          this.$selection.find(".select2-selection__rendered").attr("id", id);
          this.$selection.attr("aria-labelledby", id);

          this.$selection.on("mousedown", function (evt) {
            // Only respond to left clicks
            if (evt.which !== 1) {
              return;
            }

            self.trigger("toggle", {
              originalEvent: evt,
            });
          });

          this.$selection.on("focus", function (evt) {
            // User focuses on the container
          });

          this.$selection.on("blur", function (evt) {
            // User exits the container
          });

          container.on("focus", function (evt) {
            if (!container.isOpen()) {
              self.$selection.focus();
            }
          });

          container.on("selection:update", function (params) {
            self.update(params.data);
          });
        };

        SingleSelection.prototype.clear = function () {
          this.$selection.find(".select2-selection__rendered").empty();
        };

        SingleSelection.prototype.display = function (data, container) {
          var template = this.options.get("templateSelection");
          var escapeMarkup = this.options.get("escapeMarkup");

          return escapeMarkup(template(data, container));
        };

        SingleSelection.prototype.selectionContainer = function () {
          return $("<span></span>");
        };

        SingleSelection.prototype.update = function (data) {
          if (data.length === 0) {
            this.clear();
            return;
          }

          var selection = data[0];

          var $rendered = this.$selection.find(".select2-selection__rendered");
          var formatted = this.display(selection, $rendered);

          $rendered.empty().append(formatted);
          $rendered.prop("title", selection.title || selection.text);
        };

        return SingleSelection;
      }
    );

    S2.define(
      "select2/selection/multiple",
      ["jquery", "./base", "../utils"],
      function ($, BaseSelection, Utils) {
        function MultipleSelection($element, options) {
          MultipleSelection.__super__.constructor.apply(this, arguments);
        }

        Utils.Extend(MultipleSelection, BaseSelection);

        MultipleSelection.prototype.render = function () {
          var $selection = MultipleSelection.__super__.render.call(this);

          $selection.addClass("select2-selection--multiple");

          $selection.html('<ul class="select2-selection__rendered"></ul>');

          return $selection;
        };

        MultipleSelection.prototype.bind = function (container, $container) {
          var self = this;

          MultipleSelection.__super__.bind.apply(this, arguments);

          this.$selection.on("click", function (evt) {
            self.trigger("toggle", {
              originalEvent: evt,
            });
          });

          this.$selection.on(
            "click",
            ".select2-selection__choice__remove",
            function (evt) {
              // Ignore the event if it is disabled
              if (self.options.get("disabled")) {
                return;
              }

              var $remove = $(this);
              var $selection = $remove.parent();

              var data = $selection.data("data");

              self.trigger("unselect", {
                originalEvent: evt,
                data: data,
              });
            }
          );
        };

        MultipleSelection.prototype.clear = function () {
          this.$selection.find(".select2-selection__rendered").empty();
        };

        MultipleSelection.prototype.display = function (data, container) {
          var template = this.options.get("templateSelection");
          var escapeMarkup = this.options.get("escapeMarkup");

          return escapeMarkup(template(data, container));
        };

        MultipleSelection.prototype.selectionContainer = function () {
          var $container = $(
            '<li class="select2-selection__choice">' +
              '<span class="select2-selection__choice__remove" role="presentation">' +
              "&times;" +
              "</span>" +
              "</li>"
          );

          return $container;
        };

        MultipleSelection.prototype.update = function (data) {
          this.clear();

          if (data.length === 0) {
            return;
          }

          var $selections = [];

          for (var d = 0; d < data.length; d++) {
            var selection = data[d];

            var $selection = this.selectionContainer();
            var formatted = this.display(selection, $selection);

            $selection.append(formatted);
            $selection.prop("title", selection.title || selection.text);

            $selection.data("data", selection);

            $selections.push($selection);
          }

          var $rendered = this.$selection.find(".select2-selection__rendered");

          Utils.appendMany($rendered, $selections);
        };

        return MultipleSelection;
      }
    );

    S2.define("select2/selection/placeholder", ["../utils"], function (Utils) {
      function Placeholder(decorated, $element, options) {
        this.placeholder = this.normalizePlaceholder(
          options.get("placeholder")
        );

        decorated.call(this, $element, options);
      }

      Placeholder.prototype.normalizePlaceholder = function (_, placeholder) {
        if (typeof placeholder === "string") {
          placeholder = {
            id: "",
            text: placeholder,
          };
        }

        return placeholder;
      };

      Placeholder.prototype.createPlaceholder = function (
        decorated,
        placeholder
      ) {
        var $placeholder = this.selectionContainer();

        $placeholder.html(this.display(placeholder));
        $placeholder
          .addClass("select2-selection__placeholder")
          .removeClass("select2-selection__choice");

        return $placeholder;
      };

      Placeholder.prototype.update = function (decorated, data) {
        var singlePlaceholder =
          data.length == 1 && data[0].id != this.placeholder.id;
        var multipleSelections = data.length > 1;

        if (multipleSelections || singlePlaceholder) {
          return decorated.call(this, data);
        }

        this.clear();

        var $placeholder = this.createPlaceholder(this.placeholder);

        this.$selection
          .find(".select2-selection__rendered")
          .append($placeholder);
      };

      return Placeholder;
    });

    S2.define(
      "select2/selection/allowClear",
      ["jquery", "../keys"],
      function ($, KEYS) {
        function AllowClear() {}

        AllowClear.prototype.bind = function (
          decorated,
          container,
          $container
        ) {
          var self = this;

          decorated.call(this, container, $container);

          if (this.placeholder == null) {
            if (this.options.get("debug") && window.console && console.error) {
              console.error(
                "Select2: The `allowClear` option should be used in combination " +
                  "with the `placeholder` option."
              );
            }
          }

          this.$selection.on(
            "mousedown",
            ".select2-selection__clear",
            function (evt) {
              self._handleClear(evt);
            }
          );

          container.on("keypress", function (evt) {
            self._handleKeyboardClear(evt, container);
          });
        };

        AllowClear.prototype._handleClear = function (_, evt) {
          // Ignore the event if it is disabled
          if (this.options.get("disabled")) {
            return;
          }

          var $clear = this.$selection.find(".select2-selection__clear");

          // Ignore the event if nothing has been selected
          if ($clear.length === 0) {
            return;
          }

          evt.stopPropagation();

          var data = $clear.data("data");

          for (var d = 0; d < data.length; d++) {
            var unselectData = {
              data: data[d],
            };

            // Trigger the `unselect` event, so people can prevent it from being
            // cleared.
            this.trigger("unselect", unselectData);

            // If the event was prevented, don't clear it out.
            if (unselectData.prevented) {
              return;
            }
          }

          this.$element.val(this.placeholder.id).trigger("change");

          this.trigger("toggle", {});
        };

        AllowClear.prototype._handleKeyboardClear = function (
          _,
          evt,
          container
        ) {
          if (container.isOpen()) {
            return;
          }

          if (evt.which == KEYS.DELETE || evt.which == KEYS.BACKSPACE) {
            this._handleClear(evt);
          }
        };

        AllowClear.prototype.update = function (decorated, data) {
          decorated.call(this, data);

          if (
            this.$selection.find(".select2-selection__placeholder").length >
              0 ||
            data.length === 0
          ) {
            return;
          }

          var $remove = $(
            '<span class="select2-selection__clear">' + "&times;" + "</span>"
          );
          $remove.data("data", data);

          this.$selection.find(".select2-selection__rendered").prepend($remove);
        };

        return AllowClear;
      }
    );

    S2.define(
      "select2/selection/search",
      ["jquery", "../utils", "../keys"],
      function ($, Utils, KEYS) {
        function Search(decorated, $element, options) {
          decorated.call(this, $element, options);
        }

        Search.prototype.render = function (decorated) {
          var $search = $(
            '<li class="select2-search select2-search--inline">' +
              '<input class="select2-search__field" type="search" tabindex="-1"' +
              ' autocomplete="off" autocorrect="off" autocapitalize="off"' +
              ' spellcheck="false" role="textbox" aria-autocomplete="list" />' +
              "</li>"
          );

          this.$searchContainer = $search;
          this.$search = $search.find("input");

          var $rendered = decorated.call(this);

          this._transferTabIndex();

          return $rendered;
        };

        Search.prototype.bind = function (decorated, container, $container) {
          var self = this;

          decorated.call(this, container, $container);

          container.on("open", function () {
            self.$search.trigger("focus");
          });

          container.on("close", function () {
            self.$search.val("");
            self.$search.removeAttr("aria-activedescendant");
            self.$search.trigger("focus");
          });

          container.on("enable", function () {
            self.$search.prop("disabled", false);

            self._transferTabIndex();
          });

          container.on("disable", function () {
            self.$search.prop("disabled", true);
          });

          container.on("focus", function (evt) {
            self.$search.trigger("focus");
          });

          container.on("results:focus", function (params) {
            self.$search.attr("aria-activedescendant", params.id);
          });

          this.$selection.on(
            "focusin",
            ".select2-search--inline",
            function (evt) {
              self.trigger("focus", evt);
            }
          );

          this.$selection.on(
            "focusout",
            ".select2-search--inline",
            function (evt) {
              self._handleBlur(evt);
            }
          );

          this.$selection.on(
            "keydown",
            ".select2-search--inline",
            function (evt) {
              evt.stopPropagation();

              self.trigger("keypress", evt);

              self._keyUpPrevented = evt.isDefaultPrevented();

              var key = evt.which;

              if (key === KEYS.BACKSPACE && self.$search.val() === "") {
                var $previousChoice = self.$searchContainer.prev(
                  ".select2-selection__choice"
                );

                if ($previousChoice.length > 0) {
                  var item = $previousChoice.data("data");

                  self.searchRemoveChoice(item);

                  evt.preventDefault();
                }
              }
            }
          );

          // Try to detect the IE version should the `documentMode` property that
          // is stored on the document. This is only implemented in IE and is
          // slightly cleaner than doing a user agent check.
          // This property is not available in Edge, but Edge also doesn't have
          // this bug.
          var msie = document.documentMode;
          var disableInputEvents = msie && msie <= 11;

          // Workaround for browsers which do not support the `input` event
          // This will prevent double-triggering of events for browsers which support
          // both the `keyup` and `input` events.
          this.$selection.on(
            "input.searchcheck",
            ".select2-search--inline",
            function (evt) {
              // IE will trigger the `input` event when a placeholder is used on a
              // search box. To get around this issue, we are forced to ignore all
              // `input` events in IE and keep using `keyup`.
              if (disableInputEvents) {
                self.$selection.off("input.search input.searchcheck");
                return;
              }

              // Unbind the duplicated `keyup` event
              self.$selection.off("keyup.search");
            }
          );

          this.$selection.on(
            "keyup.search input.search",
            ".select2-search--inline",
            function (evt) {
              // IE will trigger the `input` event when a placeholder is used on a
              // search box. To get around this issue, we are forced to ignore all
              // `input` events in IE and keep using `keyup`.
              if (disableInputEvents && evt.type === "input") {
                self.$selection.off("input.search input.searchcheck");
                return;
              }

              var key = evt.which;

              // We can freely ignore events from modifier keys
              if (key == KEYS.SHIFT || key == KEYS.CTRL || key == KEYS.ALT) {
                return;
              }

              // Tabbing will be handled during the `keydown` phase
              if (key == KEYS.TAB) {
                return;
              }

              self.handleSearch(evt);
            }
          );
        };

        /**
         * This method will transfer the tabindex attribute from the rendered
         * selection to the search box. This allows for the search box to be used as
         * the primary focus instead of the selection container.
         *
         * @private
         */
        Search.prototype._transferTabIndex = function (decorated) {
          this.$search.attr("tabindex", this.$selection.attr("tabindex"));
          this.$selection.attr("tabindex", "-1");
        };

        Search.prototype.createPlaceholder = function (decorated, placeholder) {
          this.$search.attr("placeholder", placeholder.text);
        };

        Search.prototype.update = function (decorated, data) {
          var searchHadFocus = this.$search[0] == document.activeElement;

          this.$search.attr("placeholder", "");

          decorated.call(this, data);

          this.$selection
            .find(".select2-selection__rendered")
            .append(this.$searchContainer);

          this.resizeSearch();
          if (searchHadFocus) {
            this.$search.focus();
          }
        };

        Search.prototype.handleSearch = function () {
          this.resizeSearch();

          if (!this._keyUpPrevented) {
            var input = this.$search.val();

            this.trigger("query", {
              term: input,
            });
          }

          this._keyUpPrevented = false;
        };

        Search.prototype.searchRemoveChoice = function (decorated, item) {
          this.trigger("unselect", {
            data: item,
          });

          this.$search.val(item.text);
          this.handleSearch();
        };

        Search.prototype.resizeSearch = function () {
          this.$search.css("width", "25px");

          var width = "";

          if (this.$search.attr("placeholder") !== "") {
            width = this.$selection
              .find(".select2-selection__rendered")
              .innerWidth();
          } else {
            var minimumWidth = this.$search.val().length + 1;

            width = minimumWidth * 0.75 + "em";
          }

          this.$search.css("width", width);
        };

        return Search;
      }
    );

    S2.define("select2/selection/eventRelay", ["jquery"], function ($) {
      function EventRelay() {}

      EventRelay.prototype.bind = function (decorated, container, $container) {
        var self = this;
        var relayEvents = [
          "open",
          "opening",
          "close",
          "closing",
          "select",
          "selecting",
          "unselect",
          "unselecting",
        ];

        var preventableEvents = [
          "opening",
          "closing",
          "selecting",
          "unselecting",
        ];

        decorated.call(this, container, $container);

        container.on("*", function (name, params) {
          // Ignore events that should not be relayed
          if ($.inArray(name, relayEvents) === -1) {
            return;
          }

          // The parameters should always be an object
          params = params || {};

          // Generate the jQuery event for the Select2 event
          var evt = $.Event("select2:" + name, {
            params: params,
          });

          self.$element.trigger(evt);

          // Only handle preventable events if it was one
          if ($.inArray(name, preventableEvents) === -1) {
            return;
          }

          params.prevented = evt.isDefaultPrevented();
        });
      };

      return EventRelay;
    });

    S2.define(
      "select2/translation",
      ["jquery", "require"],
      function ($, require) {
        function Translation(dict) {
          this.dict = dict || {};
        }

        Translation.prototype.all = function () {
          return this.dict;
        };

        Translation.prototype.get = function (key) {
          return this.dict[key];
        };

        Translation.prototype.extend = function (translation) {
          this.dict = $.extend({}, translation.all(), this.dict);
        };

        // Static functions

        Translation._cache = {};

        Translation.loadPath = function (path) {
          if (!(path in Translation._cache)) {
            var translations = require(path);

            Translation._cache[path] = translations;
          }

          return new Translation(Translation._cache[path]);
        };

        return Translation;
      }
    );

    S2.define("select2/diacritics", [], function () {
      var diacritics = {
        "\u24B6": "A",
        "\uFF21": "A",
        "\u00C0": "A",
        "\u00C1": "A",
        "\u00C2": "A",
        "\u1EA6": "A",
        "\u1EA4": "A",
        "\u1EAA": "A",
        "\u1EA8": "A",
        "\u00C3": "A",
        "\u0100": "A",
        "\u0102": "A",
        "\u1EB0": "A",
        "\u1EAE": "A",
        "\u1EB4": "A",
        "\u1EB2": "A",
        "\u0226": "A",
        "\u01E0": "A",
        "\u00C4": "A",
        "\u01DE": "A",
        "\u1EA2": "A",
        "\u00C5": "A",
        "\u01FA": "A",
        "\u01CD": "A",
        "\u0200": "A",
        "\u0202": "A",
        "\u1EA0": "A",
        "\u1EAC": "A",
        "\u1EB6": "A",
        "\u1E00": "A",
        "\u0104": "A",
        "\u023A": "A",
        "\u2C6F": "A",
        "\uA732": "AA",
        "\u00C6": "AE",
        "\u01FC": "AE",
        "\u01E2": "AE",
        "\uA734": "AO",
        "\uA736": "AU",
        "\uA738": "AV",
        "\uA73A": "AV",
        "\uA73C": "AY",
        "\u24B7": "B",
        "\uFF22": "B",
        "\u1E02": "B",
        "\u1E04": "B",
        "\u1E06": "B",
        "\u0243": "B",
        "\u0182": "B",
        "\u0181": "B",
        "\u24B8": "C",
        "\uFF23": "C",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u00C7": "C",
        "\u1E08": "C",
        "\u0187": "C",
        "\u023B": "C",
        "\uA73E": "C",
        "\u24B9": "D",
        "\uFF24": "D",
        "\u1E0A": "D",
        "\u010E": "D",
        "\u1E0C": "D",
        "\u1E10": "D",
        "\u1E12": "D",
        "\u1E0E": "D",
        "\u0110": "D",
        "\u018B": "D",
        "\u018A": "D",
        "\u0189": "D",
        "\uA779": "D",
        "\u01F1": "DZ",
        "\u01C4": "DZ",
        "\u01F2": "Dz",
        "\u01C5": "Dz",
        "\u24BA": "E",
        "\uFF25": "E",
        "\u00C8": "E",
        "\u00C9": "E",
        "\u00CA": "E",
        "\u1EC0": "E",
        "\u1EBE": "E",
        "\u1EC4": "E",
        "\u1EC2": "E",
        "\u1EBC": "E",
        "\u0112": "E",
        "\u1E14": "E",
        "\u1E16": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u00CB": "E",
        "\u1EBA": "E",
        "\u011A": "E",
        "\u0204": "E",
        "\u0206": "E",
        "\u1EB8": "E",
        "\u1EC6": "E",
        "\u0228": "E",
        "\u1E1C": "E",
        "\u0118": "E",
        "\u1E18": "E",
        "\u1E1A": "E",
        "\u0190": "E",
        "\u018E": "E",
        "\u24BB": "F",
        "\uFF26": "F",
        "\u1E1E": "F",
        "\u0191": "F",
        "\uA77B": "F",
        "\u24BC": "G",
        "\uFF27": "G",
        "\u01F4": "G",
        "\u011C": "G",
        "\u1E20": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u01E6": "G",
        "\u0122": "G",
        "\u01E4": "G",
        "\u0193": "G",
        "\uA7A0": "G",
        "\uA77D": "G",
        "\uA77E": "G",
        "\u24BD": "H",
        "\uFF28": "H",
        "\u0124": "H",
        "\u1E22": "H",
        "\u1E26": "H",
        "\u021E": "H",
        "\u1E24": "H",
        "\u1E28": "H",
        "\u1E2A": "H",
        "\u0126": "H",
        "\u2C67": "H",
        "\u2C75": "H",
        "\uA78D": "H",
        "\u24BE": "I",
        "\uFF29": "I",
        "\u00CC": "I",
        "\u00CD": "I",
        "\u00CE": "I",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u0130": "I",
        "\u00CF": "I",
        "\u1E2E": "I",
        "\u1EC8": "I",
        "\u01CF": "I",
        "\u0208": "I",
        "\u020A": "I",
        "\u1ECA": "I",
        "\u012E": "I",
        "\u1E2C": "I",
        "\u0197": "I",
        "\u24BF": "J",
        "\uFF2A": "J",
        "\u0134": "J",
        "\u0248": "J",
        "\u24C0": "K",
        "\uFF2B": "K",
        "\u1E30": "K",
        "\u01E8": "K",
        "\u1E32": "K",
        "\u0136": "K",
        "\u1E34": "K",
        "\u0198": "K",
        "\u2C69": "K",
        "\uA740": "K",
        "\uA742": "K",
        "\uA744": "K",
        "\uA7A2": "K",
        "\u24C1": "L",
        "\uFF2C": "L",
        "\u013F": "L",
        "\u0139": "L",
        "\u013D": "L",
        "\u1E36": "L",
        "\u1E38": "L",
        "\u013B": "L",
        "\u1E3C": "L",
        "\u1E3A": "L",
        "\u0141": "L",
        "\u023D": "L",
        "\u2C62": "L",
        "\u2C60": "L",
        "\uA748": "L",
        "\uA746": "L",
        "\uA780": "L",
        "\u01C7": "LJ",
        "\u01C8": "Lj",
        "\u24C2": "M",
        "\uFF2D": "M",
        "\u1E3E": "M",
        "\u1E40": "M",
        "\u1E42": "M",
        "\u2C6E": "M",
        "\u019C": "M",
        "\u24C3": "N",
        "\uFF2E": "N",
        "\u01F8": "N",
        "\u0143": "N",
        "\u00D1": "N",
        "\u1E44": "N",
        "\u0147": "N",
        "\u1E46": "N",
        "\u0145": "N",
        "\u1E4A": "N",
        "\u1E48": "N",
        "\u0220": "N",
        "\u019D": "N",
        "\uA790": "N",
        "\uA7A4": "N",
        "\u01CA": "NJ",
        "\u01CB": "Nj",
        "\u24C4": "O",
        "\uFF2F": "O",
        "\u00D2": "O",
        "\u00D3": "O",
        "\u00D4": "O",
        "\u1ED2": "O",
        "\u1ED0": "O",
        "\u1ED6": "O",
        "\u1ED4": "O",
        "\u00D5": "O",
        "\u1E4C": "O",
        "\u022C": "O",
        "\u1E4E": "O",
        "\u014C": "O",
        "\u1E50": "O",
        "\u1E52": "O",
        "\u014E": "O",
        "\u022E": "O",
        "\u0230": "O",
        "\u00D6": "O",
        "\u022A": "O",
        "\u1ECE": "O",
        "\u0150": "O",
        "\u01D1": "O",
        "\u020C": "O",
        "\u020E": "O",
        "\u01A0": "O",
        "\u1EDC": "O",
        "\u1EDA": "O",
        "\u1EE0": "O",
        "\u1EDE": "O",
        "\u1EE2": "O",
        "\u1ECC": "O",
        "\u1ED8": "O",
        "\u01EA": "O",
        "\u01EC": "O",
        "\u00D8": "O",
        "\u01FE": "O",
        "\u0186": "O",
        "\u019F": "O",
        "\uA74A": "O",
        "\uA74C": "O",
        "\u01A2": "OI",
        "\uA74E": "OO",
        "\u0222": "OU",
        "\u24C5": "P",
        "\uFF30": "P",
        "\u1E54": "P",
        "\u1E56": "P",
        "\u01A4": "P",
        "\u2C63": "P",
        "\uA750": "P",
        "\uA752": "P",
        "\uA754": "P",
        "\u24C6": "Q",
        "\uFF31": "Q",
        "\uA756": "Q",
        "\uA758": "Q",
        "\u024A": "Q",
        "\u24C7": "R",
        "\uFF32": "R",
        "\u0154": "R",
        "\u1E58": "R",
        "\u0158": "R",
        "\u0210": "R",
        "\u0212": "R",
        "\u1E5A": "R",
        "\u1E5C": "R",
        "\u0156": "R",
        "\u1E5E": "R",
        "\u024C": "R",
        "\u2C64": "R",
        "\uA75A": "R",
        "\uA7A6": "R",
        "\uA782": "R",
        "\u24C8": "S",
        "\uFF33": "S",
        "\u1E9E": "S",
        "\u015A": "S",
        "\u1E64": "S",
        "\u015C": "S",
        "\u1E60": "S",
        "\u0160": "S",
        "\u1E66": "S",
        "\u1E62": "S",
        "\u1E68": "S",
        "\u0218": "S",
        "\u015E": "S",
        "\u2C7E": "S",
        "\uA7A8": "S",
        "\uA784": "S",
        "\u24C9": "T",
        "\uFF34": "T",
        "\u1E6A": "T",
        "\u0164": "T",
        "\u1E6C": "T",
        "\u021A": "T",
        "\u0162": "T",
        "\u1E70": "T",
        "\u1E6E": "T",
        "\u0166": "T",
        "\u01AC": "T",
        "\u01AE": "T",
        "\u023E": "T",
        "\uA786": "T",
        "\uA728": "TZ",
        "\u24CA": "U",
        "\uFF35": "U",
        "\u00D9": "U",
        "\u00DA": "U",
        "\u00DB": "U",
        "\u0168": "U",
        "\u1E78": "U",
        "\u016A": "U",
        "\u1E7A": "U",
        "\u016C": "U",
        "\u00DC": "U",
        "\u01DB": "U",
        "\u01D7": "U",
        "\u01D5": "U",
        "\u01D9": "U",
        "\u1EE6": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u01D3": "U",
        "\u0214": "U",
        "\u0216": "U",
        "\u01AF": "U",
        "\u1EEA": "U",
        "\u1EE8": "U",
        "\u1EEE": "U",
        "\u1EEC": "U",
        "\u1EF0": "U",
        "\u1EE4": "U",
        "\u1E72": "U",
        "\u0172": "U",
        "\u1E76": "U",
        "\u1E74": "U",
        "\u0244": "U",
        "\u24CB": "V",
        "\uFF36": "V",
        "\u1E7C": "V",
        "\u1E7E": "V",
        "\u01B2": "V",
        "\uA75E": "V",
        "\u0245": "V",
        "\uA760": "VY",
        "\u24CC": "W",
        "\uFF37": "W",
        "\u1E80": "W",
        "\u1E82": "W",
        "\u0174": "W",
        "\u1E86": "W",
        "\u1E84": "W",
        "\u1E88": "W",
        "\u2C72": "W",
        "\u24CD": "X",
        "\uFF38": "X",
        "\u1E8A": "X",
        "\u1E8C": "X",
        "\u24CE": "Y",
        "\uFF39": "Y",
        "\u1EF2": "Y",
        "\u00DD": "Y",
        "\u0176": "Y",
        "\u1EF8": "Y",
        "\u0232": "Y",
        "\u1E8E": "Y",
        "\u0178": "Y",
        "\u1EF6": "Y",
        "\u1EF4": "Y",
        "\u01B3": "Y",
        "\u024E": "Y",
        "\u1EFE": "Y",
        "\u24CF": "Z",
        "\uFF3A": "Z",
        "\u0179": "Z",
        "\u1E90": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u1E92": "Z",
        "\u1E94": "Z",
        "\u01B5": "Z",
        "\u0224": "Z",
        "\u2C7F": "Z",
        "\u2C6B": "Z",
        "\uA762": "Z",
        "\u24D0": "a",
        "\uFF41": "a",
        "\u1E9A": "a",
        "\u00E0": "a",
        "\u00E1": "a",
        "\u00E2": "a",
        "\u1EA7": "a",
        "\u1EA5": "a",
        "\u1EAB": "a",
        "\u1EA9": "a",
        "\u00E3": "a",
        "\u0101": "a",
        "\u0103": "a",
        "\u1EB1": "a",
        "\u1EAF": "a",
        "\u1EB5": "a",
        "\u1EB3": "a",
        "\u0227": "a",
        "\u01E1": "a",
        "\u00E4": "a",
        "\u01DF": "a",
        "\u1EA3": "a",
        "\u00E5": "a",
        "\u01FB": "a",
        "\u01CE": "a",
        "\u0201": "a",
        "\u0203": "a",
        "\u1EA1": "a",
        "\u1EAD": "a",
        "\u1EB7": "a",
        "\u1E01": "a",
        "\u0105": "a",
        "\u2C65": "a",
        "\u0250": "a",
        "\uA733": "aa",
        "\u00E6": "ae",
        "\u01FD": "ae",
        "\u01E3": "ae",
        "\uA735": "ao",
        "\uA737": "au",
        "\uA739": "av",
        "\uA73B": "av",
        "\uA73D": "ay",
        "\u24D1": "b",
        "\uFF42": "b",
        "\u1E03": "b",
        "\u1E05": "b",
        "\u1E07": "b",
        "\u0180": "b",
        "\u0183": "b",
        "\u0253": "b",
        "\u24D2": "c",
        "\uFF43": "c",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u00E7": "c",
        "\u1E09": "c",
        "\u0188": "c",
        "\u023C": "c",
        "\uA73F": "c",
        "\u2184": "c",
        "\u24D3": "d",
        "\uFF44": "d",
        "\u1E0B": "d",
        "\u010F": "d",
        "\u1E0D": "d",
        "\u1E11": "d",
        "\u1E13": "d",
        "\u1E0F": "d",
        "\u0111": "d",
        "\u018C": "d",
        "\u0256": "d",
        "\u0257": "d",
        "\uA77A": "d",
        "\u01F3": "dz",
        "\u01C6": "dz",
        "\u24D4": "e",
        "\uFF45": "e",
        "\u00E8": "e",
        "\u00E9": "e",
        "\u00EA": "e",
        "\u1EC1": "e",
        "\u1EBF": "e",
        "\u1EC5": "e",
        "\u1EC3": "e",
        "\u1EBD": "e",
        "\u0113": "e",
        "\u1E15": "e",
        "\u1E17": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u00EB": "e",
        "\u1EBB": "e",
        "\u011B": "e",
        "\u0205": "e",
        "\u0207": "e",
        "\u1EB9": "e",
        "\u1EC7": "e",
        "\u0229": "e",
        "\u1E1D": "e",
        "\u0119": "e",
        "\u1E19": "e",
        "\u1E1B": "e",
        "\u0247": "e",
        "\u025B": "e",
        "\u01DD": "e",
        "\u24D5": "f",
        "\uFF46": "f",
        "\u1E1F": "f",
        "\u0192": "f",
        "\uA77C": "f",
        "\u24D6": "g",
        "\uFF47": "g",
        "\u01F5": "g",
        "\u011D": "g",
        "\u1E21": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u01E7": "g",
        "\u0123": "g",
        "\u01E5": "g",
        "\u0260": "g",
        "\uA7A1": "g",
        "\u1D79": "g",
        "\uA77F": "g",
        "\u24D7": "h",
        "\uFF48": "h",
        "\u0125": "h",
        "\u1E23": "h",
        "\u1E27": "h",
        "\u021F": "h",
        "\u1E25": "h",
        "\u1E29": "h",
        "\u1E2B": "h",
        "\u1E96": "h",
        "\u0127": "h",
        "\u2C68": "h",
        "\u2C76": "h",
        "\u0265": "h",
        "\u0195": "hv",
        "\u24D8": "i",
        "\uFF49": "i",
        "\u00EC": "i",
        "\u00ED": "i",
        "\u00EE": "i",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u00EF": "i",
        "\u1E2F": "i",
        "\u1EC9": "i",
        "\u01D0": "i",
        "\u0209": "i",
        "\u020B": "i",
        "\u1ECB": "i",
        "\u012F": "i",
        "\u1E2D": "i",
        "\u0268": "i",
        "\u0131": "i",
        "\u24D9": "j",
        "\uFF4A": "j",
        "\u0135": "j",
        "\u01F0": "j",
        "\u0249": "j",
        "\u24DA": "k",
        "\uFF4B": "k",
        "\u1E31": "k",
        "\u01E9": "k",
        "\u1E33": "k",
        "\u0137": "k",
        "\u1E35": "k",
        "\u0199": "k",
        "\u2C6A": "k",
        "\uA741": "k",
        "\uA743": "k",
        "\uA745": "k",
        "\uA7A3": "k",
        "\u24DB": "l",
        "\uFF4C": "l",
        "\u0140": "l",
        "\u013A": "l",
        "\u013E": "l",
        "\u1E37": "l",
        "\u1E39": "l",
        "\u013C": "l",
        "\u1E3D": "l",
        "\u1E3B": "l",
        "\u017F": "l",
        "\u0142": "l",
        "\u019A": "l",
        "\u026B": "l",
        "\u2C61": "l",
        "\uA749": "l",
        "\uA781": "l",
        "\uA747": "l",
        "\u01C9": "lj",
        "\u24DC": "m",
        "\uFF4D": "m",
        "\u1E3F": "m",
        "\u1E41": "m",
        "\u1E43": "m",
        "\u0271": "m",
        "\u026F": "m",
        "\u24DD": "n",
        "\uFF4E": "n",
        "\u01F9": "n",
        "\u0144": "n",
        "\u00F1": "n",
        "\u1E45": "n",
        "\u0148": "n",
        "\u1E47": "n",
        "\u0146": "n",
        "\u1E4B": "n",
        "\u1E49": "n",
        "\u019E": "n",
        "\u0272": "n",
        "\u0149": "n",
        "\uA791": "n",
        "\uA7A5": "n",
        "\u01CC": "nj",
        "\u24DE": "o",
        "\uFF4F": "o",
        "\u00F2": "o",
        "\u00F3": "o",
        "\u00F4": "o",
        "\u1ED3": "o",
        "\u1ED1": "o",
        "\u1ED7": "o",
        "\u1ED5": "o",
        "\u00F5": "o",
        "\u1E4D": "o",
        "\u022D": "o",
        "\u1E4F": "o",
        "\u014D": "o",
        "\u1E51": "o",
        "\u1E53": "o",
        "\u014F": "o",
        "\u022F": "o",
        "\u0231": "o",
        "\u00F6": "o",
        "\u022B": "o",
        "\u1ECF": "o",
        "\u0151": "o",
        "\u01D2": "o",
        "\u020D": "o",
        "\u020F": "o",
        "\u01A1": "o",
        "\u1EDD": "o",
        "\u1EDB": "o",
        "\u1EE1": "o",
        "\u1EDF": "o",
        "\u1EE3": "o",
        "\u1ECD": "o",
        "\u1ED9": "o",
        "\u01EB": "o",
        "\u01ED": "o",
        "\u00F8": "o",
        "\u01FF": "o",
        "\u0254": "o",
        "\uA74B": "o",
        "\uA74D": "o",
        "\u0275": "o",
        "\u01A3": "oi",
        "\u0223": "ou",
        "\uA74F": "oo",
        "\u24DF": "p",
        "\uFF50": "p",
        "\u1E55": "p",
        "\u1E57": "p",
        "\u01A5": "p",
        "\u1D7D": "p",
        "\uA751": "p",
        "\uA753": "p",
        "\uA755": "p",
        "\u24E0": "q",
        "\uFF51": "q",
        "\u024B": "q",
        "\uA757": "q",
        "\uA759": "q",
        "\u24E1": "r",
        "\uFF52": "r",
        "\u0155": "r",
        "\u1E59": "r",
        "\u0159": "r",
        "\u0211": "r",
        "\u0213": "r",
        "\u1E5B": "r",
        "\u1E5D": "r",
        "\u0157": "r",
        "\u1E5F": "r",
        "\u024D": "r",
        "\u027D": "r",
        "\uA75B": "r",
        "\uA7A7": "r",
        "\uA783": "r",
        "\u24E2": "s",
        "\uFF53": "s",
        "\u00DF": "s",
        "\u015B": "s",
        "\u1E65": "s",
        "\u015D": "s",
        "\u1E61": "s",
        "\u0161": "s",
        "\u1E67": "s",
        "\u1E63": "s",
        "\u1E69": "s",
        "\u0219": "s",
        "\u015F": "s",
        "\u023F": "s",
        "\uA7A9": "s",
        "\uA785": "s",
        "\u1E9B": "s",
        "\u24E3": "t",
        "\uFF54": "t",
        "\u1E6B": "t",
        "\u1E97": "t",
        "\u0165": "t",
        "\u1E6D": "t",
        "\u021B": "t",
        "\u0163": "t",
        "\u1E71": "t",
        "\u1E6F": "t",
        "\u0167": "t",
        "\u01AD": "t",
        "\u0288": "t",
        "\u2C66": "t",
        "\uA787": "t",
        "\uA729": "tz",
        "\u24E4": "u",
        "\uFF55": "u",
        "\u00F9": "u",
        "\u00FA": "u",
        "\u00FB": "u",
        "\u0169": "u",
        "\u1E79": "u",
        "\u016B": "u",
        "\u1E7B": "u",
        "\u016D": "u",
        "\u00FC": "u",
        "\u01DC": "u",
        "\u01D8": "u",
        "\u01D6": "u",
        "\u01DA": "u",
        "\u1EE7": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u01D4": "u",
        "\u0215": "u",
        "\u0217": "u",
        "\u01B0": "u",
        "\u1EEB": "u",
        "\u1EE9": "u",
        "\u1EEF": "u",
        "\u1EED": "u",
        "\u1EF1": "u",
        "\u1EE5": "u",
        "\u1E73": "u",
        "\u0173": "u",
        "\u1E77": "u",
        "\u1E75": "u",
        "\u0289": "u",
        "\u24E5": "v",
        "\uFF56": "v",
        "\u1E7D": "v",
        "\u1E7F": "v",
        "\u028B": "v",
        "\uA75F": "v",
        "\u028C": "v",
        "\uA761": "vy",
        "\u24E6": "w",
        "\uFF57": "w",
        "\u1E81": "w",
        "\u1E83": "w",
        "\u0175": "w",
        "\u1E87": "w",
        "\u1E85": "w",
        "\u1E98": "w",
        "\u1E89": "w",
        "\u2C73": "w",
        "\u24E7": "x",
        "\uFF58": "x",
        "\u1E8B": "x",
        "\u1E8D": "x",
        "\u24E8": "y",
        "\uFF59": "y",
        "\u1EF3": "y",
        "\u00FD": "y",
        "\u0177": "y",
        "\u1EF9": "y",
        "\u0233": "y",
        "\u1E8F": "y",
        "\u00FF": "y",
        "\u1EF7": "y",
        "\u1E99": "y",
        "\u1EF5": "y",
        "\u01B4": "y",
        "\u024F": "y",
        "\u1EFF": "y",
        "\u24E9": "z",
        "\uFF5A": "z",
        "\u017A": "z",
        "\u1E91": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u1E93": "z",
        "\u1E95": "z",
        "\u01B6": "z",
        "\u0225": "z",
        "\u0240": "z",
        "\u2C6C": "z",
        "\uA763": "z",
        "\u0386": "\u0391",
        "\u0388": "\u0395",
        "\u0389": "\u0397",
        "\u038A": "\u0399",
        "\u03AA": "\u0399",
        "\u038C": "\u039F",
        "\u038E": "\u03A5",
        "\u03AB": "\u03A5",
        "\u038F": "\u03A9",
        "\u03AC": "\u03B1",
        "\u03AD": "\u03B5",
        "\u03AE": "\u03B7",
        "\u03AF": "\u03B9",
        "\u03CA": "\u03B9",
        "\u0390": "\u03B9",
        "\u03CC": "\u03BF",
        "\u03CD": "\u03C5",
        "\u03CB": "\u03C5",
        "\u03B0": "\u03C5",
        "\u03C9": "\u03C9",
        "\u03C2": "\u03C3",
      };

      return diacritics;
    });

    S2.define("select2/data/base", ["../utils"], function (Utils) {
      function BaseAdapter($element, options) {
        BaseAdapter.__super__.constructor.call(this);
      }

      Utils.Extend(BaseAdapter, Utils.Observable);

      BaseAdapter.prototype.current = function (callback) {
        throw new Error(
          "The `current` method must be defined in child classes."
        );
      };

      BaseAdapter.prototype.query = function (params, callback) {
        throw new Error("The `query` method must be defined in child classes.");
      };

      BaseAdapter.prototype.bind = function (container, $container) {
        // Can be implemented in subclasses
      };

      BaseAdapter.prototype.destroy = function () {
        // Can be implemented in subclasses
      };

      BaseAdapter.prototype.generateResultId = function (container, data) {
        var id = container.id + "-result-";

        id += Utils.generateChars(4);

        if (data.id != null) {
          id += "-" + data.id.toString();
        } else {
          id += "-" + Utils.generateChars(4);
        }
        return id;
      };

      return BaseAdapter;
    });

    S2.define(
      "select2/data/select",
      ["./base", "../utils", "jquery"],
      function (BaseAdapter, Utils, $) {
        function SelectAdapter($element, options) {
          this.$element = $element;
          this.options = options;

          SelectAdapter.__super__.constructor.call(this);
        }

        Utils.Extend(SelectAdapter, BaseAdapter);

        SelectAdapter.prototype.current = function (callback) {
          var data = [];
          var self = this;

          this.$element.find(":selected").each(function () {
            var $option = $(this);

            var option = self.item($option);

            data.push(option);
          });

          callback(data);
        };

        SelectAdapter.prototype.select = function (data) {
          var self = this;

          data.selected = true;

          // If data.element is a DOM node, use it instead
          if ($(data.element).is("option")) {
            data.element.selected = true;

            this.$element.trigger("change");

            return;
          }

          if (this.$element.prop("multiple")) {
            this.current(function (currentData) {
              var val = [];

              data = [data];
              data.push.apply(data, currentData);

              for (var d = 0; d < data.length; d++) {
                var id = data[d].id;

                if ($.inArray(id, val) === -1) {
                  val.push(id);
                }
              }

              self.$element.val(val);
              self.$element.trigger("change");
            });
          } else {
            var val = data.id;

            this.$element.val(val);
            this.$element.trigger("change");
          }
        };

        SelectAdapter.prototype.unselect = function (data) {
          var self = this;

          if (!this.$element.prop("multiple")) {
            return;
          }

          data.selected = false;

          if ($(data.element).is("option")) {
            data.element.selected = false;

            this.$element.trigger("change");

            return;
          }

          this.current(function (currentData) {
            var val = [];

            for (var d = 0; d < currentData.length; d++) {
              var id = currentData[d].id;

              if (id !== data.id && $.inArray(id, val) === -1) {
                val.push(id);
              }
            }

            self.$element.val(val);

            self.$element.trigger("change");
          });
        };

        SelectAdapter.prototype.bind = function (container, $container) {
          var self = this;

          this.container = container;

          container.on("select", function (params) {
            self.select(params.data);
          });

          container.on("unselect", function (params) {
            self.unselect(params.data);
          });
        };

        SelectAdapter.prototype.destroy = function () {
          // Remove anything added to child elements
          this.$element.find("*").each(function () {
            // Remove any custom data set by Select2
            $.removeData(this, "data");
          });
        };

        SelectAdapter.prototype.query = function (params, callback) {
          var data = [];
          var self = this;

          var $options = this.$element.children();

          $options.each(function () {
            var $option = $(this);

            if (!$option.is("option") && !$option.is("optgroup")) {
              return;
            }

            var option = self.item($option);

            var matches = self.matches(params, option);

            if (matches !== null) {
              data.push(matches);
            }
          });

          callback({
            results: data,
          });
        };

        SelectAdapter.prototype.addOptions = function ($options) {
          Utils.appendMany(this.$element, $options);
        };

        SelectAdapter.prototype.option = function (data) {
          var option;

          if (data.children) {
            option = document.createElement("optgroup");
            option.label = data.text;
          } else {
            option = document.createElement("option");

            if (option.textContent !== undefined) {
              option.textContent = data.text;
            } else {
              option.innerText = data.text;
            }
          }

          if (data.id) {
            option.value = data.id;
          }

          if (data.disabled) {
            option.disabled = true;
          }

          if (data.selected) {
            option.selected = true;
          }

          if (data.title) {
            option.title = data.title;
          }

          var $option = $(option);

          var normalizedData = this._normalizeItem(data);
          normalizedData.element = option;

          // Override the option's data with the combined data
          $.data(option, "data", normalizedData);

          return $option;
        };

        SelectAdapter.prototype.item = function ($option) {
          var data = {};

          data = $.data($option[0], "data");

          if (data != null) {
            return data;
          }

          if ($option.is("option")) {
            data = {
              id: $option.val(),
              text: $option.text(),
              disabled: $option.prop("disabled"),
              selected: $option.prop("selected"),
              title: $option.prop("title"),
            };
          } else if ($option.is("optgroup")) {
            data = {
              text: $option.prop("label"),
              children: [],
              title: $option.prop("title"),
            };

            var $children = $option.children("option");
            var children = [];

            for (var c = 0; c < $children.length; c++) {
              var $child = $($children[c]);

              var child = this.item($child);

              children.push(child);
            }

            data.children = children;
          }

          data = this._normalizeItem(data);
          data.element = $option[0];

          $.data($option[0], "data", data);

          return data;
        };

        SelectAdapter.prototype._normalizeItem = function (item) {
          if (!$.isPlainObject(item)) {
            item = {
              id: item,
              text: item,
            };
          }

          item = $.extend(
            {},
            {
              text: "",
            },
            item
          );

          var defaults = {
            selected: false,
            disabled: false,
          };

          if (item.id != null) {
            item.id = item.id.toString();
          }

          if (item.text != null) {
            item.text = item.text.toString();
          }

          if (item._resultId == null && item.id && this.container != null) {
            item._resultId = this.generateResultId(this.container, item);
          }

          return $.extend({}, defaults, item);
        };

        SelectAdapter.prototype.matches = function (params, data) {
          var matcher = this.options.get("matcher");

          return matcher(params, data);
        };

        return SelectAdapter;
      }
    );

    S2.define(
      "select2/data/array",
      ["./select", "../utils", "jquery"],
      function (SelectAdapter, Utils, $) {
        function ArrayAdapter($element, options) {
          var data = options.get("data") || [];

          ArrayAdapter.__super__.constructor.call(this, $element, options);

          this.addOptions(this.convertToOptions(data));
        }

        Utils.Extend(ArrayAdapter, SelectAdapter);

        ArrayAdapter.prototype.select = function (data) {
          var $option = this.$element.find("option").filter(function (i, elm) {
            return elm.value == data.id.toString();
          });

          if ($option.length === 0) {
            $option = this.option(data);

            this.addOptions($option);
          }

          ArrayAdapter.__super__.select.call(this, data);
        };

        ArrayAdapter.prototype.convertToOptions = function (data) {
          var self = this;

          var $existing = this.$element.find("option");
          var existingIds = $existing
            .map(function () {
              return self.item($(this)).id;
            })
            .get();

          var $options = [];

          // Filter out all items except for the one passed in the argument
          function onlyItem(item) {
            return function () {
              return $(this).val() == item.id;
            };
          }

          for (var d = 0; d < data.length; d++) {
            var item = this._normalizeItem(data[d]);

            // Skip items which were pre-loaded, only merge the data
            if ($.inArray(item.id, existingIds) >= 0) {
              var $existingOption = $existing.filter(onlyItem(item));

              var existingData = this.item($existingOption);
              var newData = $.extend(true, {}, item, existingData);

              var $newOption = this.option(newData);

              $existingOption.replaceWith($newOption);

              continue;
            }

            var $option = this.option(item);

            if (item.children) {
              var $children = this.convertToOptions(item.children);

              Utils.appendMany($option, $children);
            }

            $options.push($option);
          }

          return $options;
        };

        return ArrayAdapter;
      }
    );

    S2.define(
      "select2/data/ajax",
      ["./array", "../utils", "jquery"],
      function (ArrayAdapter, Utils, $) {
        function AjaxAdapter($element, options) {
          this.ajaxOptions = this._applyDefaults(options.get("ajax"));

          if (this.ajaxOptions.processResults != null) {
            this.processResults = this.ajaxOptions.processResults;
          }

          AjaxAdapter.__super__.constructor.call(this, $element, options);
        }

        Utils.Extend(AjaxAdapter, ArrayAdapter);

        AjaxAdapter.prototype._applyDefaults = function (options) {
          var defaults = {
            data: function (params) {
              return $.extend({}, params, {
                q: params.term,
              });
            },
            transport: function (params, success, failure) {
              var $request = $.ajax(params);

              $request.then(success);
              $request.fail(failure);

              return $request;
            },
          };

          return $.extend({}, defaults, options, true);
        };

        AjaxAdapter.prototype.processResults = function (results) {
          return results;
        };

        AjaxAdapter.prototype.query = function (params, callback) {
          var matches = [];
          var self = this;

          if (this._request != null) {
            // JSONP requests cannot always be aborted
            if ($.isFunction(this._request.abort)) {
              this._request.abort();
            }

            this._request = null;
          }

          var options = $.extend(
            {
              type: "GET",
            },
            this.ajaxOptions
          );

          if (typeof options.url === "function") {
            options.url = options.url.call(this.$element, params);
          }

          if (typeof options.data === "function") {
            options.data = options.data.call(this.$element, params);
          }

          function request() {
            var $request = options.transport(
              options,
              function (data) {
                var results = self.processResults(data, params);

                if (
                  self.options.get("debug") &&
                  window.console &&
                  console.error
                ) {
                  // Check to make sure that the response included a `results` key.
                  if (
                    !results ||
                    !results.results ||
                    !$.isArray(results.results)
                  ) {
                    console.error(
                      "Select2: The AJAX results did not return an array in the " +
                        "`results` key of the response."
                    );
                  }
                }

                callback(results);
              },
              function () {
                // Attempt to detect if a request was aborted
                // Only works if the transport exposes a status property
                if ($request.status && $request.status === "0") {
                  return;
                }

                self.trigger("results:message", {
                  message: "errorLoading",
                });
              }
            );

            self._request = $request;
          }

          if (this.ajaxOptions.delay && params.term != null) {
            if (this._queryTimeout) {
              window.clearTimeout(this._queryTimeout);
            }

            this._queryTimeout = window.setTimeout(
              request,
              this.ajaxOptions.delay
            );
          } else {
            request();
          }
        };

        return AjaxAdapter;
      }
    );

    S2.define("select2/data/tags", ["jquery"], function ($) {
      function Tags(decorated, $element, options) {
        var tags = options.get("tags");

        var createTag = options.get("createTag");

        if (createTag !== undefined) {
          this.createTag = createTag;
        }

        var insertTag = options.get("insertTag");

        if (insertTag !== undefined) {
          this.insertTag = insertTag;
        }

        decorated.call(this, $element, options);

        if ($.isArray(tags)) {
          for (var t = 0; t < tags.length; t++) {
            var tag = tags[t];
            var item = this._normalizeItem(tag);

            var $option = this.option(item);

            this.$element.append($option);
          }
        }
      }

      Tags.prototype.query = function (decorated, params, callback) {
        var self = this;

        this._removeOldTags();

        if (params.term == null || params.page != null) {
          decorated.call(this, params, callback);
          return;
        }

        function wrapper(obj, child) {
          var data = obj.results;

          for (var i = 0; i < data.length; i++) {
            var option = data[i];

            var checkChildren =
              option.children != null &&
              !wrapper(
                {
                  results: option.children,
                },
                true
              );

            var checkText = option.text === params.term;

            if (checkText || checkChildren) {
              if (child) {
                return false;
              }

              obj.data = data;
              callback(obj);

              return;
            }
          }

          if (child) {
            return true;
          }

          var tag = self.createTag(params);

          if (tag != null) {
            var $option = self.option(tag);
            $option.attr("data-select2-tag", true);

            self.addOptions([$option]);

            self.insertTag(data, tag);
          }

          obj.results = data;

          callback(obj);
        }

        decorated.call(this, params, wrapper);
      };

      Tags.prototype.createTag = function (decorated, params) {
        var term = $.trim(params.term);

        if (term === "") {
          return null;
        }

        return {
          id: term,
          text: term,
        };
      };

      Tags.prototype.insertTag = function (_, data, tag) {
        data.unshift(tag);
      };

      Tags.prototype._removeOldTags = function (_) {
        var tag = this._lastTag;

        var $options = this.$element.find("option[data-select2-tag]");

        $options.each(function () {
          if (this.selected) {
            return;
          }

          $(this).remove();
        });
      };

      return Tags;
    });

    S2.define("select2/data/tokenizer", ["jquery"], function ($) {
      function Tokenizer(decorated, $element, options) {
        var tokenizer = options.get("tokenizer");

        if (tokenizer !== undefined) {
          this.tokenizer = tokenizer;
        }

        decorated.call(this, $element, options);
      }

      Tokenizer.prototype.bind = function (decorated, container, $container) {
        decorated.call(this, container, $container);

        this.$search =
          container.dropdown.$search ||
          container.selection.$search ||
          $container.find(".select2-search__field");
      };

      Tokenizer.prototype.query = function (decorated, params, callback) {
        var self = this;

        function createAndSelect(data) {
          // Normalize the data object so we can use it for checks
          var item = self._normalizeItem(data);

          // Check if the data object already exists as a tag
          // Select it if it doesn't
          var $existingOptions = self.$element
            .find("option")
            .filter(function () {
              return $(this).val() === item.id;
            });

          // If an existing option wasn't found for it, create the option
          if (!$existingOptions.length) {
            var $option = self.option(item);
            $option.attr("data-select2-tag", true);

            self._removeOldTags();
            self.addOptions([$option]);
          }

          // Select the item, now that we know there is an option for it
          select(item);
        }

        function select(data) {
          self.trigger("select", {
            data: data,
          });
        }

        params.term = params.term || "";

        var tokenData = this.tokenizer(params, this.options, createAndSelect);

        if (tokenData.term !== params.term) {
          // Replace the search term if we have the search box
          if (this.$search.length) {
            this.$search.val(tokenData.term);
            this.$search.focus();
          }

          params.term = tokenData.term;
        }

        decorated.call(this, params, callback);
      };

      Tokenizer.prototype.tokenizer = function (_, params, options, callback) {
        var separators = options.get("tokenSeparators") || [];
        var term = params.term;
        var i = 0;

        var createTag =
          this.createTag ||
          function (params) {
            return {
              id: params.term,
              text: params.term,
            };
          };

        while (i < term.length) {
          var termChar = term[i];

          if ($.inArray(termChar, separators) === -1) {
            i++;

            continue;
          }

          var part = term.substr(0, i);
          var partParams = $.extend({}, params, {
            term: part,
          });

          var data = createTag(partParams);

          if (data == null) {
            i++;
            continue;
          }

          callback(data);

          // Reset the term to not include the tokenized portion
          term = term.substr(i + 1) || "";
          i = 0;
        }

        return {
          term: term,
        };
      };

      return Tokenizer;
    });

    S2.define("select2/data/minimumInputLength", [], function () {
      function MinimumInputLength(decorated, $e, options) {
        this.minimumInputLength = options.get("minimumInputLength");

        decorated.call(this, $e, options);
      }

      MinimumInputLength.prototype.query = function (
        decorated,
        params,
        callback
      ) {
        params.term = params.term || "";

        if (params.term.length < this.minimumInputLength) {
          this.trigger("results:message", {
            message: "inputTooShort",
            args: {
              minimum: this.minimumInputLength,
              input: params.term,
              params: params,
            },
          });

          return;
        }

        decorated.call(this, params, callback);
      };

      return MinimumInputLength;
    });

    S2.define("select2/data/maximumInputLength", [], function () {
      function MaximumInputLength(decorated, $e, options) {
        this.maximumInputLength = options.get("maximumInputLength");

        decorated.call(this, $e, options);
      }

      MaximumInputLength.prototype.query = function (
        decorated,
        params,
        callback
      ) {
        params.term = params.term || "";

        if (
          this.maximumInputLength > 0 &&
          params.term.length > this.maximumInputLength
        ) {
          this.trigger("results:message", {
            message: "inputTooLong",
            args: {
              maximum: this.maximumInputLength,
              input: params.term,
              params: params,
            },
          });

          return;
        }

        decorated.call(this, params, callback);
      };

      return MaximumInputLength;
    });

    S2.define("select2/data/maximumSelectionLength", [], function () {
      function MaximumSelectionLength(decorated, $e, options) {
        this.maximumSelectionLength = options.get("maximumSelectionLength");

        decorated.call(this, $e, options);
      }

      MaximumSelectionLength.prototype.query = function (
        decorated,
        params,
        callback
      ) {
        var self = this;

        this.current(function (currentData) {
          var count = currentData != null ? currentData.length : 0;
          if (
            self.maximumSelectionLength > 0 &&
            count >= self.maximumSelectionLength
          ) {
            self.trigger("results:message", {
              message: "maximumSelected",
              args: {
                maximum: self.maximumSelectionLength,
              },
            });
            return;
          }
          decorated.call(self, params, callback);
        });
      };

      return MaximumSelectionLength;
    });

    S2.define("select2/dropdown", ["jquery", "./utils"], function ($, Utils) {
      function Dropdown($element, options) {
        this.$element = $element;
        this.options = options;

        Dropdown.__super__.constructor.call(this);
      }

      Utils.Extend(Dropdown, Utils.Observable);

      Dropdown.prototype.render = function () {
        var $dropdown = $(
          '<span class="select2-dropdown">' +
            '<span class="select2-results"></span>' +
            "</span>"
        );

        $dropdown.attr("dir", this.options.get("dir"));

        this.$dropdown = $dropdown;

        return $dropdown;
      };

      Dropdown.prototype.bind = function () {
        // Should be implemented in subclasses
      };

      Dropdown.prototype.position = function ($dropdown, $container) {
        // Should be implmented in subclasses
      };

      Dropdown.prototype.destroy = function () {
        // Remove the dropdown from the DOM
        this.$dropdown.remove();
      };

      return Dropdown;
    });

    S2.define(
      "select2/dropdown/search",
      ["jquery", "../utils"],
      function ($, Utils) {
        function Search() {}

        Search.prototype.render = function (decorated) {
          var $rendered = decorated.call(this);

          var $search = $(
            '<span class="select2-search select2-search--dropdown">' +
              '<input class="select2-search__field" type="search" tabindex="-1"' +
              ' autocomplete="off" autocorrect="off" autocapitalize="off"' +
              ' spellcheck="false" role="textbox" />' +
              "</span>"
          );

          this.$searchContainer = $search;
          this.$search = $search.find("input");

          $rendered.prepend($search);

          return $rendered;
        };

        Search.prototype.bind = function (decorated, container, $container) {
          var self = this;

          decorated.call(this, container, $container);

          this.$search.on("keydown", function (evt) {
            self.trigger("keypress", evt);

            self._keyUpPrevented = evt.isDefaultPrevented();
          });

          // Workaround for browsers which do not support the `input` event
          // This will prevent double-triggering of events for browsers which support
          // both the `keyup` and `input` events.
          this.$search.on("input", function (evt) {
            // Unbind the duplicated `keyup` event
            $(this).off("keyup");
          });

          this.$search.on("keyup input", function (evt) {
            self.handleSearch(evt);
          });

          container.on("open", function () {
            self.$search.attr("tabindex", 0);

            self.$search.focus();

            window.setTimeout(function () {
              self.$search.focus();
            }, 0);
          });

          container.on("close", function () {
            self.$search.attr("tabindex", -1);

            self.$search.val("");
          });

          container.on("focus", function () {
            if (container.isOpen()) {
              self.$search.focus();
            }
          });

          container.on("results:all", function (params) {
            if (params.query.term == null || params.query.term === "") {
              var showSearch = self.showSearch(params);

              if (showSearch) {
                self.$searchContainer.removeClass("select2-search--hide");
              } else {
                self.$searchContainer.addClass("select2-search--hide");
              }
            }
          });
        };

        Search.prototype.handleSearch = function (evt) {
          if (!this._keyUpPrevented) {
            var input = this.$search.val();

            this.trigger("query", {
              term: input,
            });
          }

          this._keyUpPrevented = false;
        };

        Search.prototype.showSearch = function (_, params) {
          return true;
        };

        return Search;
      }
    );

    S2.define("select2/dropdown/hidePlaceholder", [], function () {
      function HidePlaceholder(decorated, $element, options, dataAdapter) {
        this.placeholder = this.normalizePlaceholder(
          options.get("placeholder")
        );

        decorated.call(this, $element, options, dataAdapter);
      }

      HidePlaceholder.prototype.append = function (decorated, data) {
        data.results = this.removePlaceholder(data.results);

        decorated.call(this, data);
      };

      HidePlaceholder.prototype.normalizePlaceholder = function (
        _,
        placeholder
      ) {
        if (typeof placeholder === "string") {
          placeholder = {
            id: "",
            text: placeholder,
          };
        }

        return placeholder;
      };

      HidePlaceholder.prototype.removePlaceholder = function (_, data) {
        var modifiedData = data.slice(0);

        for (var d = data.length - 1; d >= 0; d--) {
          var item = data[d];

          if (this.placeholder.id === item.id) {
            modifiedData.splice(d, 1);
          }
        }

        return modifiedData;
      };

      return HidePlaceholder;
    });

    S2.define("select2/dropdown/infiniteScroll", ["jquery"], function ($) {
      function InfiniteScroll(decorated, $element, options, dataAdapter) {
        this.lastParams = {};

        decorated.call(this, $element, options, dataAdapter);

        this.$loadingMore = this.createLoadingMore();
        this.loading = false;
      }

      InfiniteScroll.prototype.append = function (decorated, data) {
        this.$loadingMore.remove();
        this.loading = false;

        decorated.call(this, data);

        if (this.showLoadingMore(data)) {
          this.$results.append(this.$loadingMore);
        }
      };

      InfiniteScroll.prototype.bind = function (
        decorated,
        container,
        $container
      ) {
        var self = this;

        decorated.call(this, container, $container);

        container.on("query", function (params) {
          self.lastParams = params;
          self.loading = true;
        });

        container.on("query:append", function (params) {
          self.lastParams = params;
          self.loading = true;
        });

        this.$results.on("scroll", function () {
          var isLoadMoreVisible = $.contains(
            document.documentElement,
            self.$loadingMore[0]
          );

          if (self.loading || !isLoadMoreVisible) {
            return;
          }

          var currentOffset =
            self.$results.offset().top + self.$results.outerHeight(false);
          var loadingMoreOffset =
            self.$loadingMore.offset().top +
            self.$loadingMore.outerHeight(false);

          if (currentOffset + 50 >= loadingMoreOffset) {
            self.loadMore();
          }
        });
      };

      InfiniteScroll.prototype.loadMore = function () {
        this.loading = true;

        var params = $.extend({}, { page: 1 }, this.lastParams);

        params.page++;

        this.trigger("query:append", params);
      };

      InfiniteScroll.prototype.showLoadingMore = function (_, data) {
        return data.pagination && data.pagination.more;
      };

      InfiniteScroll.prototype.createLoadingMore = function () {
        var $option = $(
          "<li " +
            'class="select2-results__option select2-results__option--load-more"' +
            'role="treeitem" aria-disabled="true"></li>'
        );

        var message = this.options.get("translations").get("loadingMore");

        $option.html(message(this.lastParams));

        return $option;
      };

      return InfiniteScroll;
    });

    S2.define(
      "select2/dropdown/attachBody",
      ["jquery", "../utils"],
      function ($, Utils) {
        function AttachBody(decorated, $element, options) {
          this.$dropdownParent =
            options.get("dropdownParent") || $(document.body);

          decorated.call(this, $element, options);
        }

        AttachBody.prototype.bind = function (
          decorated,
          container,
          $container
        ) {
          var self = this;

          var setupResultsEvents = false;

          decorated.call(this, container, $container);

          container.on("open", function () {
            self._showDropdown();
            self._attachPositioningHandler(container);

            if (!setupResultsEvents) {
              setupResultsEvents = true;

              container.on("results:all", function () {
                self._positionDropdown();
                self._resizeDropdown();
              });

              container.on("results:append", function () {
                self._positionDropdown();
                self._resizeDropdown();
              });
            }
          });

          container.on("close", function () {
            self._hideDropdown();
            self._detachPositioningHandler(container);
          });

          this.$dropdownContainer.on("mousedown", function (evt) {
            evt.stopPropagation();
          });
        };

        AttachBody.prototype.destroy = function (decorated) {
          decorated.call(this);

          this.$dropdownContainer.remove();
        };

        AttachBody.prototype.position = function (
          decorated,
          $dropdown,
          $container
        ) {
          // Clone all of the container classes
          $dropdown.attr("class", $container.attr("class"));

          $dropdown.removeClass("select2");
          $dropdown.addClass("select2-container--open");

          $dropdown.css({
            position: "absolute",
            top: -999999,
          });

          this.$container = $container;
        };

        AttachBody.prototype.render = function (decorated) {
          var $container = $("<span></span>");

          var $dropdown = decorated.call(this);
          $container.append($dropdown);

          this.$dropdownContainer = $container;

          return $container;
        };

        AttachBody.prototype._hideDropdown = function (decorated) {
          this.$dropdownContainer.detach();
        };

        AttachBody.prototype._attachPositioningHandler = function (
          decorated,
          container
        ) {
          var self = this;

          var scrollEvent = "scroll.select2." + container.id;
          var resizeEvent = "resize.select2." + container.id;
          var orientationEvent = "orientationchange.select2." + container.id;

          var $watchers = this.$container.parents().filter(Utils.hasScroll);
          $watchers.each(function () {
            $(this).data("select2-scroll-position", {
              x: $(this).scrollLeft(),
              y: $(this).scrollTop(),
            });
          });

          $watchers.on(scrollEvent, function (ev) {
            var position = $(this).data("select2-scroll-position");
            $(this).scrollTop(position.y);
          });

          $(window).on(
            scrollEvent + " " + resizeEvent + " " + orientationEvent,
            function (e) {
              self._positionDropdown();
              self._resizeDropdown();
            }
          );
        };

        AttachBody.prototype._detachPositioningHandler = function (
          decorated,
          container
        ) {
          var scrollEvent = "scroll.select2." + container.id;
          var resizeEvent = "resize.select2." + container.id;
          var orientationEvent = "orientationchange.select2." + container.id;

          var $watchers = this.$container.parents().filter(Utils.hasScroll);
          $watchers.off(scrollEvent);

          $(window).off(
            scrollEvent + " " + resizeEvent + " " + orientationEvent
          );
        };

        AttachBody.prototype._positionDropdown = function () {
          var $window = $(window);

          var isCurrentlyAbove = this.$dropdown.hasClass(
            "select2-dropdown--above"
          );
          var isCurrentlyBelow = this.$dropdown.hasClass(
            "select2-dropdown--below"
          );

          var newDirection = null;

          var offset = this.$container.offset();

          offset.bottom = offset.top + this.$container.outerHeight(false);

          var container = {
            height: this.$container.outerHeight(false),
          };

          container.top = offset.top;
          container.bottom = offset.top + container.height;

          var dropdown = {
            height: this.$dropdown.outerHeight(false),
          };

          var viewport = {
            top: $window.scrollTop(),
            bottom: $window.scrollTop() + $window.height(),
          };

          var enoughRoomAbove = viewport.top < offset.top - dropdown.height;
          var enoughRoomBelow =
            viewport.bottom > offset.bottom + dropdown.height;

          var css = {
            left: offset.left,
            top: container.bottom,
          };

          // Determine what the parent element is to use for calciulating the offset
          var $offsetParent = this.$dropdownParent;

          // For statically positoned elements, we need to get the element
          // that is determining the offset
          if ($offsetParent.css("position") === "static") {
            $offsetParent = $offsetParent.offsetParent();
          }

          var parentOffset = $offsetParent.offset();

          css.top -= parentOffset.top;
          css.left -= parentOffset.left;

          if (!isCurrentlyAbove && !isCurrentlyBelow) {
            newDirection = "below";
          }

          if (!enoughRoomBelow && enoughRoomAbove && !isCurrentlyAbove) {
            newDirection = "above";
          } else if (!enoughRoomAbove && enoughRoomBelow && isCurrentlyAbove) {
            newDirection = "below";
          }

          if (
            newDirection == "above" ||
            (isCurrentlyAbove && newDirection !== "below")
          ) {
            css.top = container.top - parentOffset.top - dropdown.height;
          }

          if (newDirection != null) {
            this.$dropdown
              .removeClass("select2-dropdown--below select2-dropdown--above")
              .addClass("select2-dropdown--" + newDirection);
            this.$container
              .removeClass("select2-container--below select2-container--above")
              .addClass("select2-container--" + newDirection);
          }

          this.$dropdownContainer.css(css);
        };

        AttachBody.prototype._resizeDropdown = function () {
          var css = {
            width: this.$container.outerWidth(false) + "px",
          };

          if (this.options.get("dropdownAutoWidth")) {
            css.minWidth = css.width;
            css.position = "relative";
            css.width = "auto";
          }

          this.$dropdown.css(css);
        };

        AttachBody.prototype._showDropdown = function (decorated) {
          this.$dropdownContainer.appendTo(this.$dropdownParent);

          this._positionDropdown();
          this._resizeDropdown();
        };

        return AttachBody;
      }
    );

    S2.define("select2/dropdown/minimumResultsForSearch", [], function () {
      function countResults(data) {
        var count = 0;

        for (var d = 0; d < data.length; d++) {
          var item = data[d];

          if (item.children) {
            count += countResults(item.children);
          } else {
            count++;
          }
        }

        return count;
      }

      function MinimumResultsForSearch(
        decorated,
        $element,
        options,
        dataAdapter
      ) {
        this.minimumResultsForSearch = options.get("minimumResultsForSearch");

        if (this.minimumResultsForSearch < 0) {
          this.minimumResultsForSearch = Infinity;
        }

        decorated.call(this, $element, options, dataAdapter);
      }

      MinimumResultsForSearch.prototype.showSearch = function (
        decorated,
        params
      ) {
        if (countResults(params.data.results) < this.minimumResultsForSearch) {
          return false;
        }

        return decorated.call(this, params);
      };

      return MinimumResultsForSearch;
    });

    S2.define("select2/dropdown/selectOnClose", [], function () {
      function SelectOnClose() {}

      SelectOnClose.prototype.bind = function (
        decorated,
        container,
        $container
      ) {
        var self = this;

        decorated.call(this, container, $container);

        container.on("close", function (params) {
          self._handleSelectOnClose(params);
        });
      };

      SelectOnClose.prototype._handleSelectOnClose = function (_, params) {
        if (params && params.originalSelect2Event != null) {
          var event = params.originalSelect2Event;

          // Don't select an item if the close event was triggered from a select or
          // unselect event
          if (event._type === "select" || event._type === "unselect") {
            return;
          }
        }

        var $highlightedResults = this.getHighlightedResults();

        // Only select highlighted results
        if ($highlightedResults.length < 1) {
          return;
        }

        var data = $highlightedResults.data("data");

        // Don't re-select already selected resulte
        if (
          (data.element != null && data.element.selected) ||
          (data.element == null && data.selected)
        ) {
          return;
        }

        this.trigger("select", {
          data: data,
        });
      };

      return SelectOnClose;
    });

    S2.define("select2/dropdown/closeOnSelect", [], function () {
      function CloseOnSelect() {}

      CloseOnSelect.prototype.bind = function (
        decorated,
        container,
        $container
      ) {
        var self = this;

        decorated.call(this, container, $container);

        container.on("select", function (evt) {
          self._selectTriggered(evt);
        });

        container.on("unselect", function (evt) {
          self._selectTriggered(evt);
        });
      };

      CloseOnSelect.prototype._selectTriggered = function (_, evt) {
        var originalEvent = evt.originalEvent;

        // Don't close if the control key is being held
        if (originalEvent && originalEvent.ctrlKey) {
          return;
        }

        this.trigger("close", {
          originalEvent: originalEvent,
          originalSelect2Event: evt,
        });
      };

      return CloseOnSelect;
    });

    S2.define("select2/i18n/en", [], function () {
      // English
      return {
        errorLoading: function () {
          return "The results could not be loaded.";
        },
        inputTooLong: function (args) {
          var overChars = args.input.length - args.maximum;

          var message = "Please delete " + overChars + " character";

          if (overChars != 1) {
            message += "s";
          }

          return message;
        },
        inputTooShort: function (args) {
          var remainingChars = args.minimum - args.input.length;

          var message =
            "Please enter " + remainingChars + " or more characters";

          return message;
        },
        loadingMore: function () {
          return "Loading more results…";
        },
        maximumSelected: function (args) {
          var message = "You can only select " + args.maximum + " item";

          if (args.maximum != 1) {
            message += "s";
          }

          return message;
        },
        noResults: function () {
          return "No results found";
        },
        searching: function () {
          return "Searching…";
        },
      };
    });

    S2.define(
      "select2/defaults",
      [
        "jquery",
        "require",

        "./results",

        "./selection/single",
        "./selection/multiple",
        "./selection/placeholder",
        "./selection/allowClear",
        "./selection/search",
        "./selection/eventRelay",

        "./utils",
        "./translation",
        "./diacritics",

        "./data/select",
        "./data/array",
        "./data/ajax",
        "./data/tags",
        "./data/tokenizer",
        "./data/minimumInputLength",
        "./data/maximumInputLength",
        "./data/maximumSelectionLength",

        "./dropdown",
        "./dropdown/search",
        "./dropdown/hidePlaceholder",
        "./dropdown/infiniteScroll",
        "./dropdown/attachBody",
        "./dropdown/minimumResultsForSearch",
        "./dropdown/selectOnClose",
        "./dropdown/closeOnSelect",

        "./i18n/en",
      ],
      function (
        $,
        require,

        ResultsList,

        SingleSelection,
        MultipleSelection,
        Placeholder,
        AllowClear,
        SelectionSearch,
        EventRelay,

        Utils,
        Translation,
        DIACRITICS,

        SelectData,
        ArrayData,
        AjaxData,
        Tags,
        Tokenizer,
        MinimumInputLength,
        MaximumInputLength,
        MaximumSelectionLength,

        Dropdown,
        DropdownSearch,
        HidePlaceholder,
        InfiniteScroll,
        AttachBody,
        MinimumResultsForSearch,
        SelectOnClose,
        CloseOnSelect,

        EnglishTranslation
      ) {
        function Defaults() {
          this.reset();
        }

        Defaults.prototype.apply = function (options) {
          options = $.extend(true, {}, this.defaults, options);

          if (options.dataAdapter == null) {
            if (options.ajax != null) {
              options.dataAdapter = AjaxData;
            } else if (options.data != null) {
              options.dataAdapter = ArrayData;
            } else {
              options.dataAdapter = SelectData;
            }

            if (options.minimumInputLength > 0) {
              options.dataAdapter = Utils.Decorate(
                options.dataAdapter,
                MinimumInputLength
              );
            }

            if (options.maximumInputLength > 0) {
              options.dataAdapter = Utils.Decorate(
                options.dataAdapter,
                MaximumInputLength
              );
            }

            if (options.maximumSelectionLength > 0) {
              options.dataAdapter = Utils.Decorate(
                options.dataAdapter,
                MaximumSelectionLength
              );
            }

            if (options.tags) {
              options.dataAdapter = Utils.Decorate(options.dataAdapter, Tags);
            }

            if (options.tokenSeparators != null || options.tokenizer != null) {
              options.dataAdapter = Utils.Decorate(
                options.dataAdapter,
                Tokenizer
              );
            }

            if (options.query != null) {
              var Query = require(options.amdBase + "compat/query");

              options.dataAdapter = Utils.Decorate(options.dataAdapter, Query);
            }

            if (options.initSelection != null) {
              var InitSelection = require(options.amdBase +
                "compat/initSelection");

              options.dataAdapter = Utils.Decorate(
                options.dataAdapter,
                InitSelection
              );
            }
          }

          if (options.resultsAdapter == null) {
            options.resultsAdapter = ResultsList;

            if (options.ajax != null) {
              options.resultsAdapter = Utils.Decorate(
                options.resultsAdapter,
                InfiniteScroll
              );
            }

            if (options.placeholder != null) {
              options.resultsAdapter = Utils.Decorate(
                options.resultsAdapter,
                HidePlaceholder
              );
            }

            if (options.selectOnClose) {
              options.resultsAdapter = Utils.Decorate(
                options.resultsAdapter,
                SelectOnClose
              );
            }
          }

          if (options.dropdownAdapter == null) {
            if (options.multiple) {
              options.dropdownAdapter = Dropdown;
            } else {
              var SearchableDropdown = Utils.Decorate(Dropdown, DropdownSearch);

              options.dropdownAdapter = SearchableDropdown;
            }

            if (options.minimumResultsForSearch !== 0) {
              options.dropdownAdapter = Utils.Decorate(
                options.dropdownAdapter,
                MinimumResultsForSearch
              );
            }

            if (options.closeOnSelect) {
              options.dropdownAdapter = Utils.Decorate(
                options.dropdownAdapter,
                CloseOnSelect
              );
            }

            if (
              options.dropdownCssClass != null ||
              options.dropdownCss != null ||
              options.adaptDropdownCssClass != null
            ) {
              var DropdownCSS = require(options.amdBase + "compat/dropdownCss");

              options.dropdownAdapter = Utils.Decorate(
                options.dropdownAdapter,
                DropdownCSS
              );
            }

            options.dropdownAdapter = Utils.Decorate(
              options.dropdownAdapter,
              AttachBody
            );
          }

          if (options.selectionAdapter == null) {
            if (options.multiple) {
              options.selectionAdapter = MultipleSelection;
            } else {
              options.selectionAdapter = SingleSelection;
            }

            // Add the placeholder mixin if a placeholder was specified
            if (options.placeholder != null) {
              options.selectionAdapter = Utils.Decorate(
                options.selectionAdapter,
                Placeholder
              );
            }

            if (options.allowClear) {
              options.selectionAdapter = Utils.Decorate(
                options.selectionAdapter,
                AllowClear
              );
            }

            if (options.multiple) {
              options.selectionAdapter = Utils.Decorate(
                options.selectionAdapter,
                SelectionSearch
              );
            }

            if (
              options.containerCssClass != null ||
              options.containerCss != null ||
              options.adaptContainerCssClass != null
            ) {
              var ContainerCSS = require(options.amdBase +
                "compat/containerCss");

              options.selectionAdapter = Utils.Decorate(
                options.selectionAdapter,
                ContainerCSS
              );
            }

            options.selectionAdapter = Utils.Decorate(
              options.selectionAdapter,
              EventRelay
            );
          }

          if (typeof options.language === "string") {
            // Check if the language is specified with a region
            if (options.language.indexOf("-") > 0) {
              // Extract the region information if it is included
              var languageParts = options.language.split("-");
              var baseLanguage = languageParts[0];

              options.language = [options.language, baseLanguage];
            } else {
              options.language = [options.language];
            }
          }

          if ($.isArray(options.language)) {
            var languages = new Translation();
            options.language.push("en");

            var languageNames = options.language;

            for (var l = 0; l < languageNames.length; l++) {
              var name = languageNames[l];
              var language = {};

              try {
                // Try to load it with the original name
                language = Translation.loadPath(name);
              } catch (e) {
                try {
                  // If we couldn't load it, check if it wasn't the full path
                  name = this.defaults.amdLanguageBase + name;
                  language = Translation.loadPath(name);
                } catch (ex) {
                  // The translation could not be loaded at all. Sometimes this is
                  // because of a configuration problem, other times this can be
                  // because of how Select2 helps load all possible translation files.
                  if (options.debug && window.console && console.warn) {
                    console.warn(
                      'Select2: The language file for "' +
                        name +
                        '" could not be ' +
                        "automatically loaded. A fallback will be used instead."
                    );
                  }

                  continue;
                }
              }

              languages.extend(language);
            }

            options.translations = languages;
          } else {
            var baseTranslation = Translation.loadPath(
              this.defaults.amdLanguageBase + "en"
            );
            var customTranslation = new Translation(options.language);

            customTranslation.extend(baseTranslation);

            options.translations = customTranslation;
          }

          return options;
        };

        Defaults.prototype.reset = function () {
          function stripDiacritics(text) {
            // Used 'uni range + named function' from http://jsperf.com/diacritics/18
            function match(a) {
              return DIACRITICS[a] || a;
            }

            return text.replace(/[^\u0000-\u007E]/g, match);
          }

          function matcher(params, data) {
            // Always return the object if there is nothing to compare
            if ($.trim(params.term) === "") {
              return data;
            }

            // Do a recursive check for options with children
            if (data.children && data.children.length > 0) {
              // Clone the data object if there are children
              // This is required as we modify the object to remove any non-matches
              var match = $.extend(true, {}, data);

              // Check each child of the option
              for (var c = data.children.length - 1; c >= 0; c--) {
                var child = data.children[c];

                var matches = matcher(params, child);

                // If there wasn't a match, remove the object in the array
                if (matches == null) {
                  match.children.splice(c, 1);
                }
              }

              // If any children matched, return the new object
              if (match.children.length > 0) {
                return match;
              }

              // If there were no matching children, check just the plain object
              return matcher(params, match);
            }

            var original = stripDiacritics(data.text).toUpperCase();
            var term = stripDiacritics(params.term).toUpperCase();

            // Check if the text contains the term
            if (original.indexOf(term) > -1) {
              return data;
            }

            // If it doesn't contain the term, don't return anything
            return null;
          }

          this.defaults = {
            amdBase: "./",
            amdLanguageBase: "./i18n/",
            closeOnSelect: true,
            debug: false,
            dropdownAutoWidth: false,
            escapeMarkup: Utils.escapeMarkup,
            language: EnglishTranslation,
            matcher: matcher,
            minimumInputLength: 0,
            maximumInputLength: 0,
            maximumSelectionLength: 0,
            minimumResultsForSearch: 0,
            selectOnClose: false,
            sorter: function (data) {
              return data;
            },
            templateResult: function (result) {
              return result.text;
            },
            templateSelection: function (selection) {
              return selection.text;
            },
            theme: "default",
            width: "resolve",
          };
        };

        Defaults.prototype.set = function (key, value) {
          var camelKey = $.camelCase(key);

          var data = {};
          data[camelKey] = value;

          var convertedData = Utils._convertData(data);

          $.extend(this.defaults, convertedData);
        };

        var defaults = new Defaults();

        return defaults;
      }
    );

    S2.define(
      "select2/options",
      ["require", "jquery", "./defaults", "./utils"],
      function (require, $, Defaults, Utils) {
        function Options(options, $element) {
          this.options = options;

          if ($element != null) {
            this.fromElement($element);
          }

          this.options = Defaults.apply(this.options);

          if ($element && $element.is("input")) {
            var InputCompat = require(this.get("amdBase") + "compat/inputData");

            this.options.dataAdapter = Utils.Decorate(
              this.options.dataAdapter,
              InputCompat
            );
          }
        }

        Options.prototype.fromElement = function ($e) {
          var excludedData = ["select2"];

          if (this.options.multiple == null) {
            this.options.multiple = $e.prop("multiple");
          }

          if (this.options.disabled == null) {
            this.options.disabled = $e.prop("disabled");
          }

          if (this.options.language == null) {
            if ($e.prop("lang")) {
              this.options.language = $e.prop("lang").toLowerCase();
            } else if ($e.closest("[lang]").prop("lang")) {
              this.options.language = $e.closest("[lang]").prop("lang");
            }
          }

          if (this.options.dir == null) {
            if ($e.prop("dir")) {
              this.options.dir = $e.prop("dir");
            } else if ($e.closest("[dir]").prop("dir")) {
              this.options.dir = $e.closest("[dir]").prop("dir");
            } else {
              this.options.dir = "ltr";
            }
          }

          $e.prop("disabled", this.options.disabled);
          $e.prop("multiple", this.options.multiple);

          if ($e.data("select2Tags")) {
            if (this.options.debug && window.console && console.warn) {
              console.warn(
                "Select2: The `data-select2-tags` attribute has been changed to " +
                  'use the `data-data` and `data-tags="true"` attributes and will be ' +
                  "removed in future versions of Select2."
              );
            }

            $e.data("data", $e.data("select2Tags"));
            $e.data("tags", true);
          }

          if ($e.data("ajaxUrl")) {
            if (this.options.debug && window.console && console.warn) {
              console.warn(
                "Select2: The `data-ajax-url` attribute has been changed to " +
                  "`data-ajax--url` and support for the old attribute will be removed" +
                  " in future versions of Select2."
              );
            }

            $e.attr("ajax--url", $e.data("ajaxUrl"));
            $e.data("ajax--url", $e.data("ajaxUrl"));
          }

          var dataset = {};

          // Prefer the element's `dataset` attribute if it exists
          // jQuery 1.x does not correctly handle data attributes with multiple dashes
          if (
            $.fn.jquery &&
            $.fn.jquery.substr(0, 2) == "1." &&
            $e[0].dataset
          ) {
            dataset = $.extend(true, {}, $e[0].dataset, $e.data());
          } else {
            dataset = $e.data();
          }

          var data = $.extend(true, {}, dataset);

          data = Utils._convertData(data);

          for (var key in data) {
            if ($.inArray(key, excludedData) > -1) {
              continue;
            }

            if ($.isPlainObject(this.options[key])) {
              $.extend(this.options[key], data[key]);
            } else {
              this.options[key] = data[key];
            }
          }

          return this;
        };

        Options.prototype.get = function (key) {
          return this.options[key];
        };

        Options.prototype.set = function (key, val) {
          this.options[key] = val;
        };

        return Options;
      }
    );

    S2.define(
      "select2/core",
      ["jquery", "./options", "./utils", "./keys"],
      function ($, Options, Utils, KEYS) {
        var Select2 = function ($element, options) {
          if ($element.data("select2") != null) {
            $element.data("select2").destroy();
          }

          this.$element = $element;

          this.id = this._generateId($element);

          options = options || {};

          this.options = new Options(options, $element);

          Select2.__super__.constructor.call(this);

          // Set up the tabindex

          var tabindex = $element.attr("tabindex") || 0;
          $element.data("old-tabindex", tabindex);
          $element.attr("tabindex", "-1");

          // Set up containers and adapters

          var DataAdapter = this.options.get("dataAdapter");
          this.dataAdapter = new DataAdapter($element, this.options);

          var $container = this.render();

          this._placeContainer($container);

          var SelectionAdapter = this.options.get("selectionAdapter");
          this.selection = new SelectionAdapter($element, this.options);
          this.$selection = this.selection.render();

          this.selection.position(this.$selection, $container);

          var DropdownAdapter = this.options.get("dropdownAdapter");
          this.dropdown = new DropdownAdapter($element, this.options);
          this.$dropdown = this.dropdown.render();

          this.dropdown.position(this.$dropdown, $container);

          var ResultsAdapter = this.options.get("resultsAdapter");
          this.results = new ResultsAdapter(
            $element,
            this.options,
            this.dataAdapter
          );
          this.$results = this.results.render();

          this.results.position(this.$results, this.$dropdown);

          // Bind events

          var self = this;

          // Bind the container to all of the adapters
          this._bindAdapters();

          // Register any DOM event handlers
          this._registerDomEvents();

          // Register any internal event handlers
          this._registerDataEvents();
          this._registerSelectionEvents();
          this._registerDropdownEvents();
          this._registerResultsEvents();
          this._registerEvents();

          // Set the initial state
          this.dataAdapter.current(function (initialData) {
            self.trigger("selection:update", {
              data: initialData,
            });
          });

          // Hide the original select
          $element.addClass("select2-hidden-accessible");
          $element.attr("aria-hidden", "true");

          // Synchronize any monitored attributes
          this._syncAttributes();

          $element.data("select2", this);
        };

        Utils.Extend(Select2, Utils.Observable);

        Select2.prototype._generateId = function ($element) {
          var id = "";

          if ($element.attr("id") != null) {
            id = $element.attr("id");
          } else if ($element.attr("name") != null) {
            id = $element.attr("name") + "-" + Utils.generateChars(2);
          } else {
            id = Utils.generateChars(4);
          }

          id = id.replace(/(:|\.|\[|\]|,)/g, "");
          id = "select2-" + id;

          return id;
        };

        Select2.prototype._placeContainer = function ($container) {
          $container.insertAfter(this.$element);

          var width = this._resolveWidth(
            this.$element,
            this.options.get("width")
          );

          if (width != null) {
            $container.css("width", width);
          }
        };

        Select2.prototype._resolveWidth = function ($element, method) {
          var WIDTH =
            /^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;

          if (method == "resolve") {
            var styleWidth = this._resolveWidth($element, "style");

            if (styleWidth != null) {
              return styleWidth;
            }

            return this._resolveWidth($element, "element");
          }

          if (method == "element") {
            var elementWidth = $element.outerWidth(false);

            if (elementWidth <= 0) {
              return "auto";
            }

            return elementWidth + "px";
          }

          if (method == "style") {
            var style = $element.attr("style");

            if (typeof style !== "string") {
              return null;
            }

            var attrs = style.split(";");

            for (var i = 0, l = attrs.length; i < l; i = i + 1) {
              var attr = attrs[i].replace(/\s/g, "");
              var matches = attr.match(WIDTH);

              if (matches !== null && matches.length >= 1) {
                return matches[1];
              }
            }

            return null;
          }

          return method;
        };

        Select2.prototype._bindAdapters = function () {
          this.dataAdapter.bind(this, this.$container);
          this.selection.bind(this, this.$container);

          this.dropdown.bind(this, this.$container);
          this.results.bind(this, this.$container);
        };

        Select2.prototype._registerDomEvents = function () {
          var self = this;

          this.$element.on("change.select2", function () {
            self.dataAdapter.current(function (data) {
              self.trigger("selection:update", {
                data: data,
              });
            });
          });

          this.$element.on("focus.select2", function (evt) {
            self.trigger("focus", evt);
          });

          this._syncA = Utils.bind(this._syncAttributes, this);
          this._syncS = Utils.bind(this._syncSubtree, this);

          if (this.$element[0].attachEvent) {
            this.$element[0].attachEvent("onpropertychange", this._syncA);
          }

          var observer =
            window.MutationObserver ||
            window.WebKitMutationObserver ||
            window.MozMutationObserver;
          if (observer != null) {
            this._observer = new observer(function (mutations) {
              $.each(mutations, self._syncA);
              $.each(mutations, self._syncS);
            });
            this._observer.observe(this.$element[0], {
              attributes: true,
              childList: true,
              subtree: false,
            });
          } else if (this.$element[0].addEventListener) {
            this.$element[0].addEventListener(
              "DOMAttrModified",
              self._syncA,
              false
            );
            this.$element[0].addEventListener(
              "DOMNodeInserted",
              self._syncS,
              false
            );
            this.$element[0].addEventListener(
              "DOMNodeRemoved",
              self._syncS,
              false
            );
          }
        };

        Select2.prototype._registerDataEvents = function () {
          var self = this;

          this.dataAdapter.on("*", function (name, params) {
            self.trigger(name, params);
          });
        };

        Select2.prototype._registerSelectionEvents = function () {
          var self = this;
          var nonRelayEvents = ["toggle", "focus"];

          this.selection.on("toggle", function () {
            self.toggleDropdown();
          });

          this.selection.on("focus", function (params) {
            self.focus(params);
          });

          this.selection.on("*", function (name, params) {
            if ($.inArray(name, nonRelayEvents) !== -1) {
              return;
            }

            self.trigger(name, params);
          });
        };

        Select2.prototype._registerDropdownEvents = function () {
          var self = this;

          this.dropdown.on("*", function (name, params) {
            self.trigger(name, params);
          });
        };

        Select2.prototype._registerResultsEvents = function () {
          var self = this;

          this.results.on("*", function (name, params) {
            self.trigger(name, params);
          });
        };

        Select2.prototype._registerEvents = function () {
          var self = this;

          this.on("open", function () {
            self.$container.addClass("select2-container--open");
          });

          this.on("close", function () {
            self.$container.removeClass("select2-container--open");
          });

          this.on("enable", function () {
            self.$container.removeClass("select2-container--disabled");
          });

          this.on("disable", function () {
            self.$container.addClass("select2-container--disabled");
          });

          this.on("blur", function () {
            self.$container.removeClass("select2-container--focus");
          });

          this.on("query", function (params) {
            if (!self.isOpen()) {
              self.trigger("open", {});
            }

            this.dataAdapter.query(params, function (data) {
              self.trigger("results:all", {
                data: data,
                query: params,
              });
            });
          });

          this.on("query:append", function (params) {
            this.dataAdapter.query(params, function (data) {
              self.trigger("results:append", {
                data: data,
                query: params,
              });
            });
          });

          this.on("keypress", function (evt) {
            var key = evt.which;

            if (self.isOpen()) {
              if (
                key === KEYS.ESC ||
                key === KEYS.TAB ||
                (key === KEYS.UP && evt.altKey)
              ) {
                self.close();

                evt.preventDefault();
              } else if (key === KEYS.ENTER) {
                self.trigger("results:select", {});

                evt.preventDefault();
              } else if (key === KEYS.SPACE && evt.ctrlKey) {
                self.trigger("results:toggle", {});

                evt.preventDefault();
              } else if (key === KEYS.UP) {
                self.trigger("results:previous", {});

                evt.preventDefault();
              } else if (key === KEYS.DOWN) {
                self.trigger("results:next", {});

                evt.preventDefault();
              }
            } else {
              if (
                key === KEYS.ENTER ||
                key === KEYS.SPACE ||
                (key === KEYS.DOWN && evt.altKey)
              ) {
                self.open();

                evt.preventDefault();
              }
            }
          });
        };

        Select2.prototype._syncAttributes = function () {
          this.options.set("disabled", this.$element.prop("disabled"));

          if (this.options.get("disabled")) {
            if (this.isOpen()) {
              this.close();
            }

            this.trigger("disable", {});
          } else {
            this.trigger("enable", {});
          }
        };

        Select2.prototype._syncSubtree = function (evt, mutations) {
          var changed = false;
          var self = this;

          // Ignore any mutation events raised for elements that aren't options or
          // optgroups. This handles the case when the select element is destroyed
          if (
            evt &&
            evt.target &&
            evt.target.nodeName !== "OPTION" &&
            evt.target.nodeName !== "OPTGROUP"
          ) {
            return;
          }

          if (!mutations) {
            // If mutation events aren't supported, then we can only assume that the
            // change affected the selections
            changed = true;
          } else if (mutations.addedNodes && mutations.addedNodes.length > 0) {
            for (var n = 0; n < mutations.addedNodes.length; n++) {
              var node = mutations.addedNodes[n];

              if (node.selected) {
                changed = true;
              }
            }
          } else if (
            mutations.removedNodes &&
            mutations.removedNodes.length > 0
          ) {
            changed = true;
          }

          // Only re-pull the data if we think there is a change
          if (changed) {
            this.dataAdapter.current(function (currentData) {
              self.trigger("selection:update", {
                data: currentData,
              });
            });
          }
        };

        /**
         * Override the trigger method to automatically trigger pre-events when
         * there are events that can be prevented.
         */
        Select2.prototype.trigger = function (name, args) {
          var actualTrigger = Select2.__super__.trigger;
          var preTriggerMap = {
            open: "opening",
            close: "closing",
            select: "selecting",
            unselect: "unselecting",
          };

          if (args === undefined) {
            args = {};
          }

          if (name in preTriggerMap) {
            var preTriggerName = preTriggerMap[name];
            var preTriggerArgs = {
              prevented: false,
              name: name,
              args: args,
            };

            actualTrigger.call(this, preTriggerName, preTriggerArgs);

            if (preTriggerArgs.prevented) {
              args.prevented = true;

              return;
            }
          }

          actualTrigger.call(this, name, args);
        };

        Select2.prototype.toggleDropdown = function () {
          if (this.options.get("disabled")) {
            return;
          }

          if (this.isOpen()) {
            this.close();
          } else {
            this.open();
          }
        };

        Select2.prototype.open = function () {
          if (this.isOpen()) {
            return;
          }

          this.trigger("query", {});
        };

        Select2.prototype.close = function () {
          if (!this.isOpen()) {
            return;
          }

          this.trigger("close", {});
        };

        Select2.prototype.isOpen = function () {
          return this.$container.hasClass("select2-container--open");
        };

        Select2.prototype.hasFocus = function () {
          return this.$container.hasClass("select2-container--focus");
        };

        Select2.prototype.focus = function (data) {
          // No need to re-trigger focus events if we are already focused
          if (this.hasFocus()) {
            return;
          }

          this.$container.addClass("select2-container--focus");
          this.trigger("focus", {});
        };

        Select2.prototype.enable = function (args) {
          if (this.options.get("debug") && window.console && console.warn) {
            console.warn(
              'Select2: The `select2("enable")` method has been deprecated and will' +
                ' be removed in later Select2 versions. Use $element.prop("disabled")' +
                " instead."
            );
          }

          if (args == null || args.length === 0) {
            args = [true];
          }

          var disabled = !args[0];

          this.$element.prop("disabled", disabled);
        };

        Select2.prototype.data = function () {
          if (
            this.options.get("debug") &&
            arguments.length > 0 &&
            window.console &&
            console.warn
          ) {
            console.warn(
              'Select2: Data can no longer be set using `select2("data")`. You ' +
                "should consider setting the value instead using `$element.val()`."
            );
          }

          var data = [];

          this.dataAdapter.current(function (currentData) {
            data = currentData;
          });

          return data;
        };

        Select2.prototype.val = function (args) {
          if (this.options.get("debug") && window.console && console.warn) {
            console.warn(
              'Select2: The `select2("val")` method has been deprecated and will be' +
                " removed in later Select2 versions. Use $element.val() instead."
            );
          }

          if (args == null || args.length === 0) {
            return this.$element.val();
          }

          var newVal = args[0];

          if ($.isArray(newVal)) {
            newVal = $.map(newVal, function (obj) {
              return obj.toString();
            });
          }

          this.$element.val(newVal).trigger("change");
        };

        Select2.prototype.destroy = function () {
          this.$container.remove();

          if (this.$element[0].detachEvent) {
            this.$element[0].detachEvent("onpropertychange", this._syncA);
          }

          if (this._observer != null) {
            this._observer.disconnect();
            this._observer = null;
          } else if (this.$element[0].removeEventListener) {
            this.$element[0].removeEventListener(
              "DOMAttrModified",
              this._syncA,
              false
            );
            this.$element[0].removeEventListener(
              "DOMNodeInserted",
              this._syncS,
              false
            );
            this.$element[0].removeEventListener(
              "DOMNodeRemoved",
              this._syncS,
              false
            );
          }

          this._syncA = null;
          this._syncS = null;

          this.$element.off(".select2");
          this.$element.attr("tabindex", this.$element.data("old-tabindex"));

          this.$element.removeClass("select2-hidden-accessible");
          this.$element.attr("aria-hidden", "false");
          this.$element.removeData("select2");

          this.dataAdapter.destroy();
          this.selection.destroy();
          this.dropdown.destroy();
          this.results.destroy();

          this.dataAdapter = null;
          this.selection = null;
          this.dropdown = null;
          this.results = null;
        };

        Select2.prototype.render = function () {
          var $container = $(
            '<span class="select2 select2-container">' +
              '<span class="selection"></span>' +
              '<span class="dropdown-wrapper" aria-hidden="true"></span>' +
              "</span>"
          );

          $container.attr("dir", this.options.get("dir"));

          this.$container = $container;

          this.$container.addClass(
            "select2-container--" + this.options.get("theme")
          );

          $container.data("element", this.$element);

          return $container;
        };

        return Select2;
      }
    );

    S2.define("select2/compat/utils", ["jquery"], function ($) {
      function syncCssClasses($dest, $src, adapter) {
        var classes,
          replacements = [],
          adapted;

        classes = $.trim($dest.attr("class"));

        if (classes) {
          classes = "" + classes; // for IE which returns object

          $(classes.split(/\s+/)).each(function () {
            // Save all Select2 classes
            if (this.indexOf("select2-") === 0) {
              replacements.push(this);
            }
          });
        }

        classes = $.trim($src.attr("class"));

        if (classes) {
          classes = "" + classes; // for IE which returns object

          $(classes.split(/\s+/)).each(function () {
            // Only adapt non-Select2 classes
            if (this.indexOf("select2-") !== 0) {
              adapted = adapter(this);

              if (adapted != null) {
                replacements.push(adapted);
              }
            }
          });
        }

        $dest.attr("class", replacements.join(" "));
      }

      return {
        syncCssClasses: syncCssClasses,
      };
    });

    S2.define(
      "select2/compat/containerCss",
      ["jquery", "./utils"],
      function ($, CompatUtils) {
        // No-op CSS adapter that discards all classes by default
        function _containerAdapter(clazz) {
          return null;
        }

        function ContainerCSS() {}

        ContainerCSS.prototype.render = function (decorated) {
          var $container = decorated.call(this);

          var containerCssClass = this.options.get("containerCssClass") || "";

          if ($.isFunction(containerCssClass)) {
            containerCssClass = containerCssClass(this.$element);
          }

          var containerCssAdapter = this.options.get("adaptContainerCssClass");
          containerCssAdapter = containerCssAdapter || _containerAdapter;

          if (containerCssClass.indexOf(":all:") !== -1) {
            containerCssClass = containerCssClass.replace(":all:", "");

            var _cssAdapter = containerCssAdapter;

            containerCssAdapter = function (clazz) {
              var adapted = _cssAdapter(clazz);

              if (adapted != null) {
                // Append the old one along with the adapted one
                return adapted + " " + clazz;
              }

              return clazz;
            };
          }

          var containerCss = this.options.get("containerCss") || {};

          if ($.isFunction(containerCss)) {
            containerCss = containerCss(this.$element);
          }

          CompatUtils.syncCssClasses(
            $container,
            this.$element,
            containerCssAdapter
          );

          $container.css(containerCss);
          $container.addClass(containerCssClass);

          return $container;
        };

        return ContainerCSS;
      }
    );

    S2.define(
      "select2/compat/dropdownCss",
      ["jquery", "./utils"],
      function ($, CompatUtils) {
        // No-op CSS adapter that discards all classes by default
        function _dropdownAdapter(clazz) {
          return null;
        }

        function DropdownCSS() {}

        DropdownCSS.prototype.render = function (decorated) {
          var $dropdown = decorated.call(this);

          var dropdownCssClass = this.options.get("dropdownCssClass") || "";

          if ($.isFunction(dropdownCssClass)) {
            dropdownCssClass = dropdownCssClass(this.$element);
          }

          var dropdownCssAdapter = this.options.get("adaptDropdownCssClass");
          dropdownCssAdapter = dropdownCssAdapter || _dropdownAdapter;

          if (dropdownCssClass.indexOf(":all:") !== -1) {
            dropdownCssClass = dropdownCssClass.replace(":all:", "");

            var _cssAdapter = dropdownCssAdapter;

            dropdownCssAdapter = function (clazz) {
              var adapted = _cssAdapter(clazz);

              if (adapted != null) {
                // Append the old one along with the adapted one
                return adapted + " " + clazz;
              }

              return clazz;
            };
          }

          var dropdownCss = this.options.get("dropdownCss") || {};

          if ($.isFunction(dropdownCss)) {
            dropdownCss = dropdownCss(this.$element);
          }

          CompatUtils.syncCssClasses(
            $dropdown,
            this.$element,
            dropdownCssAdapter
          );

          $dropdown.css(dropdownCss);
          $dropdown.addClass(dropdownCssClass);

          return $dropdown;
        };

        return DropdownCSS;
      }
    );

    S2.define("select2/compat/initSelection", ["jquery"], function ($) {
      function InitSelection(decorated, $element, options) {
        if (options.get("debug") && window.console && console.warn) {
          console.warn(
            "Select2: The `initSelection` option has been deprecated in favor" +
              " of a custom data adapter that overrides the `current` method. " +
              "This method is now called multiple times instead of a single " +
              "time when the instance is initialized. Support will be removed " +
              "for the `initSelection` option in future versions of Select2"
          );
        }

        this.initSelection = options.get("initSelection");
        this._isInitialized = false;

        decorated.call(this, $element, options);
      }

      InitSelection.prototype.current = function (decorated, callback) {
        var self = this;

        if (this._isInitialized) {
          decorated.call(this, callback);

          return;
        }

        this.initSelection.call(null, this.$element, function (data) {
          self._isInitialized = true;

          if (!$.isArray(data)) {
            data = [data];
          }

          callback(data);
        });
      };

      return InitSelection;
    });

    S2.define("select2/compat/inputData", ["jquery"], function ($) {
      function InputData(decorated, $element, options) {
        this._currentData = [];
        this._valueSeparator = options.get("valueSeparator") || ",";

        if ($element.prop("type") === "hidden") {
          if (options.get("debug") && console && console.warn) {
            console.warn(
              "Select2: Using a hidden input with Select2 is no longer " +
                "supported and may stop working in the future. It is recommended " +
                "to use a `<select>` element instead."
            );
          }
        }

        decorated.call(this, $element, options);
      }

      InputData.prototype.current = function (_, callback) {
        function getSelected(data, selectedIds) {
          var selected = [];

          if (data.selected || $.inArray(data.id, selectedIds) !== -1) {
            data.selected = true;
            selected.push(data);
          } else {
            data.selected = false;
          }

          if (data.children) {
            selected.push.apply(
              selected,
              getSelected(data.children, selectedIds)
            );
          }

          return selected;
        }

        var selected = [];

        for (var d = 0; d < this._currentData.length; d++) {
          var data = this._currentData[d];

          selected.push.apply(
            selected,
            getSelected(data, this.$element.val().split(this._valueSeparator))
          );
        }

        callback(selected);
      };

      InputData.prototype.select = function (_, data) {
        if (!this.options.get("multiple")) {
          this.current(function (allData) {
            $.map(allData, function (data) {
              data.selected = false;
            });
          });

          this.$element.val(data.id);
          this.$element.trigger("change");
        } else {
          var value = this.$element.val();
          value += this._valueSeparator + data.id;

          this.$element.val(value);
          this.$element.trigger("change");
        }
      };

      InputData.prototype.unselect = function (_, data) {
        var self = this;

        data.selected = false;

        this.current(function (allData) {
          var values = [];

          for (var d = 0; d < allData.length; d++) {
            var item = allData[d];

            if (data.id == item.id) {
              continue;
            }

            values.push(item.id);
          }

          self.$element.val(values.join(self._valueSeparator));
          self.$element.trigger("change");
        });
      };

      InputData.prototype.query = function (_, params, callback) {
        var results = [];

        for (var d = 0; d < this._currentData.length; d++) {
          var data = this._currentData[d];

          var matches = this.matches(params, data);

          if (matches !== null) {
            results.push(matches);
          }
        }

        callback({
          results: results,
        });
      };

      InputData.prototype.addOptions = function (_, $options) {
        var options = $.map($options, function ($option) {
          return $.data($option[0], "data");
        });

        this._currentData.push.apply(this._currentData, options);
      };

      return InputData;
    });

    S2.define("select2/compat/matcher", ["jquery"], function ($) {
      function oldMatcher(matcher) {
        function wrappedMatcher(params, data) {
          var match = $.extend(true, {}, data);

          if (params.term == null || $.trim(params.term) === "") {
            return match;
          }

          if (data.children) {
            for (var c = data.children.length - 1; c >= 0; c--) {
              var child = data.children[c];

              // Check if the child object matches
              // The old matcher returned a boolean true or false
              var doesMatch = matcher(params.term, child.text, child);

              // If the child didn't match, pop it off
              if (!doesMatch) {
                match.children.splice(c, 1);
              }
            }

            if (match.children.length > 0) {
              return match;
            }
          }

          if (matcher(params.term, data.text, data)) {
            return match;
          }

          return null;
        }

        return wrappedMatcher;
      }

      return oldMatcher;
    });

    S2.define("select2/compat/query", [], function () {
      function Query(decorated, $element, options) {
        if (options.get("debug") && window.console && console.warn) {
          console.warn(
            "Select2: The `query` option has been deprecated in favor of a " +
              "custom data adapter that overrides the `query` method. Support " +
              "will be removed for the `query` option in future versions of " +
              "Select2."
          );
        }

        decorated.call(this, $element, options);
      }

      Query.prototype.query = function (_, params, callback) {
        params.callback = callback;

        var query = this.options.get("query");

        query.call(null, params);
      };

      return Query;
    });

    S2.define("select2/dropdown/attachContainer", [], function () {
      function AttachContainer(decorated, $element, options) {
        decorated.call(this, $element, options);
      }

      AttachContainer.prototype.position = function (
        decorated,
        $dropdown,
        $container
      ) {
        var $dropdownContainer = $container.find(".dropdown-wrapper");
        $dropdownContainer.append($dropdown);

        $dropdown.addClass("select2-dropdown--below");
        $container.addClass("select2-container--below");
      };

      return AttachContainer;
    });

    S2.define("select2/dropdown/stopPropagation", [], function () {
      function StopPropagation() {}

      StopPropagation.prototype.bind = function (
        decorated,
        container,
        $container
      ) {
        decorated.call(this, container, $container);

        var stoppedEvents = [
          "blur",
          "change",
          "click",
          "dblclick",
          "focus",
          "focusin",
          "focusout",
          "input",
          "keydown",
          "keyup",
          "keypress",
          "mousedown",
          "mouseenter",
          "mouseleave",
          "mousemove",
          "mouseover",
          "mouseup",
          "search",
          "touchend",
          "touchstart",
        ];

        this.$dropdown.on(stoppedEvents.join(" "), function (evt) {
          evt.stopPropagation();
        });
      };

      return StopPropagation;
    });

    S2.define("select2/selection/stopPropagation", [], function () {
      function StopPropagation() {}

      StopPropagation.prototype.bind = function (
        decorated,
        container,
        $container
      ) {
        decorated.call(this, container, $container);

        var stoppedEvents = [
          "blur",
          "change",
          "click",
          "dblclick",
          "focus",
          "focusin",
          "focusout",
          "input",
          "keydown",
          "keyup",
          "keypress",
          "mousedown",
          "mouseenter",
          "mouseleave",
          "mousemove",
          "mouseover",
          "mouseup",
          "search",
          "touchend",
          "touchstart",
        ];

        this.$selection.on(stoppedEvents.join(" "), function (evt) {
          evt.stopPropagation();
        });
      };

      return StopPropagation;
    });

    /*!
     * jQuery Mousewheel 3.1.13
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license
     * http://jquery.org/license
     */

    (function (factory) {
      if (typeof S2.define === "function" && S2.define.amd) {
        // AMD. Register as an anonymous module.
        S2.define("jquery-mousewheel", ["jquery"], factory);
      } else if (typeof exports === "object") {
        // Node/CommonJS style for Browserify
        module.exports = factory;
      } else {
        // Browser globals
        factory(jQuery);
      }
    })(function ($) {
      var toFix = [
          "wheel",
          "mousewheel",
          "DOMMouseScroll",
          "MozMousePixelScroll",
        ],
        toBind =
          "onwheel" in document || document.documentMode >= 9
            ? ["wheel"]
            : ["mousewheel", "DomMouseScroll", "MozMousePixelScroll"],
        slice = Array.prototype.slice,
        nullLowestDeltaTimeout,
        lowestDelta;

      if ($.event.fixHooks) {
        for (var i = toFix.length; i; ) {
          $.event.fixHooks[toFix[--i]] = $.event.mouseHooks;
        }
      }

      var special = ($.event.special.mousewheel = {
        version: "3.1.12",

        setup: function () {
          if (this.addEventListener) {
            for (var i = toBind.length; i; ) {
              this.addEventListener(toBind[--i], handler, false);
            }
          } else {
            this.onmousewheel = handler;
          }
          // Store the line height and page height for this particular element
          $.data(this, "mousewheel-line-height", special.getLineHeight(this));
          $.data(this, "mousewheel-page-height", special.getPageHeight(this));
        },

        teardown: function () {
          if (this.removeEventListener) {
            for (var i = toBind.length; i; ) {
              this.removeEventListener(toBind[--i], handler, false);
            }
          } else {
            this.onmousewheel = null;
          }
          // Clean up the data we added to the element
          $.removeData(this, "mousewheel-line-height");
          $.removeData(this, "mousewheel-page-height");
        },

        getLineHeight: function (elem) {
          var $elem = $(elem),
            $parent =
              $elem["offsetParent" in $.fn ? "offsetParent" : "parent"]();
          if (!$parent.length) {
            $parent = $("body");
          }
          return (
            parseInt($parent.css("fontSize"), 10) ||
            parseInt($elem.css("fontSize"), 10) ||
            16
          );
        },

        getPageHeight: function (elem) {
          return $(elem).height();
        },

        settings: {
          adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
          normalizeOffset: true, // calls getBoundingClientRect for each event
        },
      });

      $.fn.extend({
        mousewheel: function (fn) {
          return fn ? this.bind("mousewheel", fn) : this.trigger("mousewheel");
        },

        unmousewheel: function (fn) {
          return this.unbind("mousewheel", fn);
        },
      });

      function handler(event) {
        var orgEvent = event || window.event,
          args = slice.call(arguments, 1),
          delta = 0,
          deltaX = 0,
          deltaY = 0,
          absDelta = 0,
          offsetX = 0,
          offsetY = 0;
        event = $.event.fix(orgEvent);
        event.type = "mousewheel";

        // Old school scrollwheel delta
        if ("detail" in orgEvent) {
          deltaY = orgEvent.detail * -1;
        }
        if ("wheelDelta" in orgEvent) {
          deltaY = orgEvent.wheelDelta;
        }
        if ("wheelDeltaY" in orgEvent) {
          deltaY = orgEvent.wheelDeltaY;
        }
        if ("wheelDeltaX" in orgEvent) {
          deltaX = orgEvent.wheelDeltaX * -1;
        }

        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
        if ("axis" in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS) {
          deltaX = deltaY * -1;
          deltaY = 0;
        }

        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
        delta = deltaY === 0 ? deltaX : deltaY;

        // New school wheel delta (wheel event)
        if ("deltaY" in orgEvent) {
          deltaY = orgEvent.deltaY * -1;
          delta = deltaY;
        }
        if ("deltaX" in orgEvent) {
          deltaX = orgEvent.deltaX;
          if (deltaY === 0) {
            delta = deltaX * -1;
          }
        }

        // No change actually happened, no reason to go any further
        if (deltaY === 0 && deltaX === 0) {
          return;
        }

        // Need to convert lines and pages to pixels if we aren't already in pixels
        // There are three delta modes:
        //   * deltaMode 0 is by pixels, nothing to do
        //   * deltaMode 1 is by lines
        //   * deltaMode 2 is by pages
        if (orgEvent.deltaMode === 1) {
          var lineHeight = $.data(this, "mousewheel-line-height");
          delta *= lineHeight;
          deltaY *= lineHeight;
          deltaX *= lineHeight;
        } else if (orgEvent.deltaMode === 2) {
          var pageHeight = $.data(this, "mousewheel-page-height");
          delta *= pageHeight;
          deltaY *= pageHeight;
          deltaX *= pageHeight;
        }

        // Store lowest absolute delta to normalize the delta values
        absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX));

        if (!lowestDelta || absDelta < lowestDelta) {
          lowestDelta = absDelta;

          // Adjust older deltas if necessary
          if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
            lowestDelta /= 40;
          }
        }

        // Adjust older deltas if necessary
        if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
          // Divide all the things by 40!
          delta /= 40;
          deltaX /= 40;
          deltaY /= 40;
        }

        // Get a whole, normalized value for the deltas
        delta = Math[delta >= 1 ? "floor" : "ceil"](delta / lowestDelta);
        deltaX = Math[deltaX >= 1 ? "floor" : "ceil"](deltaX / lowestDelta);
        deltaY = Math[deltaY >= 1 ? "floor" : "ceil"](deltaY / lowestDelta);

        // Normalise offsetX and offsetY properties
        if (special.settings.normalizeOffset && this.getBoundingClientRect) {
          var boundingRect = this.getBoundingClientRect();
          offsetX = event.clientX - boundingRect.left;
          offsetY = event.clientY - boundingRect.top;
        }

        // Add information to the event object
        event.deltaX = deltaX;
        event.deltaY = deltaY;
        event.deltaFactor = lowestDelta;
        event.offsetX = offsetX;
        event.offsetY = offsetY;
        // Go ahead and set deltaMode to 0 since we converted to pixels
        // Although this is a little odd since we overwrite the deltaX/Y
        // properties with normalized deltas.
        event.deltaMode = 0;

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        // Clearout lowestDelta after sometime to better
        // handle multiple device types that give different
        // a different lowestDelta
        // Ex: trackpad = 3 and mouse wheel = 120
        if (nullLowestDeltaTimeout) {
          clearTimeout(nullLowestDeltaTimeout);
        }
        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);

        return ($.event.dispatch || $.event.handle).apply(this, args);
      }

      function nullLowestDelta() {
        lowestDelta = null;
      }

      function shouldAdjustOldDeltas(orgEvent, absDelta) {
        // If this is an older event and the delta is divisable by 120,
        // then we are assuming that the browser is treating this as an
        // older mouse wheel event and that we should divide the deltas
        // by 40 to try and get a more usable deltaFactor.
        // Side note, this actually impacts the reported scroll distance
        // in older browsers and can cause scrolling to be slower than native.
        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
        return (
          special.settings.adjustOldDeltas &&
          orgEvent.type === "mousewheel" &&
          absDelta % 120 === 0
        );
      }
    });

    S2.define(
      "jquery.select2",
      ["jquery", "jquery-mousewheel", "./select2/core", "./select2/defaults"],
      function ($, _, Select2, Defaults) {
        if ($.fn.select2 == null) {
          // All methods that should return the element
          var thisMethods = ["open", "close", "destroy"];

          $.fn.select2 = function (options) {
            options = options || {};

            if (typeof options === "object") {
              this.each(function () {
                var instanceOptions = $.extend(true, {}, options);

                var instance = new Select2($(this), instanceOptions);
              });

              return this;
            } else if (typeof options === "string") {
              var ret;
              var args = Array.prototype.slice.call(arguments, 1);

              this.each(function () {
                var instance = $(this).data("select2");

                if (instance == null && window.console && console.error) {
                  console.error(
                    "The select2('" +
                      options +
                      "') method was called on an " +
                      "element that is not using Select2."
                  );
                }

                ret = instance[options].apply(instance, args);
              });

              // Check if we should be returning `this`
              if ($.inArray(options, thisMethods) > -1) {
                return this;
              }

              return ret;
            } else {
              throw new Error("Invalid arguments for Select2: " + options);
            }
          };
        }

        if ($.fn.select2.defaults == null) {
          $.fn.select2.defaults = Defaults;
        }

        return Select2;
      }
    );

    // Return the AMD loader configuration so it can be used outside of this file
    return {
      define: S2.define,
      require: S2.require,
    };
  })();

  // Autoload the jQuery bindings
  // We know that all of the modules exist above this, so we're safe
  var select2 = S2.require("jquery.select2");

  // Hold the AMD module references on the jQuery function that was just loaded
  // This allows Select2 to use the internal loader outside of this file, such
  // as in the language files.
  jQuery.fn.select2.amd = S2;

  // Return the Select2 instance for anyone who is importing it.
  return select2;
});

/*!
 * clipboard.js v2.0.0
 * https://zenorocha.github.io/clipboard.js
 *
 * Licensed MIT © Zeno Rocha
 */
(function webpackUniversalModuleDefinition(root, factory) {
  // if(typeof exports === 'object' && typeof module === 'object')
  // 	module.exports = factory();
  // else if(typeof define === 'function' && define.amd)
  // 	define([], factory);
  // else if(typeof exports === 'object')
  // 	exports["ClipboardJS"] = factory();
  // else
  root["ClipboardJS"] = factory();
})(this, function () {
  return /******/ (function (modules) {
    // webpackBootstrap
    /******/ // The module cache
    /******/ var installedModules = {};
    /******/
    /******/ // The require function
    /******/ function __webpack_require__(moduleId) {
      /******/
      /******/ // Check if module is in cache
      /******/ if (installedModules[moduleId]) {
        /******/ return installedModules[moduleId].exports;
        /******/
      }
      /******/ // Create a new module (and put it into the cache)
      /******/ var module = (installedModules[moduleId] = {
        /******/ i: moduleId,
        /******/ l: false,
        /******/ exports: {},
        /******/
      });
      /******/
      /******/ // Execute the module function
      /******/ modules[moduleId].call(
        module.exports,
        module,
        module.exports,
        __webpack_require__
      );
      /******/
      /******/ // Flag the module as loaded
      /******/ module.l = true;
      /******/
      /******/ // Return the exports of the module
      /******/ return module.exports;
      /******/
    }
    /******/
    /******/
    /******/ // expose the modules object (__webpack_modules__)
    /******/ __webpack_require__.m = modules;
    /******/
    /******/ // expose the module cache
    /******/ __webpack_require__.c = installedModules;
    /******/
    /******/ // identity function for calling harmony imports with the correct context
    /******/ __webpack_require__.i = function (value) {
      return value;
    };
    /******/
    /******/ // define getter function for harmony exports
    /******/ __webpack_require__.d = function (exports, name, getter) {
      /******/ if (!__webpack_require__.o(exports, name)) {
        /******/ Object.defineProperty(exports, name, {
          /******/ configurable: false,
          /******/ enumerable: true,
          /******/ get: getter,
          /******/
        });
        /******/
      }
      /******/
    };
    /******/
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/ __webpack_require__.n = function (module) {
      /******/ var getter =
        module && module.__esModule
          ? /******/ function getDefault() {
              return module["default"];
            }
          : /******/ function getModuleExports() {
              return module;
            };
      /******/ __webpack_require__.d(getter, "a", getter);
      /******/ return getter;
      /******/
    };
    /******/
    /******/ // Object.prototype.hasOwnProperty.call
    /******/ __webpack_require__.o = function (object, property) {
      return Object.prototype.hasOwnProperty.call(object, property);
    };
    /******/
    /******/ // __webpack_public_path__
    /******/ __webpack_require__.p = "";
    /******/
    /******/ // Load entry module and return exports
    /******/ return __webpack_require__((__webpack_require__.s = 3));
    /******/
  })(
    /************************************************************************/
    /******/ [
      /* 0 */
      /***/ function (module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_FACTORY__,
          __WEBPACK_AMD_DEFINE_ARRAY__,
          __WEBPACK_AMD_DEFINE_RESULT__;
        (function (global, factory) {
          if (true) {
            !((__WEBPACK_AMD_DEFINE_ARRAY__ = [module, __webpack_require__(7)]),
            (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
            (__WEBPACK_AMD_DEFINE_RESULT__ =
              typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function"
                ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                    exports,
                    __WEBPACK_AMD_DEFINE_ARRAY__
                  )
                : __WEBPACK_AMD_DEFINE_FACTORY__),
            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
              (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          } else if (typeof exports !== "undefined") {
            factory(module, require("select"));
          } else {
            var mod = {
              exports: {},
            };
            factory(mod, global.select);
            global.clipboardAction = mod.exports;
          }
        })(this, function (module, _select) {
          "use strict";

          var _select2 = _interopRequireDefault(_select);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var _typeof =
            typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
              ? function (obj) {
                  return typeof obj;
                }
              : function (obj) {
                  return obj &&
                    typeof Symbol === "function" &&
                    obj.constructor === Symbol &&
                    obj !== Symbol.prototype
                    ? "symbol"
                    : typeof obj;
                };

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          var _createClass = (function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();

          var ClipboardAction = (function () {
            /**
             * @param {Object} options
             */
            function ClipboardAction(options) {
              _classCallCheck(this, ClipboardAction);

              this.resolveOptions(options);
              this.initSelection();
            }

            /**
             * Defines base properties passed from constructor.
             * @param {Object} options
             */

            _createClass(ClipboardAction, [
              {
                key: "resolveOptions",
                value: function resolveOptions() {
                  var options =
                    arguments.length > 0 && arguments[0] !== undefined
                      ? arguments[0]
                      : {};

                  this.action = options.action;
                  this.container = options.container;
                  this.emitter = options.emitter;
                  this.target = options.target;
                  this.text = options.text;
                  this.trigger = options.trigger;

                  this.selectedText = "";
                },
              },
              {
                key: "initSelection",
                value: function initSelection() {
                  if (this.text) {
                    this.selectFake();
                  } else if (this.target) {
                    this.selectTarget();
                  }
                },
              },
              {
                key: "selectFake",
                value: function selectFake() {
                  var _this = this;

                  var isRTL =
                    document.documentElement.getAttribute("dir") == "rtl";

                  this.removeFake();

                  this.fakeHandlerCallback = function () {
                    return _this.removeFake();
                  };
                  this.fakeHandler =
                    this.container.addEventListener(
                      "click",
                      this.fakeHandlerCallback
                    ) || true;

                  this.fakeElem = document.createElement("textarea");
                  // Prevent zooming on iOS
                  this.fakeElem.style.fontSize = "12pt";
                  // Reset box model
                  this.fakeElem.style.border = "0";
                  this.fakeElem.style.padding = "0";
                  this.fakeElem.style.margin = "0";
                  // Move element out of screen horizontally
                  this.fakeElem.style.position = "absolute";
                  this.fakeElem.style[isRTL ? "right" : "left"] = "-9999px";
                  // Move element to the same position vertically
                  var yPosition =
                    window.pageYOffset || document.documentElement.scrollTop;
                  this.fakeElem.style.top = yPosition + "px";

                  this.fakeElem.setAttribute("readonly", "");
                  this.fakeElem.value = this.text;

                  this.container.appendChild(this.fakeElem);

                  this.selectedText = (0, _select2.default)(this.fakeElem);
                  this.copyText();
                },
              },
              {
                key: "removeFake",
                value: function removeFake() {
                  if (this.fakeHandler) {
                    this.container.removeEventListener(
                      "click",
                      this.fakeHandlerCallback
                    );
                    this.fakeHandler = null;
                    this.fakeHandlerCallback = null;
                  }

                  if (this.fakeElem) {
                    this.container.removeChild(this.fakeElem);
                    this.fakeElem = null;
                  }
                },
              },
              {
                key: "selectTarget",
                value: function selectTarget() {
                  this.selectedText = (0, _select2.default)(this.target);
                  this.copyText();
                },
              },
              {
                key: "copyText",
                value: function copyText() {
                  var succeeded = void 0;

                  try {
                    succeeded = document.execCommand(this.action);
                  } catch (err) {
                    succeeded = false;
                  }

                  this.handleResult(succeeded);
                },
              },
              {
                key: "handleResult",
                value: function handleResult(succeeded) {
                  this.emitter.emit(succeeded ? "success" : "error", {
                    action: this.action,
                    text: this.selectedText,
                    trigger: this.trigger,
                    clearSelection: this.clearSelection.bind(this),
                  });
                },
              },
              {
                key: "clearSelection",
                value: function clearSelection() {
                  if (this.trigger) {
                    this.trigger.focus();
                  }

                  window.getSelection().removeAllRanges();
                },
              },
              {
                key: "destroy",
                value: function destroy() {
                  this.removeFake();
                },
              },
              {
                key: "action",
                set: function set() {
                  var action =
                    arguments.length > 0 && arguments[0] !== undefined
                      ? arguments[0]
                      : "copy";

                  this._action = action;

                  if (this._action !== "copy" && this._action !== "cut") {
                    throw new Error(
                      'Invalid "action" value, use either "copy" or "cut"'
                    );
                  }
                },
                get: function get() {
                  return this._action;
                },
              },
              {
                key: "target",
                set: function set(target) {
                  if (target !== undefined) {
                    if (
                      target &&
                      (typeof target === "undefined"
                        ? "undefined"
                        : _typeof(target)) === "object" &&
                      target.nodeType === 1
                    ) {
                      if (
                        this.action === "copy" &&
                        target.hasAttribute("disabled")
                      ) {
                        throw new Error(
                          'Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute'
                        );
                      }

                      if (
                        this.action === "cut" &&
                        (target.hasAttribute("readonly") ||
                          target.hasAttribute("disabled"))
                      ) {
                        throw new Error(
                          'Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes'
                        );
                      }

                      this._target = target;
                    } else {
                      throw new Error(
                        'Invalid "target" value, use a valid Element'
                      );
                    }
                  }
                },
                get: function get() {
                  return this._target;
                },
              },
            ]);

            return ClipboardAction;
          })();

          module.exports = ClipboardAction;
        });

        /***/
      },
      /* 1 */
      /***/ function (module, exports, __webpack_require__) {
        var is = __webpack_require__(6);
        var delegate = __webpack_require__(5);

        /**
         * Validates all params and calls the right
         * listener function based on its target type.
         *
         * @param {String|HTMLElement|HTMLCollection|NodeList} target
         * @param {String} type
         * @param {Function} callback
         * @return {Object}
         */
        function listen(target, type, callback) {
          if (!target && !type && !callback) {
            throw new Error("Missing required arguments");
          }

          if (!is.string(type)) {
            throw new TypeError("Second argument must be a String");
          }

          if (!is.fn(callback)) {
            throw new TypeError("Third argument must be a Function");
          }

          if (is.node(target)) {
            return listenNode(target, type, callback);
          } else if (is.nodeList(target)) {
            return listenNodeList(target, type, callback);
          } else if (is.string(target)) {
            return listenSelector(target, type, callback);
          } else {
            throw new TypeError(
              "First argument must be a String, HTMLElement, HTMLCollection, or NodeList"
            );
          }
        }

        /**
         * Adds an event listener to a HTML element
         * and returns a remove listener function.
         *
         * @param {HTMLElement} node
         * @param {String} type
         * @param {Function} callback
         * @return {Object}
         */
        function listenNode(node, type, callback) {
          node.addEventListener(type, callback);

          return {
            destroy: function () {
              node.removeEventListener(type, callback);
            },
          };
        }

        /**
         * Add an event listener to a list of HTML elements
         * and returns a remove listener function.
         *
         * @param {NodeList|HTMLCollection} nodeList
         * @param {String} type
         * @param {Function} callback
         * @return {Object}
         */
        function listenNodeList(nodeList, type, callback) {
          Array.prototype.forEach.call(nodeList, function (node) {
            node.addEventListener(type, callback);
          });

          return {
            destroy: function () {
              Array.prototype.forEach.call(nodeList, function (node) {
                node.removeEventListener(type, callback);
              });
            },
          };
        }

        /**
         * Add an event listener to a selector
         * and returns a remove listener function.
         *
         * @param {String} selector
         * @param {String} type
         * @param {Function} callback
         * @return {Object}
         */
        function listenSelector(selector, type, callback) {
          return delegate(document.body, selector, type, callback);
        }

        module.exports = listen;

        /***/
      },
      /* 2 */
      /***/ function (module, exports) {
        function E() {
          // Keep this empty so it's easier to inherit from
          // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)
        }

        E.prototype = {
          on: function (name, callback, ctx) {
            var e = this.e || (this.e = {});

            (e[name] || (e[name] = [])).push({
              fn: callback,
              ctx: ctx,
            });

            return this;
          },

          once: function (name, callback, ctx) {
            var self = this;
            function listener() {
              self.off(name, listener);
              callback.apply(ctx, arguments);
            }

            listener._ = callback;
            return this.on(name, listener, ctx);
          },

          emit: function (name) {
            var data = [].slice.call(arguments, 1);
            var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
            var i = 0;
            var len = evtArr.length;

            for (i; i < len; i++) {
              evtArr[i].fn.apply(evtArr[i].ctx, data);
            }

            return this;
          },

          off: function (name, callback) {
            var e = this.e || (this.e = {});
            var evts = e[name];
            var liveEvents = [];

            if (evts && callback) {
              for (var i = 0, len = evts.length; i < len; i++) {
                if (evts[i].fn !== callback && evts[i].fn._ !== callback)
                  liveEvents.push(evts[i]);
              }
            }

            // Remove event from queue to prevent memory leak
            // Suggested by https://github.com/lazd
            // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910

            liveEvents.length ? (e[name] = liveEvents) : delete e[name];

            return this;
          },
        };

        module.exports = E;

        /***/
      },
      /* 3 */
      /***/ function (module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_FACTORY__,
          __WEBPACK_AMD_DEFINE_ARRAY__,
          __WEBPACK_AMD_DEFINE_RESULT__;
        (function (global, factory) {
          if (true) {
            !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
              module,
              __webpack_require__(0),
              __webpack_require__(2),
              __webpack_require__(1),
            ]),
            (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
            (__WEBPACK_AMD_DEFINE_RESULT__ =
              typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function"
                ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                    exports,
                    __WEBPACK_AMD_DEFINE_ARRAY__
                  )
                : __WEBPACK_AMD_DEFINE_FACTORY__),
            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
              (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          } else if (typeof exports !== "undefined") {
            factory(
              module,
              require("./clipboard-action"),
              require("tiny-emitter"),
              require("good-listener")
            );
          } else {
            var mod = {
              exports: {},
            };
            factory(
              mod,
              global.clipboardAction,
              global.tinyEmitter,
              global.goodListener
            );
            global.clipboard = mod.exports;
          }
        })(
          this,
          function (module, _clipboardAction, _tinyEmitter, _goodListener) {
            "use strict";

            var _clipboardAction2 = _interopRequireDefault(_clipboardAction);

            var _tinyEmitter2 = _interopRequireDefault(_tinyEmitter);

            var _goodListener2 = _interopRequireDefault(_goodListener);

            function _interopRequireDefault(obj) {
              return obj && obj.__esModule
                ? obj
                : {
                    default: obj,
                  };
            }

            var _typeof =
              typeof Symbol === "function" &&
              typeof Symbol.iterator === "symbol"
                ? function (obj) {
                    return typeof obj;
                  }
                : function (obj) {
                    return obj &&
                      typeof Symbol === "function" &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? "symbol"
                      : typeof obj;
                  };

            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }

            var _createClass = (function () {
              function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor) descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }

              return function (Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
              };
            })();

            function _possibleConstructorReturn(self, call) {
              if (!self) {
                throw new ReferenceError(
                  "this hasn't been initialised - super() hasn't been called"
                );
              }

              return call &&
                (typeof call === "object" || typeof call === "function")
                ? call
                : self;
            }

            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError(
                  "Super expression must either be null or a function, not " +
                    typeof superClass
                );
              }

              subClass.prototype = Object.create(
                superClass && superClass.prototype,
                {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true,
                  },
                }
              );
              if (superClass)
                Object.setPrototypeOf
                  ? Object.setPrototypeOf(subClass, superClass)
                  : (subClass.__proto__ = superClass);
            }

            var Clipboard = (function (_Emitter) {
              _inherits(Clipboard, _Emitter);

              /**
               * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
               * @param {Object} options
               */
              function Clipboard(trigger, options) {
                _classCallCheck(this, Clipboard);

                var _this = _possibleConstructorReturn(
                  this,
                  (
                    Clipboard.__proto__ || Object.getPrototypeOf(Clipboard)
                  ).call(this)
                );

                _this.resolveOptions(options);
                _this.listenClick(trigger);
                return _this;
              }

              /**
               * Defines if attributes would be resolved using internal setter functions
               * or custom functions that were passed in the constructor.
               * @param {Object} options
               */

              _createClass(
                Clipboard,
                [
                  {
                    key: "resolveOptions",
                    value: function resolveOptions() {
                      var options =
                        arguments.length > 0 && arguments[0] !== undefined
                          ? arguments[0]
                          : {};

                      this.action =
                        typeof options.action === "function"
                          ? options.action
                          : this.defaultAction;
                      this.target =
                        typeof options.target === "function"
                          ? options.target
                          : this.defaultTarget;
                      this.text =
                        typeof options.text === "function"
                          ? options.text
                          : this.defaultText;
                      this.container =
                        _typeof(options.container) === "object"
                          ? options.container
                          : document.body;
                    },
                  },
                  {
                    key: "listenClick",
                    value: function listenClick(trigger) {
                      var _this2 = this;

                      this.listener = (0, _goodListener2.default)(
                        trigger,
                        "click",
                        function (e) {
                          return _this2.onClick(e);
                        }
                      );
                    },
                  },
                  {
                    key: "onClick",
                    value: function onClick(e) {
                      var trigger = e.delegateTarget || e.currentTarget;

                      if (this.clipboardAction) {
                        this.clipboardAction = null;
                      }

                      this.clipboardAction = new _clipboardAction2.default({
                        action: this.action(trigger),
                        target: this.target(trigger),
                        text: this.text(trigger),
                        container: this.container,
                        trigger: trigger,
                        emitter: this,
                      });
                    },
                  },
                  {
                    key: "defaultAction",
                    value: function defaultAction(trigger) {
                      return getAttributeValue("action", trigger);
                    },
                  },
                  {
                    key: "defaultTarget",
                    value: function defaultTarget(trigger) {
                      var selector = getAttributeValue("target", trigger);

                      if (selector) {
                        return document.querySelector(selector);
                      }
                    },
                  },
                  {
                    key: "defaultText",
                    value: function defaultText(trigger) {
                      return getAttributeValue("text", trigger);
                    },
                  },
                  {
                    key: "destroy",
                    value: function destroy() {
                      this.listener.destroy();

                      if (this.clipboardAction) {
                        this.clipboardAction.destroy();
                        this.clipboardAction = null;
                      }
                    },
                  },
                ],
                [
                  {
                    key: "isSupported",
                    value: function isSupported() {
                      var action =
                        arguments.length > 0 && arguments[0] !== undefined
                          ? arguments[0]
                          : ["copy", "cut"];

                      var actions =
                        typeof action === "string" ? [action] : action;
                      var support = !!document.queryCommandSupported;

                      actions.forEach(function (action) {
                        support =
                          support && !!document.queryCommandSupported(action);
                      });

                      return support;
                    },
                  },
                ]
              );

              return Clipboard;
            })(_tinyEmitter2.default);

            /**
             * Helper function to retrieve attribute value.
             * @param {String} suffix
             * @param {Element} element
             */
            function getAttributeValue(suffix, element) {
              var attribute = "data-clipboard-" + suffix;

              if (!element.hasAttribute(attribute)) {
                return;
              }

              return element.getAttribute(attribute);
            }

            module.exports = Clipboard;
          }
        );

        /***/
      },
      /* 4 */
      /***/ function (module, exports) {
        var DOCUMENT_NODE_TYPE = 9;

        /**
         * A polyfill for Element.matches()
         */
        if (typeof Element !== "undefined" && !Element.prototype.matches) {
          var proto = Element.prototype;

          proto.matches =
            proto.matchesSelector ||
            proto.mozMatchesSelector ||
            proto.msMatchesSelector ||
            proto.oMatchesSelector ||
            proto.webkitMatchesSelector;
        }

        /**
         * Finds the closest parent that matches a selector.
         *
         * @param {Element} element
         * @param {String} selector
         * @return {Function}
         */
        function closest(element, selector) {
          while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
            if (
              typeof element.matches === "function" &&
              element.matches(selector)
            ) {
              return element;
            }
            element = element.parentNode;
          }
        }

        module.exports = closest;

        /***/
      },
      /* 5 */
      /***/ function (module, exports, __webpack_require__) {
        var closest = __webpack_require__(4);

        /**
         * Delegates event to a selector.
         *
         * @param {Element} element
         * @param {String} selector
         * @param {String} type
         * @param {Function} callback
         * @param {Boolean} useCapture
         * @return {Object}
         */
        function _delegate(element, selector, type, callback, useCapture) {
          var listenerFn = listener.apply(this, arguments);

          element.addEventListener(type, listenerFn, useCapture);

          return {
            destroy: function () {
              element.removeEventListener(type, listenerFn, useCapture);
            },
          };
        }

        /**
         * Delegates event to a selector.
         *
         * @param {Element|String|Array} [elements]
         * @param {String} selector
         * @param {String} type
         * @param {Function} callback
         * @param {Boolean} useCapture
         * @return {Object}
         */
        function delegate(elements, selector, type, callback, useCapture) {
          // Handle the regular Element usage
          if (typeof elements.addEventListener === "function") {
            return _delegate.apply(null, arguments);
          }

          // Handle Element-less usage, it defaults to global delegation
          if (typeof type === "function") {
            // Use `document` as the first parameter, then apply arguments
            // This is a short way to .unshift `arguments` without running into deoptimizations
            return _delegate.bind(null, document).apply(null, arguments);
          }

          // Handle Selector-based usage
          if (typeof elements === "string") {
            elements = document.querySelectorAll(elements);
          }

          // Handle Array-like based usage
          return Array.prototype.map.call(elements, function (element) {
            return _delegate(element, selector, type, callback, useCapture);
          });
        }

        /**
         * Finds closest match and invokes callback.
         *
         * @param {Element} element
         * @param {String} selector
         * @param {String} type
         * @param {Function} callback
         * @return {Function}
         */
        function listener(element, selector, type, callback) {
          return function (e) {
            e.delegateTarget = closest(e.target, selector);

            if (e.delegateTarget) {
              callback.call(element, e);
            }
          };
        }

        module.exports = delegate;

        /***/
      },
      /* 6 */
      /***/ function (module, exports) {
        /**
         * Check if argument is a HTML element.
         *
         * @param {Object} value
         * @return {Boolean}
         */
        exports.node = function (value) {
          return (
            value !== undefined &&
            value instanceof HTMLElement &&
            value.nodeType === 1
          );
        };

        /**
         * Check if argument is a list of HTML elements.
         *
         * @param {Object} value
         * @return {Boolean}
         */
        exports.nodeList = function (value) {
          var type = Object.prototype.toString.call(value);

          return (
            value !== undefined &&
            (type === "[object NodeList]" ||
              type === "[object HTMLCollection]") &&
            "length" in value &&
            (value.length === 0 || exports.node(value[0]))
          );
        };

        /**
         * Check if argument is a string.
         *
         * @param {Object} value
         * @return {Boolean}
         */
        exports.string = function (value) {
          return typeof value === "string" || value instanceof String;
        };

        /**
         * Check if argument is a function.
         *
         * @param {Object} value
         * @return {Boolean}
         */
        exports.fn = function (value) {
          var type = Object.prototype.toString.call(value);

          return type === "[object Function]";
        };

        /***/
      },
      /* 7 */
      /***/ function (module, exports) {
        function select(element) {
          var selectedText;

          if (element.nodeName === "SELECT") {
            element.focus();

            selectedText = element.value;
          } else if (
            element.nodeName === "INPUT" ||
            element.nodeName === "TEXTAREA"
          ) {
            var isReadOnly = element.hasAttribute("readonly");

            if (!isReadOnly) {
              element.setAttribute("readonly", "");
            }

            element.select();
            element.setSelectionRange(0, element.value.length);

            if (!isReadOnly) {
              element.removeAttribute("readonly");
            }

            selectedText = element.value;
          } else {
            if (element.hasAttribute("contenteditable")) {
              element.focus();
            }

            var selection = window.getSelection();
            var range = document.createRange();

            range.selectNodeContents(element);
            selection.removeAllRanges();
            selection.addRange(range);

            selectedText = selection.toString();
          }

          return selectedText;
        }

        module.exports = select;

        /***/
      },
      /******/
    ]
  );
});

//! moment.js

(function (global, factory) {
  // typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  // typeof define === 'function' && define.amd ? define(factory) :
  global.moment = factory();
})(this, function () {
  "use strict";

  var hookCallback;

  function hooks() {
    return hookCallback.apply(null, arguments);
  }

  // This is done to register the method called with moment()
  // without creating circular dependencies.
  function setHookCallback(callback) {
    hookCallback = callback;
  }

  function isArray(input) {
    return (
      input instanceof Array ||
      Object.prototype.toString.call(input) === "[object Array]"
    );
  }

  function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return (
      input != null &&
      Object.prototype.toString.call(input) === "[object Object]"
    );
  }

  function isObjectEmpty(obj) {
    if (Object.getOwnPropertyNames) {
      return Object.getOwnPropertyNames(obj).length === 0;
    } else {
      var k;
      for (k in obj) {
        if (obj.hasOwnProperty(k)) {
          return false;
        }
      }
      return true;
    }
  }

  function isUndefined(input) {
    return input === void 0;
  }

  function isNumber(input) {
    return (
      typeof input === "number" ||
      Object.prototype.toString.call(input) === "[object Number]"
    );
  }

  function isDate(input) {
    return (
      input instanceof Date ||
      Object.prototype.toString.call(input) === "[object Date]"
    );
  }

  function map(arr, fn) {
    var res = [],
      i;
    for (i = 0; i < arr.length; ++i) {
      res.push(fn(arr[i], i));
    }
    return res;
  }

  function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
  }

  function extend(a, b) {
    for (var i in b) {
      if (hasOwnProp(b, i)) {
        a[i] = b[i];
      }
    }

    if (hasOwnProp(b, "toString")) {
      a.toString = b.toString;
    }

    if (hasOwnProp(b, "valueOf")) {
      a.valueOf = b.valueOf;
    }

    return a;
  }

  function createUTC(input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
  }

  function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
      empty: false,
      unusedTokens: [],
      unusedInput: [],
      overflow: -2,
      charsLeftOver: 0,
      nullInput: false,
      invalidMonth: null,
      invalidFormat: false,
      userInvalidated: false,
      iso: false,
      parsedDateParts: [],
      meridiem: null,
      rfc2822: false,
      weekdayMismatch: false,
    };
  }

  function getParsingFlags(m) {
    if (m._pf == null) {
      m._pf = defaultParsingFlags();
    }
    return m._pf;
  }

  var some;
  if (Array.prototype.some) {
    some = Array.prototype.some;
  } else {
    some = function (fun) {
      var t = Object(this);
      var len = t.length >>> 0;

      for (var i = 0; i < len; i++) {
        if (i in t && fun.call(this, t[i], i, t)) {
          return true;
        }
      }

      return false;
    };
  }

  function isValid(m) {
    if (m._isValid == null) {
      var flags = getParsingFlags(m);
      var parsedParts = some.call(flags.parsedDateParts, function (i) {
        return i != null;
      });
      var isNowValid =
        !isNaN(m._d.getTime()) &&
        flags.overflow < 0 &&
        !flags.empty &&
        !flags.invalidMonth &&
        !flags.invalidWeekday &&
        !flags.weekdayMismatch &&
        !flags.nullInput &&
        !flags.invalidFormat &&
        !flags.userInvalidated &&
        (!flags.meridiem || (flags.meridiem && parsedParts));

      if (m._strict) {
        isNowValid =
          isNowValid &&
          flags.charsLeftOver === 0 &&
          flags.unusedTokens.length === 0 &&
          flags.bigHour === undefined;
      }

      if (Object.isFrozen == null || !Object.isFrozen(m)) {
        m._isValid = isNowValid;
      } else {
        return isNowValid;
      }
    }
    return m._isValid;
  }

  function createInvalid(flags) {
    var m = createUTC(NaN);
    if (flags != null) {
      extend(getParsingFlags(m), flags);
    } else {
      getParsingFlags(m).userInvalidated = true;
    }

    return m;
  }

  // Plugins that add properties should also add the key here (null value),
  // so we can properly clone ourselves.
  var momentProperties = (hooks.momentProperties = []);

  function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined(from._isAMomentObject)) {
      to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
      to._i = from._i;
    }
    if (!isUndefined(from._f)) {
      to._f = from._f;
    }
    if (!isUndefined(from._l)) {
      to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
      to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
      to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
      to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
      to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
      to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
      to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
      for (i = 0; i < momentProperties.length; i++) {
        prop = momentProperties[i];
        val = from[prop];
        if (!isUndefined(val)) {
          to[prop] = val;
        }
      }
    }

    return to;
  }

  var updateInProgress = false;

  // Moment prototype object
  function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
      this._d = new Date(NaN);
    }
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
      updateInProgress = true;
      hooks.updateOffset(this);
      updateInProgress = false;
    }
  }

  function isMoment(obj) {
    return (
      obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
    );
  }

  function absFloor(number) {
    if (number < 0) {
      // -0 -> 0
      return Math.ceil(number) || 0;
    } else {
      return Math.floor(number);
    }
  }

  function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
      value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
      value = absFloor(coercedNumber);
    }

    return value;
  }

  // compare two arrays, return the number of differences
  function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
      lengthDiff = Math.abs(array1.length - array2.length),
      diffs = 0,
      i;
    for (i = 0; i < len; i++) {
      if (
        (dontConvert && array1[i] !== array2[i]) ||
        (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
      ) {
        diffs++;
      }
    }
    return diffs + lengthDiff;
  }

  function warn(msg) {
    if (
      hooks.suppressDeprecationWarnings === false &&
      typeof console !== "undefined" &&
      console.warn
    ) {
      console.warn("Deprecation warning: " + msg);
    }
  }

  function deprecate(msg, fn) {
    var firstTime = true;

    return extend(function () {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(null, msg);
      }
      if (firstTime) {
        var args = [];
        var arg;
        for (var i = 0; i < arguments.length; i++) {
          arg = "";
          if (typeof arguments[i] === "object") {
            arg += "\n[" + i + "] ";
            for (var key in arguments[0]) {
              arg += key + ": " + arguments[0][key] + ", ";
            }
            arg = arg.slice(0, -2); // Remove trailing comma and space
          } else {
            arg = arguments[i];
          }
          args.push(arg);
        }
        warn(
          msg +
            "\nArguments: " +
            Array.prototype.slice.call(args).join("") +
            "\n" +
            new Error().stack
        );
        firstTime = false;
      }
      return fn.apply(this, arguments);
    }, fn);
  }

  var deprecations = {};

  function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
      warn(msg);
      deprecations[name] = true;
    }
  }

  hooks.suppressDeprecationWarnings = false;
  hooks.deprecationHandler = null;

  function isFunction(input) {
    return (
      input instanceof Function ||
      Object.prototype.toString.call(input) === "[object Function]"
    );
  }

  function set(config) {
    var prop, i;
    for (i in config) {
      prop = config[i];
      if (isFunction(prop)) {
        this[i] = prop;
      } else {
        this["_" + i] = prop;
      }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in next major release.
    this._dayOfMonthOrdinalParseLenient = new RegExp(
      (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
        "|" +
        /\d{1,2}/.source
    );
  }

  function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig),
      prop;
    for (prop in childConfig) {
      if (hasOwnProp(childConfig, prop)) {
        if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
          res[prop] = {};
          extend(res[prop], parentConfig[prop]);
          extend(res[prop], childConfig[prop]);
        } else if (childConfig[prop] != null) {
          res[prop] = childConfig[prop];
        } else {
          delete res[prop];
        }
      }
    }
    for (prop in parentConfig) {
      if (
        hasOwnProp(parentConfig, prop) &&
        !hasOwnProp(childConfig, prop) &&
        isObject(parentConfig[prop])
      ) {
        // make sure changes to properties don't modify parent config
        res[prop] = extend({}, res[prop]);
      }
    }
    return res;
  }

  function Locale(config) {
    if (config != null) {
      this.set(config);
    }
  }

  var keys;

  if (Object.keys) {
    keys = Object.keys;
  } else {
    keys = function (obj) {
      var i,
        res = [];
      for (i in obj) {
        if (hasOwnProp(obj, i)) {
          res.push(i);
        }
      }
      return res;
    };
  }

  var defaultCalendar = {
    sameDay: "[Today at] LT",
    nextDay: "[Tomorrow at] LT",
    nextWeek: "dddd [at] LT",
    lastDay: "[Yesterday at] LT",
    lastWeek: "[Last] dddd [at] LT",
    sameElse: "L",
  };

  function calendar(key, mom, now) {
    var output = this._calendar[key] || this._calendar["sameElse"];
    return isFunction(output) ? output.call(mom, now) : output;
  }

  var defaultLongDateFormat = {
    LTS: "h:mm:ss A",
    LT: "h:mm A",
    L: "MM/DD/YYYY",
    LL: "MMMM D, YYYY",
    LLL: "MMMM D, YYYY h:mm A",
    LLLL: "dddd, MMMM D, YYYY h:mm A",
  };

  function longDateFormat(key) {
    var format = this._longDateFormat[key],
      formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
      return format;
    }

    this._longDateFormat[key] = formatUpper.replace(
      /MMMM|MM|DD|dddd/g,
      function (val) {
        return val.slice(1);
      }
    );

    return this._longDateFormat[key];
  }

  var defaultInvalidDate = "Invalid date";

  function invalidDate() {
    return this._invalidDate;
  }

  var defaultOrdinal = "%d";
  var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

  function ordinal(number) {
    return this._ordinal.replace("%d", number);
  }

  var defaultRelativeTime = {
    future: "in %s",
    past: "%s ago",
    s: "a few seconds",
    ss: "%d seconds",
    m: "a minute",
    mm: "%d minutes",
    h: "an hour",
    hh: "%d hours",
    d: "a day",
    dd: "%d days",
    M: "a month",
    MM: "%d months",
    y: "a year",
    yy: "%d years",
  };

  function relativeTime(number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return isFunction(output)
      ? output(number, withoutSuffix, string, isFuture)
      : output.replace(/%d/i, number);
  }

  function pastFuture(diff, output) {
    var format = this._relativeTime[diff > 0 ? "future" : "past"];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
  }

  var aliases = {};

  function addUnitAlias(unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
  }

  function normalizeUnits(units) {
    return typeof units === "string"
      ? aliases[units] || aliases[units.toLowerCase()]
      : undefined;
  }

  function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
      normalizedProp,
      prop;

    for (prop in inputObject) {
      if (hasOwnProp(inputObject, prop)) {
        normalizedProp = normalizeUnits(prop);
        if (normalizedProp) {
          normalizedInput[normalizedProp] = inputObject[prop];
        }
      }
    }

    return normalizedInput;
  }

  var priorities = {};

  function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
  }

  function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
      units.push({ unit: u, priority: priorities[u] });
    }
    units.sort(function (a, b) {
      return a.priority - b.priority;
    });
    return units;
  }

  function zeroFill(number, targetLength, forceSign) {
    var absNumber = "" + Math.abs(number),
      zerosToFill = targetLength - absNumber.length,
      sign = number >= 0;
    return (
      (sign ? (forceSign ? "+" : "") : "-") +
      Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
      absNumber
    );
  }

  var formattingTokens =
    /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

  var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

  var formatFunctions = {};

  var formatTokenFunctions = {};

  // token:    'M'
  // padded:   ['MM', 2]
  // ordinal:  'Mo'
  // callback: function () { this.month() + 1 }
  function addFormatToken(token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === "string") {
      func = function () {
        return this[callback]();
      };
    }
    if (token) {
      formatTokenFunctions[token] = func;
    }
    if (padded) {
      formatTokenFunctions[padded[0]] = function () {
        return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
      };
    }
    if (ordinal) {
      formatTokenFunctions[ordinal] = function () {
        return this.localeData().ordinal(func.apply(this, arguments), token);
      };
    }
  }

  function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
      return input.replace(/^\[|\]$/g, "");
    }
    return input.replace(/\\/g, "");
  }

  function makeFormatFunction(format) {
    var array = format.match(formattingTokens),
      i,
      length;

    for (i = 0, length = array.length; i < length; i++) {
      if (formatTokenFunctions[array[i]]) {
        array[i] = formatTokenFunctions[array[i]];
      } else {
        array[i] = removeFormattingTokens(array[i]);
      }
    }

    return function (mom) {
      var output = "",
        i;
      for (i = 0; i < length; i++) {
        output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
      }
      return output;
    };
  }

  // format date using native date object
  function formatMoment(m, format) {
    if (!m.isValid()) {
      return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] =
      formatFunctions[format] || makeFormatFunction(format);

    return formatFunctions[format](m);
  }

  function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
      return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
      format = format.replace(
        localFormattingTokens,
        replaceLongDateFormatTokens
      );
      localFormattingTokens.lastIndex = 0;
      i -= 1;
    }

    return format;
  }

  var match1 = /\d/; //       0 - 9
  var match2 = /\d\d/; //      00 - 99
  var match3 = /\d{3}/; //     000 - 999
  var match4 = /\d{4}/; //    0000 - 9999
  var match6 = /[+-]?\d{6}/; // -999999 - 999999
  var match1to2 = /\d\d?/; //       0 - 99
  var match3to4 = /\d\d\d\d?/; //     999 - 9999
  var match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999
  var match1to3 = /\d{1,3}/; //       0 - 999
  var match1to4 = /\d{1,4}/; //       0 - 9999
  var match1to6 = /[+-]?\d{1,6}/; // -999999 - 999999

  var matchUnsigned = /\d+/; //       0 - inf
  var matchSigned = /[+-]?\d+/; //    -inf - inf

  var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
  var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

  var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

  // any word (or two) characters or numbers including two/three word month in arabic.
  // includes scottish gaelic two word and hyphenated months
  var matchWord =
    /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

  var regexes = {};

  function addRegexToken(token, regex, strictRegex) {
    regexes[token] = isFunction(regex)
      ? regex
      : function (isStrict, localeData) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
  }

  function getParseRegexForToken(token, config) {
    if (!hasOwnProp(regexes, token)) {
      return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
  }

  // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
  function unescapeFormat(s) {
    return regexEscape(
      s
        .replace("\\", "")
        .replace(
          /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
          function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
          }
        )
    );
  }

  function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
  }

  var tokens = {};

  function addParseToken(token, callback) {
    var i,
      func = callback;
    if (typeof token === "string") {
      token = [token];
    }
    if (isNumber(callback)) {
      func = function (input, array) {
        array[callback] = toInt(input);
      };
    }
    for (i = 0; i < token.length; i++) {
      tokens[token[i]] = func;
    }
  }

  function addWeekParseToken(token, callback) {
    addParseToken(token, function (input, array, config, token) {
      config._w = config._w || {};
      callback(input, config._w, config, token);
    });
  }

  function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
      tokens[token](input, config._a, config, token);
    }
  }

  var YEAR = 0;
  var MONTH = 1;
  var DATE = 2;
  var HOUR = 3;
  var MINUTE = 4;
  var SECOND = 5;
  var MILLISECOND = 6;
  var WEEK = 7;
  var WEEKDAY = 8;

  // FORMATTING

  addFormatToken("Y", 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? "" + y : "+" + y;
  });

  addFormatToken(0, ["YY", 2], 0, function () {
    return this.year() % 100;
  });

  addFormatToken(0, ["YYYY", 4], 0, "year");
  addFormatToken(0, ["YYYYY", 5], 0, "year");
  addFormatToken(0, ["YYYYYY", 6, true], 0, "year");

  // ALIASES

  addUnitAlias("year", "y");

  // PRIORITIES

  addUnitPriority("year", 1);

  // PARSING

  addRegexToken("Y", matchSigned);
  addRegexToken("YY", match1to2, match2);
  addRegexToken("YYYY", match1to4, match4);
  addRegexToken("YYYYY", match1to6, match6);
  addRegexToken("YYYYYY", match1to6, match6);

  addParseToken(["YYYYY", "YYYYYY"], YEAR);
  addParseToken("YYYY", function (input, array) {
    array[YEAR] =
      input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
  });
  addParseToken("YY", function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
  });
  addParseToken("Y", function (input, array) {
    array[YEAR] = parseInt(input, 10);
  });

  // HELPERS

  function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
  }

  function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
  }

  // HOOKS

  hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
  };

  // MOMENTS

  var getSetYear = makeGetSet("FullYear", true);

  function getIsLeapYear() {
    return isLeapYear(this.year());
  }

  function makeGetSet(unit, keepTime) {
    return function (value) {
      if (value != null) {
        set$1(this, unit, value);
        hooks.updateOffset(this, keepTime);
        return this;
      } else {
        return get(this, unit);
      }
    };
  }

  function get(mom, unit) {
    return mom.isValid()
      ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]()
      : NaN;
  }

  function set$1(mom, unit, value) {
    if (mom.isValid() && !isNaN(value)) {
      if (
        unit === "FullYear" &&
        isLeapYear(mom.year()) &&
        mom.month() === 1 &&
        mom.date() === 29
      ) {
        mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
          value,
          mom.month(),
          daysInMonth(value, mom.month())
        );
      } else {
        mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
      }
    }
  }

  // MOMENTS

  function stringGet(units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
      return this[units]();
    }
    return this;
  }

  function stringSet(units, value) {
    if (typeof units === "object") {
      units = normalizeObjectUnits(units);
      var prioritized = getPrioritizedUnits(units);
      for (var i = 0; i < prioritized.length; i++) {
        this[prioritized[i].unit](units[prioritized[i].unit]);
      }
    } else {
      units = normalizeUnits(units);
      if (isFunction(this[units])) {
        return this[units](value);
      }
    }
    return this;
  }

  function mod(n, x) {
    return ((n % x) + x) % x;
  }

  var indexOf;

  if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
  } else {
    indexOf = function (o) {
      // I know
      var i;
      for (i = 0; i < this.length; ++i) {
        if (this[i] === o) {
          return i;
        }
      }
      return -1;
    };
  }

  function daysInMonth(year, month) {
    if (isNaN(year) || isNaN(month)) {
      return NaN;
    }
    var modMonth = mod(month, 12);
    year += (month - modMonth) / 12;
    return modMonth === 1
      ? isLeapYear(year)
        ? 29
        : 28
      : 31 - ((modMonth % 7) % 2);
  }

  // FORMATTING

  addFormatToken("M", ["MM", 2], "Mo", function () {
    return this.month() + 1;
  });

  addFormatToken("MMM", 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
  });

  addFormatToken("MMMM", 0, 0, function (format) {
    return this.localeData().months(this, format);
  });

  // ALIASES

  addUnitAlias("month", "M");

  // PRIORITY

  addUnitPriority("month", 8);

  // PARSING

  addRegexToken("M", match1to2);
  addRegexToken("MM", match1to2, match2);
  addRegexToken("MMM", function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
  });
  addRegexToken("MMMM", function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
  });

  addParseToken(["M", "MM"], function (input, array) {
    array[MONTH] = toInt(input) - 1;
  });

  addParseToken(["MMM", "MMMM"], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
      array[MONTH] = month;
    } else {
      getParsingFlags(config).invalidMonth = input;
    }
  });

  // LOCALES

  var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
  var defaultLocaleMonths =
    "January_February_March_April_May_June_July_August_September_October_November_December".split(
      "_"
    );
  function localeMonths(m, format) {
    if (!m) {
      return isArray(this._months) ? this._months : this._months["standalone"];
    }
    return isArray(this._months)
      ? this._months[m.month()]
      : this._months[
          (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
            ? "format"
            : "standalone"
        ][m.month()];
  }

  var defaultLocaleMonthsShort =
    "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");
  function localeMonthsShort(m, format) {
    if (!m) {
      return isArray(this._monthsShort)
        ? this._monthsShort
        : this._monthsShort["standalone"];
    }
    return isArray(this._monthsShort)
      ? this._monthsShort[m.month()]
      : this._monthsShort[
          MONTHS_IN_FORMAT.test(format) ? "format" : "standalone"
        ][m.month()];
  }

  function handleStrictParse(monthName, format, strict) {
    var i,
      ii,
      mom,
      llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
      // this is not used
      this._monthsParse = [];
      this._longMonthsParse = [];
      this._shortMonthsParse = [];
      for (i = 0; i < 12; ++i) {
        mom = createUTC([2000, i]);
        this._shortMonthsParse[i] = this.monthsShort(
          mom,
          ""
        ).toLocaleLowerCase();
        this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
      }
    }

    if (strict) {
      if (format === "MMM") {
        ii = indexOf.call(this._shortMonthsParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._longMonthsParse, llc);
        return ii !== -1 ? ii : null;
      }
    } else {
      if (format === "MMM") {
        ii = indexOf.call(this._shortMonthsParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._longMonthsParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._longMonthsParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._shortMonthsParse, llc);
        return ii !== -1 ? ii : null;
      }
    }
  }

  function localeMonthsParse(monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
      return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
      this._monthsParse = [];
      this._longMonthsParse = [];
      this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
      // make the regex if we don't have it already
      mom = createUTC([2000, i]);
      if (strict && !this._longMonthsParse[i]) {
        this._longMonthsParse[i] = new RegExp(
          "^" + this.months(mom, "").replace(".", "") + "$",
          "i"
        );
        this._shortMonthsParse[i] = new RegExp(
          "^" + this.monthsShort(mom, "").replace(".", "") + "$",
          "i"
        );
      }
      if (!strict && !this._monthsParse[i]) {
        regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
        this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
      }
      // test the regex
      if (
        strict &&
        format === "MMMM" &&
        this._longMonthsParse[i].test(monthName)
      ) {
        return i;
      } else if (
        strict &&
        format === "MMM" &&
        this._shortMonthsParse[i].test(monthName)
      ) {
        return i;
      } else if (!strict && this._monthsParse[i].test(monthName)) {
        return i;
      }
    }
  }

  // MOMENTS

  function setMonth(mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
      // No op
      return mom;
    }

    if (typeof value === "string") {
      if (/^\d+$/.test(value)) {
        value = toInt(value);
      } else {
        value = mom.localeData().monthsParse(value);
        // TODO: Another silent failure?
        if (!isNumber(value)) {
          return mom;
        }
      }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
    return mom;
  }

  function getSetMonth(value) {
    if (value != null) {
      setMonth(this, value);
      hooks.updateOffset(this, true);
      return this;
    } else {
      return get(this, "Month");
    }
  }

  function getDaysInMonth() {
    return daysInMonth(this.year(), this.month());
  }

  var defaultMonthsShortRegex = matchWord;
  function monthsShortRegex(isStrict) {
    if (this._monthsParseExact) {
      if (!hasOwnProp(this, "_monthsRegex")) {
        computeMonthsParse.call(this);
      }
      if (isStrict) {
        return this._monthsShortStrictRegex;
      } else {
        return this._monthsShortRegex;
      }
    } else {
      if (!hasOwnProp(this, "_monthsShortRegex")) {
        this._monthsShortRegex = defaultMonthsShortRegex;
      }
      return this._monthsShortStrictRegex && isStrict
        ? this._monthsShortStrictRegex
        : this._monthsShortRegex;
    }
  }

  var defaultMonthsRegex = matchWord;
  function monthsRegex(isStrict) {
    if (this._monthsParseExact) {
      if (!hasOwnProp(this, "_monthsRegex")) {
        computeMonthsParse.call(this);
      }
      if (isStrict) {
        return this._monthsStrictRegex;
      } else {
        return this._monthsRegex;
      }
    } else {
      if (!hasOwnProp(this, "_monthsRegex")) {
        this._monthsRegex = defaultMonthsRegex;
      }
      return this._monthsStrictRegex && isStrict
        ? this._monthsStrictRegex
        : this._monthsRegex;
    }
  }

  function computeMonthsParse() {
    function cmpLenRev(a, b) {
      return b.length - a.length;
    }

    var shortPieces = [],
      longPieces = [],
      mixedPieces = [],
      i,
      mom;
    for (i = 0; i < 12; i++) {
      // make the regex if we don't have it already
      mom = createUTC([2000, i]);
      shortPieces.push(this.monthsShort(mom, ""));
      longPieces.push(this.months(mom, ""));
      mixedPieces.push(this.months(mom, ""));
      mixedPieces.push(this.monthsShort(mom, ""));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
      shortPieces[i] = regexEscape(shortPieces[i]);
      longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
      mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp(
      "^(" + longPieces.join("|") + ")",
      "i"
    );
    this._monthsShortStrictRegex = new RegExp(
      "^(" + shortPieces.join("|") + ")",
      "i"
    );
  }

  function createDate(y, m, d, h, M, s, ms) {
    // can't just apply() to create a date:
    // https://stackoverflow.com/q/181348
    var date = new Date(y, m, d, h, M, s, ms);

    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
      date.setFullYear(y);
    }
    return date;
  }

  function createUTCDate(y) {
    var date = new Date(Date.UTC.apply(null, arguments));

    // the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
      date.setUTCFullYear(y);
    }
    return date;
  }

  // start-of-first-week - start-of-year
  function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
      fwd = 7 + dow - doy,
      // first-week day local weekday -- which local weekday is fwd
      fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

    return -fwdlw + fwd - 1;
  }

  // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
  function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
      weekOffset = firstWeekOffset(year, dow, doy),
      dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
      resYear,
      resDayOfYear;

    if (dayOfYear <= 0) {
      resYear = year - 1;
      resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
      resYear = year + 1;
      resDayOfYear = dayOfYear - daysInYear(year);
    } else {
      resYear = year;
      resDayOfYear = dayOfYear;
    }

    return {
      year: resYear,
      dayOfYear: resDayOfYear,
    };
  }

  function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
      week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
      resWeek,
      resYear;

    if (week < 1) {
      resYear = mom.year() - 1;
      resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
      resWeek = week - weeksInYear(mom.year(), dow, doy);
      resYear = mom.year() + 1;
    } else {
      resYear = mom.year();
      resWeek = week;
    }

    return {
      week: resWeek,
      year: resYear,
    };
  }

  function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
      weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
  }

  // FORMATTING

  addFormatToken("w", ["ww", 2], "wo", "week");
  addFormatToken("W", ["WW", 2], "Wo", "isoWeek");

  // ALIASES

  addUnitAlias("week", "w");
  addUnitAlias("isoWeek", "W");

  // PRIORITIES

  addUnitPriority("week", 5);
  addUnitPriority("isoWeek", 5);

  // PARSING

  addRegexToken("w", match1to2);
  addRegexToken("ww", match1to2, match2);
  addRegexToken("W", match1to2);
  addRegexToken("WW", match1to2, match2);

  addWeekParseToken(
    ["w", "ww", "W", "WW"],
    function (input, week, config, token) {
      week[token.substr(0, 1)] = toInt(input);
    }
  );

  // HELPERS

  // LOCALES

  function localeWeek(mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
  }

  var defaultLocaleWeek = {
    dow: 0, // Sunday is the first day of the week.
    doy: 6, // The week that contains Jan 1st is the first week of the year.
  };

  function localeFirstDayOfWeek() {
    return this._week.dow;
  }

  function localeFirstDayOfYear() {
    return this._week.doy;
  }

  // MOMENTS

  function getSetWeek(input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, "d");
  }

  function getSetISOWeek(input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, "d");
  }

  // FORMATTING

  addFormatToken("d", 0, "do", "day");

  addFormatToken("dd", 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
  });

  addFormatToken("ddd", 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
  });

  addFormatToken("dddd", 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
  });

  addFormatToken("e", 0, 0, "weekday");
  addFormatToken("E", 0, 0, "isoWeekday");

  // ALIASES

  addUnitAlias("day", "d");
  addUnitAlias("weekday", "e");
  addUnitAlias("isoWeekday", "E");

  // PRIORITY
  addUnitPriority("day", 11);
  addUnitPriority("weekday", 11);
  addUnitPriority("isoWeekday", 11);

  // PARSING

  addRegexToken("d", match1to2);
  addRegexToken("e", match1to2);
  addRegexToken("E", match1to2);
  addRegexToken("dd", function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
  });
  addRegexToken("ddd", function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
  });
  addRegexToken("dddd", function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
  });

  addWeekParseToken(
    ["dd", "ddd", "dddd"],
    function (input, week, config, token) {
      var weekday = config._locale.weekdaysParse(input, token, config._strict);
      // if we didn't get a weekday name, mark the date as invalid
      if (weekday != null) {
        week.d = weekday;
      } else {
        getParsingFlags(config).invalidWeekday = input;
      }
    }
  );

  addWeekParseToken(["d", "e", "E"], function (input, week, config, token) {
    week[token] = toInt(input);
  });

  // HELPERS

  function parseWeekday(input, locale) {
    if (typeof input !== "string") {
      return input;
    }

    if (!isNaN(input)) {
      return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);
    if (typeof input === "number") {
      return input;
    }

    return null;
  }

  function parseIsoWeekday(input, locale) {
    if (typeof input === "string") {
      return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
  }

  // LOCALES

  var defaultLocaleWeekdays =
    "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");
  function localeWeekdays(m, format) {
    if (!m) {
      return isArray(this._weekdays)
        ? this._weekdays
        : this._weekdays["standalone"];
    }
    return isArray(this._weekdays)
      ? this._weekdays[m.day()]
      : this._weekdays[
          this._weekdays.isFormat.test(format) ? "format" : "standalone"
        ][m.day()];
  }

  var defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");
  function localeWeekdaysShort(m) {
    return m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
  }

  var defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");
  function localeWeekdaysMin(m) {
    return m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
  }

  function handleStrictParse$1(weekdayName, format, strict) {
    var i,
      ii,
      mom,
      llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
      this._weekdaysParse = [];
      this._shortWeekdaysParse = [];
      this._minWeekdaysParse = [];

      for (i = 0; i < 7; ++i) {
        mom = createUTC([2000, 1]).day(i);
        this._minWeekdaysParse[i] = this.weekdaysMin(
          mom,
          ""
        ).toLocaleLowerCase();
        this._shortWeekdaysParse[i] = this.weekdaysShort(
          mom,
          ""
        ).toLocaleLowerCase();
        this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
      }
    }

    if (strict) {
      if (format === "dddd") {
        ii = indexOf.call(this._weekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else if (format === "ddd") {
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      }
    } else {
      if (format === "dddd") {
        ii = indexOf.call(this._weekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else if (format === "ddd") {
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._weekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._minWeekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._weekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      }
    }
  }

  function localeWeekdaysParse(weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
      return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
      this._weekdaysParse = [];
      this._minWeekdaysParse = [];
      this._shortWeekdaysParse = [];
      this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
      // make the regex if we don't have it already

      mom = createUTC([2000, 1]).day(i);
      if (strict && !this._fullWeekdaysParse[i]) {
        this._fullWeekdaysParse[i] = new RegExp(
          "^" + this.weekdays(mom, "").replace(".", ".?") + "$",
          "i"
        );
        this._shortWeekdaysParse[i] = new RegExp(
          "^" + this.weekdaysShort(mom, "").replace(".", ".?") + "$",
          "i"
        );
        this._minWeekdaysParse[i] = new RegExp(
          "^" + this.weekdaysMin(mom, "").replace(".", ".?") + "$",
          "i"
        );
      }
      if (!this._weekdaysParse[i]) {
        regex =
          "^" +
          this.weekdays(mom, "") +
          "|^" +
          this.weekdaysShort(mom, "") +
          "|^" +
          this.weekdaysMin(mom, "");
        this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
      }
      // test the regex
      if (
        strict &&
        format === "dddd" &&
        this._fullWeekdaysParse[i].test(weekdayName)
      ) {
        return i;
      } else if (
        strict &&
        format === "ddd" &&
        this._shortWeekdaysParse[i].test(weekdayName)
      ) {
        return i;
      } else if (
        strict &&
        format === "dd" &&
        this._minWeekdaysParse[i].test(weekdayName)
      ) {
        return i;
      } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
        return i;
      }
    }
  }

  // MOMENTS

  function getSetDayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
      input = parseWeekday(input, this.localeData());
      return this.add(input - day, "d");
    } else {
      return day;
    }
  }

  function getSetLocaleDayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, "d");
  }

  function getSetISODayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
      var weekday = parseIsoWeekday(input, this.localeData());
      return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
      return this.day() || 7;
    }
  }

  var defaultWeekdaysRegex = matchWord;
  function weekdaysRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, "_weekdaysRegex")) {
        computeWeekdaysParse.call(this);
      }
      if (isStrict) {
        return this._weekdaysStrictRegex;
      } else {
        return this._weekdaysRegex;
      }
    } else {
      if (!hasOwnProp(this, "_weekdaysRegex")) {
        this._weekdaysRegex = defaultWeekdaysRegex;
      }
      return this._weekdaysStrictRegex && isStrict
        ? this._weekdaysStrictRegex
        : this._weekdaysRegex;
    }
  }

  var defaultWeekdaysShortRegex = matchWord;
  function weekdaysShortRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, "_weekdaysRegex")) {
        computeWeekdaysParse.call(this);
      }
      if (isStrict) {
        return this._weekdaysShortStrictRegex;
      } else {
        return this._weekdaysShortRegex;
      }
    } else {
      if (!hasOwnProp(this, "_weekdaysShortRegex")) {
        this._weekdaysShortRegex = defaultWeekdaysShortRegex;
      }
      return this._weekdaysShortStrictRegex && isStrict
        ? this._weekdaysShortStrictRegex
        : this._weekdaysShortRegex;
    }
  }

  var defaultWeekdaysMinRegex = matchWord;
  function weekdaysMinRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, "_weekdaysRegex")) {
        computeWeekdaysParse.call(this);
      }
      if (isStrict) {
        return this._weekdaysMinStrictRegex;
      } else {
        return this._weekdaysMinRegex;
      }
    } else {
      if (!hasOwnProp(this, "_weekdaysMinRegex")) {
        this._weekdaysMinRegex = defaultWeekdaysMinRegex;
      }
      return this._weekdaysMinStrictRegex && isStrict
        ? this._weekdaysMinStrictRegex
        : this._weekdaysMinRegex;
    }
  }

  function computeWeekdaysParse() {
    function cmpLenRev(a, b) {
      return b.length - a.length;
    }

    var minPieces = [],
      shortPieces = [],
      longPieces = [],
      mixedPieces = [],
      i,
      mom,
      minp,
      shortp,
      longp;
    for (i = 0; i < 7; i++) {
      // make the regex if we don't have it already
      mom = createUTC([2000, 1]).day(i);
      minp = this.weekdaysMin(mom, "");
      shortp = this.weekdaysShort(mom, "");
      longp = this.weekdays(mom, "");
      minPieces.push(minp);
      shortPieces.push(shortp);
      longPieces.push(longp);
      mixedPieces.push(minp);
      mixedPieces.push(shortp);
      mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
      shortPieces[i] = regexEscape(shortPieces[i]);
      longPieces[i] = regexEscape(longPieces[i]);
      mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;

    this._weekdaysStrictRegex = new RegExp(
      "^(" + longPieces.join("|") + ")",
      "i"
    );
    this._weekdaysShortStrictRegex = new RegExp(
      "^(" + shortPieces.join("|") + ")",
      "i"
    );
    this._weekdaysMinStrictRegex = new RegExp(
      "^(" + minPieces.join("|") + ")",
      "i"
    );
  }

  // FORMATTING

  function hFormat() {
    return this.hours() % 12 || 12;
  }

  function kFormat() {
    return this.hours() || 24;
  }

  addFormatToken("H", ["HH", 2], 0, "hour");
  addFormatToken("h", ["hh", 2], 0, hFormat);
  addFormatToken("k", ["kk", 2], 0, kFormat);

  addFormatToken("hmm", 0, 0, function () {
    return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
  });

  addFormatToken("hmmss", 0, 0, function () {
    return (
      "" +
      hFormat.apply(this) +
      zeroFill(this.minutes(), 2) +
      zeroFill(this.seconds(), 2)
    );
  });

  addFormatToken("Hmm", 0, 0, function () {
    return "" + this.hours() + zeroFill(this.minutes(), 2);
  });

  addFormatToken("Hmmss", 0, 0, function () {
    return (
      "" +
      this.hours() +
      zeroFill(this.minutes(), 2) +
      zeroFill(this.seconds(), 2)
    );
  });

  function meridiem(token, lowercase) {
    addFormatToken(token, 0, 0, function () {
      return this.localeData().meridiem(
        this.hours(),
        this.minutes(),
        lowercase
      );
    });
  }

  meridiem("a", true);
  meridiem("A", false);

  // ALIASES

  addUnitAlias("hour", "h");

  // PRIORITY
  addUnitPriority("hour", 13);

  // PARSING

  function matchMeridiem(isStrict, locale) {
    return locale._meridiemParse;
  }

  addRegexToken("a", matchMeridiem);
  addRegexToken("A", matchMeridiem);
  addRegexToken("H", match1to2);
  addRegexToken("h", match1to2);
  addRegexToken("k", match1to2);
  addRegexToken("HH", match1to2, match2);
  addRegexToken("hh", match1to2, match2);
  addRegexToken("kk", match1to2, match2);

  addRegexToken("hmm", match3to4);
  addRegexToken("hmmss", match5to6);
  addRegexToken("Hmm", match3to4);
  addRegexToken("Hmmss", match5to6);

  addParseToken(["H", "HH"], HOUR);
  addParseToken(["k", "kk"], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
  });
  addParseToken(["a", "A"], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
  });
  addParseToken(["h", "hh"], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
  });
  addParseToken("hmm", function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
  });
  addParseToken("hmmss", function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
  });
  addParseToken("Hmm", function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
  });
  addParseToken("Hmmss", function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
  });

  // LOCALES

  function localeIsPM(input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return (input + "").toLowerCase().charAt(0) === "p";
  }

  var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
  function localeMeridiem(hours, minutes, isLower) {
    if (hours > 11) {
      return isLower ? "pm" : "PM";
    } else {
      return isLower ? "am" : "AM";
    }
  }

  // MOMENTS

  // Setting the hour should keep the time, because the user explicitly
  // specified which hour he wants. So trying to maintain the same hour (in
  // a new timezone) makes sense. Adding/subtracting hours does not follow
  // this rule.
  var getSetHour = makeGetSet("Hours", true);

  var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,

    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,

    week: defaultLocaleWeek,

    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,

    meridiemParse: defaultLocaleMeridiemParse,
  };

  // internal storage for locale config files
  var locales = {};
  var localeFamilies = {};
  var globalLocale;

  function normalizeLocale(key) {
    return key ? key.toLowerCase().replace("_", "-") : key;
  }

  // pick the locale from the array
  // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
  // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
  function chooseLocale(names) {
    var i = 0,
      j,
      next,
      locale,
      split;

    while (i < names.length) {
      split = normalizeLocale(names[i]).split("-");
      j = split.length;
      next = normalizeLocale(names[i + 1]);
      next = next ? next.split("-") : null;
      while (j > 0) {
        locale = loadLocale(split.slice(0, j).join("-"));
        if (locale) {
          return locale;
        }
        if (
          next &&
          next.length >= j &&
          compareArrays(split, next, true) >= j - 1
        ) {
          //the next array item is better than a shallower substring of this one
          break;
        }
        j--;
      }
      i++;
    }
    return globalLocale;
  }

  function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (
      !locales[name] &&
      typeof module !== "undefined" &&
      module &&
      module.exports
    ) {
      try {
        oldLocale = globalLocale._abbr;
        var aliasedRequire = require;
        aliasedRequire("./locale/" + name);
        getSetGlobalLocale(oldLocale);
      } catch (e) {}
    }
    return locales[name];
  }

  // This function will load locale and then set the global locale.  If
  // no arguments are passed in, it will simply return the current global
  // locale key.
  function getSetGlobalLocale(key, values) {
    var data;
    if (key) {
      if (isUndefined(values)) {
        data = getLocale(key);
      } else {
        data = defineLocale(key, values);
      }

      if (data) {
        // moment.duration._locale = moment._locale = data;
        globalLocale = data;
      } else {
        if (typeof console !== "undefined" && console.warn) {
          //warn user if arguments are passed but the locale could not be set
          console.warn(
            "Locale " + key + " not found. Did you forget to load it?"
          );
        }
      }
    }

    return globalLocale._abbr;
  }

  function defineLocale(name, config) {
    if (config !== null) {
      var locale,
        parentConfig = baseConfig;
      config.abbr = name;
      if (locales[name] != null) {
        deprecateSimple(
          "defineLocaleOverride",
          "use moment.updateLocale(localeName, config) to change " +
            "an existing locale. moment.defineLocale(localeName, " +
            "config) should only be used for creating a new locale " +
            "See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
        );
        parentConfig = locales[name]._config;
      } else if (config.parentLocale != null) {
        if (locales[config.parentLocale] != null) {
          parentConfig = locales[config.parentLocale]._config;
        } else {
          locale = loadLocale(config.parentLocale);
          if (locale != null) {
            parentConfig = locale._config;
          } else {
            if (!localeFamilies[config.parentLocale]) {
              localeFamilies[config.parentLocale] = [];
            }
            localeFamilies[config.parentLocale].push({
              name: name,
              config: config,
            });
            return null;
          }
        }
      }
      locales[name] = new Locale(mergeConfigs(parentConfig, config));

      if (localeFamilies[name]) {
        localeFamilies[name].forEach(function (x) {
          defineLocale(x.name, x.config);
        });
      }

      // backwards compat for now: also set the locale
      // make sure we set the locale AFTER all child locales have been
      // created, so we won't end up with the child locale set.
      getSetGlobalLocale(name);

      return locales[name];
    } else {
      // useful for testing
      delete locales[name];
      return null;
    }
  }

  function updateLocale(name, config) {
    if (config != null) {
      var locale,
        tmpLocale,
        parentConfig = baseConfig;
      // MERGE
      tmpLocale = loadLocale(name);
      if (tmpLocale != null) {
        parentConfig = tmpLocale._config;
      }
      config = mergeConfigs(parentConfig, config);
      locale = new Locale(config);
      locale.parentLocale = locales[name];
      locales[name] = locale;

      // backwards compat for now: also set the locale
      getSetGlobalLocale(name);
    } else {
      // pass null for config to unupdate, useful for tests
      if (locales[name] != null) {
        if (locales[name].parentLocale != null) {
          locales[name] = locales[name].parentLocale;
        } else if (locales[name] != null) {
          delete locales[name];
        }
      }
    }
    return locales[name];
  }

  // returns locale data
  function getLocale(key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
      key = key._locale._abbr;
    }

    if (!key) {
      return globalLocale;
    }

    if (!isArray(key)) {
      //short-circuit everything else
      locale = loadLocale(key);
      if (locale) {
        return locale;
      }
      key = [key];
    }

    return chooseLocale(key);
  }

  function listLocales() {
    return keys(locales);
  }

  function checkOverflow(m) {
    var overflow;
    var a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
      overflow =
        a[MONTH] < 0 || a[MONTH] > 11
          ? MONTH
          : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
          ? DATE
          : a[HOUR] < 0 ||
            a[HOUR] > 24 ||
            (a[HOUR] === 24 &&
              (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0))
          ? HOUR
          : a[MINUTE] < 0 || a[MINUTE] > 59
          ? MINUTE
          : a[SECOND] < 0 || a[SECOND] > 59
          ? SECOND
          : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
          ? MILLISECOND
          : -1;

      if (
        getParsingFlags(m)._overflowDayOfYear &&
        (overflow < YEAR || overflow > DATE)
      ) {
        overflow = DATE;
      }
      if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
        overflow = WEEK;
      }
      if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
        overflow = WEEKDAY;
      }

      getParsingFlags(m).overflow = overflow;
    }

    return m;
  }

  // Pick the first defined of two or three arguments.
  function defaults(a, b, c) {
    if (a != null) {
      return a;
    }
    if (b != null) {
      return b;
    }
    return c;
  }

  function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
      return [
        nowValue.getUTCFullYear(),
        nowValue.getUTCMonth(),
        nowValue.getUTCDate(),
      ];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
  }

  // convert an array to a date.
  // the array should mirror the parameters below
  // note: all values past the year are optional and will default to the lowest possible value.
  // [year, month, day , hour, minute, second, millisecond]
  function configFromArray(config) {
    var i,
      date,
      input = [],
      currentDate,
      expectedWeekday,
      yearToUse;

    if (config._d) {
      return;
    }

    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
      dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear != null) {
      yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

      if (
        config._dayOfYear > daysInYear(yearToUse) ||
        config._dayOfYear === 0
      ) {
        getParsingFlags(config)._overflowDayOfYear = true;
      }

      date = createUTCDate(yearToUse, 0, config._dayOfYear);
      config._a[MONTH] = date.getUTCMonth();
      config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
      config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
      config._a[i] = input[i] =
        config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
    }

    // Check for 24:00:00.000
    if (
      config._a[HOUR] === 24 &&
      config._a[MINUTE] === 0 &&
      config._a[SECOND] === 0 &&
      config._a[MILLISECOND] === 0
    ) {
      config._nextDay = true;
      config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(
      null,
      input
    );
    expectedWeekday = config._useUTC
      ? config._d.getUTCDay()
      : config._d.getDay();

    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
      config._a[HOUR] = 24;
    }

    // check for mismatching day of week
    if (
      config._w &&
      typeof config._w.d !== "undefined" &&
      config._w.d !== expectedWeekday
    ) {
      getParsingFlags(config).weekdayMismatch = true;
    }
  }

  function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
      dow = 1;
      doy = 4;

      // TODO: We need to take the current isoWeekYear, but that depends on
      // how we interpret now (local, utc, fixed offset). So create
      // a now version of current config (take local/utc/offset flags, and
      // create now).
      weekYear = defaults(
        w.GG,
        config._a[YEAR],
        weekOfYear(createLocal(), 1, 4).year
      );
      week = defaults(w.W, 1);
      weekday = defaults(w.E, 1);
      if (weekday < 1 || weekday > 7) {
        weekdayOverflow = true;
      }
    } else {
      dow = config._locale._week.dow;
      doy = config._locale._week.doy;

      var curWeek = weekOfYear(createLocal(), dow, doy);

      weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

      // Default to current week.
      week = defaults(w.w, curWeek.week);

      if (w.d != null) {
        // weekday -- low day numbers are considered next week
        weekday = w.d;
        if (weekday < 0 || weekday > 6) {
          weekdayOverflow = true;
        }
      } else if (w.e != null) {
        // local weekday -- counting starts from begining of week
        weekday = w.e + dow;
        if (w.e < 0 || w.e > 6) {
          weekdayOverflow = true;
        }
      } else {
        // default to begining of week
        weekday = dow;
      }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
      getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
      getParsingFlags(config)._overflowWeekday = true;
    } else {
      temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
      config._a[YEAR] = temp.year;
      config._dayOfYear = temp.dayOfYear;
    }
  }

  // iso 8601 regex
  // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
  var extendedIsoRegex =
    /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
  var basicIsoRegex =
    /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

  var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

  var isoDates = [
    ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
    ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
    ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
    ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
    ["YYYY-DDD", /\d{4}-\d{3}/],
    ["YYYY-MM", /\d{4}-\d\d/, false],
    ["YYYYYYMMDD", /[+-]\d{10}/],
    ["YYYYMMDD", /\d{8}/],
    // YYYYMM is NOT allowed by the standard
    ["GGGG[W]WWE", /\d{4}W\d{3}/],
    ["GGGG[W]WW", /\d{4}W\d{2}/, false],
    ["YYYYDDD", /\d{7}/],
  ];

  // iso time formats and regexes
  var isoTimes = [
    ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
    ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
    ["HH:mm:ss", /\d\d:\d\d:\d\d/],
    ["HH:mm", /\d\d:\d\d/],
    ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
    ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
    ["HHmmss", /\d\d\d\d\d\d/],
    ["HHmm", /\d\d\d\d/],
    ["HH", /\d\d/],
  ];

  var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

  // date from iso format
  function configFromISO(config) {
    var i,
      l,
      string = config._i,
      match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
      allowTime,
      dateFormat,
      timeFormat,
      tzFormat;

    if (match) {
      getParsingFlags(config).iso = true;

      for (i = 0, l = isoDates.length; i < l; i++) {
        if (isoDates[i][1].exec(match[1])) {
          dateFormat = isoDates[i][0];
          allowTime = isoDates[i][2] !== false;
          break;
        }
      }
      if (dateFormat == null) {
        config._isValid = false;
        return;
      }
      if (match[3]) {
        for (i = 0, l = isoTimes.length; i < l; i++) {
          if (isoTimes[i][1].exec(match[3])) {
            // match[2] should be 'T' or space
            timeFormat = (match[2] || " ") + isoTimes[i][0];
            break;
          }
        }
        if (timeFormat == null) {
          config._isValid = false;
          return;
        }
      }
      if (!allowTime && timeFormat != null) {
        config._isValid = false;
        return;
      }
      if (match[4]) {
        if (tzRegex.exec(match[4])) {
          tzFormat = "Z";
        } else {
          config._isValid = false;
          return;
        }
      }
      config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
      configFromStringAndFormat(config);
    } else {
      config._isValid = false;
    }
  }

  // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
  var rfc2822 =
    /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

  function extractFromRFC2822Strings(
    yearStr,
    monthStr,
    dayStr,
    hourStr,
    minuteStr,
    secondStr
  ) {
    var result = [
      untruncateYear(yearStr),
      defaultLocaleMonthsShort.indexOf(monthStr),
      parseInt(dayStr, 10),
      parseInt(hourStr, 10),
      parseInt(minuteStr, 10),
    ];

    if (secondStr) {
      result.push(parseInt(secondStr, 10));
    }

    return result;
  }

  function untruncateYear(yearStr) {
    var year = parseInt(yearStr, 10);
    if (year <= 49) {
      return 2000 + year;
    } else if (year <= 999) {
      return 1900 + year;
    }
    return year;
  }

  function preprocessRFC2822(s) {
    // Remove comments and folding whitespace and replace multiple-spaces with a single space
    return s
      .replace(/\([^)]*\)|[\n\t]/g, " ")
      .replace(/(\s\s+)/g, " ")
      .trim();
  }

  function checkWeekday(weekdayStr, parsedInput, config) {
    if (weekdayStr) {
      // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
      var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
        weekdayActual = new Date(
          parsedInput[0],
          parsedInput[1],
          parsedInput[2]
        ).getDay();
      if (weekdayProvided !== weekdayActual) {
        getParsingFlags(config).weekdayMismatch = true;
        config._isValid = false;
        return false;
      }
    }
    return true;
  }

  var obsOffsets = {
    UT: 0,
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60,
  };

  function calculateOffset(obsOffset, militaryOffset, numOffset) {
    if (obsOffset) {
      return obsOffsets[obsOffset];
    } else if (militaryOffset) {
      // the only allowed military tz is Z
      return 0;
    } else {
      var hm = parseInt(numOffset, 10);
      var m = hm % 100,
        h = (hm - m) / 100;
      return h * 60 + m;
    }
  }

  // date and time from ref 2822 format
  function configFromRFC2822(config) {
    var match = rfc2822.exec(preprocessRFC2822(config._i));
    if (match) {
      var parsedArray = extractFromRFC2822Strings(
        match[4],
        match[3],
        match[2],
        match[5],
        match[6],
        match[7]
      );
      if (!checkWeekday(match[1], parsedArray, config)) {
        return;
      }

      config._a = parsedArray;
      config._tzm = calculateOffset(match[8], match[9], match[10]);

      config._d = createUTCDate.apply(null, config._a);
      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

      getParsingFlags(config).rfc2822 = true;
    } else {
      config._isValid = false;
    }
  }

  // date from iso format or fallback
  function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
      config._d = new Date(+matched[1]);
      return;
    }

    configFromISO(config);
    if (config._isValid === false) {
      delete config._isValid;
    } else {
      return;
    }

    configFromRFC2822(config);
    if (config._isValid === false) {
      delete config._isValid;
    } else {
      return;
    }

    // Final attempt, use Input Fallback
    hooks.createFromInputFallback(config);
  }

  hooks.createFromInputFallback = deprecate(
    "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), " +
      "which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are " +
      "discouraged and will be removed in an upcoming major release. Please refer to " +
      "http://momentjs.com/guides/#/warnings/js-date/ for more info.",
    function (config) {
      config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
    }
  );

  // constant that refers to the ISO standard
  hooks.ISO_8601 = function () {};

  // constant that refers to the RFC 2822 form
  hooks.RFC_2822 = function () {};

  // date from string and format string
  function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
      configFromISO(config);
      return;
    }
    if (config._f === hooks.RFC_2822) {
      configFromRFC2822(config);
      return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = "" + config._i,
      i,
      parsedInput,
      tokens,
      token,
      skipped,
      stringLength = string.length,
      totalParsedInputLength = 0;

    tokens =
      expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
      token = tokens[i];
      parsedInput = (string.match(getParseRegexForToken(token, config)) ||
        [])[0];
      // console.log('token', token, 'parsedInput', parsedInput,
      //         'regex', getParseRegexForToken(token, config));
      if (parsedInput) {
        skipped = string.substr(0, string.indexOf(parsedInput));
        if (skipped.length > 0) {
          getParsingFlags(config).unusedInput.push(skipped);
        }
        string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
        totalParsedInputLength += parsedInput.length;
      }
      // don't parse if it's not a known token
      if (formatTokenFunctions[token]) {
        if (parsedInput) {
          getParsingFlags(config).empty = false;
        } else {
          getParsingFlags(config).unusedTokens.push(token);
        }
        addTimeToArrayFromToken(token, parsedInput, config);
      } else if (config._strict && !parsedInput) {
        getParsingFlags(config).unusedTokens.push(token);
      }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver =
      stringLength - totalParsedInputLength;
    if (string.length > 0) {
      getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (
      config._a[HOUR] <= 12 &&
      getParsingFlags(config).bigHour === true &&
      config._a[HOUR] > 0
    ) {
      getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(
      config._locale,
      config._a[HOUR],
      config._meridiem
    );

    configFromArray(config);
    checkOverflow(config);
  }

  function meridiemFixWrap(locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
      // nothing to do
      return hour;
    }
    if (locale.meridiemHour != null) {
      return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
      // Fallback
      isPm = locale.isPM(meridiem);
      if (isPm && hour < 12) {
        hour += 12;
      }
      if (!isPm && hour === 12) {
        hour = 0;
      }
      return hour;
    } else {
      // this is not supposed to happen
      return hour;
    }
  }

  // date from string and array of format strings
  function configFromStringAndArray(config) {
    var tempConfig, bestMoment, scoreToBeat, i, currentScore;

    if (config._f.length === 0) {
      getParsingFlags(config).invalidFormat = true;
      config._d = new Date(NaN);
      return;
    }

    for (i = 0; i < config._f.length; i++) {
      currentScore = 0;
      tempConfig = copyConfig({}, config);
      if (config._useUTC != null) {
        tempConfig._useUTC = config._useUTC;
      }
      tempConfig._f = config._f[i];
      configFromStringAndFormat(tempConfig);

      if (!isValid(tempConfig)) {
        continue;
      }

      // if there is any input that was not parsed add a penalty for that format
      currentScore += getParsingFlags(tempConfig).charsLeftOver;

      //or tokens
      currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

      getParsingFlags(tempConfig).score = currentScore;

      if (scoreToBeat == null || currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }

    extend(config, bestMoment || tempConfig);
  }

  function configFromObject(config) {
    if (config._d) {
      return;
    }

    var i = normalizeObjectUnits(config._i);
    config._a = map(
      [
        i.year,
        i.month,
        i.day || i.date,
        i.hour,
        i.minute,
        i.second,
        i.millisecond,
      ],
      function (obj) {
        return obj && parseInt(obj, 10);
      }
    );

    configFromArray(config);
  }

  function createFromConfig(config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
      // Adding is smart enough around DST
      res.add(1, "d");
      res._nextDay = undefined;
    }

    return res;
  }

  function prepareConfig(config) {
    var input = config._i,
      format = config._f;

    config._locale = config._locale || getLocale(config._l);

    if (input === null || (format === undefined && input === "")) {
      return createInvalid({ nullInput: true });
    }

    if (typeof input === "string") {
      config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
      return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
      config._d = input;
    } else if (isArray(format)) {
      configFromStringAndArray(config);
    } else if (format) {
      configFromStringAndFormat(config);
    } else {
      configFromInput(config);
    }

    if (!isValid(config)) {
      config._d = null;
    }

    return config;
  }

  function configFromInput(config) {
    var input = config._i;
    if (isUndefined(input)) {
      config._d = new Date(hooks.now());
    } else if (isDate(input)) {
      config._d = new Date(input.valueOf());
    } else if (typeof input === "string") {
      configFromString(config);
    } else if (isArray(input)) {
      config._a = map(input.slice(0), function (obj) {
        return parseInt(obj, 10);
      });
      configFromArray(config);
    } else if (isObject(input)) {
      configFromObject(config);
    } else if (isNumber(input)) {
      // from milliseconds
      config._d = new Date(input);
    } else {
      hooks.createFromInputFallback(config);
    }
  }

  function createLocalOrUTC(input, format, locale, strict, isUTC) {
    var c = {};

    if (locale === true || locale === false) {
      strict = locale;
      locale = undefined;
    }

    if (
      (isObject(input) && isObjectEmpty(input)) ||
      (isArray(input) && input.length === 0)
    ) {
      input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;

    return createFromConfig(c);
  }

  function createLocal(input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
  }

  var prototypeMin = deprecate(
    "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
    function () {
      var other = createLocal.apply(null, arguments);
      if (this.isValid() && other.isValid()) {
        return other < this ? this : other;
      } else {
        return createInvalid();
      }
    }
  );

  var prototypeMax = deprecate(
    "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
    function () {
      var other = createLocal.apply(null, arguments);
      if (this.isValid() && other.isValid()) {
        return other > this ? this : other;
      } else {
        return createInvalid();
      }
    }
  );

  // Pick a moment m from moments so that m[fn](other) is true for all
  // other. This relies on the function fn to be transitive.
  //
  // moments should either be an array of moment objects or an array, whose
  // first element is an array of moment objects.
  function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
      moments = moments[0];
    }
    if (!moments.length) {
      return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
      if (!moments[i].isValid() || moments[i][fn](res)) {
        res = moments[i];
      }
    }
    return res;
  }

  // TODO: Use [].sort instead?
  function min() {
    var args = [].slice.call(arguments, 0);

    return pickBy("isBefore", args);
  }

  function max() {
    var args = [].slice.call(arguments, 0);

    return pickBy("isAfter", args);
  }

  var now = function () {
    return Date.now ? Date.now() : +new Date();
  };

  var ordering = [
    "year",
    "quarter",
    "month",
    "week",
    "day",
    "hour",
    "minute",
    "second",
    "millisecond",
  ];

  function isDurationValid(m) {
    for (var key in m) {
      if (
        !(
          indexOf.call(ordering, key) !== -1 &&
          (m[key] == null || !isNaN(m[key]))
        )
      ) {
        return false;
      }
    }

    var unitHasDecimal = false;
    for (var i = 0; i < ordering.length; ++i) {
      if (m[ordering[i]]) {
        if (unitHasDecimal) {
          return false; // only allow non-integers for smallest unit
        }
        if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
          unitHasDecimal = true;
        }
      }
    }

    return true;
  }

  function isValid$1() {
    return this._isValid;
  }

  function createInvalid$1() {
    return createDuration(NaN);
  }

  function Duration(duration) {
    var normalizedInput = normalizeObjectUnits(duration),
      years = normalizedInput.year || 0,
      quarters = normalizedInput.quarter || 0,
      months = normalizedInput.month || 0,
      weeks = normalizedInput.week || 0,
      days = normalizedInput.day || 0,
      hours = normalizedInput.hour || 0,
      minutes = normalizedInput.minute || 0,
      seconds = normalizedInput.second || 0,
      milliseconds = normalizedInput.millisecond || 0;

    this._isValid = isDurationValid(normalizedInput);

    // representation for dateAddRemove
    this._milliseconds =
      +milliseconds +
      seconds * 1e3 + // 1000
      minutes * 6e4 + // 1000 * 60
      hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days + weeks * 7;
    // It is impossible to translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months + quarters * 3 + years * 12;

    this._data = {};

    this._locale = getLocale();

    this._bubble();
  }

  function isDuration(obj) {
    return obj instanceof Duration;
  }

  function absRound(number) {
    if (number < 0) {
      return Math.round(-1 * number) * -1;
    } else {
      return Math.round(number);
    }
  }

  // FORMATTING

  function offset(token, separator) {
    addFormatToken(token, 0, 0, function () {
      var offset = this.utcOffset();
      var sign = "+";
      if (offset < 0) {
        offset = -offset;
        sign = "-";
      }
      return (
        sign +
        zeroFill(~~(offset / 60), 2) +
        separator +
        zeroFill(~~offset % 60, 2)
      );
    });
  }

  offset("Z", ":");
  offset("ZZ", "");

  // PARSING

  addRegexToken("Z", matchShortOffset);
  addRegexToken("ZZ", matchShortOffset);
  addParseToken(["Z", "ZZ"], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
  });

  // HELPERS

  // timezone chunker
  // '+10:00' > ['10',  '00']
  // '-1530'  > ['-15', '30']
  var chunkOffset = /([\+\-]|\d\d)/gi;

  function offsetFromString(matcher, string) {
    var matches = (string || "").match(matcher);

    if (matches === null) {
      return null;
    }

    var chunk = matches[matches.length - 1] || [];
    var parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);

    return minutes === 0 ? 0 : parts[0] === "+" ? minutes : -minutes;
  }

  // Return a moment from input, that is local/utc/zone equivalent to model.
  function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
      res = model.clone();
      diff =
        (isMoment(input) || isDate(input)
          ? input.valueOf()
          : createLocal(input).valueOf()) - res.valueOf();
      // Use low-level api, because this fn is low-level api.
      res._d.setTime(res._d.valueOf() + diff);
      hooks.updateOffset(res, false);
      return res;
    } else {
      return createLocal(input).local();
    }
  }

  function getDateOffset(m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
  }

  // HOOKS

  // This function will be called whenever a moment is mutated.
  // It is intended to keep the offset in sync with the timezone.
  hooks.updateOffset = function () {};

  // MOMENTS

  // keepLocalTime = true means only change the timezone, without
  // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
  // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
  // +0200, so we adjust the time as needed, to be valid.
  //
  // Keeping the time actually adds/subtracts (one hour)
  // from the actual represented time. That is why we call updateOffset
  // a second time. In case it wants us to change the offset again
  // _changeInProgress == true case, then we have to adjust, because
  // there is no such time in the given timezone.
  function getSetOffset(input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
      localAdjust;
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    if (input != null) {
      if (typeof input === "string") {
        input = offsetFromString(matchShortOffset, input);
        if (input === null) {
          return this;
        }
      } else if (Math.abs(input) < 16 && !keepMinutes) {
        input = input * 60;
      }
      if (!this._isUTC && keepLocalTime) {
        localAdjust = getDateOffset(this);
      }
      this._offset = input;
      this._isUTC = true;
      if (localAdjust != null) {
        this.add(localAdjust, "m");
      }
      if (offset !== input) {
        if (!keepLocalTime || this._changeInProgress) {
          addSubtract(this, createDuration(input - offset, "m"), 1, false);
        } else if (!this._changeInProgress) {
          this._changeInProgress = true;
          hooks.updateOffset(this, true);
          this._changeInProgress = null;
        }
      }
      return this;
    } else {
      return this._isUTC ? offset : getDateOffset(this);
    }
  }

  function getSetZone(input, keepLocalTime) {
    if (input != null) {
      if (typeof input !== "string") {
        input = -input;
      }

      this.utcOffset(input, keepLocalTime);

      return this;
    } else {
      return -this.utcOffset();
    }
  }

  function setOffsetToUTC(keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
  }

  function setOffsetToLocal(keepLocalTime) {
    if (this._isUTC) {
      this.utcOffset(0, keepLocalTime);
      this._isUTC = false;

      if (keepLocalTime) {
        this.subtract(getDateOffset(this), "m");
      }
    }
    return this;
  }

  function setOffsetToParsedOffset() {
    if (this._tzm != null) {
      this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === "string") {
      var tZone = offsetFromString(matchOffset, this._i);
      if (tZone != null) {
        this.utcOffset(tZone);
      } else {
        this.utcOffset(0, true);
      }
    }
    return this;
  }

  function hasAlignedHourOffset(input) {
    if (!this.isValid()) {
      return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;

    return (this.utcOffset() - input) % 60 === 0;
  }

  function isDaylightSavingTime() {
    return (
      this.utcOffset() > this.clone().month(0).utcOffset() ||
      this.utcOffset() > this.clone().month(5).utcOffset()
    );
  }

  function isDaylightSavingTimeShifted() {
    if (!isUndefined(this._isDSTShifted)) {
      return this._isDSTShifted;
    }

    var c = {};

    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
      var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
      this._isDSTShifted =
        this.isValid() && compareArrays(c._a, other.toArray()) > 0;
    } else {
      this._isDSTShifted = false;
    }

    return this._isDSTShifted;
  }

  function isLocal() {
    return this.isValid() ? !this._isUTC : false;
  }

  function isUtcOffset() {
    return this.isValid() ? this._isUTC : false;
  }

  function isUtc() {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
  }

  // ASP.NET json date format regex
  var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

  // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
  // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
  // and further modified to allow for strings containing both week and day
  var isoRegex =
    /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

  function createDuration(input, key) {
    var duration = input,
      // matching against regexp is expensive, do it on demand
      match = null,
      sign,
      ret,
      diffRes;

    if (isDuration(input)) {
      duration = {
        ms: input._milliseconds,
        d: input._days,
        M: input._months,
      };
    } else if (isNumber(input)) {
      duration = {};
      if (key) {
        duration[key] = input;
      } else {
        duration.milliseconds = input;
      }
    } else if (!!(match = aspNetRegex.exec(input))) {
      sign = match[1] === "-" ? -1 : 1;
      duration = {
        y: 0,
        d: toInt(match[DATE]) * sign,
        h: toInt(match[HOUR]) * sign,
        m: toInt(match[MINUTE]) * sign,
        s: toInt(match[SECOND]) * sign,
        ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
      };
    } else if (!!(match = isoRegex.exec(input))) {
      sign = match[1] === "-" ? -1 : match[1] === "+" ? 1 : 1;
      duration = {
        y: parseIso(match[2], sign),
        M: parseIso(match[3], sign),
        w: parseIso(match[4], sign),
        d: parseIso(match[5], sign),
        h: parseIso(match[6], sign),
        m: parseIso(match[7], sign),
        s: parseIso(match[8], sign),
      };
    } else if (duration == null) {
      // checks for null or undefined
      duration = {};
    } else if (
      typeof duration === "object" &&
      ("from" in duration || "to" in duration)
    ) {
      diffRes = momentsDifference(
        createLocal(duration.from),
        createLocal(duration.to)
      );

      duration = {};
      duration.ms = diffRes.milliseconds;
      duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, "_locale")) {
      ret._locale = input._locale;
    }

    return ret;
  }

  createDuration.fn = Duration.prototype;
  createDuration.invalid = createInvalid$1;

  function parseIso(inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(",", "."));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
  }

  function positiveMomentsDifference(base, other) {
    var res = { milliseconds: 0, months: 0 };

    res.months =
      other.month() - base.month() + (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, "M").isAfter(other)) {
      --res.months;
    }

    res.milliseconds = +other - +base.clone().add(res.months, "M");

    return res;
  }

  function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
      return { milliseconds: 0, months: 0 };
    }

    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
      res = positiveMomentsDifference(base, other);
    } else {
      res = positiveMomentsDifference(other, base);
      res.milliseconds = -res.milliseconds;
      res.months = -res.months;
    }

    return res;
  }

  // TODO: remove 'name' arg after deprecation is removed
  function createAdder(direction, name) {
    return function (val, period) {
      var dur, tmp;
      //invert the arguments, but complain about it
      if (period !== null && !isNaN(+period)) {
        deprecateSimple(
          name,
          "moment()." +
            name +
            "(period, number) is deprecated. Please use moment()." +
            name +
            "(number, period). " +
            "See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
        );
        tmp = val;
        val = period;
        period = tmp;
      }

      val = typeof val === "string" ? +val : val;
      dur = createDuration(val, period);
      addSubtract(this, dur, direction);
      return this;
    };
  }

  function addSubtract(mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
      days = absRound(duration._days),
      months = absRound(duration._months);

    if (!mom.isValid()) {
      // No op
      return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (months) {
      setMonth(mom, get(mom, "Month") + months * isAdding);
    }
    if (days) {
      set$1(mom, "Date", get(mom, "Date") + days * isAdding);
    }
    if (milliseconds) {
      mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (updateOffset) {
      hooks.updateOffset(mom, days || months);
    }
  }

  var add = createAdder(1, "add");
  var subtract = createAdder(-1, "subtract");

  function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, "days", true);
    return diff < -6
      ? "sameElse"
      : diff < -1
      ? "lastWeek"
      : diff < 0
      ? "lastDay"
      : diff < 1
      ? "sameDay"
      : diff < 2
      ? "nextDay"
      : diff < 7
      ? "nextWeek"
      : "sameElse";
  }

  function calendar$1(time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
      sod = cloneWithOffset(now, this).startOf("day"),
      format = hooks.calendarFormat(this, sod) || "sameElse";

    var output =
      formats &&
      (isFunction(formats[format])
        ? formats[format].call(this, now)
        : formats[format]);

    return this.format(
      output || this.localeData().calendar(format, this, createLocal(now))
    );
  }

  function clone() {
    return new Moment(this);
  }

  function isAfter(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : "millisecond");
    if (units === "millisecond") {
      return this.valueOf() > localInput.valueOf();
    } else {
      return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
  }

  function isBefore(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : "millisecond");
    if (units === "millisecond") {
      return this.valueOf() < localInput.valueOf();
    } else {
      return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
  }

  function isBetween(from, to, units, inclusivity) {
    inclusivity = inclusivity || "()";
    return (
      (inclusivity[0] === "("
        ? this.isAfter(from, units)
        : !this.isBefore(from, units)) &&
      (inclusivity[1] === ")"
        ? this.isBefore(to, units)
        : !this.isAfter(to, units))
    );
  }

  function isSame(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
      inputMs;
    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }
    units = normalizeUnits(units || "millisecond");
    if (units === "millisecond") {
      return this.valueOf() === localInput.valueOf();
    } else {
      inputMs = localInput.valueOf();
      return (
        this.clone().startOf(units).valueOf() <= inputMs &&
        inputMs <= this.clone().endOf(units).valueOf()
      );
    }
  }

  function isSameOrAfter(input, units) {
    return this.isSame(input, units) || this.isAfter(input, units);
  }

  function isSameOrBefore(input, units) {
    return this.isSame(input, units) || this.isBefore(input, units);
  }

  function diff(input, units, asFloat) {
    var that, zoneDelta, output;

    if (!this.isValid()) {
      return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
      return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

    units = normalizeUnits(units);

    switch (units) {
      case "year":
        output = monthDiff(this, that) / 12;
        break;
      case "month":
        output = monthDiff(this, that);
        break;
      case "quarter":
        output = monthDiff(this, that) / 3;
        break;
      case "second":
        output = (this - that) / 1e3;
        break; // 1000
      case "minute":
        output = (this - that) / 6e4;
        break; // 1000 * 60
      case "hour":
        output = (this - that) / 36e5;
        break; // 1000 * 60 * 60
      case "day":
        output = (this - that - zoneDelta) / 864e5;
        break; // 1000 * 60 * 60 * 24, negate dst
      case "week":
        output = (this - that - zoneDelta) / 6048e5;
        break; // 1000 * 60 * 60 * 24 * 7, negate dst
      default:
        output = this - that;
    }

    return asFloat ? output : absFloor(output);
  }

  function monthDiff(a, b) {
    // difference in months
    var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
      // b is in (anchor - 1 month, anchor + 1 month)
      anchor = a.clone().add(wholeMonthDiff, "months"),
      anchor2,
      adjust;

    if (b - anchor < 0) {
      anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
      // linear across the month
      adjust = (b - anchor) / (anchor - anchor2);
    } else {
      anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
      // linear across the month
      adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
  }

  hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
  hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";

  function toString() {
    return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
  }

  function toISOString(keepOffset) {
    if (!this.isValid()) {
      return null;
    }
    var utc = keepOffset !== true;
    var m = utc ? this.clone().utc() : this;
    if (m.year() < 0 || m.year() > 9999) {
      return formatMoment(
        m,
        utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
      );
    }
    if (isFunction(Date.prototype.toISOString)) {
      // native implementation is ~50x faster, use it when we can
      if (utc) {
        return this.toDate().toISOString();
      } else {
        return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
          .toISOString()
          .replace("Z", formatMoment(m, "Z"));
      }
    }
    return formatMoment(
      m,
      utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
    );
  }

  /**
   * Return a human readable representation of a moment that can
   * also be evaluated to get a new moment which is the same
   *
   * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
   */
  function inspect() {
    if (!this.isValid()) {
      return "moment.invalid(/* " + this._i + " */)";
    }
    var func = "moment";
    var zone = "";
    if (!this.isLocal()) {
      func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
      zone = "Z";
    }
    var prefix = "[" + func + '("]';
    var year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
    var datetime = "-MM-DD[T]HH:mm:ss.SSS";
    var suffix = zone + '[")]';

    return this.format(prefix + year + datetime + suffix);
  }

  function format(inputString) {
    if (!inputString) {
      inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
  }

  function from(time, withoutSuffix) {
    if (
      this.isValid() &&
      ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
    ) {
      return createDuration({ to: this, from: time })
        .locale(this.locale())
        .humanize(!withoutSuffix);
    } else {
      return this.localeData().invalidDate();
    }
  }

  function fromNow(withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
  }

  function to(time, withoutSuffix) {
    if (
      this.isValid() &&
      ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
    ) {
      return createDuration({ from: this, to: time })
        .locale(this.locale())
        .humanize(!withoutSuffix);
    } else {
      return this.localeData().invalidDate();
    }
  }

  function toNow(withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
  }

  // If passed a locale key, it will set the locale for this
  // instance.  Otherwise, it will return the locale configuration
  // variables for this instance.
  function locale(key) {
    var newLocaleData;

    if (key === undefined) {
      return this._locale._abbr;
    } else {
      newLocaleData = getLocale(key);
      if (newLocaleData != null) {
        this._locale = newLocaleData;
      }
      return this;
    }
  }

  var lang = deprecate(
    "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
    function (key) {
      if (key === undefined) {
        return this.localeData();
      } else {
        return this.locale(key);
      }
    }
  );

  function localeData() {
    return this._locale;
  }

  function startOf(units) {
    units = normalizeUnits(units);
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (units) {
      case "year":
        this.month(0);
      /* falls through */
      case "quarter":
      case "month":
        this.date(1);
      /* falls through */
      case "week":
      case "isoWeek":
      case "day":
      case "date":
        this.hours(0);
      /* falls through */
      case "hour":
        this.minutes(0);
      /* falls through */
      case "minute":
        this.seconds(0);
      /* falls through */
      case "second":
        this.milliseconds(0);
    }

    // weeks are a special case
    if (units === "week") {
      this.weekday(0);
    }
    if (units === "isoWeek") {
      this.isoWeekday(1);
    }

    // quarters are also special
    if (units === "quarter") {
      this.month(Math.floor(this.month() / 3) * 3);
    }

    return this;
  }

  function endOf(units) {
    units = normalizeUnits(units);
    if (units === undefined || units === "millisecond") {
      return this;
    }

    // 'date' is an alias for 'day', so it should be considered as such.
    if (units === "date") {
      units = "day";
    }

    return this.startOf(units)
      .add(1, units === "isoWeek" ? "week" : units)
      .subtract(1, "ms");
  }

  function valueOf() {
    return this._d.valueOf() - (this._offset || 0) * 60000;
  }

  function unix() {
    return Math.floor(this.valueOf() / 1000);
  }

  function toDate() {
    return new Date(this.valueOf());
  }

  function toArray() {
    var m = this;
    return [
      m.year(),
      m.month(),
      m.date(),
      m.hour(),
      m.minute(),
      m.second(),
      m.millisecond(),
    ];
  }

  function toObject() {
    var m = this;
    return {
      years: m.year(),
      months: m.month(),
      date: m.date(),
      hours: m.hours(),
      minutes: m.minutes(),
      seconds: m.seconds(),
      milliseconds: m.milliseconds(),
    };
  }

  function toJSON() {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
  }

  function isValid$2() {
    return isValid(this);
  }

  function parsingFlags() {
    return extend({}, getParsingFlags(this));
  }

  function invalidAt() {
    return getParsingFlags(this).overflow;
  }

  function creationData() {
    return {
      input: this._i,
      format: this._f,
      locale: this._locale,
      isUTC: this._isUTC,
      strict: this._strict,
    };
  }

  // FORMATTING

  addFormatToken(0, ["gg", 2], 0, function () {
    return this.weekYear() % 100;
  });

  addFormatToken(0, ["GG", 2], 0, function () {
    return this.isoWeekYear() % 100;
  });

  function addWeekYearFormatToken(token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
  }

  addWeekYearFormatToken("gggg", "weekYear");
  addWeekYearFormatToken("ggggg", "weekYear");
  addWeekYearFormatToken("GGGG", "isoWeekYear");
  addWeekYearFormatToken("GGGGG", "isoWeekYear");

  // ALIASES

  addUnitAlias("weekYear", "gg");
  addUnitAlias("isoWeekYear", "GG");

  // PRIORITY

  addUnitPriority("weekYear", 1);
  addUnitPriority("isoWeekYear", 1);

  // PARSING

  addRegexToken("G", matchSigned);
  addRegexToken("g", matchSigned);
  addRegexToken("GG", match1to2, match2);
  addRegexToken("gg", match1to2, match2);
  addRegexToken("GGGG", match1to4, match4);
  addRegexToken("gggg", match1to4, match4);
  addRegexToken("GGGGG", match1to6, match6);
  addRegexToken("ggggg", match1to6, match6);

  addWeekParseToken(
    ["gggg", "ggggg", "GGGG", "GGGGG"],
    function (input, week, config, token) {
      week[token.substr(0, 2)] = toInt(input);
    }
  );

  addWeekParseToken(["gg", "GG"], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
  });

  // MOMENTS

  function getSetWeekYear(input) {
    return getSetWeekYearHelper.call(
      this,
      input,
      this.week(),
      this.weekday(),
      this.localeData()._week.dow,
      this.localeData()._week.doy
    );
  }

  function getSetISOWeekYear(input) {
    return getSetWeekYearHelper.call(
      this,
      input,
      this.isoWeek(),
      this.isoWeekday(),
      1,
      4
    );
  }

  function getISOWeeksInYear() {
    return weeksInYear(this.year(), 1, 4);
  }

  function getWeeksInYear() {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
  }

  function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
      return weekOfYear(this, dow, doy).year;
    } else {
      weeksTarget = weeksInYear(input, dow, doy);
      if (week > weeksTarget) {
        week = weeksTarget;
      }
      return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
  }

  function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
      date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
  }

  // FORMATTING

  addFormatToken("Q", 0, "Qo", "quarter");

  // ALIASES

  addUnitAlias("quarter", "Q");

  // PRIORITY

  addUnitPriority("quarter", 7);

  // PARSING

  addRegexToken("Q", match1);
  addParseToken("Q", function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
  });

  // MOMENTS

  function getSetQuarter(input) {
    return input == null
      ? Math.ceil((this.month() + 1) / 3)
      : this.month((input - 1) * 3 + (this.month() % 3));
  }

  // FORMATTING

  addFormatToken("D", ["DD", 2], "Do", "date");

  // ALIASES

  addUnitAlias("date", "D");

  // PRIOROITY
  addUnitPriority("date", 9);

  // PARSING

  addRegexToken("D", match1to2);
  addRegexToken("DD", match1to2, match2);
  addRegexToken("Do", function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict
      ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
      : locale._dayOfMonthOrdinalParseLenient;
  });

  addParseToken(["D", "DD"], DATE);
  addParseToken("Do", function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0]);
  });

  // MOMENTS

  var getSetDayOfMonth = makeGetSet("Date", true);

  // FORMATTING

  addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");

  // ALIASES

  addUnitAlias("dayOfYear", "DDD");

  // PRIORITY
  addUnitPriority("dayOfYear", 4);

  // PARSING

  addRegexToken("DDD", match1to3);
  addRegexToken("DDDD", match3);
  addParseToken(["DDD", "DDDD"], function (input, array, config) {
    config._dayOfYear = toInt(input);
  });

  // HELPERS

  // MOMENTS

  function getSetDayOfYear(input) {
    var dayOfYear =
      Math.round(
        (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
      ) + 1;
    return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
  }

  // FORMATTING

  addFormatToken("m", ["mm", 2], 0, "minute");

  // ALIASES

  addUnitAlias("minute", "m");

  // PRIORITY

  addUnitPriority("minute", 14);

  // PARSING

  addRegexToken("m", match1to2);
  addRegexToken("mm", match1to2, match2);
  addParseToken(["m", "mm"], MINUTE);

  // MOMENTS

  var getSetMinute = makeGetSet("Minutes", false);

  // FORMATTING

  addFormatToken("s", ["ss", 2], 0, "second");

  // ALIASES

  addUnitAlias("second", "s");

  // PRIORITY

  addUnitPriority("second", 15);

  // PARSING

  addRegexToken("s", match1to2);
  addRegexToken("ss", match1to2, match2);
  addParseToken(["s", "ss"], SECOND);

  // MOMENTS

  var getSetSecond = makeGetSet("Seconds", false);

  // FORMATTING

  addFormatToken("S", 0, 0, function () {
    return ~~(this.millisecond() / 100);
  });

  addFormatToken(0, ["SS", 2], 0, function () {
    return ~~(this.millisecond() / 10);
  });

  addFormatToken(0, ["SSS", 3], 0, "millisecond");
  addFormatToken(0, ["SSSS", 4], 0, function () {
    return this.millisecond() * 10;
  });
  addFormatToken(0, ["SSSSS", 5], 0, function () {
    return this.millisecond() * 100;
  });
  addFormatToken(0, ["SSSSSS", 6], 0, function () {
    return this.millisecond() * 1000;
  });
  addFormatToken(0, ["SSSSSSS", 7], 0, function () {
    return this.millisecond() * 10000;
  });
  addFormatToken(0, ["SSSSSSSS", 8], 0, function () {
    return this.millisecond() * 100000;
  });
  addFormatToken(0, ["SSSSSSSSS", 9], 0, function () {
    return this.millisecond() * 1000000;
  });

  // ALIASES

  addUnitAlias("millisecond", "ms");

  // PRIORITY

  addUnitPriority("millisecond", 16);

  // PARSING

  addRegexToken("S", match1to3, match1);
  addRegexToken("SS", match1to3, match2);
  addRegexToken("SSS", match1to3, match3);

  var token;
  for (token = "SSSS"; token.length <= 9; token += "S") {
    addRegexToken(token, matchUnsigned);
  }

  function parseMs(input, array) {
    array[MILLISECOND] = toInt(("0." + input) * 1000);
  }

  for (token = "S"; token.length <= 9; token += "S") {
    addParseToken(token, parseMs);
  }
  // MOMENTS

  var getSetMillisecond = makeGetSet("Milliseconds", false);

  // FORMATTING

  addFormatToken("z", 0, 0, "zoneAbbr");
  addFormatToken("zz", 0, 0, "zoneName");

  // MOMENTS

  function getZoneAbbr() {
    return this._isUTC ? "UTC" : "";
  }

  function getZoneName() {
    return this._isUTC ? "Coordinated Universal Time" : "";
  }

  var proto = Moment.prototype;

  proto.add = add;
  proto.calendar = calendar$1;
  proto.clone = clone;
  proto.diff = diff;
  proto.endOf = endOf;
  proto.format = format;
  proto.from = from;
  proto.fromNow = fromNow;
  proto.to = to;
  proto.toNow = toNow;
  proto.get = stringGet;
  proto.invalidAt = invalidAt;
  proto.isAfter = isAfter;
  proto.isBefore = isBefore;
  proto.isBetween = isBetween;
  proto.isSame = isSame;
  proto.isSameOrAfter = isSameOrAfter;
  proto.isSameOrBefore = isSameOrBefore;
  proto.isValid = isValid$2;
  proto.lang = lang;
  proto.locale = locale;
  proto.localeData = localeData;
  proto.max = prototypeMax;
  proto.min = prototypeMin;
  proto.parsingFlags = parsingFlags;
  proto.set = stringSet;
  proto.startOf = startOf;
  proto.subtract = subtract;
  proto.toArray = toArray;
  proto.toObject = toObject;
  proto.toDate = toDate;
  proto.toISOString = toISOString;
  proto.inspect = inspect;
  proto.toJSON = toJSON;
  proto.toString = toString;
  proto.unix = unix;
  proto.valueOf = valueOf;
  proto.creationData = creationData;
  proto.year = getSetYear;
  proto.isLeapYear = getIsLeapYear;
  proto.weekYear = getSetWeekYear;
  proto.isoWeekYear = getSetISOWeekYear;
  proto.quarter = proto.quarters = getSetQuarter;
  proto.month = getSetMonth;
  proto.daysInMonth = getDaysInMonth;
  proto.week = proto.weeks = getSetWeek;
  proto.isoWeek = proto.isoWeeks = getSetISOWeek;
  proto.weeksInYear = getWeeksInYear;
  proto.isoWeeksInYear = getISOWeeksInYear;
  proto.date = getSetDayOfMonth;
  proto.day = proto.days = getSetDayOfWeek;
  proto.weekday = getSetLocaleDayOfWeek;
  proto.isoWeekday = getSetISODayOfWeek;
  proto.dayOfYear = getSetDayOfYear;
  proto.hour = proto.hours = getSetHour;
  proto.minute = proto.minutes = getSetMinute;
  proto.second = proto.seconds = getSetSecond;
  proto.millisecond = proto.milliseconds = getSetMillisecond;
  proto.utcOffset = getSetOffset;
  proto.utc = setOffsetToUTC;
  proto.local = setOffsetToLocal;
  proto.parseZone = setOffsetToParsedOffset;
  proto.hasAlignedHourOffset = hasAlignedHourOffset;
  proto.isDST = isDaylightSavingTime;
  proto.isLocal = isLocal;
  proto.isUtcOffset = isUtcOffset;
  proto.isUtc = isUtc;
  proto.isUTC = isUtc;
  proto.zoneAbbr = getZoneAbbr;
  proto.zoneName = getZoneName;
  proto.dates = deprecate(
    "dates accessor is deprecated. Use date instead.",
    getSetDayOfMonth
  );
  proto.months = deprecate(
    "months accessor is deprecated. Use month instead",
    getSetMonth
  );
  proto.years = deprecate(
    "years accessor is deprecated. Use year instead",
    getSetYear
  );
  proto.zone = deprecate(
    "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
    getSetZone
  );
  proto.isDSTShifted = deprecate(
    "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
    isDaylightSavingTimeShifted
  );

  function createUnix(input) {
    return createLocal(input * 1000);
  }

  function createInZone() {
    return createLocal.apply(null, arguments).parseZone();
  }

  function preParsePostFormat(string) {
    return string;
  }

  var proto$1 = Locale.prototype;

  proto$1.calendar = calendar;
  proto$1.longDateFormat = longDateFormat;
  proto$1.invalidDate = invalidDate;
  proto$1.ordinal = ordinal;
  proto$1.preparse = preParsePostFormat;
  proto$1.postformat = preParsePostFormat;
  proto$1.relativeTime = relativeTime;
  proto$1.pastFuture = pastFuture;
  proto$1.set = set;

  proto$1.months = localeMonths;
  proto$1.monthsShort = localeMonthsShort;
  proto$1.monthsParse = localeMonthsParse;
  proto$1.monthsRegex = monthsRegex;
  proto$1.monthsShortRegex = monthsShortRegex;
  proto$1.week = localeWeek;
  proto$1.firstDayOfYear = localeFirstDayOfYear;
  proto$1.firstDayOfWeek = localeFirstDayOfWeek;

  proto$1.weekdays = localeWeekdays;
  proto$1.weekdaysMin = localeWeekdaysMin;
  proto$1.weekdaysShort = localeWeekdaysShort;
  proto$1.weekdaysParse = localeWeekdaysParse;

  proto$1.weekdaysRegex = weekdaysRegex;
  proto$1.weekdaysShortRegex = weekdaysShortRegex;
  proto$1.weekdaysMinRegex = weekdaysMinRegex;

  proto$1.isPM = localeIsPM;
  proto$1.meridiem = localeMeridiem;

  function get$1(format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
  }

  function listMonthsImpl(format, index, field) {
    if (isNumber(format)) {
      index = format;
      format = undefined;
    }

    format = format || "";

    if (index != null) {
      return get$1(format, index, field, "month");
    }

    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
      out[i] = get$1(format, i, field, "month");
    }
    return out;
  }

  // ()
  // (5)
  // (fmt, 5)
  // (fmt)
  // (true)
  // (true, 5)
  // (true, fmt, 5)
  // (true, fmt)
  function listWeekdaysImpl(localeSorted, format, index, field) {
    if (typeof localeSorted === "boolean") {
      if (isNumber(format)) {
        index = format;
        format = undefined;
      }

      format = format || "";
    } else {
      format = localeSorted;
      index = format;
      localeSorted = false;

      if (isNumber(format)) {
        index = format;
        format = undefined;
      }

      format = format || "";
    }

    var locale = getLocale(),
      shift = localeSorted ? locale._week.dow : 0;

    if (index != null) {
      return get$1(format, (index + shift) % 7, field, "day");
    }

    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
      out[i] = get$1(format, (i + shift) % 7, field, "day");
    }
    return out;
  }

  function listMonths(format, index) {
    return listMonthsImpl(format, index, "months");
  }

  function listMonthsShort(format, index) {
    return listMonthsImpl(format, index, "monthsShort");
  }

  function listWeekdays(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, "weekdays");
  }

  function listWeekdaysShort(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, "weekdaysShort");
  }

  function listWeekdaysMin(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, "weekdaysMin");
  }

  getSetGlobalLocale("en", {
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal: function (number) {
      var b = number % 10,
        output =
          toInt((number % 100) / 10) === 1
            ? "th"
            : b === 1
            ? "st"
            : b === 2
            ? "nd"
            : b === 3
            ? "rd"
            : "th";
      return number + output;
    },
  });

  // Side effect imports

  hooks.lang = deprecate(
    "moment.lang is deprecated. Use moment.locale instead.",
    getSetGlobalLocale
  );
  hooks.langData = deprecate(
    "moment.langData is deprecated. Use moment.localeData instead.",
    getLocale
  );

  var mathAbs = Math.abs;

  function abs() {
    var data = this._data;

    this._milliseconds = mathAbs(this._milliseconds);
    this._days = mathAbs(this._days);
    this._months = mathAbs(this._months);

    data.milliseconds = mathAbs(data.milliseconds);
    data.seconds = mathAbs(data.seconds);
    data.minutes = mathAbs(data.minutes);
    data.hours = mathAbs(data.hours);
    data.months = mathAbs(data.months);
    data.years = mathAbs(data.years);

    return this;
  }

  function addSubtract$1(duration, input, value, direction) {
    var other = createDuration(input, value);

    duration._milliseconds += direction * other._milliseconds;
    duration._days += direction * other._days;
    duration._months += direction * other._months;

    return duration._bubble();
  }

  // supports only 2.0-style add(1, 's') or add(duration)
  function add$1(input, value) {
    return addSubtract$1(this, input, value, 1);
  }

  // supports only 2.0-style subtract(1, 's') or subtract(duration)
  function subtract$1(input, value) {
    return addSubtract$1(this, input, value, -1);
  }

  function absCeil(number) {
    if (number < 0) {
      return Math.floor(number);
    } else {
      return Math.ceil(number);
    }
  }

  function bubble() {
    var milliseconds = this._milliseconds;
    var days = this._days;
    var months = this._months;
    var data = this._data;
    var seconds, minutes, hours, years, monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (
      !(
        (milliseconds >= 0 && days >= 0 && months >= 0) ||
        (milliseconds <= 0 && days <= 0 && months <= 0)
      )
    ) {
      milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
      days = 0;
      months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;

    seconds = absFloor(milliseconds / 1000);
    data.seconds = seconds % 60;

    minutes = absFloor(seconds / 60);
    data.minutes = minutes % 60;

    hours = absFloor(minutes / 60);
    data.hours = hours % 24;

    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    data.days = days;
    data.months = months;
    data.years = years;

    return this;
  }

  function daysToMonths(days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return (days * 4800) / 146097;
  }

  function monthsToDays(months) {
    // the reverse of daysToMonths
    return (months * 146097) / 4800;
  }

  function as(units) {
    if (!this.isValid()) {
      return NaN;
    }
    var days;
    var months;
    var milliseconds = this._milliseconds;

    units = normalizeUnits(units);

    if (units === "month" || units === "year") {
      days = this._days + milliseconds / 864e5;
      months = this._months + daysToMonths(days);
      return units === "month" ? months : months / 12;
    } else {
      // handle milliseconds separately because of floating point math errors (issue #1867)
      days = this._days + Math.round(monthsToDays(this._months));
      switch (units) {
        case "week":
          return days / 7 + milliseconds / 6048e5;
        case "day":
          return days + milliseconds / 864e5;
        case "hour":
          return days * 24 + milliseconds / 36e5;
        case "minute":
          return days * 1440 + milliseconds / 6e4;
        case "second":
          return days * 86400 + milliseconds / 1000;
        // Math.floor prevents floating point math errors here
        case "millisecond":
          return Math.floor(days * 864e5) + milliseconds;
        default:
          throw new Error("Unknown unit " + units);
      }
    }
  }

  // TODO: Use this.as('ms')?
  function valueOf$1() {
    if (!this.isValid()) {
      return NaN;
    }
    return (
      this._milliseconds +
      this._days * 864e5 +
      (this._months % 12) * 2592e6 +
      toInt(this._months / 12) * 31536e6
    );
  }

  function makeAs(alias) {
    return function () {
      return this.as(alias);
    };
  }

  var asMilliseconds = makeAs("ms");
  var asSeconds = makeAs("s");
  var asMinutes = makeAs("m");
  var asHours = makeAs("h");
  var asDays = makeAs("d");
  var asWeeks = makeAs("w");
  var asMonths = makeAs("M");
  var asYears = makeAs("y");

  function clone$1() {
    return createDuration(this);
  }

  function get$2(units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + "s"]() : NaN;
  }

  function makeGetter(name) {
    return function () {
      return this.isValid() ? this._data[name] : NaN;
    };
  }

  var milliseconds = makeGetter("milliseconds");
  var seconds = makeGetter("seconds");
  var minutes = makeGetter("minutes");
  var hours = makeGetter("hours");
  var days = makeGetter("days");
  var months = makeGetter("months");
  var years = makeGetter("years");

  function weeks() {
    return absFloor(this.days() / 7);
  }

  var round = Math.round;
  var thresholds = {
    ss: 44, // a few seconds to seconds
    s: 45, // seconds to minute
    m: 45, // minutes to hour
    h: 22, // hours to day
    d: 26, // days to month
    M: 11, // months to year
  };

  // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
  function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
  }

  function relativeTime$1(posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds = round(duration.as("s"));
    var minutes = round(duration.as("m"));
    var hours = round(duration.as("h"));
    var days = round(duration.as("d"));
    var months = round(duration.as("M"));
    var years = round(duration.as("y"));

    var a = (seconds <= thresholds.ss && ["s", seconds]) ||
      (seconds < thresholds.s && ["ss", seconds]) ||
      (minutes <= 1 && ["m"]) ||
      (minutes < thresholds.m && ["mm", minutes]) ||
      (hours <= 1 && ["h"]) ||
      (hours < thresholds.h && ["hh", hours]) ||
      (days <= 1 && ["d"]) ||
      (days < thresholds.d && ["dd", days]) ||
      (months <= 1 && ["M"]) ||
      (months < thresholds.M && ["MM", months]) ||
      (years <= 1 && ["y"]) || ["yy", years];

    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
  }

  // This function allows you to set the rounding function for relative time strings
  function getSetRelativeTimeRounding(roundingFunction) {
    if (roundingFunction === undefined) {
      return round;
    }
    if (typeof roundingFunction === "function") {
      round = roundingFunction;
      return true;
    }
    return false;
  }

  // This function allows you to set a threshold for relative time strings
  function getSetRelativeTimeThreshold(threshold, limit) {
    if (thresholds[threshold] === undefined) {
      return false;
    }
    if (limit === undefined) {
      return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    if (threshold === "s") {
      thresholds.ss = limit - 1;
    }
    return true;
  }

  function humanize(withSuffix) {
    if (!this.isValid()) {
      return this.localeData().invalidDate();
    }

    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);

    if (withSuffix) {
      output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
  }

  var abs$1 = Math.abs;

  function sign(x) {
    return (x > 0) - (x < 0) || +x;
  }

  function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    if (!this.isValid()) {
      return this.localeData().invalidDate();
    }

    var seconds = abs$1(this._milliseconds) / 1000;
    var days = abs$1(this._days);
    var months = abs$1(this._months);
    var minutes, hours, years;

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes = absFloor(seconds / 60);
    hours = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, "") : "";
    var total = this.asSeconds();

    if (!total) {
      // this is the same as C#'s (Noda) and python (isodate)...
      // but not other JS (goog.date)
      return "P0D";
    }

    var totalSign = total < 0 ? "-" : "";
    var ymSign = sign(this._months) !== sign(total) ? "-" : "";
    var daysSign = sign(this._days) !== sign(total) ? "-" : "";
    var hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";

    return (
      totalSign +
      "P" +
      (Y ? ymSign + Y + "Y" : "") +
      (M ? ymSign + M + "M" : "") +
      (D ? daysSign + D + "D" : "") +
      (h || m || s ? "T" : "") +
      (h ? hmsSign + h + "H" : "") +
      (m ? hmsSign + m + "M" : "") +
      (s ? hmsSign + s + "S" : "")
    );
  }

  var proto$2 = Duration.prototype;

  proto$2.isValid = isValid$1;
  proto$2.abs = abs;
  proto$2.add = add$1;
  proto$2.subtract = subtract$1;
  proto$2.as = as;
  proto$2.asMilliseconds = asMilliseconds;
  proto$2.asSeconds = asSeconds;
  proto$2.asMinutes = asMinutes;
  proto$2.asHours = asHours;
  proto$2.asDays = asDays;
  proto$2.asWeeks = asWeeks;
  proto$2.asMonths = asMonths;
  proto$2.asYears = asYears;
  proto$2.valueOf = valueOf$1;
  proto$2._bubble = bubble;
  proto$2.clone = clone$1;
  proto$2.get = get$2;
  proto$2.milliseconds = milliseconds;
  proto$2.seconds = seconds;
  proto$2.minutes = minutes;
  proto$2.hours = hours;
  proto$2.days = days;
  proto$2.weeks = weeks;
  proto$2.months = months;
  proto$2.years = years;
  proto$2.humanize = humanize;
  proto$2.toISOString = toISOString$1;
  proto$2.toString = toISOString$1;
  proto$2.toJSON = toISOString$1;
  proto$2.locale = locale;
  proto$2.localeData = localeData;

  proto$2.toIsoString = deprecate(
    "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
    toISOString$1
  );
  proto$2.lang = lang;

  // Side effect imports

  // FORMATTING

  addFormatToken("X", 0, 0, "unix");
  addFormatToken("x", 0, 0, "valueOf");

  // PARSING

  addRegexToken("x", matchSigned);
  addRegexToken("X", matchTimestamp);
  addParseToken("X", function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
  });
  addParseToken("x", function (input, array, config) {
    config._d = new Date(toInt(input));
  });

  // Side effect imports

  hooks.version = "2.21.0";

  setHookCallback(createLocal);

  hooks.fn = proto;
  hooks.min = min;
  hooks.max = max;
  hooks.now = now;
  hooks.utc = createUTC;
  hooks.unix = createUnix;
  hooks.months = listMonths;
  hooks.isDate = isDate;
  hooks.locale = getSetGlobalLocale;
  hooks.invalid = createInvalid;
  hooks.duration = createDuration;
  hooks.isMoment = isMoment;
  hooks.weekdays = listWeekdays;
  hooks.parseZone = createInZone;
  hooks.localeData = getLocale;
  hooks.isDuration = isDuration;
  hooks.monthsShort = listMonthsShort;
  hooks.weekdaysMin = listWeekdaysMin;
  hooks.defineLocale = defineLocale;
  hooks.updateLocale = updateLocale;
  hooks.locales = listLocales;
  hooks.weekdaysShort = listWeekdaysShort;
  hooks.normalizeUnits = normalizeUnits;
  hooks.relativeTimeRounding = getSetRelativeTimeRounding;
  hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
  hooks.calendarFormat = getCalendarFormat;
  hooks.prototype = proto;

  // currently HTML5 input type only supports 24-hour formats
  hooks.HTML5_FMT = {
    DATETIME_LOCAL: "YYYY-MM-DDTHH:mm", // <input type="datetime-local" />
    DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss", // <input type="datetime-local" step="1" />
    DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS", // <input type="datetime-local" step="0.001" />
    DATE: "YYYY-MM-DD", // <input type="date" />
    TIME: "HH:mm", // <input type="time" />
    TIME_SECONDS: "HH:mm:ss", // <input type="time" step="1" />
    TIME_MS: "HH:mm:ss.SSS", // <input type="time" step="0.001" />
    WEEK: "YYYY-[W]WW", // <input type="week" />
    MONTH: "YYYY-MM", // <input type="month" />
  };

  return hooks;
});

/**
 * isMobile.js v0.4.1
 *
 * A simple library to detect Apple phones and tablets,
 * Android phones and tablets, other mobile devices (like blackberry, mini-opera and windows phone),
 * and any kind of seven inch device, via user agent sniffing.
 *
 * @author: Kai Mallea (kmallea@gmail.com)
 *
 * @license: http://creativecommons.org/publicdomain/zero/1.0/
 */
!(function (a) {
  var b = /iPhone/i,
    c = /iPod/i,
    d = /iPad/i,
    e = /(?=.*\bAndroid\b)(?=.*\bMobile\b)/i,
    f = /Android/i,
    g = /(?=.*\bAndroid\b)(?=.*\bSD4930UR\b)/i,
    h =
      /(?=.*\bAndroid\b)(?=.*\b(?:KFOT|KFTT|KFJWI|KFJWA|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|KFARWI|KFASWI|KFSAWI|KFSAWA)\b)/i,
    i = /Windows Phone/i,
    j = /(?=.*\bWindows\b)(?=.*\bARM\b)/i,
    k = /BlackBerry/i,
    l = /BB10/i,
    m = /Opera Mini/i,
    n = /(CriOS|Chrome)(?=.*\bMobile\b)/i,
    o = /(?=.*\bFirefox\b)(?=.*\bMobile\b)/i,
    p = new RegExp("(?:Nexus 7|BNTV250|Kindle Fire|Silk|GT-P1000)", "i"),
    q = function (a, b) {
      return a.test(b);
    },
    r = function (a) {
      var r = a || navigator.userAgent,
        s = r.split("[FBAN");
      if (
        ("undefined" != typeof s[1] && (r = s[0]),
        (s = r.split("Twitter")),
        "undefined" != typeof s[1] && (r = s[0]),
        (this.apple = {
          phone: q(b, r),
          ipod: q(c, r),
          tablet: !q(b, r) && q(d, r),
          device: q(b, r) || q(c, r) || q(d, r),
        }),
        (this.amazon = {
          phone: q(g, r),
          tablet: !q(g, r) && q(h, r),
          device: q(g, r) || q(h, r),
        }),
        (this.android = {
          phone: q(g, r) || q(e, r),
          tablet: !q(g, r) && !q(e, r) && (q(h, r) || q(f, r)),
          device: q(g, r) || q(h, r) || q(e, r) || q(f, r),
        }),
        (this.windows = {
          phone: q(i, r),
          tablet: q(j, r),
          device: q(i, r) || q(j, r),
        }),
        (this.other = {
          blackberry: q(k, r),
          blackberry10: q(l, r),
          opera: q(m, r),
          firefox: q(o, r),
          chrome: q(n, r),
          device: q(k, r) || q(l, r) || q(m, r) || q(o, r) || q(n, r),
        }),
        (this.seven_inch = q(p, r)),
        (this.any =
          this.apple.device ||
          this.android.device ||
          this.windows.device ||
          this.other.device ||
          this.seven_inch),
        (this.phone =
          this.apple.phone || this.android.phone || this.windows.phone),
        (this.tablet =
          this.apple.tablet || this.android.tablet || this.windows.tablet),
        "undefined" == typeof window)
      )
        return this;
    },
    s = function () {
      var a = new r();
      return (a.Class = r), a;
    };
  "undefined" != typeof module && module.exports && "undefined" == typeof window
    ? (module.exports = r)
    : "undefined" != typeof module &&
      module.exports &&
      "undefined" != typeof window
    ? (module.exports = s())
    : "function" == typeof define && define.amd
    ? define("isMobile", [], (a.isMobile = s()))
    : (a.isMobile = s());
})(this);

/**!

 @license
 handlebars v4.0.11

Copyright (C) 2011-2017 by Yehuda Katz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
(function(){}