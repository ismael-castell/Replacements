(function (window) {
  "use strict";
  function minErr(module, ErrorConstructor) {
    ErrorConstructor = ErrorConstructor || Error;
    return function () {
      var SKIP_INDEXES = 2;
      var templateArgs = arguments,
        code = templateArgs[0],
        message = "[" + (module ? module + ":" : "") + code + "] ",
        template = templateArgs[1],
        paramPrefix,
        i;
      message += template.replace(/\{\d+\}/g, function (match) {
        var index = +match.slice(1, -1),
          shiftedIndex = index + SKIP_INDEXES;
        if (shiftedIndex < templateArgs.length) {
          return toDebugString(templateArgs[shiftedIndex]);
        }
        return match;
      });
      message +=
        "\nhttp://errors.angularjs.org/1.6.1/" +
        (module ? module + "/" : "") +
        code;
      for (
        i = SKIP_INDEXES, paramPrefix = "?";
        i < templateArgs.length;
        i++, paramPrefix = "&"
      ) {
        message +=
          paramPrefix +
          "p" +
          (i - SKIP_INDEXES) +
          "=" +
          encodeURIComponent(toDebugString(templateArgs[i]));
      }
      return new ErrorConstructor(message);
    };
  }
  var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
  var VALIDITY_STATE_PROPERTY = "validity";
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var lowercase = function (string) {
    return isString(string) ? string.toLowerCase() : string;
  };
  var uppercase = function (string) {
    return isString(string) ? string.toUpperCase() : string;
  };
  var manualLowercase = function (s) {
    return isString(s)
      ? s.replace(/[A-Z]/g, function (ch) {
          return String.fromCharCode(ch.charCodeAt(0) | 32);
        })
      : s;
  };
  var manualUppercase = function (s) {
    return isString(s)
      ? s.replace(/[a-z]/g, function (ch) {
          return String.fromCharCode(ch.charCodeAt(0) & ~32);
        })
      : s;
  };
  if ("i" !== "I".toLowerCase()) {
    lowercase = manualLowercase;
    uppercase = manualUppercase;
  }
  var msie,
    jqLite,
    jQuery,
    slice = [].slice,
    splice = [].splice,
    push = [].push,
    toString = Object.prototype.toString,
    getPrototypeOf = Object.getPrototypeOf,
    ngMinErr = minErr("ng"),
    angular = window.angular || (window.angular = {}),
    angularModule,
    uid = 0;
  msie = window.document.documentMode;
  function isArrayLike(obj) {
    if (obj == null || isWindow(obj)) return false;
    if (isArray(obj) || isString(obj) || (jqLite && obj instanceof jqLite))
      return true;
    var length = "length" in Object(obj) && obj.length;
    return (
      isNumber(length) &&
      ((length >= 0 && (length - 1 in obj || obj instanceof Array)) ||
        typeof obj.item === "function")
    );
  }
  function forEach(obj, iterator, context) {
    var key, length;
    if (obj) {
      if (isFunction(obj)) {
        for (key in obj) {
          if (
            key !== "prototype" &&
            key !== "length" &&
            key !== "name" &&
            obj.hasOwnProperty(key)
          ) {
            iterator.call(context, obj[key], key, obj);
          }
        }
      } else if (isArray(obj) || isArrayLike(obj)) {
        var isPrimitive = typeof obj !== "object";
        for (key = 0, length = obj.length; key < length; key++) {
          if (isPrimitive || key in obj) {
            iterator.call(context, obj[key], key, obj);
          }
        }
      } else if (obj.forEach && obj.forEach !== forEach) {
        obj.forEach(iterator, context, obj);
      } else if (isBlankObject(obj)) {
        for (key in obj) {
          iterator.call(context, obj[key], key, obj);
        }
      } else if (typeof obj.hasOwnProperty === "function") {
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            iterator.call(context, obj[key], key, obj);
          }
        }
      } else {
        for (key in obj) {
          if (hasOwnProperty.call(obj, key)) {
            iterator.call(context, obj[key], key, obj);
          }
        }
      }
    }
    return obj;
  }
  function forEachSorted(obj, iterator, context) {
    var keys = Object.keys(obj).sort();
    for (var i = 0; i < keys.length; i++) {
      iterator.call(context, obj[keys[i]], keys[i]);
    }
    return keys;
  }
  function reverseParams(iteratorFn) {
    return function (value, key) {
      iteratorFn(key, value);
    };
  }
  function nextUid() {
    return ++uid;
  }
  function setHashKey(obj, h) {
    if (h) {
      obj.$$hashKey = h;
    } else {
      delete obj.$$hashKey;
    }
  }
  function baseExtend(dst, objs, deep) {
    var h = dst.$$hashKey;
    for (var i = 0, ii = objs.length; i < ii; ++i) {
      var obj = objs[i];
      if (!isObject(obj) && !isFunction(obj)) continue;
      var keys = Object.keys(obj);
      for (var j = 0, jj = keys.length; j < jj; j++) {
        var key = keys[j];
        var src = obj[key];
        if (deep && isObject(src)) {
          if (isDate(src)) {
            dst[key] = new Date(src.valueOf());
          } else if (isRegExp(src)) {
            dst[key] = new RegExp(src);
          } else if (src.nodeName) {
            dst[key] = src.cloneNode(true);
          } else if (isElement(src)) {
            dst[key] = src.clone();
          } else {
            if (!isObject(dst[key])) dst[key] = isArray(src) ? [] : {};
            baseExtend(dst[key], [src], true);
          }
        } else {
          dst[key] = src;
        }
      }
    }
    setHashKey(dst, h);
    return dst;
  }
  function extend(dst) {
    return baseExtend(dst, slice.call(arguments, 1), false);
  }
  function merge(dst) {
    return baseExtend(dst, slice.call(arguments, 1), true);
  }
  function toInt(str) {
    return parseInt(str, 10);
  }
  var isNumberNaN =
    Number.isNaN ||
    function isNumberNaN(num) {
      return num !== num;
    };
  function inherit(parent, extra) {
    return extend(Object.create(parent), extra);
  }
  function noop() {}
  noop.$inject = [];
  function identity($) {
    return $;
  }
  identity.$inject = [];
  function valueFn(value) {
    return function valueRef() {
      return value;
    };
  }
  function hasCustomToString(obj) {
    return isFunction(obj.toString) && obj.toString !== toString;
  }
  function isUndefined(value) {
    return typeof value === "undefined";
  }
  function isDefined(value) {
    return typeof value !== "undefined";
  }
  function isObject(value) {
    return value !== null && typeof value === "object";
  }
  function isBlankObject(value) {
    return (
      value !== null && typeof value === "object" && !getPrototypeOf(value)
    );
  }
  function isString(value) {
    return typeof value === "string";
  }
  function isNumber(value) {
    return typeof value === "number";
  }
  function isDate(value) {
    return toString.call(value) === "[object Date]";
  }
  var isArray = Array.isArray;
  function isFunction(value) {
    return typeof value === "function";
  }
  function isRegExp(value) {
    return toString.call(value) === "[object RegExp]";
  }
  function isWindow(obj) {
    return obj && obj.window === obj;
  }
  function isScope(obj) {
    return obj && obj.$evalAsync && obj.$watch;
  }
  function isFile(obj) {
    return toString.call(obj) === "[object File]";
  }
  function isFormData(obj) {
    return toString.call(obj) === "[object FormData]";
  }
  function isBlob(obj) {
    return toString.call(obj) === "[object Blob]";
  }
  function isBoolean(value) {
    return typeof value === "boolean";
  }
  function isPromiseLike(obj) {
    return obj && isFunction(obj.then);
  }
  var TYPED_ARRAY_REGEXP =
    /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$/;
  function isTypedArray(value) {
    return (
      value &&
      isNumber(value.length) &&
      TYPED_ARRAY_REGEXP.test(toString.call(value))
    );
  }
  function isArrayBuffer(obj) {
    return toString.call(obj) === "[object ArrayBuffer]";
  }
  var trim = function (value) {
    return isString(value) ? value.trim() : value;
  };
  var escapeForRegexp = function (s) {
    return s
      .replace(/([-()[\]{}+?*.$^|,:#<!\\])/g, "\\$1")
      .replace(/\x08/g, "\\x08");
  };
  function isElement(node) {
    return !!(node && (node.nodeName || (node.prop && node.attr && node.find)));
  }
  function makeMap(str) {
    var obj = {},
      items = str.split(","),
      i;
    for (i = 0; i < items.length; i++) {
      obj[items[i]] = true;
    }
    return obj;
  }
  function nodeName_(element) {
    return lowercase(element.nodeName || (element[0] && element[0].nodeName));
  }
  function includes(array, obj) {
    return Array.prototype.indexOf.call(array, obj) !== -1;
  }
  function arrayRemove(array, value) {
    var index = array.indexOf(value);
    if (index >= 0) {
      array.splice(index, 1);
    }
    return index;
  }
  function copy(source, destination) {
    var stackSource = [];
    var stackDest = [];
    if (destination) {
      if (isTypedArray(destination) || isArrayBuffer(destination)) {
        throw ngMinErr(
          "cpta",
          "Can't copy! TypedArray destination cannot be mutated."
        );
      }
      if (source === destination) {
        throw ngMinErr(
          "cpi",
          "Can't copy! Source and destination are identical."
        );
      }
      if (isArray(destination)) {
        destination.length = 0;
      } else {
        forEach(destination, function (value, key) {
          if (key !== "$$hashKey") {
            delete destination[key];
          }
        });
      }
      stackSource.push(source);
      stackDest.push(destination);
      return copyRecurse(source, destination);
    }
    return copyElement(source);
    function copyRecurse(source, destination) {
      var h = destination.$$hashKey;
      var key;
      if (isArray(source)) {
        for (var i = 0, ii = source.length; i < ii; i++) {
          destination.push(copyElement(source[i]));
        }
      } else if (isBlankObject(source)) {
        for (key in source) {
          destination[key] = copyElement(source[key]);
        }
      } else if (source && typeof source.hasOwnProperty === "function") {
        for (key in source) {
          if (source.hasOwnProperty(key)) {
            destination[key] = copyElement(source[key]);
          }
        }
      } else {
        for (key in source) {
          if (hasOwnProperty.call(source, key)) {
            destination[key] = copyElement(source[key]);
          }
        }
      }
      setHashKey(destination, h);
      return destination;
    }
    function copyElement(source) {
      if (!isObject(source)) {
        return source;
      }
      var index = stackSource.indexOf(source);
      if (index !== -1) {
        return stackDest[index];
      }
      if (isWindow(source) || isScope(source)) {
        throw ngMinErr(
          "cpws",
          "Can't copy! Making copies of Window or Scope instances is not supported."
        );
      }
      var needsRecurse = false;
      var destination = copyType(source);
      if (destination === undefined) {
        destination = isArray(source)
          ? []
          : Object.create(getPrototypeOf(source));
        needsRecurse = true;
      }
      stackSource.push(source);
      stackDest.push(destination);
      return needsRecurse ? copyRecurse(source, destination) : destination;
    }
    function copyType(source) {
      switch (toString.call(source)) {
        case "[object Int8Array]":
        case "[object Int16Array]":
        case "[object Int32Array]":
        case "[object Float32Array]":
        case "[object Float64Array]":
        case "[object Uint8Array]":
        case "[object Uint8ClampedArray]":
        case "[object Uint16Array]":
        case "[object Uint32Array]":
          return new source.constructor(
            copyElement(source.buffer),
            source.byteOffset,
            source.length
          );
        case "[object ArrayBuffer]":
          if (!source.slice) {
            var copied = new ArrayBuffer(source.byteLength);
            new Uint8Array(copied).set(new Uint8Array(source));
            return copied;
          }
          return source.slice(0);
        case "[object Boolean]":
        case "[object Number]":
        case "[object String]":
        case "[object Date]":
          return new source.constructor(source.valueOf());
        case "[object RegExp]":
          var re = new RegExp(
            source.source,
            source.toString().match(/[^\/]*$/)[0]
          );
          re.lastIndex = source.lastIndex;
          return re;
        case "[object Blob]":
          return new source.constructor([source], { type: source.type });
      }
      if (isFunction(source.cloneNode)) {
        return source.cloneNode(true);
      }
    }
  }
  function equals(o1, o2) {
    if (o1 === o2) return true;
    if (o1 === null || o2 === null) return false;
    if (o1 !== o1 && o2 !== o2) return true;
    var t1 = typeof o1,
      t2 = typeof o2,
      length,
      key,
      keySet;
    if (t1 === t2 && t1 === "object") {
      if (isArray(o1)) {
        if (!isArray(o2)) return false;
        if ((length = o1.length) === o2.length) {
          for (key = 0; key < length; key++) {
            if (!equals(o1[key], o2[key])) return false;
          }
          return true;
        }
      } else if (isDate(o1)) {
        if (!isDate(o2)) return false;
        return equals(o1.getTime(), o2.getTime());
      } else if (isRegExp(o1)) {
        if (!isRegExp(o2)) return false;
        return o1.toString() === o2.toString();
      } else {
        if (
          isScope(o1) ||
          isScope(o2) ||
          isWindow(o1) ||
          isWindow(o2) ||
          isArray(o2) ||
          isDate(o2) ||
          isRegExp(o2)
        )
          return false;
        keySet = createMap();
        for (key in o1) {
          if (key.charAt(0) === "$" || isFunction(o1[key])) continue;
          if (!equals(o1[key], o2[key])) return false;
          keySet[key] = true;
        }
        for (key in o2) {
          if (
            !(key in keySet) &&
            key.charAt(0) !== "$" &&
            isDefined(o2[key]) &&
            !isFunction(o2[key])
          )
            return false;
        }
        return true;
      }
    }
    return false;
  }
  var csp = function () {
    if (!isDefined(csp.rules)) {
      var ngCspElement =
        window.document.querySelector("[ng-csp]") ||
        window.document.querySelector("[data-ng-csp]");
      if (ngCspElement) {
        var ngCspAttribute =
          ngCspElement.getAttribute("ng-csp") ||
          ngCspElement.getAttribute("data-ng-csp");
        csp.rules = {
          noUnsafeEval:
            !ngCspAttribute || ngCspAttribute.indexOf("no-unsafe-eval") !== -1,
          noInlineStyle:
            !ngCspAttribute || ngCspAttribute.indexOf("no-inline-style") !== -1,
        };
      } else {
        csp.rules = { noUnsafeEval: noUnsafeEval(), noInlineStyle: false };
      }
    }
    return csp.rules;
    function noUnsafeEval() {
      try {
        new Function("");
        return false;
      } catch (e) {
        return true;
      }
    }
  };
  var jq = function () {
    if (isDefined(jq.name_)) return jq.name_;
    var el;
    var i,
      ii = ngAttrPrefixes.length,
      prefix,
      name;
    for (i = 0; i < ii; ++i) {
      prefix = ngAttrPrefixes[i];
      el = window.document.querySelector(
        "[" + prefix.replace(":", "\\:") + "jq]"
      );
      if (el) {
        name = el.getAttribute(prefix + "jq");
        break;
      }
    }
    return (jq.name_ = name);
  };
  function concat(array1, array2, index) {
    return array1.concat(slice.call(array2, index));
  }
  function sliceArgs(args, startIndex) {
    return slice.call(args, startIndex || 0);
  }
  function bind(self, fn) {
    var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
    if (isFunction(fn) && !(fn instanceof RegExp)) {
      return curryArgs.length
        ? function () {
            return arguments.length
              ? fn.apply(self, concat(curryArgs, arguments, 0))
              : fn.apply(self, curryArgs);
          }
        : function () {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self);
          };
    } else {
      return fn;
    }
  }
  function toJsonReplacer(key, value) {
    var val = value;
    if (
      typeof key === "string" &&
      key.charAt(0) === "$" &&
      key.charAt(1) === "$"
    ) {
      val = undefined;
    } else if (isWindow(value)) {
      val = "$WINDOW";
    } else if (value && window.document === value) {
      val = "$DOCUMENT";
    } else if (isScope(value)) {
      val = "$SCOPE";
    }
    return val;
  }
  function toJson(obj, pretty) {
    if (isUndefined(obj)) return undefined;
    if (!isNumber(pretty)) {
      pretty = pretty ? 2 : null;
    }
    return JSON.stringify(obj, toJsonReplacer, pretty);
  }
  function fromJson(json) {
    return isString(json) ? JSON.parse(json) : json;
  }
  var ALL_COLONS = /:/g;
  function timezoneToOffset(timezone, fallback) {
    timezone = timezone.replace(ALL_COLONS, "");
    var requestedTimezoneOffset =
      Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
    return isNumberNaN(requestedTimezoneOffset)
      ? fallback
      : requestedTimezoneOffset;
  }
  function addDateMinutes(date, minutes) {
    date = new Date(date.getTime());
    date.setMinutes(date.getMinutes() + minutes);
    return date;
  }
  function convertTimezoneToLocal(date, timezone, reverse) {
    reverse = reverse ? -1 : 1;
    var dateTimezoneOffset = date.getTimezoneOffset();
    var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
    return addDateMinutes(
      date,
      reverse * (timezoneOffset - dateTimezoneOffset)
    );
  }
  function startingTag(element) {
    element = jqLite(element).clone();
    try {
      element.empty();
    } catch (e) {}
    var elemHtml = jqLite("<div>").append(element).html();
    try {
      return element[0].nodeType === NODE_TYPE_TEXT
        ? lowercase(elemHtml)
        : elemHtml
            .match(/^(<[^>]+>)/)[1]
            .replace(/^<([\w-]+)/, function (match, nodeName) {
              return "<" + lowercase(nodeName);
            });
    } catch (e) {
      return lowercase(elemHtml);
    }
  }
  function tryDecodeURIComponent(value) {
    try {
      return decodeURIComponent(value);
    } catch (e) {}
  }
  function parseKeyValue(keyValue) {
    var obj = {};
    forEach((keyValue || "").split("&"), function (keyValue) {
      var splitPoint, key, val;
      if (keyValue) {
        key = keyValue = keyValue.replace(/\+/g, "%20");
        splitPoint = keyValue.indexOf("=");
        if (splitPoint !== -1) {
          key = keyValue.substring(0, splitPoint);
          val = keyValue.substring(splitPoint + 1);
        }
        key = tryDecodeURIComponent(key);
        if (isDefined(key)) {
          val = isDefined(val) ? tryDecodeURIComponent(val) : true;
          if (!hasOwnProperty.call(obj, key)) {
            obj[key] = val;
          } else if (isArray(obj[key])) {
            obj[key].push(val);
          } else {
            obj[key] = [obj[key], val];
          }
        }
      }
    });
    return obj;
  }
  function toKeyValue(obj) {
    var parts = [];
    forEach(obj, function (value, key) {
      if (isArray(value)) {
        forEach(value, function (arrayValue) {
          parts.push(
            encodeUriQuery(key, true) +
              (arrayValue === true
                ? ""
                : "=" + encodeUriQuery(arrayValue, true))
          );
        });
      } else {
        parts.push(
          encodeUriQuery(key, true) +
            (value === true ? "" : "=" + encodeUriQuery(value, true))
        );
      }
    });
    return parts.length ? parts.join("&") : "";
  }
  function encodeUriSegment(val) {
    return encodeUriQuery(val, true)
      .replace(/%26/gi, "&")
      .replace(/%3D/gi, "=")
      .replace(/%2B/gi, "+");
  }
  function encodeUriQuery(val, pctEncodeSpaces) {
    return encodeURIComponent(val)
      .replace(/%40/gi, "@")
      .replace(/%3A/gi, ":")
      .replace(/%24/g, "$")
      .replace(/%2C/gi, ",")
      .replace(/%3B/gi, ";")
      .replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
  }
  var ngAttrPrefixes = ["ng-", "data-ng-", "ng:", "x-ng-"];
  function getNgAttribute(element, ngAttr) {
    var attr,
      i,
      ii = ngAttrPrefixes.length;
    for (i = 0; i < ii; ++i) {
      attr = ngAttrPrefixes[i] + ngAttr;
      if (isString((attr = element.getAttribute(attr)))) {
        return attr;
      }
    }
    return null;
  }
  function allowAutoBootstrap(document) {
    if (!document.currentScript) {
      return true;
    }
    var src = document.currentScript.getAttribute("src");
    var link = document.createElement("a");
    link.href = src;
    if (document.location.origin === link.origin) {
      return true;
    }
    switch (link.protocol) {
      case "http:":
      case "https:":
      case "ftp:":
      case "blob:":
      case "file:":
      case "data:":
        return true;
      default:
        return false;
    }
  }
  var isAutoBootstrapAllowed = allowAutoBootstrap(window.document);
  function angularInit(element, bootstrap) {
    var appElement,
      module,
      config = {};
    forEach(ngAttrPrefixes, function (prefix) {
      var name = prefix + "app";
      if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
        appElement = element;
        module = element.getAttribute(name);
      }
    });
    forEach(ngAttrPrefixes, function (prefix) {
      var name = prefix + "app";
      var candidate;
      if (
        !appElement &&
        (candidate = element.querySelector(
          "[" + name.replace(":", "\\:") + "]"
        ))
      ) {
        appElement = candidate;
        module = candidate.getAttribute(name);
      }
    });
    if (appElement) {
      if (!isAutoBootstrapAllowed) {
        window.console.error(
          "Angular: disabling automatic bootstrap. <script> protocol indicates " +
            "an extension, document.location.href does not match."
        );
        return;
      }
      config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
      bootstrap(appElement, module ? [module] : [], config);
    }
  }
  function bootstrap(element, modules, config) {
    if (!isObject(config)) config = {};
    var defaultConfig = { strictDi: false };
    config = extend(defaultConfig, config);
    var doBootstrap = function () {
      element = jqLite(element);
      if (element.injector()) {
        var tag =
          element[0] === window.document ? "document" : startingTag(element);
        throw ngMinErr(
          "btstrpd",
          "App already bootstrapped with this element '{0}'",
          tag.replace(/</, "&lt;").replace(/>/, "&gt;")
        );
      }
      modules = modules || [];
      modules.unshift([
        "$provide",
        function ($provide) {
          $provide.value("$rootElement", element);
        },
      ]);
      if (config.debugInfoEnabled) {
        modules.push([
          "$compileProvider",
          function ($compileProvider) {
            $compileProvider.debugInfoEnabled(true);
          },
        ]);
      }
      modules.unshift("ng");
      var injector = createInjector(modules, config.strictDi);
      injector.invoke([
        "$rootScope",
        "$rootElement",
        "$compile",
        "$injector",
        function bootstrapApply(scope, element, compile, injector) {
          scope.$apply(function () {
            element.data("$injector", injector);
            compile(element)(scope);
          });
        },
      ]);
      return injector;
    };
    var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
    var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
    if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
      config.debugInfoEnabled = true;
      window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, "");
    }
    if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
      return doBootstrap();
    }
    window.name = window.name.replace(NG_DEFER_BOOTSTRAP, "");
    angular.resumeBootstrap = function (extraModules) {
      forEach(extraModules, function (module) {
        modules.push(module);
      });
      return doBootstrap();
    };
    if (isFunction(angular.resumeDeferredBootstrap)) {
      angular.resumeDeferredBootstrap();
    }
  }
  function reloadWithDebugInfo() {
    window.name = "NG_ENABLE_DEBUG_INFO!" + window.name;
    window.location.reload();
  }
  function getTestability(rootElement) {
    var injector = angular.element(rootElement).injector();
    if (!injector) {
      throw ngMinErr(
        "test",
        "no injector found for element argument to getTestability"
      );
    }
    return injector.get("$$testability");
  }
  var SNAKE_CASE_REGEXP = /[A-Z]/g;
  function snake_case(name, separator) {
    separator = separator || "_";
    return name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {
      return (pos ? separator : "") + letter.toLowerCase();
    });
  }
  var bindJQueryFired = false;
  function bindJQuery() {
    var originalCleanData;
    if (bindJQueryFired) {
      return;
    }
    var jqName = jq();
    jQuery = isUndefined(jqName)
      ? window.jQuery
      : !jqName
      ? undefined
      : window[jqName];
    if (jQuery && jQuery.fn.on) {
      jqLite = jQuery;
      extend(jQuery.fn, {
        scope: JQLitePrototype.scope,
        isolateScope: JQLitePrototype.isolateScope,
        controller: JQLitePrototype.controller,
        injector: JQLitePrototype.injector,
        inheritedData: JQLitePrototype.inheritedData,
      });
      originalCleanData = jQuery.cleanData;
      jQuery.cleanData = function (elems) {
        var events;
        for (var i = 0, elem; (elem = elems[i]) != null; i++) {
          events = jQuery._data(elem, "events");
          if (events && events.$destroy) {
            jQuery(elem).triggerHandler("$destroy");
          }
        }
        originalCleanData(elems);
      };
    } else {
      jqLite = JQLite;
    }
    angular.element = jqLite;
    bindJQueryFired = true;
  }
  function assertArg(arg, name, reason) {
    if (!arg) {
      throw ngMinErr(
        "areq",
        "Argument '{0}' is {1}",
        name || "?",
        reason || "required"
      );
    }
    return arg;
  }
  function assertArgFn(arg, name, acceptArrayAnnotation) {
    if (acceptArrayAnnotation && isArray(arg)) {
      arg = arg[arg.length - 1];
    }
    assertArg(
      isFunction(arg),
      name,
      "not a function, got " +
        (arg && typeof arg === "object"
          ? arg.constructor.name || "Object"
          : typeof arg)
    );
    return arg;
  }
  function assertNotHasOwnProperty(name, context) {
    if (name === "hasOwnProperty") {
      throw ngMinErr(
        "badname",
        "hasOwnProperty is not a valid {0} name",
        context
      );
    }
  }
  function getter(obj, path, bindFnToScope) {
    if (!path) return obj;
    var keys = path.split(".");
    var key;
    var lastInstance = obj;
    var len = keys.length;
    for (var i = 0; i < len; i++) {
      key = keys[i];
      if (obj) {
        obj = (lastInstance = obj)[key];
      }
    }
    if (!bindFnToScope && isFunction(obj)) {
      return bind(lastInstance, obj);
    }
    return obj;
  }
  function getBlockNodes(nodes) {
    var node = nodes[0];
    var endNode = nodes[nodes.length - 1];
    var blockNodes;
    for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {
      if (blockNodes || nodes[i] !== node) {
        if (!blockNodes) {
          blockNodes = jqLite(slice.call(nodes, 0, i));
        }
        blockNodes.push(node);
      }
    }
    return blockNodes || nodes;
  }
  function createMap() {
    return Object.create(null);
  }
  function stringify(value) {
    if (value == null) {
      return "";
    }
    switch (typeof value) {
      case "string":
        break;
      case "number":
        value = "" + value;
        break;
      default:
        if (hasCustomToString(value) && !isArray(value) && !isDate(value)) {
          value = value.toString();
        } else {
          value = toJson(value);
        }
    }
    return value;
  }
  var NODE_TYPE_ELEMENT = 1;
  var NODE_TYPE_ATTRIBUTE = 2;
  var NODE_TYPE_TEXT = 3;
  var NODE_TYPE_COMMENT = 8;
  var NODE_TYPE_DOCUMENT = 9;
  var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
  function setupModuleLoader(window) {
    var $injectorMinErr = minErr("$injector");
    var ngMinErr = minErr("ng");
    function ensure(obj, name, factory) {
      return obj[name] || (obj[name] = factory());
    }
    var angular = ensure(window, "angular", Object);
    angular.$$minErr = angular.$$minErr || minErr;
    return ensure(angular, "module", function () {
      var modules = {};
      return function module(name, requires, configFn) {
        var assertNotHasOwnProperty = function (name, context) {
          if (name === "hasOwnProperty") {
            throw ngMinErr(
              "badname",
              "hasOwnProperty is not a valid {0} name",
              context
            );
          }
        };
        assertNotHasOwnProperty(name, "module");
        if (requires && modules.hasOwnProperty(name)) {
          modules[name] = null;
        }
        return ensure(modules, name, function () {
          if (!requires) {
            throw $injectorMinErr(
              "nomod",
              "Module '{0}' is not available! You either misspelled " +
                "the module name or forgot to load it. If registering a module ensure that you " +
                "specify the dependencies as the second argument.",
              name
            );
          }
          var invokeQueue = [];
          var configBlocks = [];
          var runBlocks = [];
          var config = invokeLater("$injector", "invoke", "push", configBlocks);
          var moduleInstance = {
            _invokeQueue: invokeQueue,
            _configBlocks: configBlocks,
            _runBlocks: runBlocks,
            requires: requires,
            name: name,
            provider: invokeLaterAndSetModuleName("$provide", "provider"),
            factory: invokeLaterAndSetModuleName("$provide", "factory"),
            service: invokeLaterAndSetModuleName("$provide", "service"),
            value: invokeLater("$provide", "value"),
            constant: invokeLater("$provide", "constant", "unshift"),
            decorator: invokeLaterAndSetModuleName(
              "$provide",
              "decorator",
              configBlocks
            ),
            animation: invokeLaterAndSetModuleName(
              "$animateProvider",
              "register"
            ),
            filter: invokeLaterAndSetModuleName("$filterProvider", "register"),
            controller: invokeLaterAndSetModuleName(
              "$controllerProvider",
              "register"
            ),
            directive: invokeLaterAndSetModuleName(
              "$compileProvider",
              "directive"
            ),
            component: invokeLaterAndSetModuleName(
              "$compileProvider",
              "component"
            ),
            config: config,
            run: function (block) {
              runBlocks.push(block);
              return this;
            },
          };
          if (configFn) {
            config(configFn);
          }
          return moduleInstance;
          function invokeLater(provider, method, insertMethod, queue) {
            if (!queue) queue = invokeQueue;
            return function () {
              queue[insertMethod || "push"]([provider, method, arguments]);
              return moduleInstance;
            };
          }
          function invokeLaterAndSetModuleName(provider, method, queue) {
            if (!queue) queue = invokeQueue;
            return function (recipeName, factoryFunction) {
              if (factoryFunction && isFunction(factoryFunction))
                factoryFunction.$$moduleName = name;
              queue.push([provider, method, arguments]);
              return moduleInstance;
            };
          }
        });
      };
    });
  }
  function shallowCopy(src, dst) {
    if (isArray(src)) {
      dst = dst || [];
      for (var i = 0, ii = src.length; i < ii; i++) {
        dst[i] = src[i];
      }
    } else if (isObject(src)) {
      dst = dst || {};
      for (var key in src) {
        if (!(key.charAt(0) === "$" && key.charAt(1) === "$")) {
          dst[key] = src[key];
        }
      }
    }
    return dst || src;
  }
  function serializeObject(obj) {
    var seen = [];
    return JSON.stringify(obj, function (key, val) {
      val = toJsonReplacer(key, val);
      if (isObject(val)) {
        if (seen.indexOf(val) >= 0) return "...";
        seen.push(val);
      }
      return val;
    });
  }
  function toDebugString(obj) {
    if (typeof obj === "function") {
      return obj.toString().replace(/ \{[\s\S]*$/, "");
    } else if (isUndefined(obj)) {
      return "undefined";
    } else if (typeof obj !== "string") {
      return serializeObject(obj);
    }
    return obj;
  }
  var version = {
    full: "1.6.1",
    major: 1,
    minor: 6,
    dot: 1,
    codeName: "promise-rectification",
  };
  function publishExternalAPI(angular) {
    extend(angular, {
      bootstrap: bootstrap,
      copy: copy,
      extend: extend,
      merge: merge,
      equals: equals,
      element: jqLite,
      forEach: forEach,
      injector: createInjector,
      noop: noop,
      bind: bind,
      toJson: toJson,
      fromJson: fromJson,
      identity: identity,
      isUndefined: isUndefined,
      isDefined: isDefined,
      isString: isString,
      isFunction: isFunction,
      isObject: isObject,
      isNumber: isNumber,
      isElement: isElement,
      isArray: isArray,
      version: version,
      isDate: isDate,
      lowercase: lowercase,
      uppercase: uppercase,
      callbacks: { $$counter: 0 },
      getTestability: getTestability,
      reloadWithDebugInfo: reloadWithDebugInfo,
      $$minErr: minErr,
      $$csp: csp,
      $$encodeUriSegment: encodeUriSegment,
      $$encodeUriQuery: encodeUriQuery,
      $$stringify: stringify,
    });
    angularModule = setupModuleLoader(window);
    angularModule(
      "ng",
      ["ngLocale"],
      [
        "$provide",
        function ngModule($provide) {
          $provide.provider({ $$sanitizeUri: $$SanitizeUriProvider });
          $provide
            .provider("$compile", $CompileProvider)
            .directive({
              a: htmlAnchorDirective,
              input: inputDirective,
              textarea: inputDirective,
              form: formDirective,
              script: scriptDirective,
              select: selectDirective,
              option: optionDirective,
              ngBind: ngBindDirective,
              ngBindHtml: ngBindHtmlDirective,
              ngBindTemplate: ngBindTemplateDirective,
              ngClass: ngClassDirective,
              ngClassEven: ngClassEvenDirective,
              ngClassOdd: ngClassOddDirective,
              ngCloak: ngCloakDirective,
              ngController: ngControllerDirective,
              ngForm: ngFormDirective,
              ngHide: ngHideDirective,
              ngIf: ngIfDirective,
              ngInclude: ngIncludeDirective,
              ngInit: ngInitDirective,
              ngNonBindable: ngNonBindableDirective,
              ngPluralize: ngPluralizeDirective,
              ngRepeat: ngRepeatDirective,
              ngShow: ngShowDirective,
              ngStyle: ngStyleDirective,
              ngSwitch: ngSwitchDirective,
              ngSwitchWhen: ngSwitchWhenDirective,
              ngSwitchDefault: ngSwitchDefaultDirective,
              ngOptions: ngOptionsDirective,
              ngTransclude: ngTranscludeDirective,
              ngModel: ngModelDirective,
              ngList: ngListDirective,
              ngChange: ngChangeDirective,
              pattern: patternDirective,
              ngPattern: patternDirective,
              required: requiredDirective,
              ngRequired: requiredDirective,
              minlength: minlengthDirective,
              ngMinlength: minlengthDirective,
              maxlength: maxlengthDirective,
              ngMaxlength: maxlengthDirective,
              ngValue: ngValueDirective,
              ngModelOptions: ngModelOptionsDirective,
            })
            .directive({ ngInclude: ngIncludeFillContentDirective })
            .directive(ngAttributeAliasDirectives)
            .directive(ngEventDirectives);
          $provide.provider({
            $anchorScroll: $AnchorScrollProvider,
            $animate: $AnimateProvider,
            $animateCss: $CoreAnimateCssProvider,
            $$animateJs: $$CoreAnimateJsProvider,
            $$animateQueue: $$CoreAnimateQueueProvider,
            $$AnimateRunner: $$AnimateRunnerFactoryProvider,
            $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
            $browser: $BrowserProvider,
            $cacheFactory: $CacheFactoryProvider,
            $controller: $ControllerProvider,
            $document: $DocumentProvider,
            $$isDocumentHidden: $$IsDocumentHiddenProvider,
            $exceptionHandler: $ExceptionHandlerProvider,
            $filter: $FilterProvider,
            $$forceReflow: $$ForceReflowProvider,
            $interpolate: $InterpolateProvider,
            $interval: $IntervalProvider,
            $http: $HttpProvider,
            $httpParamSerializer: $HttpParamSerializerProvider,
            $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
            $httpBackend: $HttpBackendProvider,
            $xhrFactory: $xhrFactoryProvider,
            $jsonpCallbacks: $jsonpCallbacksProvider,
            $location: $LocationProvider,
            $log: $LogProvider,
            $parse: $ParseProvider,
            $rootScope: $RootScopeProvider,
            $q: $QProvider,
            $$q: $$QProvider,
            $sce: $SceProvider,
            $sceDelegate: $SceDelegateProvider,
            $sniffer: $SnifferProvider,
            $templateCache: $TemplateCacheProvider,
            $templateRequest: $TemplateRequestProvider,
            $$testability: $$TestabilityProvider,
            $timeout: $TimeoutProvider,
            $window: $WindowProvider,
            $$rAF: $$RAFProvider,
            $$jqLite: $$jqLiteProvider,
            $$HashMap: $$HashMapProvider,
            $$cookieReader: $$CookieReaderProvider,
          });
        },
      ]
    );
  }
  JQLite.expando = "ng339";
  var jqCache = (JQLite.cache = {}),
    jqId = 1;
  JQLite._data = function (node) {
    return this.cache[node[this.expando]] || {};
  };
  function jqNextId() {
    return ++jqId;
  }
  var DASH_LOWERCASE_REGEXP = /-([a-z])/g;
  var MS_HACK_REGEXP = /^-ms-/;
  var MOUSE_EVENT_MAP = { mouseleave: "mouseout", mouseenter: "mouseover" };
  var jqLiteMinErr = minErr("jqLite");
  function cssKebabToCamel(name) {
    return kebabToCamel(name.replace(MS_HACK_REGEXP, "ms-"));
  }
  function fnCamelCaseReplace(all, letter) {
    return letter.toUpperCase();
  }
  function kebabToCamel(name) {
    return name.replace(DASH_LOWERCASE_REGEXP, fnCamelCaseReplace);
  }
  var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
  var HTML_REGEXP = /<|&#?\w+;/;
  var TAG_NAME_REGEXP = /<([\w:-]+)/;
  var XHTML_TAG_REGEXP =
    /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi;
  var wrapMap = {
    option: [1, '<select multiple="multiple">', "</select>"],
    thead: [1, "<table>", "</table>"],
    col: [2, "<table><colgroup>", "</colgroup></table>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
    _default: [0, "", ""],
  };
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody =
    wrapMap.tfoot =
    wrapMap.colgroup =
    wrapMap.caption =
      wrapMap.thead;
  wrapMap.th = wrapMap.td;
  function jqLiteIsTextNode(html) {
    return !HTML_REGEXP.test(html);
  }
  function jqLiteAcceptsData(node) {
    var nodeType = node.nodeType;
    return (
      nodeType === NODE_TYPE_ELEMENT ||
      !nodeType ||
      nodeType === NODE_TYPE_DOCUMENT
    );
  }
  function jqLiteHasData(node) {
    for (var key in jqCache[node.ng339]) {
      return true;
    }
    return false;
  }
  function jqLiteCleanData(nodes) {
    for (var i = 0, ii = nodes.length; i < ii; i++) {
      jqLiteRemoveData(nodes[i]);
    }
  }
  function jqLiteBuildFragment(html, context) {
    var tmp,
      tag,
      wrap,
      fragment = context.createDocumentFragment(),
      nodes = [],
      i;
    if (jqLiteIsTextNode(html)) {
      nodes.push(context.createTextNode(html));
    } else {
      tmp = fragment.appendChild(context.createElement("div"));
      tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase();
      wrap = wrapMap[tag] || wrapMap._default;
      tmp.innerHTML =
        wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
      i = wrap[0];
      while (i--) {
        tmp = tmp.lastChild;
      }
      nodes = concat(nodes, tmp.childNodes);
      tmp = fragment.firstChild;
      tmp.textContent = "";
    }
    fragment.textContent = "";
    fragment.innerHTML = "";
    forEach(nodes, function (node) {
      fragment.appendChild(node);
    });
    return fragment;
  }
  function jqLiteParseHTML(html, context) {
    context = context || window.document;
    var parsed;
    if ((parsed = SINGLE_TAG_REGEXP.exec(html))) {
      return [context.createElement(parsed[1])];
    }
    if ((parsed = jqLiteBuildFragment(html, context))) {
      return parsed.childNodes;
    }
    return [];
  }
  function jqLiteWrapNode(node, wrapper) {
    var parent = node.parentNode;
    if (parent) {
      parent.replaceChild(wrapper, node);
    }
    wrapper.appendChild(node);
  }
  var jqLiteContains =
    window.Node.prototype.contains ||
    function (arg) {
      return !!(this.compareDocumentPosition(arg) & 16);
    };
  function JQLite(element) {
    if (element instanceof JQLite) {
      return element;
    }
    var argIsString;
    if (isString(element)) {
      element = trim(element);
      argIsString = true;
    }
    if (!(this instanceof JQLite)) {
      if (argIsString && element.charAt(0) !== "<") {
        throw jqLiteMinErr(
          "nosel",
          "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element"
        );
      }
      return new JQLite(element);
    }
    if (argIsString) {
      jqLiteAddNodes(this, jqLiteParseHTML(element));
    } else if (isFunction(element)) {
      jqLiteReady(element);
    } else {
      jqLiteAddNodes(this, element);
    }
  }
  function jqLiteClone(element) {
    return element.cloneNode(true);
  }
  function jqLiteDealoc(element, onlyDescendants) {
    if (!onlyDescendants) jqLiteRemoveData(element);
    if (element.querySelectorAll) {
      var descendants = element.querySelectorAll("*");
      for (var i = 0, l = descendants.length; i < l; i++) {
        jqLiteRemoveData(descendants[i]);
      }
    }
  }
  function jqLiteOff(element, type, fn, unsupported) {
    if (isDefined(unsupported))
      throw jqLiteMinErr(
        "offargs",
        "jqLite#off() does not support the `selector` argument"
      );
    var expandoStore = jqLiteExpandoStore(element);
    var events = expandoStore && expandoStore.events;
    var handle = expandoStore && expandoStore.handle;
    if (!handle) return;
    if (!type) {
      for (type in events) {
        if (type !== "$destroy") {
          element.removeEventListener(type, handle);
        }
        delete events[type];
      }
    } else {
      var removeHandler = function (type) {
        var listenerFns = events[type];
        if (isDefined(fn)) {
          arrayRemove(listenerFns || [], fn);
        }
        if (!(isDefined(fn) && listenerFns && listenerFns.length > 0)) {
          element.removeEventListener(type, handle);
          delete events[type];
        }
      };
      forEach(type.split(" "), function (type) {
        removeHandler(type);
        if (MOUSE_EVENT_MAP[type]) {
          removeHandler(MOUSE_EVENT_MAP[type]);
        }
      });
    }
  }
  function jqLiteRemoveData(element, name) {
    var expandoId = element.ng339;
    var expandoStore = expandoId && jqCache[expandoId];
    if (expandoStore) {
      if (name) {
        delete expandoStore.data[name];
        return;
      }
      if (expandoStore.handle) {
        if (expandoStore.events.$destroy) {
          expandoStore.handle({}, "$destroy");
        }
        jqLiteOff(element);
      }
      delete jqCache[expandoId];
      element.ng339 = undefined;
    }
  }
  function jqLiteExpandoStore(element, createIfNecessary) {
    var expandoId = element.ng339,
      expandoStore = expandoId && jqCache[expandoId];
    if (createIfNecessary && !expandoStore) {
      element.ng339 = expandoId = jqNextId();
      expandoStore = jqCache[expandoId] = {
        events: {},
        data: {},
        handle: undefined,
      };
    }
    return expandoStore;
  }
  function jqLiteData(element, key, value) {
    if (jqLiteAcceptsData(element)) {
      var prop;
      var isSimpleSetter = isDefined(value);
      var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
      var massGetter = !key;
      var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
      var data = expandoStore && expandoStore.data;
      if (isSimpleSetter) {
        data[kebabToCamel(key)] = value;
      } else {
        if (massGetter) {
          return data;
        } else {
          if (isSimpleGetter) {
            return data && data[kebabToCamel(key)];
          } else {
            for (prop in key) {
              data[kebabToCamel(prop)] = key[prop];
            }
          }
        }
      }
    }
  }
  function jqLiteHasClass(element, selector) {
    if (!element.getAttribute) return false;
    return (
      (" " + (element.getAttribute("class") || "") + " ")
        .replace(/[\n\t]/g, " ")
        .indexOf(" " + selector + " ") > -1
    );
  }
  function jqLiteRemoveClass(element, cssClasses) {
    if (cssClasses && element.setAttribute) {
      forEach(cssClasses.split(" "), function (cssClass) {
        element.setAttribute(
          "class",
          trim(
            (" " + (element.getAttribute("class") || "") + " ")
              .replace(/[\n\t]/g, " ")
              .replace(" " + trim(cssClass) + " ", " ")
          )
        );
      });
    }
  }
  function jqLiteAddClass(element, cssClasses) {
    if (cssClasses && element.setAttribute) {
      var existingClasses = (
        " " +
        (element.getAttribute("class") || "") +
        " "
      ).replace(/[\n\t]/g, " ");
      forEach(cssClasses.split(" "), function (cssClass) {
        cssClass = trim(cssClass);
        if (existingClasses.indexOf(" " + cssClass + " ") === -1) {
          existingClasses += cssClass + " ";
        }
      });
      element.setAttribute("class", trim(existingClasses));
    }
  }
  function jqLiteAddNodes(root, elements) {
    if (elements) {
      if (elements.nodeType) {
        root[root.length++] = elements;
      } else {
        var length = elements.length;
        if (typeof length === "number" && elements.window !== elements) {
          if (length) {
            for (var i = 0; i < length; i++) {
              root[root.length++] = elements[i];
            }
          }
        } else {
          root[root.length++] = elements;
        }
      }
    }
  }
  function jqLiteController(element, name) {
    return jqLiteInheritedData(
      element,
      "$" + (name || "ngController") + "Controller"
    );
  }
  function jqLiteInheritedData(element, name, value) {
    if (element.nodeType === NODE_TYPE_DOCUMENT) {
      element = element.documentElement;
    }
    var names = isArray(name) ? name : [name];
    while (element) {
      for (var i = 0, ii = names.length; i < ii; i++) {
        if (isDefined((value = jqLite.data(element, names[i])))) return value;
      }
      element =
        element.parentNode ||
        (element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host);
    }
  }
  function jqLiteEmpty(element) {
    jqLiteDealoc(element, true);
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }
  function jqLiteRemove(element, keepData) {
    if (!keepData) jqLiteDealoc(element);
    var parent = element.parentNode;
    if (parent) parent.removeChild(element);
  }
  function jqLiteDocumentLoaded(action, win) {
    win = win || window;
    if (win.document.readyState === "complete") {
      win.setTimeout(action);
    } else {
      jqLite(win).on("load", action);
    }
  }
  function jqLiteReady(fn) {
    function trigger() {
      window.document.removeEventListener("DOMContentLoaded", trigger);
      window.removeEventListener("load", trigger);
      fn();
    }
    if (window.document.readyState === "complete") {
      window.setTimeout(fn);
    } else {
      window.document.addEventListener("DOMContentLoaded", trigger);
      window.addEventListener("load", trigger);
    }
  }
  var JQLitePrototype = (JQLite.prototype = {
    ready: jqLiteReady,
    toString: function () {
      var value = [];
      forEach(this, function (e) {
        value.push("" + e);
      });
      return "[" + value.join(", ") + "]";
    },
    eq: function (index) {
      return index >= 0
        ? jqLite(this[index])
        : jqLite(this[this.length + index]);
    },
    length: 0,
    push: push,
    sort: [].sort,
    splice: [].splice,
  });
  var BOOLEAN_ATTR = {};
  forEach(
    "multiple,selected,checked,disabled,readOnly,required,open".split(","),
    function (value) {
      BOOLEAN_ATTR[lowercase(value)] = value;
    }
  );
  var BOOLEAN_ELEMENTS = {};
  forEach(
    "input,select,option,textarea,button,form,details".split(","),
    function (value) {
      BOOLEAN_ELEMENTS[value] = true;
    }
  );
  var ALIASED_ATTR = {
    ngMinlength: "minlength",
    ngMaxlength: "maxlength",
    ngMin: "min",
    ngMax: "max",
    ngPattern: "pattern",
    ngStep: "step",
  };
  function getBooleanAttrName(element, name) {
    var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
    return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
  }
  function getAliasedAttrName(name) {
    return ALIASED_ATTR[name];
  }
  forEach(
    {
      data: jqLiteData,
      removeData: jqLiteRemoveData,
      hasData: jqLiteHasData,
      cleanData: jqLiteCleanData,
    },
    function (fn, name) {
      JQLite[name] = fn;
    }
  );
  forEach(
    {
      data: jqLiteData,
      inheritedData: jqLiteInheritedData,
      scope: function (element) {
        return (
          jqLite.data(element, "$scope") ||
          jqLiteInheritedData(element.parentNode || element, [
            "$isolateScope",
            "$scope",
          ])
        );
      },
      isolateScope: function (element) {
        return (
          jqLite.data(element, "$isolateScope") ||
          jqLite.data(element, "$isolateScopeNoTemplate")
        );
      },
      controller: jqLiteController,
      injector: function (element) {
        return jqLiteInheritedData(element, "$injector");
      },
      removeAttr: function (element, name) {
        element.removeAttribute(name);
      },
      hasClass: jqLiteHasClass,
      css: function (element, name, value) {
        name = cssKebabToCamel(name);
        if (isDefined(value)) {
          element.style[name] = value;
        } else {
          return element.style[name];
        }
      },
      attr: function (element, name, value) {
        var ret;
        var nodeType = element.nodeType;
        if (
          nodeType === NODE_TYPE_TEXT ||
          nodeType === NODE_TYPE_ATTRIBUTE ||
          nodeType === NODE_TYPE_COMMENT ||
          !element.getAttribute
        ) {
          return;
        }
        var lowercasedName = lowercase(name);
        var isBooleanAttr = BOOLEAN_ATTR[lowercasedName];
        if (isDefined(value)) {
          if (value === null || (value === false && isBooleanAttr)) {
            element.removeAttribute(name);
          } else {
            element.setAttribute(name, isBooleanAttr ? lowercasedName : value);
          }
        } else {
          ret = element.getAttribute(name);
          if (isBooleanAttr && ret !== null) {
            ret = lowercasedName;
          }
          return ret === null ? undefined : ret;
        }
      },
      prop: function (element, name, value) {
        if (isDefined(value)) {
          element[name] = value;
        } else {
          return element[name];
        }
      },
      text: (function () {
        getText.$dv = "";
        return getText;
        function getText(element, value) {
          if (isUndefined(value)) {
            var nodeType = element.nodeType;
            return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT
              ? element.textContent
              : "";
          }
          element.textContent = value;
        }
      })(),
      val: function (element, value) {
        if (isUndefined(value)) {
          if (element.multiple && nodeName_(element) === "select") {
            var result = [];
            forEach(element.options, function (option) {
              if (option.selected) {
                result.push(option.value || option.text);
              }
            });
            return result;
          }
          return element.value;
        }
        element.value = value;
      },
      html: function (element, value) {
        if (isUndefined(value)) {
          return element.innerHTML;
        }
        jqLiteDealoc(element, true);
        element.innerHTML = value;
      },
      empty: jqLiteEmpty,
    },
    function (fn, name) {
      JQLite.prototype[name] = function (arg1, arg2) {
        var i, key;
        var nodeCount = this.length;
        if (
          fn !== jqLiteEmpty &&
          isUndefined(
            fn.length === 2 && fn !== jqLiteHasClass && fn !== jqLiteController
              ? arg1
              : arg2
          )
        ) {
          if (isObject(arg1)) {
            for (i = 0; i < nodeCount; i++) {
              if (fn === jqLiteData) {
                fn(this[i], arg1);
              } else {
                for (key in arg1) {
                  fn(this[i], key, arg1[key]);
                }
              }
            }
            return this;
          } else {
            var value = fn.$dv;
            var jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount;
            for (var j = 0; j < jj; j++) {
              var nodeValue = fn(this[j], arg1, arg2);
              value = value ? value + nodeValue : nodeValue;
            }
            return value;
          }
        } else {
          for (i = 0; i < nodeCount; i++) {
            fn(this[i], arg1, arg2);
          }
          return this;
        }
      };
    }
  );
  function createEventHandler(element, events) {
    var eventHandler = function (event, type) {
      event.isDefaultPrevented = function () {
        return event.defaultPrevented;
      };
      var eventFns = events[type || event.type];
      var eventFnsLength = eventFns ? eventFns.length : 0;
      if (!eventFnsLength) return;
      if (isUndefined(event.immediatePropagationStopped)) {
        var originalStopImmediatePropagation = event.stopImmediatePropagation;
        event.stopImmediatePropagation = function () {
          event.immediatePropagationStopped = true;
          if (event.stopPropagation) {
            event.stopPropagation();
          }
          if (originalStopImmediatePropagation) {
            originalStopImmediatePropagation.call(event);
          }
        };
      }
      event.isImmediatePropagationStopped = function () {
        return event.immediatePropagationStopped === true;
      };
      var handlerWrapper =
        eventFns.specialHandlerWrapper || defaultHandlerWrapper;
      if (eventFnsLength > 1) {
        eventFns = shallowCopy(eventFns);
      }
      for (var i = 0; i < eventFnsLength; i++) {
        if (!event.isImmediatePropagationStopped()) {
          handlerWrapper(element, event, eventFns[i]);
        }
      }
    };
    eventHandler.elem = element;
    return eventHandler;
  }
  function defaultHandlerWrapper(element, event, handler) {
    handler.call(element, event);
  }
  function specialMouseHandlerWrapper(target, event, handler) {
    var related = event.relatedTarget;
    if (
      !related ||
      (related !== target && !jqLiteContains.call(target, related))
    ) {
      handler.call(target, event);
    }
  }
  forEach(
    {
      removeData: jqLiteRemoveData,
      on: function jqLiteOn(element, type, fn, unsupported) {
        if (isDefined(unsupported))
          throw jqLiteMinErr(
            "onargs",
            "jqLite#on() does not support the `selector` or `eventData` parameters"
          );
        if (!jqLiteAcceptsData(element)) {
          return;
        }
        var expandoStore = jqLiteExpandoStore(element, true);
        var events = expandoStore.events;
        var handle = expandoStore.handle;
        if (!handle) {
          handle = expandoStore.handle = createEventHandler(element, events);
        }
        var types = type.indexOf(" ") >= 0 ? type.split(" ") : [type];
        var i = types.length;
        var addHandler = function (
          type,
          specialHandlerWrapper,
          noEventListener
        ) {
          var eventFns = events[type];
          if (!eventFns) {
            eventFns = events[type] = [];
            eventFns.specialHandlerWrapper = specialHandlerWrapper;
            if (type !== "$destroy" && !noEventListener) {
              element.addEventListener(type, handle);
            }
          }
          eventFns.push(fn);
        };
        while (i--) {
          type = types[i];
          if (MOUSE_EVENT_MAP[type]) {
            addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper);
            addHandler(type, undefined, true);
          } else {
            addHandler(type);
          }
        }
      },
      off: jqLiteOff,
      one: function (element, type, fn) {
        element = jqLite(element);
        element.on(type, function onFn() {
          element.off(type, fn);
          element.off(type, onFn);
        });
        element.on(type, fn);
      },
      replaceWith: function (element, replaceNode) {
        var index,
          parent = element.parentNode;
        jqLiteDealoc(element);
        forEach(new JQLite(replaceNode), function (node) {
          if (index) {
            parent.insertBefore(node, index.nextSibling);
          } else {
            parent.replaceChild(node, element);
          }
          index = node;
        });
      },
      children: function (element) {
        var children = [];
        forEach(element.childNodes, function (element) {
          if (element.nodeType === NODE_TYPE_ELEMENT) {
            children.push(element);
          }
        });
        return children;
      },
      contents: function (element) {
        return element.contentDocument || element.childNodes || [];
      },
      append: function (element, node) {
        var nodeType = element.nodeType;
        if (
          nodeType !== NODE_TYPE_ELEMENT &&
          nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT
        )
          return;
        node = new JQLite(node);
        for (var i = 0, ii = node.length; i < ii; i++) {
          var child = node[i];
          element.appendChild(child);
        }
      },
      prepend: function (element, node) {
        if (element.nodeType === NODE_TYPE_ELEMENT) {
          var index = element.firstChild;
          forEach(new JQLite(node), function (child) {
            element.insertBefore(child, index);
          });
        }
      },
      wrap: function (element, wrapNode) {
        jqLiteWrapNode(element, jqLite(wrapNode).eq(0).clone()[0]);
      },
      remove: jqLiteRemove,
      detach: function (element) {
        jqLiteRemove(element, true);
      },
      after: function (element, newElement) {
        var index = element,
          parent = element.parentNode;
        if (parent) {
          newElement = new JQLite(newElement);
          for (var i = 0, ii = newElement.length; i < ii; i++) {
            var node = newElement[i];
            parent.insertBefore(node, index.nextSibling);
            index = node;
          }
        }
      },
      addClass: jqLiteAddClass,
      removeClass: jqLiteRemoveClass,
      toggleClass: function (element, selector, condition) {
        if (selector) {
          forEach(selector.split(" "), function (className) {
            var classCondition = condition;
            if (isUndefined(classCondition)) {
              classCondition = !jqLiteHasClass(element, className);
            }
            (classCondition
              ? jqLiteAddClass
              : jqLiteRemoveClass)(element, className);
          });
        }
      },
      parent: function (element) {
        var parent = element.parentNode;
        return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT
          ? parent
          : null;
      },
      next: function (element) {
        return element.nextElementSibling;
      },
      find: function (element, selector) {
        if (element.getElementsByTagName) {
          return element.getElementsByTagName(selector);
        } else {
          return [];
        }
      },
      clone: jqLiteClone,
      triggerHandler: function (element, event, extraParameters) {
        var dummyEvent, eventFnsCopy, handlerArgs;
        var eventName = event.type || event;
        var expandoStore = jqLiteExpandoStore(element);
        var events = expandoStore && expandoStore.events;
        var eventFns = events && events[eventName];
        if (eventFns) {
          dummyEvent = {
            preventDefault: function () {
              this.defaultPrevented = true;
            },
            isDefaultPrevented: function () {
              return this.defaultPrevented === true;
            },
            stopImmediatePropagation: function () {
              this.immediatePropagationStopped = true;
            },
            isImmediatePropagationStopped: function () {
              return this.immediatePropagationStopped === true;
            },
            stopPropagation: noop,
            type: eventName,
            target: element,
          };
          if (event.type) {
            dummyEvent = extend(dummyEvent, event);
          }
          eventFnsCopy = shallowCopy(eventFns);
          handlerArgs = extraParameters
            ? [dummyEvent].concat(extraParameters)
            : [dummyEvent];
          forEach(eventFnsCopy, function (fn) {
            if (!dummyEvent.isImmediatePropagationStopped()) {
              fn.apply(element, handlerArgs);
            }
          });
        }
      },
    },
    function (fn, name) {
      JQLite.prototype[name] = function (arg1, arg2, arg3) {
        var value;
        for (var i = 0, ii = this.length; i < ii; i++) {
          if (isUndefined(value)) {
            value = fn(this[i], arg1, arg2, arg3);
            if (isDefined(value)) {
              value = jqLite(value);
            }
          } else {
            jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
          }
        }
        return isDefined(value) ? value : this;
      };
    }
  );
  JQLite.prototype.bind = JQLite.prototype.on;
  JQLite.prototype.unbind = JQLite.prototype.off;
  function $$jqLiteProvider() {
    this.$get = function $$jqLite() {
      return extend(JQLite, {
        hasClass: function (node, classes) {
          if (node.attr) node = node[0];
          return jqLiteHasClass(node, classes);
        },
        addClass: function (node, classes) {
          if (node.attr) node = node[0];
          return jqLiteAddClass(node, classes);
        },
        removeClass: function (node, classes) {
          if (node.attr) node = node[0];
          return jqLiteRemoveClass(node, classes);
        },
      });
    };
  }
  function hashKey(obj, nextUidFn) {
    var key = obj && obj.$$hashKey;
    if (key) {
      if (typeof key === "function") {
        key = obj.$$hashKey();
      }
      return key;
    }
    var objType = typeof obj;
    if (objType === "function" || (objType === "object" && obj !== null)) {
      key = obj.$$hashKey = objType + ":" + (nextUidFn || nextUid)();
    } else {
      key = objType + ":" + obj;
    }
    return key;
  }
  function HashMap(array, isolatedUid) {
    if (isolatedUid) {
      var uid = 0;
      this.nextUid = function () {
        return ++uid;
      };
    }
    forEach(array, this.put, this);
  }
  HashMap.prototype = {
    put: function (key, value) {
      this[hashKey(key, this.nextUid)] = value;
    },
    get: function (key) {
      return this[hashKey(key, this.nextUid)];
    },
    remove: function (key) {
      var value = this[(key = hashKey(key, this.nextUid))];
      delete this[key];
      return value;
    },
  };
  var $$HashMapProvider = [
    function () {
      this.$get = [
        function () {
          return HashMap;
        },
      ];
    },
  ];
  var ARROW_ARG = /^([^(]+?)=>/;
  var FN_ARGS = /^[^(]*\(\s*([^)]*)\)/m;
  var FN_ARG_SPLIT = /,/;
  var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
  var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
  var $injectorMinErr = minErr("$injector");
  function stringifyFn(fn) {
    return Function.prototype.toString.call(fn) + " ";
  }
  function extractArgs(fn) {
    var fnText = stringifyFn(fn).replace(STRIP_COMMENTS, ""),
      args = fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
    return args;
  }
  function anonFn(fn) {
    var args = extractArgs(fn);
    if (args) {
      return "function(" + (args[1] || "").replace(/[\s\r\n]+/, " ") + ")";
    }
    return "fn";
  }
  function annotate(fn, strictDi, name) {
    var $inject, argDecl, last;
    if (typeof fn === "function") {
      if (!($inject = fn.$inject)) {
        $inject = [];
        if (fn.length) {
          if (strictDi) {
            if (!isString(name) || !name) {
              name = fn.name || anonFn(fn);
            }
            throw $injectorMinErr(
              "strictdi",
              "{0} is not using explicit annotation and cannot be invoked in strict mode",
              name
            );
          }
          argDecl = extractArgs(fn);
          forEach(argDecl[1].split(FN_ARG_SPLIT), function (arg) {
            arg.replace(FN_ARG, function (all, underscore, name) {
              $inject.push(name);
            });
          });
        }
        fn.$inject = $inject;
      }
    } else if (isArray(fn)) {
      last = fn.length - 1;
      assertArgFn(fn[last], "fn");
      $inject = fn.slice(0, last);
    } else {
      assertArgFn(fn, "fn", true);
    }
    return $inject;
  }
  function createInjector(modulesToLoad, strictDi) {
    strictDi = strictDi === true;
    var INSTANTIATING = {},
      providerSuffix = "Provider",
      path = [],
      loadedModules = new HashMap([], true),
      providerCache = {
        $provide: {
          provider: supportObject(provider),
          factory: supportObject(factory),
          service: supportObject(service),
          value: supportObject(value),
          constant: supportObject(constant),
          decorator: decorator,
        },
      },
      providerInjector = (providerCache.$injector = createInternalInjector(
        providerCache,
        function (serviceName, caller) {
          if (angular.isString(caller)) {
            path.push(caller);
          }
          throw $injectorMinErr(
            "unpr",
            "Unknown provider: {0}",
            path.join(" <- ")
          );
        }
      )),
      instanceCache = {},
      protoInstanceInjector = createInternalInjector(
        instanceCache,
        function (serviceName, caller) {
          var provider = providerInjector.get(
            serviceName + providerSuffix,
            caller
          );
          return instanceInjector.invoke(
            provider.$get,
            provider,
            undefined,
            serviceName
          );
        }
      ),
      instanceInjector = protoInstanceInjector;
    providerCache["$injector" + providerSuffix] = {
      $get: valueFn(protoInstanceInjector),
    };
    var runBlocks = loadModules(modulesToLoad);
    instanceInjector = protoInstanceInjector.get("$injector");
    instanceInjector.strictDi = strictDi;
    forEach(runBlocks, function (fn) {
      if (fn) instanceInjector.invoke(fn);
    });
    return instanceInjector;
    function supportObject(delegate) {
      return function (key, value) {
        if (isObject(key)) {
          forEach(key, reverseParams(delegate));
        } else {
          return delegate(key, value);
        }
      };
    }
    function provider(name, provider_) {
      assertNotHasOwnProperty(name, "service");
      if (isFunction(provider_) || isArray(provider_)) {
        provider_ = providerInjector.instantiate(provider_);
      }
      if (!provider_.$get) {
        throw $injectorMinErr(
          "pget",
          "Provider '{0}' must define $get factory method.",
          name
        );
      }
      return (providerCache[name + providerSuffix] = provider_);
    }
    function enforceReturnValue(name, factory) {
      return function enforcedReturnValue() {
        var result = instanceInjector.invoke(factory, this);
        if (isUndefined(result)) {
          throw $injectorMinErr(
            "undef",
            "Provider '{0}' must return a value from $get factory method.",
            name
          );
        }
        return result;
      };
    }
    function factory(name, factoryFn, enforce) {
      return provider(name, {
        $get:
          enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn,
      });
    }
    function service(name, constructor) {
      return factory(name, [
        "$injector",
        function ($injector) {
          return $injector.instantiate(constructor);
        },
      ]);
    }
    function value(name, val) {
      return factory(name, valueFn(val), false);
    }
    function constant(name, value) {
      assertNotHasOwnProperty(name, "constant");
      providerCache[name] = value;
      instanceCache[name] = value;
    }
    function decorator(serviceName, decorFn) {
      var origProvider = providerInjector.get(serviceName + providerSuffix),
        orig$get = origProvider.$get;
      origProvider.$get = function () {
        var origInstance = instanceInjector.invoke(orig$get, origProvider);
        return instanceInjector.invoke(decorFn, null, {
          $delegate: origInstance,
        });
      };
    }
    function loadModules(modulesToLoad) {
      assertArg(
        isUndefined(modulesToLoad) || isArray(modulesToLoad),
        "modulesToLoad",
        "not an array"
      );
      var runBlocks = [],
        moduleFn;
      forEach(modulesToLoad, function (module) {
        if (loadedModules.get(module)) return;
        loadedModules.put(module, true);
        function runInvokeQueue(queue) {
          var i, ii;
          for (i = 0, ii = queue.length; i < ii; i++) {
            var invokeArgs = queue[i],
              provider = providerInjector.get(invokeArgs[0]);
            provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
          }
        }
        try {
          if (isString(module)) {
            moduleFn = angularModule(module);
            runBlocks = runBlocks
              .concat(loadModules(moduleFn.requires))
              .concat(moduleFn._runBlocks);
            runInvokeQueue(moduleFn._invokeQueue);
            runInvokeQueue(moduleFn._configBlocks);
          } else if (isFunction(module)) {
            runBlocks.push(providerInjector.invoke(module));
          } else if (isArray(module)) {
            runBlocks.push(providerInjector.invoke(module));
          } else {
            assertArgFn(module, "module");
          }
        } catch (e) {
          if (isArray(module)) {
            module = module[module.length - 1];
          }
          if (e.message && e.stack && e.stack.indexOf(e.message) === -1) {
            e = e.message + "\n" + e.stack;
          }
          throw $injectorMinErr(
            "modulerr",
            "Failed to instantiate module {0} due to:\n{1}",
            module,
            e.stack || e.message || e
          );
        }
      });
      return runBlocks;
    }
    function createInternalInjector(cache, factory) {
      function getService(serviceName, caller) {
        if (cache.hasOwnProperty(serviceName)) {
          if (cache[serviceName] === INSTANTIATING) {
            throw $injectorMinErr(
              "cdep",
              "Circular dependency found: {0}",
              serviceName + " <- " + path.join(" <- ")
            );
          }
          return cache[serviceName];
        } else {
          try {
            path.unshift(serviceName);
            cache[serviceName] = INSTANTIATING;
            cache[serviceName] = factory(serviceName, caller);
            return cache[serviceName];
          } catch (err) {
            if (cache[serviceName] === INSTANTIATING) {
              delete cache[serviceName];
            }
            throw err;
          } finally {
            path.shift();
          }
        }
      }
      function injectionArgs(fn, locals, serviceName) {
        var args = [],
          $inject = createInjector.$$annotate(fn, strictDi, serviceName);
        for (var i = 0, length = $inject.length; i < length; i++) {
          var key = $inject[i];
          if (typeof key !== "string") {
            throw $injectorMinErr(
              "itkn",
              "Incorrect injection token! Expected service name as string, got {0}",
              key
            );
          }
          args.push(
            locals && locals.hasOwnProperty(key)
              ? locals[key]
              : getService(key, serviceName)
          );
        }
        return args;
      }
      function isClass(func) {
        if (msie || typeof func !== "function") {
          return false;
        }
        var result = func.$$ngIsClass;
        if (!isBoolean(result)) {
          result = func.$$ngIsClass = /^(?:class\b|constructor\()/.test(
            stringifyFn(func)
          );
        }
        return result;
      }
      function invoke(fn, self, locals, serviceName) {
        if (typeof locals === "string") {
          serviceName = locals;
          locals = null;
        }
        var args = injectionArgs(fn, locals, serviceName);
        if (isArray(fn)) {
          fn = fn[fn.length - 1];
        }
        if (!isClass(fn)) {
          return fn.apply(self, args);
        } else {
          args.unshift(null);
          return new (Function.prototype.bind.apply(fn, args))();
        }
      }
      function instantiate(Type, locals, serviceName) {
        var ctor = isArray(Type) ? Type[Type.length - 1] : Type;
        var args = injectionArgs(Type, locals, serviceName);
        args.unshift(null);
        return new (Function.prototype.bind.apply(ctor, args))();
      }
      return {
        invoke: invoke,
        instantiate: instantiate,
        get: getService,
        annotate: createInjector.$$annotate,
        has: function (name) {
          return (
            providerCache.hasOwnProperty(name + providerSuffix) ||
            cache.hasOwnProperty(name)
          );
        },
      };
    }
  }
  createInjector.$$annotate = annotate;
  function $AnchorScrollProvider() {
    var autoScrollingEnabled = true;
    this.disableAutoScrolling = function () {
      autoScrollingEnabled = false;
    };
    this.$get = [
      "$window",
      "$location",
      "$rootScope",
      function ($window, $location, $rootScope) {
        var document = $window.document;
        function getFirstAnchor(list) {
          var result = null;
          Array.prototype.some.call(list, function (element) {
            if (nodeName_(element) === "a") {
              result = element;
              return true;
            }
          });
          return result;
        }
        function getYOffset() {
          var offset = scroll.yOffset;
          if (isFunction(offset)) {
            offset = offset();
          } else if (isElement(offset)) {
            var elem = offset[0];
            var style = $window.getComputedStyle(elem);
            if (style.position !== "fixed") {
              offset = 0;
            } else {
              offset = elem.getBoundingClientRect().bottom;
            }
          } else if (!isNumber(offset)) {
            offset = 0;
          }
          return offset;
        }
        function scrollTo(elem) {
          if (elem) {
            elem.scrollIntoView();
            var offset = getYOffset();
            if (offset) {
              var elemTop = elem.getBoundingClientRect().top;
              $window.scrollBy(0, elemTop - offset);
            }
          } else {
            $window.scrollTo(0, 0);
          }
        }
        function scroll(hash) {
          hash = isString(hash)
            ? hash
            : isNumber(hash)
            ? hash.toString()
            : $location.hash();
          var elm;
          if (!hash) scrollTo(null);
          else if ((elm = document.getElementById(hash))) scrollTo(elm);
          else if ((elm = getFirstAnchor(document.getElementsByName(hash))))
            scrollTo(elm);
          else if (hash === "top") scrollTo(null);
        }
        if (autoScrollingEnabled) {
          $rootScope.$watch(
            function autoScrollWatch() {
              return $location.hash();
            },
            function autoScrollWatchAction(newVal, oldVal) {
              if (newVal === oldVal && newVal === "") return;
              jqLiteDocumentLoaded(function () {
                $rootScope.$evalAsync(scroll);
              });
            }
          );
        }
        return scroll;
      },
    ];
  }
  var $animateMinErr = minErr("$animate");
  var ELEMENT_NODE = 1;
  var NG_ANIMATE_CLASSNAME = "ng-animate";
  function mergeClasses(a, b) {
    if (!a && !b) return "";
    if (!a) return b;
    if (!b) return a;
    if (isArray(a)) a = a.join(" ");
    if (isArray(b)) b = b.join(" ");
    return a + " " + b;
  }
  function extractElementNode(element) {
    for (var i = 0; i < element.length; i++) {
      var elm = element[i];
      if (elm.nodeType === ELEMENT_NODE) {
        return elm;
      }
    }
  }
  function splitClasses(classes) {
    if (isString(classes)) {
      classes = classes.split(" ");
    }
    var obj = createMap();
    forEach(classes, function (klass) {
      if (klass.length) {
        obj[klass] = true;
      }
    });
    return obj;
  }
  function prepareAnimateOptions(options) {
    return isObject(options) ? options : {};
  }
  var $$CoreAnimateJsProvider = function () {
    this.$get = noop;
  };
  var $$CoreAnimateQueueProvider = function () {
    var postDigestQueue = new HashMap();
    var postDigestElements = [];
    this.$get = [
      "$$AnimateRunner",
      "$rootScope",
      function ($$AnimateRunner, $rootScope) {
        return {
          enabled: noop,
          on: noop,
          off: noop,
          pin: noop,
          push: function (element, event, options, domOperation) {
            if (domOperation) {
              domOperation();
            }
            options = options || {};
            if (options.from) {
              element.css(options.from);
            }
            if (options.to) {
              element.css(options.to);
            }
            if (options.addClass || options.removeClass) {
              addRemoveClassesPostDigest(
                element,
                options.addClass,
                options.removeClass
              );
            }
            var runner = new $$AnimateRunner();
            runner.complete();
            return runner;
          },
        };
        function updateData(data, classes, value) {
          var changed = false;
          if (classes) {
            classes = isString(classes)
              ? classes.split(" ")
              : isArray(classes)
              ? classes
              : [];
            forEach(classes, function (className) {
              if (className) {
                changed = true;
                data[className] = value;
              }
            });
          }
          return changed;
        }
        function handleCSSClassChanges() {
          forEach(postDigestElements, function (element) {
            var data = postDigestQueue.get(element);
            if (data) {
              var existing = splitClasses(element.attr("class"));
              var toAdd = "";
              var toRemove = "";
              forEach(data, function (status, className) {
                var hasClass = !!existing[className];
                if (status !== hasClass) {
                  if (status) {
                    toAdd += (toAdd.length ? " " : "") + className;
                  } else {
                    toRemove += (toRemove.length ? " " : "") + className;
                  }
                }
              });
              forEach(element, function (elm) {
                if (toAdd) {
                  jqLiteAddClass(elm, toAdd);
                }
                if (toRemove) {
                  jqLiteRemoveClass(elm, toRemove);
                }
              });
              postDigestQueue.remove(element);
            }
          });
          postDigestElements.length = 0;
        }
        function addRemoveClassesPostDigest(element, add, remove) {
          var data = postDigestQueue.get(element) || {};
          var classesAdded = updateData(data, add, true);
          var classesRemoved = updateData(data, remove, false);
          if (classesAdded || classesRemoved) {
            postDigestQueue.put(element, data);
            postDigestElements.push(element);
            if (postDigestElements.length === 1) {
              $rootScope.$$postDigest(handleCSSClassChanges);
            }
          }
        }
      },
    ];
  };
  var $AnimateProvider = [
    "$provide",
    function ($provide) {
      var provider = this;
      this.$$registeredAnimations = Object.create(null);
      this.register = function (name, factory) {
        if (name && name.charAt(0) !== ".") {
          throw $animateMinErr(
            "notcsel",
            "Expecting class selector starting with '.' got '{0}'.",
            name
          );
        }
        var key = name + "-animation";
        provider.$$registeredAnimations[name.substr(1)] = key;
        $provide.factory(key, factory);
      };
      this.classNameFilter = function (expression) {
        if (arguments.length === 1) {
          this.$$classNameFilter =
            expression instanceof RegExp ? expression : null;
          if (this.$$classNameFilter) {
            var reservedRegex = new RegExp(
              "(\\s+|\\/)" + NG_ANIMATE_CLASSNAME + "(\\s+|\\/)"
            );
            if (reservedRegex.test(this.$$classNameFilter.toString())) {
              throw $animateMinErr(
                "nongcls",
                '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.',
                NG_ANIMATE_CLASSNAME
              );
            }
          }
        }
        return this.$$classNameFilter;
      };
      this.$get = [
        "$$animateQueue",
        function ($$animateQueue) {
          function domInsert(element, parentElement, afterElement) {
            if (afterElement) {
              var afterNode = extractElementNode(afterElement);
              if (
                afterNode &&
                !afterNode.parentNode &&
                !afterNode.previousElementSibling
              ) {
                afterElement = null;
              }
            }
            if (afterElement) {
              afterElement.after(element);
            } else {
              parentElement.prepend(element);
            }
          }
          return {
            on: $$animateQueue.on,
            off: $$animateQueue.off,
            pin: $$animateQueue.pin,
            enabled: $$animateQueue.enabled,
            cancel: function (runner) {
              if (runner.end) {
                runner.end();
              }
            },
            enter: function (element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(
                element,
                "enter",
                prepareAnimateOptions(options)
              );
            },
            move: function (element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(
                element,
                "move",
                prepareAnimateOptions(options)
              );
            },
            leave: function (element, options) {
              return $$animateQueue.push(
                element,
                "leave",
                prepareAnimateOptions(options),
                function () {
                  element.remove();
                }
              );
            },
            addClass: function (element, className, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addclass, className);
              return $$animateQueue.push(element, "addClass", options);
            },
            removeClass: function (element, className, options) {
              options = prepareAnimateOptions(options);
              options.removeClass = mergeClasses(
                options.removeClass,
                className
              );
              return $$animateQueue.push(element, "removeClass", options);
            },
            setClass: function (element, add, remove, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addClass, add);
              options.removeClass = mergeClasses(options.removeClass, remove);
              return $$animateQueue.push(element, "setClass", options);
            },
            animate: function (element, from, to, className, options) {
              options = prepareAnimateOptions(options);
              options.from = options.from ? extend(options.from, from) : from;
              options.to = options.to ? extend(options.to, to) : to;
              className = className || "ng-inline-animate";
              options.tempClasses = mergeClasses(
                options.tempClasses,
                className
              );
              return $$animateQueue.push(element, "animate", options);
            },
          };
        },
      ];
    },
  ];
  var $$AnimateAsyncRunFactoryProvider = function () {
    this.$get = [
      "$$rAF",
      function ($$rAF) {
        var waitQueue = [];
        function waitForTick(fn) {
          waitQueue.push(fn);
          if (waitQueue.length > 1) return;
          $$rAF(function () {
            for (var i = 0; i < waitQueue.length; i++) {
              waitQueue[i]();
            }
            waitQueue = [];
          });
        }
        return function () {
          var passed = false;
          waitForTick(function () {
            passed = true;
          });
          return function (callback) {
            if (passed) {
              callback();
            } else {
              waitForTick(callback);
            }
          };
        };
      },
    ];
  };
  var $$AnimateRunnerFactoryProvider = function () {
    this.$get = [
      "$q",
      "$sniffer",
      "$$animateAsyncRun",
      "$$isDocumentHidden",
      "$timeout",
      function ($q, $sniffer, $$animateAsyncRun, $$isDocumentHidden, $timeout) {
        var INITIAL_STATE = 0;
        var DONE_PENDING_STATE = 1;
        var DONE_COMPLETE_STATE = 2;
        AnimateRunner.chain = function (chain, callback) {
          var index = 0;
          next();
          function next() {
            if (index === chain.length) {
              callback(true);
              return;
            }
            chain[index](function (response) {
              if (response === false) {
                callback(false);
                return;
              }
              index++;
              next();
            });
          }
        };
        AnimateRunner.all = function (runners, callback) {
          var count = 0;
          var status = true;
          forEach(runners, function (runner) {
            runner.done(onProgress);
          });
          function onProgress(response) {
            status = status && response;
            if (++count === runners.length) {
              callback(status);
            }
          }
        };
        function AnimateRunner(host) {
          this.setHost(host);
          var rafTick = $$animateAsyncRun();
          var timeoutTick = function (fn) {
            $timeout(fn, 0, false);
          };
          this._doneCallbacks = [];
          this._tick = function (fn) {
            if ($$isDocumentHidden()) {
              timeoutTick(fn);
            } else {
              rafTick(fn);
            }
          };
          this._state = 0;
        }
        AnimateRunner.prototype = {
          setHost: function (host) {
            this.host = host || {};
          },
          done: function (fn) {
            if (this._state === DONE_COMPLETE_STATE) {
              fn();
            } else {
              this._doneCallbacks.push(fn);
            }
          },
          progress: noop,
          getPromise: function () {
            if (!this.promise) {
              var self = this;
              this.promise = $q(function (resolve, reject) {
                self.done(function (status) {
                  if (status === false) {
                    reject();
                  } else {
                    resolve();
                  }
                });
              });
            }
            return this.promise;
          },
          then: function (resolveHandler, rejectHandler) {
            return this.getPromise().then(resolveHandler, rejectHandler);
          },
          catch: function (handler) {
            return this.getPromise()["catch"](handler);
          },
          finally: function (handler) {
            return this.getPromise()["finally"](handler);
          },
          pause: function () {
            if (this.host.pause) {
              this.host.pause();
            }
          },
          resume: function () {
            if (this.host.resume) {
              this.host.resume();
            }
          },
          end: function () {
            if (this.host.end) {
              this.host.end();
            }
            this._resolve(true);
          },
          cancel: function () {
            if (this.host.cancel) {
              this.host.cancel();
            }
            this._resolve(false);
          },
          complete: function (response) {
            var self = this;
            if (self._state === INITIAL_STATE) {
              self._state = DONE_PENDING_STATE;
              self._tick(function () {
                self._resolve(response);
              });
            }
          },
          _resolve: function (response) {
            if (this._state !== DONE_COMPLETE_STATE) {
              forEach(this._doneCallbacks, function (fn) {
                fn(response);
              });
              this._doneCallbacks.length = 0;
              this._state = DONE_COMPLETE_STATE;
            }
          },
        };
        return AnimateRunner;
      },
    ];
  };
  var $CoreAnimateCssProvider = function () {
    this.$get = [
      "$$rAF",
      "$q",
      "$$AnimateRunner",
      function ($$rAF, $q, $$AnimateRunner) {
        return function (element, initialOptions) {
          var options = initialOptions || {};
          if (!options.$$prepared) {
            options = copy(options);
          }
          if (options.cleanupStyles) {
            options.from = options.to = null;
          }
          if (options.from) {
            element.css(options.from);
            options.from = null;
          }
          var closed,
            runner = new $$AnimateRunner();
          return { start: run, end: run };
          function run() {
            $$rAF(function () {
              applyAnimationContents();
              if (!closed) {
                runner.complete();
              }
              closed = true;
            });
            return runner;
          }
          function applyAnimationContents() {
            if (options.addClass) {
              element.addClass(options.addClass);
              options.addClass = null;
            }
            if (options.removeClass) {
              element.removeClass(options.removeClass);
              options.removeClass = null;
            }
            if (options.to) {
              element.css(options.to);
              options.to = null;
            }
          }
        };
      },
    ];
  };
  function Browser(window, document, $log, $sniffer) {
    var self = this,
      location = window.location,
      history = window.history,
      setTimeout = window.setTimeout,
      clearTimeout = window.clearTimeout,
      pendingDeferIds = {};
    self.isMock = false;
    var outstandingRequestCount = 0;
    var outstandingRequestCallbacks = [];
    self.$$completeOutstandingRequest = completeOutstandingRequest;
    self.$$incOutstandingRequestCount = function () {
      outstandingRequestCount++;
    };
    function completeOutstandingRequest(fn) {
      try {
        fn.apply(null, sliceArgs(arguments, 1));
      } finally {
        outstandingRequestCount--;
        if (outstandingRequestCount === 0) {
          while (outstandingRequestCallbacks.length) {
            try {
              outstandingRequestCallbacks.pop()();
            } catch (e) {
              $log.error(e);
            }
          }
        }
      }
    }
    function getHash(url) {
      var index = url.indexOf("#");
      return index === -1 ? "" : url.substr(index);
    }
    self.notifyWhenNoOutstandingRequests = function (callback) {
      if (outstandingRequestCount === 0) {
        callback();
      } else {
        outstandingRequestCallbacks.push(callback);
      }
    };
    var cachedState,
      lastHistoryState,
      lastBrowserUrl = location.href,
      baseElement = document.find("base"),
      pendingLocation = null,
      getCurrentState = !$sniffer.history
        ? noop
        : function getCurrentState() {
            try {
              return history.state;
            } catch (e) {}
          };
    cacheState();
    lastHistoryState = cachedState;
    self.url = function (url, replace, state) {
      if (isUndefined(state)) {
        state = null;
      }
      if (location !== window.location) location = window.location;
      if (history !== window.history) history = window.history;
      if (url) {
        var sameState = lastHistoryState === state;
        if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
          return self;
        }
        var sameBase =
          lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
        lastBrowserUrl = url;
        lastHistoryState = state;
        if ($sniffer.history && (!sameBase || !sameState)) {
          history[replace ? "replaceState" : "pushState"](state, "", url);
          cacheState();
          lastHistoryState = cachedState;
        } else {
          if (!sameBase) {
            pendingLocation = url;
          }
          if (replace) {
            location.replace(url);
          } else if (!sameBase) {
            location.href = url;
          } else {
            location.hash = getHash(url);
          }
          if (location.href !== url) {
            pendingLocation = url;
          }
        }
        if (pendingLocation) {
          pendingLocation = url;
        }
        return self;
      } else {
        return pendingLocation || location.href.replace(/%27/g, "'");
      }
    };
    self.state = function () {
      return cachedState;
    };
    var urlChangeListeners = [],
      urlChangeInit = false;
    function cacheStateAndFireUrlChange() {
      pendingLocation = null;
      cacheState();
      fireUrlChange();
    }
    var lastCachedState = null;
    function cacheState() {
      cachedState = getCurrentState();
      cachedState = isUndefined(cachedState) ? null : cachedState;
      if (equals(cachedState, lastCachedState)) {
        cachedState = lastCachedState;
      }
      lastCachedState = cachedState;
    }
    function fireUrlChange() {
      if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
        return;
      }
      lastBrowserUrl = self.url();
      lastHistoryState = cachedState;
      forEach(urlChangeListeners, function (listener) {
        listener(self.url(), cachedState);
      });
    }
    self.onUrlChange = function (callback) {
      if (!urlChangeInit) {
        if ($sniffer.history)
          jqLite(window).on("popstate", cacheStateAndFireUrlChange);
        jqLite(window).on("hashchange", cacheStateAndFireUrlChange);
        urlChangeInit = true;
      }
      urlChangeListeners.push(callback);
      return callback;
    };
    self.$$applicationDestroyed = function () {
      jqLite(window).off("hashchange popstate", cacheStateAndFireUrlChange);
    };
    self.$$checkUrlChange = fireUrlChange;
    self.baseHref = function () {
      var href = baseElement.attr("href");
      return href ? href.replace(/^(https?:)?\/\/[^\/]*/, "") : "";
    };
    self.defer = function (fn, delay) {
      var timeoutId;
      outstandingRequestCount++;
      timeoutId = setTimeout(function () {
        delete pendingDeferIds[timeoutId];
        completeOutstandingRequest(fn);
      }, delay || 0);
      pendingDeferIds[timeoutId] = true;
      return timeoutId;
    };
    self.defer.cancel = function (deferId) {
      if (pendingDeferIds[deferId]) {
        delete pendingDeferIds[deferId];
        clearTimeout(deferId);
        completeOutstandingRequest(noop);
        return true;
      }
      return false;
    };
  }
  function $BrowserProvider() {
    this.$get = [
      "$window",
      "$log",
      "$sniffer",
      "$document",
      function ($window, $log, $sniffer, $document) {
        return new Browser($window, $document, $log, $sniffer);
      },
    ];
  }
  function $CacheFactoryProvider() {
    this.$get = function () {
      var caches = {};
      function cacheFactory(cacheId, options) {
        if (cacheId in caches) {
          throw minErr("$cacheFactory")(
            "iid",
            "CacheId '{0}' is already taken!",
            cacheId
          );
        }
        var size = 0,
          stats = extend({}, options, { id: cacheId }),
          data = createMap(),
          capacity = (options && options.capacity) || Number.MAX_VALUE,
          lruHash = createMap(),
          freshEnd = null,
          staleEnd = null;
        return (caches[cacheId] = {
          put: function (key, value) {
            if (isUndefined(value)) return;
            if (capacity < Number.MAX_VALUE) {
              var lruEntry = lruHash[key] || (lruHash[key] = { key: key });
              refresh(lruEntry);
            }
            if (!(key in data)) size++;
            data[key] = value;
            if (size > capacity) {
              this.remove(staleEnd.key);
            }
            return value;
          },
          get: function (key) {
            if (capacity < Number.MAX_VALUE) {
              var lruEntry = lruHash[key];
              if (!lruEntry) return;
              refresh(lruEntry);
            }
            return data[key];
          },
          remove: function (key) {
            if (capacity < Number.MAX_VALUE) {
              var lruEntry = lruHash[key];
              if (!lruEntry) return;
              if (lruEntry === freshEnd) freshEnd = lruEntry.p;
              if (lruEntry === staleEnd) staleEnd = lruEntry.n;
              link(lruEntry.n, lruEntry.p);
              delete lruHash[key];
            }
            if (!(key in data)) return;
            delete data[key];
            size--;
          },
          removeAll: function () {
            data = createMap();
            size = 0;
            lruHash = createMap();
            freshEnd = staleEnd = null;
          },
          destroy: function () {
            data = null;
            stats = null;
            lruHash = null;
            delete caches[cacheId];
          },
          info: function () {
            return extend({}, stats, { size: size });
          },
        });
        function refresh(entry) {
          if (entry !== freshEnd) {
            if (!staleEnd) {
              staleEnd = entry;
            } else if (staleEnd === entry) {
              staleEnd = entry.n;
            }
            link(entry.n, entry.p);
            link(entry, freshEnd);
            freshEnd = entry;
            freshEnd.n = null;
          }
        }
        function link(nextEntry, prevEntry) {
          if (nextEntry !== prevEntry) {
            if (nextEntry) nextEntry.p = prevEntry;
            if (prevEntry) prevEntry.n = nextEntry;
          }
        }
      }
      cacheFactory.info = function () {
        var info = {};
        forEach(caches, function (cache, cacheId) {
          info[cacheId] = cache.info();
        });
        return info;
      };
      cacheFactory.get = function (cacheId) {
        return caches[cacheId];
      };
      return cacheFactory;
    };
  }
  function $TemplateCacheProvider() {
    this.$get = [
      "$cacheFactory",
      function ($cacheFactory) {
        return $cacheFactory("templates");
      },
    ];
  }
  var $compileMinErr = minErr("$compile");
  function UNINITIALIZED_VALUE() {}
  var _UNINITIALIZED_VALUE = new UNINITIALIZED_VALUE();
  $CompileProvider.$inject = ["$provide", "$$sanitizeUriProvider"];
  function $CompileProvider($provide, $$sanitizeUriProvider) {
    var hasDirectives = {},
      Suffix = "Directive",
      COMMENT_DIRECTIVE_REGEXP = /^\s*directive:\s*([\w-]+)\s+(.*)$/,
      CLASS_DIRECTIVE_REGEXP = /(([\w-]+)(?::([^;]+))?;?)/,
      ALL_OR_NOTHING_ATTRS = makeMap("ngSrc,ngSrcset,src,srcset"),
      REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
    var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
    var bindingCache = createMap();
    function parseIsolateBindings(scope, directiveName, isController) {
      var LOCAL_REGEXP = /^\s*([@&<]|=(\*?))(\??)\s*(\w*)\s*$/;
      var bindings = createMap();
      forEach(scope, function (definition, scopeName) {
        if (definition in bindingCache) {
          bindings[scopeName] = bindingCache[definition];
          return;
        }
        var match = definition.match(LOCAL_REGEXP);
        if (!match) {
          throw $compileMinErr(
            "iscp",
            "Invalid {3} for directive '{0}'." +
              " Definition: {... {1}: '{2}' ...}",
            directiveName,
            scopeName,
            definition,
            isController
              ? "controller bindings definition"
              : "isolate scope definition"
          );
        }
        bindings[scopeName] = {
          mode: match[1][0],
          collection: match[2] === "*",
          optional: match[3] === "?",
          attrName: match[4] || scopeName,
        };
        if (match[4]) {
          bindingCache[definition] = bindings[scopeName];
        }
      });
      return bindings;
    }
    function parseDirectiveBindings(directive, directiveName) {
      var bindings = { isolateScope: null, bindToController: null };
      if (isObject(directive.scope)) {
        if (directive.bindToController === true) {
          bindings.bindToController = parseIsolateBindings(
            directive.scope,
            directiveName,
            true
          );
          bindings.isolateScope = {};
        } else {
          bindings.isolateScope = parseIsolateBindings(
            directive.scope,
            directiveName,
            false
          );
        }
      }
      if (isObject(directive.bindToController)) {
        bindings.bindToController = parseIsolateBindings(
          directive.bindToController,
          directiveName,
          true
        );
      }
      if (bindings.bindToController && !directive.controller) {
        throw $compileMinErr(
          "noctrl",
          "Cannot bind to controller without directive '{0}'s controller.",
          directiveName
        );
      }
      return bindings;
    }
    function assertValidDirectiveName(name) {
      var letter = name.charAt(0);
      if (!letter || letter !== lowercase(letter)) {
        throw $compileMinErr(
          "baddir",
          "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter",
          name
        );
      }
      if (name !== name.trim()) {
        throw $compileMinErr(
          "baddir",
          "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces",
          name
        );
      }
    }
    function getDirectiveRequire(directive) {
      var require =
        directive.require || (directive.controller && directive.name);
      if (!isArray(require) && isObject(require)) {
        forEach(require, function (value, key) {
          var match = value.match(REQUIRE_PREFIX_REGEXP);
          var name = value.substring(match[0].length);
          if (!name) require[key] = match[0] + key;
        });
      }
      return require;
    }
    function getDirectiveRestrict(restrict, name) {
      if (restrict && !(isString(restrict) && /[EACM]/.test(restrict))) {
        throw $compileMinErr(
          "badrestrict",
          "Restrict property '{0}' of directive '{1}' is invalid",
          restrict,
          name
        );
      }
      return restrict || "EA";
    }
    this.directive = function registerDirective(name, directiveFactory) {
      assertArg(name, "name");
      assertNotHasOwnProperty(name, "directive");
      if (isString(name)) {
        assertValidDirectiveName(name);
        assertArg(directiveFactory, "directiveFactory");
        if (!hasDirectives.hasOwnProperty(name)) {
          hasDirectives[name] = [];
          $provide.factory(name + Suffix, [
            "$injector",
            "$exceptionHandler",
            function ($injector, $exceptionHandler) {
              var directives = [];
              forEach(hasDirectives[name], function (directiveFactory, index) {
                try {
                  var directive = $injector.invoke(directiveFactory);
                  if (isFunction(directive)) {
                    directive = { compile: valueFn(directive) };
                  } else if (!directive.compile && directive.link) {
                    directive.compile = valueFn(directive.link);
                  }
                  directive.priority = directive.priority || 0;
                  directive.index = index;
                  directive.name = directive.name || name;
                  directive.require = getDirectiveRequire(directive);
                  directive.restrict = getDirectiveRestrict(
                    directive.restrict,
                    name
                  );
                  directive.$$moduleName = directiveFactory.$$moduleName;
                  directives.push(directive);
                } catch (e) {
                  $exceptionHandler(e);
                }
              });
              return directives;
            },
          ]);
        }
        hasDirectives[name].push(directiveFactory);
      } else {
        forEach(name, reverseParams(registerDirective));
      }
      return this;
    };
    this.component = function registerComponent(name, options) {
      var controller = options.controller || function () {};
      function factory($injector) {
        function makeInjectable(fn) {
          if (isFunction(fn) || isArray(fn)) {
            return function (tElement, tAttrs) {
              return $injector.invoke(fn, this, {
                $element: tElement,
                $attrs: tAttrs,
              });
            };
          } else {
            return fn;
          }
        }
        var template =
          !options.template && !options.templateUrl ? "" : options.template;
        var ddo = {
          controller: controller,
          controllerAs:
            identifierForController(options.controller) ||
            options.controllerAs ||
            "$ctrl",
          template: makeInjectable(template),
          templateUrl: makeInjectable(options.templateUrl),
          transclude: options.transclude,
          scope: {},
          bindToController: options.bindings || {},
          restrict: "E",
          require: options.require,
        };
        forEach(options, function (val, key) {
          if (key.charAt(0) === "$") ddo[key] = val;
        });
        return ddo;
      }
      forEach(options, function (val, key) {
        if (key.charAt(0) === "$") {
          factory[key] = val;
          if (isFunction(controller)) controller[key] = val;
        }
      });
      factory.$inject = ["$injector"];
      return this.directive(name, factory);
    };
    this.aHrefSanitizationWhitelist = function (regexp) {
      if (isDefined(regexp)) {
        $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
        return this;
      } else {
        return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
      }
    };
    this.imgSrcSanitizationWhitelist = function (regexp) {
      if (isDefined(regexp)) {
        $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
        return this;
      } else {
        return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
      }
    };
    var debugInfoEnabled = true;
    this.debugInfoEnabled = function (enabled) {
      if (isDefined(enabled)) {
        debugInfoEnabled = enabled;
        return this;
      }
      return debugInfoEnabled;
    };
    var preAssignBindingsEnabled = false;
    this.preAssignBindingsEnabled = function (enabled) {
      if (isDefined(enabled)) {
        preAssignBindingsEnabled = enabled;
        return this;
      }
      return preAssignBindingsEnabled;
    };
    var TTL = 10;
    this.onChangesTtl = function (value) {
      if (arguments.length) {
        TTL = value;
        return this;
      }
      return TTL;
    };
    var commentDirectivesEnabledConfig = true;
    this.commentDirectivesEnabled = function (value) {
      if (arguments.length) {
        commentDirectivesEnabledConfig = value;
        return this;
      }
      return commentDirectivesEnabledConfig;
    };
    var cssClassDirectivesEnabledConfig = true;
    this.cssClassDirectivesEnabled = function (value) {
      if (arguments.length) {
        cssClassDirectivesEnabledConfig = value;
        return this;
      }
      return cssClassDirectivesEnabledConfig;
    };
    this.$get = [
      "$injector",
      "$interpolate",
      "$exceptionHandler",
      "$templateRequest",
      "$parse",
      "$controller",
      "$rootScope",
      "$sce",
      "$animate",
      "$$sanitizeUri",
      function (
        $injector,
        $interpolate,
        $exceptionHandler,
        $templateRequest,
        $parse,
        $controller,
        $rootScope,
        $sce,
        $animate,
        $$sanitizeUri
      ) {
        var SIMPLE_ATTR_NAME = /^\w/;
        var specialAttrHolder = window.document.createElement("div");
        var commentDirectivesEnabled = commentDirectivesEnabledConfig;
        var cssClassDirectivesEnabled = cssClassDirectivesEnabledConfig;
        var onChangesTtl = TTL;
        var onChangesQueue;
        function flushOnChangesQueue() {
          try {
            if (!--onChangesTtl) {
              onChangesQueue = undefined;
              throw $compileMinErr(
                "infchng",
                "{0} $onChanges() iterations reached. Aborting!\n",
                TTL
              );
            }
            $rootScope.$apply(function () {
              var errors = [];
              for (var i = 0, ii = onChangesQueue.length; i < ii; ++i) {
                try {
                  onChangesQueue[i]();
                } catch (e) {
                  errors.push(e);
                }
              }
              onChangesQueue = undefined;
              if (errors.length) {
                throw errors;
              }
            });
          } finally {
            onChangesTtl++;
          }
        }
        function Attributes(element, attributesToCopy) {
          if (attributesToCopy) {
            var keys = Object.keys(attributesToCopy);
            var i, l, key;
            for (i = 0, l = keys.length; i < l; i++) {
              key = keys[i];
              this[key] = attributesToCopy[key];
            }
          } else {
            this.$attr = {};
          }
          this.$$element = element;
        }
        Attributes.prototype = {
          $normalize: directiveNormalize,
          $addClass: function (classVal) {
            if (classVal && classVal.length > 0) {
              $animate.addClass(this.$$element, classVal);
            }
          },
          $removeClass: function (classVal) {
            if (classVal && classVal.length > 0) {
              $animate.removeClass(this.$$element, classVal);
            }
          },
          $updateClass: function (newClasses, oldClasses) {
            var toAdd = tokenDifference(newClasses, oldClasses);
            if (toAdd && toAdd.length) {
              $animate.addClass(this.$$element, toAdd);
            }
            var toRemove = tokenDifference(oldClasses, newClasses);
            if (toRemove && toRemove.length) {
              $animate.removeClass(this.$$element, toRemove);
            }
          },
          $set: function (key, value, writeAttr, attrName) {
            var node = this.$$element[0],
              booleanKey = getBooleanAttrName(node, key),
              aliasedKey = getAliasedAttrName(key),
              observer = key,
              nodeName;
            if (booleanKey) {
              this.$$element.prop(key, value);
              attrName = booleanKey;
            } else if (aliasedKey) {
              this[aliasedKey] = value;
              observer = aliasedKey;
            }
            this[key] = value;
            if (attrName) {
              this.$attr[key] = attrName;
            } else {
              attrName = this.$attr[key];
              if (!attrName) {
                this.$attr[key] = attrName = snake_case(key, "-");
              }
            }
            nodeName = nodeName_(this.$$element);
            if (
              (nodeName === "a" && (key === "href" || key === "xlinkHref")) ||
              (nodeName === "img" && key === "src")
            ) {
              this[key] = value = $$sanitizeUri(value, key === "src");
            } else if (
              nodeName === "img" &&
              key === "srcset" &&
              isDefined(value)
            ) {
              var result = "";
              var trimmedSrcset = trim(value);
              var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
              var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
              var rawUris = trimmedSrcset.split(pattern);
              var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
              for (var i = 0; i < nbrUrisWith2parts; i++) {
                var innerIdx = i * 2;
                result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                result += " " + trim(rawUris[innerIdx + 1]);
              }
              var lastTuple = trim(rawUris[i * 2]).split(/\s/);
              result += $$sanitizeUri(trim(lastTuple[0]), true);
              if (lastTuple.length === 2) {
                result += " " + trim(lastTuple[1]);
              }
              this[key] = value = result;
            }
            if (writeAttr !== false) {
              if (value === null || isUndefined(value)) {
                this.$$element.removeAttr(attrName);
              } else {
                if (SIMPLE_ATTR_NAME.test(attrName)) {
                  this.$$element.attr(attrName, value);
                } else {
                  setSpecialAttr(this.$$element[0], attrName, value);
                }
              }
            }
            var $$observers = this.$$observers;
            if ($$observers) {
              forEach($$observers[observer], function (fn) {
                try {
                  fn(value);
                } catch (e) {
                  $exceptionHandler(e);
                }
              });
            }
          },
          $observe: function (key, fn) {
            var attrs = this,
              $$observers =
                attrs.$$observers || (attrs.$$observers = createMap()),
              listeners = $$observers[key] || ($$observers[key] = []);
            listeners.push(fn);
            $rootScope.$evalAsync(function () {
              if (
                !listeners.$$inter &&
                attrs.hasOwnProperty(key) &&
                !isUndefined(attrs[key])
              ) {
                fn(attrs[key]);
              }
            });
            return function () {
              arrayRemove(listeners, fn);
            };
          },
        };
        function setSpecialAttr(element, attrName, value) {
          specialAttrHolder.innerHTML = "<span " + attrName + ">";
          var attributes = specialAttrHolder.firstChild.attributes;
          var attribute = attributes[0];
          attributes.removeNamedItem(attribute.name);
          attribute.value = value;
          element.attributes.setNamedItem(attribute);
        }
        function safeAddClass($element, className) {
          try {
            $element.addClass(className);
          } catch (e) {}
        }
        var startSymbol = $interpolate.startSymbol(),
          endSymbol = $interpolate.endSymbol(),
          denormalizeTemplate =
            startSymbol === "{{" && endSymbol === "}}"
              ? identity
              : function denormalizeTemplate(template) {
                  return template
                    .replace(/\{\{/g, startSymbol)
                    .replace(/}}/g, endSymbol);
                },
          NG_ATTR_BINDING = /^ngAttr[A-Z]/;
        var MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
        compile.$$addBindingInfo = debugInfoEnabled
          ? function $$addBindingInfo($element, binding) {
              var bindings = $element.data("$binding") || [];
              if (isArray(binding)) {
                bindings = bindings.concat(binding);
              } else {
                bindings.push(binding);
              }
              $element.data("$binding", bindings);
            }
          : noop;
        compile.$$addBindingClass = debugInfoEnabled
          ? function $$addBindingClass($element) {
              safeAddClass($element, "ng-binding");
            }
          : noop;
        compile.$$addScopeInfo = debugInfoEnabled
          ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
              var dataName = isolated
                ? noTemplate
                  ? "$isolateScopeNoTemplate"
                  : "$isolateScope"
                : "$scope";
              $element.data(dataName, scope);
            }
          : noop;
        compile.$$addScopeClass = debugInfoEnabled
          ? function $$addScopeClass($element, isolated) {
              safeAddClass(
                $element,
                isolated ? "ng-isolate-scope" : "ng-scope"
              );
            }
          : noop;
        compile.$$createComment = function (directiveName, comment) {
          var content = "";
          if (debugInfoEnabled) {
            content = " " + (directiveName || "") + ": ";
            if (comment) content += comment + " ";
          }
          return window.document.createComment(content);
        };
        return compile;
        function compile(
          $compileNodes,
          transcludeFn,
          maxPriority,
          ignoreDirective,
          previousCompileContext
        ) {
          if (!($compileNodes instanceof jqLite)) {
            $compileNodes = jqLite($compileNodes);
          }
          var compositeLinkFn = compileNodes(
            $compileNodes,
            transcludeFn,
            $compileNodes,
            maxPriority,
            ignoreDirective,
            previousCompileContext
          );
          compile.$$addScopeClass($compileNodes);
          var namespace = null;
          return function publicLinkFn(scope, cloneConnectFn, options) {
            if (!$compileNodes) {
              throw $compileMinErr(
                "multilink",
                "This element has already been linked."
              );
            }
            assertArg(scope, "scope");
            if (
              previousCompileContext &&
              previousCompileContext.needsNewScope
            ) {
              scope = scope.$parent.$new();
            }
            options = options || {};
            var parentBoundTranscludeFn = options.parentBoundTranscludeFn,
              transcludeControllers = options.transcludeControllers,
              futureParentElement = options.futureParentElement;
            if (
              parentBoundTranscludeFn &&
              parentBoundTranscludeFn.$$boundTransclude
            ) {
              parentBoundTranscludeFn =
                parentBoundTranscludeFn.$$boundTransclude;
            }
            if (!namespace) {
              namespace = detectNamespaceForChildElements(futureParentElement);
            }
            var $linkNode;
            if (namespace !== "html") {
              $linkNode = jqLite(
                wrapTemplate(
                  namespace,
                  jqLite("<div>").append($compileNodes).html()
                )
              );
            } else if (cloneConnectFn) {
              $linkNode = JQLitePrototype.clone.call($compileNodes);
            } else {
              $linkNode = $compileNodes;
            }
            if (transcludeControllers) {
              for (var controllerName in transcludeControllers) {
                $linkNode.data(
                  "$" + controllerName + "Controller",
                  transcludeControllers[controllerName].instance
                );
              }
            }
            compile.$$addScopeInfo($linkNode, scope);
            if (cloneConnectFn) cloneConnectFn($linkNode, scope);
            if (compositeLinkFn)
              compositeLinkFn(
                scope,
                $linkNode,
                $linkNode,
                parentBoundTranscludeFn
              );
            if (!cloneConnectFn) {
              $compileNodes = compositeLinkFn = null;
            }
            return $linkNode;
          };
        }
        function detectNamespaceForChildElements(parentElement) {
          var node = parentElement && parentElement[0];
          if (!node) {
            return "html";
          } else {
            return nodeName_(node) !== "foreignobject" &&
              toString.call(node).match(/SVG/)
              ? "svg"
              : "html";
          }
        }
        function compileNodes(
          nodeList,
          transcludeFn,
          $rootElement,
          maxPriority,
          ignoreDirective,
          previousCompileContext
        ) {
          var linkFns = [],
            notLiveList = isArray(nodeList) || nodeList instanceof jqLite,
            attrs,
            directives,
            nodeLinkFn,
            childNodes,
            childLinkFn,
            linkFnFound,
            nodeLinkFnFound;
          for (var i = 0; i < nodeList.length; i++) {
            attrs = new Attributes();
            if (msie === 11) {
              mergeConsecutiveTextNodes(nodeList, i, notLiveList);
            }
            directives = collectDirectives(
              nodeList[i],
              [],
              attrs,
              i === 0 ? maxPriority : undefined,
              ignoreDirective
            );
            nodeLinkFn = directives.length
              ? applyDirectivesToNode(
                  directives,
                  nodeList[i],
                  attrs,
                  transcludeFn,
                  $rootElement,
                  null,
                  [],
                  [],
                  previousCompileContext
                )
              : null;
            if (nodeLinkFn && nodeLinkFn.scope) {
              compile.$$addScopeClass(attrs.$$element);
            }
            childLinkFn =
              (nodeLinkFn && nodeLinkFn.terminal) ||
              !(childNodes = nodeList[i].childNodes) ||
              !childNodes.length
                ? null
                : compileNodes(
                    childNodes,
                    nodeLinkFn
                      ? (nodeLinkFn.transcludeOnThisElement ||
                          !nodeLinkFn.templateOnThisElement) &&
                          nodeLinkFn.transclude
                      : transcludeFn
                  );
            if (nodeLinkFn || childLinkFn) {
              linkFns.push(i, nodeLinkFn, childLinkFn);
              linkFnFound = true;
              nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
            }
            previousCompileContext = null;
          }
          return linkFnFound ? compositeLinkFn : null;
          function compositeLinkFn(
            scope,
            nodeList,
            $rootElement,
            parentBoundTranscludeFn
          ) {
            var nodeLinkFn,
              childLinkFn,
              node,
              childScope,
              i,
              ii,
              idx,
              childBoundTranscludeFn;
            var stableNodeList;
            if (nodeLinkFnFound) {
              var nodeListLength = nodeList.length;
              stableNodeList = new Array(nodeListLength);
              for (i = 0; i < linkFns.length; i += 3) {
                idx = linkFns[i];
                stableNodeList[idx] = nodeList[idx];
              }
            } else {
              stableNodeList = nodeList;
            }
            for (i = 0, ii = linkFns.length; i < ii; ) {
              node = stableNodeList[linkFns[i++]];
              nodeLinkFn = linkFns[i++];
              childLinkFn = linkFns[i++];
              if (nodeLinkFn) {
                if (nodeLinkFn.scope) {
                  childScope = scope.$new();
                  compile.$$addScopeInfo(jqLite(node), childScope);
                } else {
                  childScope = scope;
                }
                if (nodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(
                    scope,
                    nodeLinkFn.transclude,
                    parentBoundTranscludeFn
                  );
                } else if (
                  !nodeLinkFn.templateOnThisElement &&
                  parentBoundTranscludeFn
                ) {
                  childBoundTranscludeFn = parentBoundTranscludeFn;
                } else if (!parentBoundTranscludeFn && transcludeFn) {
                  childBoundTranscludeFn = createBoundTranscludeFn(
                    scope,
                    transcludeFn
                  );
                } else {
                  childBoundTranscludeFn = null;
                }
                nodeLinkFn(
                  childLinkFn,
                  childScope,
                  node,
                  $rootElement,
                  childBoundTranscludeFn
                );
              } else if (childLinkFn) {
                childLinkFn(
                  scope,
                  node.childNodes,
                  undefined,
                  parentBoundTranscludeFn
                );
              }
            }
          }
        }
        function mergeConsecutiveTextNodes(nodeList, idx, notLiveList) {
          var node = nodeList[idx];
          var parent = node.parentNode;
          var sibling;
          if (node.nodeType !== NODE_TYPE_TEXT) {
            return;
          }
          while (true) {
            sibling = parent ? node.nextSibling : nodeList[idx + 1];
            if (!sibling || sibling.nodeType !== NODE_TYPE_TEXT) {
              break;
            }
            node.nodeValue = node.nodeValue + sibling.nodeValue;
            if (sibling.parentNode) {
              sibling.parentNode.removeChild(sibling);
            }
            if (notLiveList && sibling === nodeList[idx + 1]) {
              nodeList.splice(idx + 1, 1);
            }
          }
        }
        function createBoundTranscludeFn(
          scope,
          transcludeFn,
          previousBoundTranscludeFn
        ) {
          function boundTranscludeFn(
            transcludedScope,
            cloneFn,
            controllers,
            futureParentElement,
            containingScope
          ) {
            if (!transcludedScope) {
              transcludedScope = scope.$new(false, containingScope);
              transcludedScope.$$transcluded = true;
            }
            return transcludeFn(transcludedScope, cloneFn, {
              parentBoundTranscludeFn: previousBoundTranscludeFn,
              transcludeControllers: controllers,
              futureParentElement: futureParentElement,
            });
          }
          var boundSlots = (boundTranscludeFn.$$slots = createMap());
          for (var slotName in transcludeFn.$$slots) {
            if (transcludeFn.$$slots[slotName]) {
              boundSlots[slotName] = createBoundTranscludeFn(
                scope,
                transcludeFn.$$slots[slotName],
                previousBoundTranscludeFn
              );
            } else {
              boundSlots[slotName] = null;
            }
          }
          return boundTranscludeFn;
        }
        function collectDirectives(
          node,
          directives,
          attrs,
          maxPriority,
          ignoreDirective
        ) {
          var nodeType = node.nodeType,
            attrsMap = attrs.$attr,
            match,
            nodeName,
            className;
          switch (nodeType) {
            case NODE_TYPE_ELEMENT:
              nodeName = nodeName_(node);
              addDirective(
                directives,
                directiveNormalize(nodeName),
                "E",
                maxPriority,
                ignoreDirective
              );
              for (
                var attr,
                  name,
                  nName,
                  ngAttrName,
                  value,
                  isNgAttr,
                  nAttrs = node.attributes,
                  j = 0,
                  jj = nAttrs && nAttrs.length;
                j < jj;
                j++
              ) {
                var attrStartName = false;
                var attrEndName = false;
                attr = nAttrs[j];
                name = attr.name;
                value = attr.value;
                ngAttrName = directiveNormalize(name);
                isNgAttr = NG_ATTR_BINDING.test(ngAttrName);
                if (isNgAttr) {
                  name = name
                    .replace(PREFIX_REGEXP, "")
                    .substr(8)
                    .replace(/_(.)/g, function (match, letter) {
                      return letter.toUpperCase();
                    });
                }
                var multiElementMatch = ngAttrName.match(MULTI_ELEMENT_DIR_RE);
                if (
                  multiElementMatch &&
                  directiveIsMultiElement(multiElementMatch[1])
                ) {
                  attrStartName = name;
                  attrEndName = name.substr(0, name.length - 5) + "end";
                  name = name.substr(0, name.length - 6);
                }
                nName = directiveNormalize(name.toLowerCase());
                attrsMap[nName] = name;
                if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                  attrs[nName] = value;
                  if (getBooleanAttrName(node, nName)) {
                    attrs[nName] = true;
                  }
                }
                addAttrInterpolateDirective(
                  node,
                  directives,
                  value,
                  nName,
                  isNgAttr
                );
                addDirective(
                  directives,
                  nName,
                  "A",
                  maxPriority,
                  ignoreDirective,
                  attrStartName,
                  attrEndName
                );
              }
              if (
                nodeName === "input" &&
                node.getAttribute("type") === "hidden"
              ) {
                node.setAttribute("autocomplete", "off");
              }
              if (!cssClassDirectivesEnabled) break;
              className = node.className;
              if (isObject(className)) {
                className = className.animVal;
              }
              if (isString(className) && className !== "") {
                while ((match = CLASS_DIRECTIVE_REGEXP.exec(className))) {
                  nName = directiveNormalize(match[2]);
                  if (
                    addDirective(
                      directives,
                      nName,
                      "C",
                      maxPriority,
                      ignoreDirective
                    )
                  ) {
                    attrs[nName] = trim(match[3]);
                  }
                  className = className.substr(match.index + match[0].length);
                }
              }
              break;
            case NODE_TYPE_TEXT:
              addTextInterpolateDirective(directives, node.nodeValue);
              break;
            case NODE_TYPE_COMMENT:
              if (!commentDirectivesEnabled) break;
              collectCommentDirectives(
                node,
                directives,
                attrs,
                maxPriority,
                ignoreDirective
              );
              break;
          }
          directives.sort(byPriority);
          return directives;
        }
        function collectCommentDirectives(
          node,
          directives,
          attrs,
          maxPriority,
          ignoreDirective
        ) {
          try {
            var match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
            if (match) {
              var nName = directiveNormalize(match[1]);
              if (
                addDirective(
                  directives,
                  nName,
                  "M",
                  maxPriority,
                  ignoreDirective
                )
              ) {
                attrs[nName] = trim(match[2]);
              }
            }
          } catch (e) {}
        }
        function groupScan(node, attrStart, attrEnd) {
          var nodes = [];
          var depth = 0;
          if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
            do {
              if (!node) {
                throw $compileMinErr(
                  "uterdir",
                  "Unterminated attribute, found '{0}' but no matching '{1}' found.",
                  attrStart,
                  attrEnd
                );
              }
              if (node.nodeType === NODE_TYPE_ELEMENT) {
                if (node.hasAttribute(attrStart)) depth++;
                if (node.hasAttribute(attrEnd)) depth--;
              }
              nodes.push(node);
              node = node.nextSibling;
            } while (depth > 0);
          } else {
            nodes.push(node);
          }
          return jqLite(nodes);
        }
        function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
          return function groupedElementsLink(
            scope,
            element,
            attrs,
            controllers,
            transcludeFn
          ) {
            element = groupScan(element[0], attrStart, attrEnd);
            return linkFn(scope, element, attrs, controllers, transcludeFn);
          };
        }
        function compilationGenerator(
          eager,
          $compileNodes,
          transcludeFn,
          maxPriority,
          ignoreDirective,
          previousCompileContext
        ) {
          var compiled;
          if (eager) {
            return compile(
              $compileNodes,
              transcludeFn,
              maxPriority,
              ignoreDirective,
              previousCompileContext
            );
          }
          return function lazyCompilation() {
            if (!compiled) {
              compiled = compile(
                $compileNodes,
                transcludeFn,
                maxPriority,
                ignoreDirective,
                previousCompileContext
              );
              $compileNodes = transcludeFn = previousCompileContext = null;
            }
            return compiled.apply(this, arguments);
          };
        }
        function applyDirectivesToNode(
          directives,
          compileNode,
          templateAttrs,
          transcludeFn,
          jqCollection,
          originalReplaceDirective,
          preLinkFns,
          postLinkFns,
          previousCompileContext
        ) {
          previousCompileContext = previousCompileContext || {};
          var terminalPriority = -Number.MAX_VALUE,
            newScopeDirective = previousCompileContext.newScopeDirective,
            controllerDirectives = previousCompileContext.controllerDirectives,
            newIsolateScopeDirective =
              previousCompileContext.newIsolateScopeDirective,
            templateDirective = previousCompileContext.templateDirective,
            nonTlbTranscludeDirective =
              previousCompileContext.nonTlbTranscludeDirective,
            hasTranscludeDirective = false,
            hasTemplate = false,
            hasElementTranscludeDirective =
              previousCompileContext.hasElementTranscludeDirective,
            $compileNode = (templateAttrs.$$element = jqLite(compileNode)),
            directive,
            directiveName,
            $template,
            replaceDirective = originalReplaceDirective,
            childTranscludeFn = transcludeFn,
            linkFn,
            didScanForMultipleTransclusion = false,
            mightHaveMultipleTransclusionError = false,
            directiveValue;
          for (var i = 0, ii = directives.length; i < ii; i++) {
            directive = directives[i];
            var attrStart = directive.$$start;
            var attrEnd = directive.$$end;
            if (attrStart) {
              $compileNode = groupScan(compileNode, attrStart, attrEnd);
            }
            $template = undefined;
            if (terminalPriority > directive.priority) {
              break;
            }
            directiveValue = directive.scope;
            if (directiveValue) {
              if (!directive.templateUrl) {
                if (isObject(directiveValue)) {
                  assertNoDuplicate(
                    "new/isolated scope",
                    newIsolateScopeDirective || newScopeDirective,
                    directive,
                    $compileNode
                  );
                  newIsolateScopeDirective = directive;
                } else {
                  assertNoDuplicate(
                    "new/isolated scope",
                    newIsolateScopeDirective,
                    directive,
                    $compileNode
                  );
                }
              }
              newScopeDirective = newScopeDirective || directive;
            }
            directiveName = directive.name;
            if (
              !didScanForMultipleTransclusion &&
              ((directive.replace &&
                (directive.templateUrl || directive.template)) ||
                (directive.transclude && !directive.$$tlb))
            ) {
              var candidateDirective;
              for (
                var scanningIndex = i + 1;
                (candidateDirective = directives[scanningIndex++]);

              ) {
                if (
                  (candidateDirective.transclude &&
                    !candidateDirective.$$tlb) ||
                  (candidateDirective.replace &&
                    (candidateDirective.templateUrl ||
                      candidateDirective.template))
                ) {
                  mightHaveMultipleTransclusionError = true;
                  break;
                }
              }
              didScanForMultipleTransclusion = true;
            }
            if (!directive.templateUrl && directive.controller) {
              controllerDirectives = controllerDirectives || createMap();
              assertNoDuplicate(
                "'" + directiveName + "' controller",
                controllerDirectives[directiveName],
                directive,
                $compileNode
              );
              controllerDirectives[directiveName] = directive;
            }
            directiveValue = directive.transclude;
            if (directiveValue) {
              hasTranscludeDirective = true;
              if (!directive.$$tlb) {
                assertNoDuplicate(
                  "transclusion",
                  nonTlbTranscludeDirective,
                  directive,
                  $compileNode
                );
                nonTlbTranscludeDirective = directive;
              }
              if (directiveValue === "element") {
                hasElementTranscludeDirective = true;
                terminalPriority = directive.priority;
                $template = $compileNode;
                $compileNode = templateAttrs.$$element = jqLite(
                  compile.$$createComment(
                    directiveName,
                    templateAttrs[directiveName]
                  )
                );
                compileNode = $compileNode[0];
                replaceWith(jqCollection, sliceArgs($template), compileNode);
                $template[0].$$parentNode = $template[0].parentNode;
                childTranscludeFn = compilationGenerator(
                  mightHaveMultipleTransclusionError,
                  $template,
                  transcludeFn,
                  terminalPriority,
                  replaceDirective && replaceDirective.name,
                  { nonTlbTranscludeDirective: nonTlbTranscludeDirective }
                );
              } else {
                var slots = createMap();
                if (!isObject(directiveValue)) {
                  $template = jqLite(jqLiteClone(compileNode)).contents();
                } else {
                  $template = [];
                  var slotMap = createMap();
                  var filledSlots = createMap();
                  forEach(directiveValue, function (elementSelector, slotName) {
                    var optional = elementSelector.charAt(0) === "?";
                    elementSelector = optional
                      ? elementSelector.substring(1)
                      : elementSelector;
                    slotMap[elementSelector] = slotName;
                    slots[slotName] = null;
                    filledSlots[slotName] = optional;
                  });
                  forEach($compileNode.contents(), function (node) {
                    var slotName = slotMap[directiveNormalize(nodeName_(node))];
                    if (slotName) {
                      filledSlots[slotName] = true;
                      slots[slotName] = slots[slotName] || [];
                      slots[slotName].push(node);
                    } else {
                      $template.push(node);
                    }
                  });
                  forEach(filledSlots, function (filled, slotName) {
                    if (!filled) {
                      throw $compileMinErr(
                        "reqslot",
                        "Required transclusion slot `{0}` was not filled.",
                        slotName
                      );
                    }
                  });
                  for (var slotName in slots) {
                    if (slots[slotName]) {
                      slots[slotName] = compilationGenerator(
                        mightHaveMultipleTransclusionError,
                        slots[slotName],
                        transcludeFn
                      );
                    }
                  }
                }
                $compileNode.empty();
                childTranscludeFn = compilationGenerator(
                  mightHaveMultipleTransclusionError,
                  $template,
                  transcludeFn,
                  undefined,
                  undefined,
                  {
                    needsNewScope:
                      directive.$$isolateScope || directive.$$newScope,
                  }
                );
                childTranscludeFn.$$slots = slots;
              }
            }
            if (directive.template) {
              hasTemplate = true;
              assertNoDuplicate(
                "template",
                templateDirective,
                directive,
                $compileNode
              );
              templateDirective = directive;
              directiveValue = isFunction(directive.template)
                ? directive.template($compileNode, templateAttrs)
                : directive.template;
              directiveValue = denormalizeTemplate(directiveValue);
              if (directive.replace) {
                replaceDirective = directive;
                if (jqLiteIsTextNode(directiveValue)) {
                  $template = [];
                } else {
                  $template = removeComments(
                    wrapTemplate(
                      directive.templateNamespace,
                      trim(directiveValue)
                    )
                  );
                }
                compileNode = $template[0];
                if (
                  $template.length !== 1 ||
                  compileNode.nodeType !== NODE_TYPE_ELEMENT
                ) {
                  throw $compileMinErr(
                    "tplrt",
                    "Template for directive '{0}' must have exactly one root element. {1}",
                    directiveName,
                    ""
                  );
                }
                replaceWith(jqCollection, $compileNode, compileNode);
                var newTemplateAttrs = { $attr: {} };
                var templateDirectives = collectDirectives(
                  compileNode,
                  [],
                  newTemplateAttrs
                );
                var unprocessedDirectives = directives.splice(
                  i + 1,
                  directives.length - (i + 1)
                );
                if (newIsolateScopeDirective || newScopeDirective) {
                  markDirectiveScope(
                    templateDirectives,
                    newIsolateScopeDirective,
                    newScopeDirective
                  );
                }
                directives = directives
                  .concat(templateDirectives)
                  .concat(unprocessedDirectives);
                mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                ii = directives.length;
              } else {
                $compileNode.html(directiveValue);
              }
            }
            if (directive.templateUrl) {
              hasTemplate = true;
              assertNoDuplicate(
                "template",
                templateDirective,
                directive,
                $compileNode
              );
              templateDirective = directive;
              if (directive.replace) {
                replaceDirective = directive;
              }
              nodeLinkFn = compileTemplateUrl(
                directives.splice(i, directives.length - i),
                $compileNode,
                templateAttrs,
                jqCollection,
                hasTranscludeDirective && childTranscludeFn,
                preLinkFns,
                postLinkFns,
                {
                  controllerDirectives: controllerDirectives,
                  newScopeDirective:
                    newScopeDirective !== directive && newScopeDirective,
                  newIsolateScopeDirective: newIsolateScopeDirective,
                  templateDirective: templateDirective,
                  nonTlbTranscludeDirective: nonTlbTranscludeDirective,
                }
              );
              ii = directives.length;
            } else if (directive.compile) {
              try {
                linkFn = directive.compile(
                  $compileNode,
                  templateAttrs,
                  childTranscludeFn
                );
                var context = directive.$$originalDirective || directive;
                if (isFunction(linkFn)) {
                  addLinkFns(null, bind(context, linkFn), attrStart, attrEnd);
                } else if (linkFn) {
                  addLinkFns(
                    bind(context, linkFn.pre),
                    bind(context, linkFn.post),
                    attrStart,
                    attrEnd
                  );
                }
              } catch (e) {
                $exceptionHandler(e, startingTag($compileNode));
              }
            }
            if (directive.terminal) {
              nodeLinkFn.terminal = true;
              terminalPriority = Math.max(terminalPriority, directive.priority);
            }
          }
          nodeLinkFn.scope =
            newScopeDirective && newScopeDirective.scope === true;
          nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
          nodeLinkFn.templateOnThisElement = hasTemplate;
          nodeLinkFn.transclude = childTranscludeFn;
          previousCompileContext.hasElementTranscludeDirective =
            hasElementTranscludeDirective;
          return nodeLinkFn;
          function addLinkFns(pre, post, attrStart, attrEnd) {
            if (pre) {
              if (attrStart)
                pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
              pre.require = directive.require;
              pre.directiveName = directiveName;
              if (
                newIsolateScopeDirective === directive ||
                directive.$$isolateScope
              ) {
                pre = cloneAndAnnotateFn(pre, { isolateScope: true });
              }
              preLinkFns.push(pre);
            }
            if (post) {
              if (attrStart)
                post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
              post.require = directive.require;
              post.directiveName = directiveName;
              if (
                newIsolateScopeDirective === directive ||
                directive.$$isolateScope
              ) {
                post = cloneAndAnnotateFn(post, { isolateScope: true });
              }
              postLinkFns.push(post);
            }
          }
          function nodeLinkFn(
            childLinkFn,
            scope,
            linkNode,
            $rootElement,
            boundTranscludeFn
          ) {
            var i,
              ii,
              linkFn,
              isolateScope,
              controllerScope,
              elementControllers,
              transcludeFn,
              $element,
              attrs,
              scopeBindingInfo;
            if (compileNode === linkNode) {
              attrs = templateAttrs;
              $element = templateAttrs.$$element;
            } else {
              $element = jqLite(linkNode);
              attrs = new Attributes($element, templateAttrs);
            }
            controllerScope = scope;
            if (newIsolateScopeDirective) {
              isolateScope = scope.$new(true);
            } else if (newScopeDirective) {
              controllerScope = scope.$parent;
            }
            if (boundTranscludeFn) {
              transcludeFn = controllersBoundTransclude;
              transcludeFn.$$boundTransclude = boundTranscludeFn;
              transcludeFn.isSlotFilled = function (slotName) {
                return !!boundTranscludeFn.$$slots[slotName];
              };
            }
            if (controllerDirectives) {
              elementControllers = setupControllers(
                $element,
                attrs,
                transcludeFn,
                controllerDirectives,
                isolateScope,
                scope,
                newIsolateScopeDirective
              );
            }
            if (newIsolateScopeDirective) {
              compile.$$addScopeInfo(
                $element,
                isolateScope,
                true,
                !(
                  templateDirective &&
                  (templateDirective === newIsolateScopeDirective ||
                    templateDirective ===
                      newIsolateScopeDirective.$$originalDirective)
                )
              );
              compile.$$addScopeClass($element, true);
              isolateScope.$$isolateBindings =
                newIsolateScopeDirective.$$isolateBindings;
              scopeBindingInfo = initializeDirectiveBindings(
                scope,
                attrs,
                isolateScope,
                isolateScope.$$isolateBindings,
                newIsolateScopeDirective
              );
              if (scopeBindingInfo.removeWatches) {
                isolateScope.$on("$destroy", scopeBindingInfo.removeWatches);
              }
            }
            for (var name in elementControllers) {
              var controllerDirective = controllerDirectives[name];
              var controller = elementControllers[name];
              var bindings = controllerDirective.$$bindings.bindToController;
              if (preAssignBindingsEnabled) {
                if (bindings) {
                  controller.bindingInfo = initializeDirectiveBindings(
                    controllerScope,
                    attrs,
                    controller.instance,
                    bindings,
                    controllerDirective
                  );
                } else {
                  controller.bindingInfo = {};
                }
                var controllerResult = controller();
                if (controllerResult !== controller.instance) {
                  controller.instance = controllerResult;
                  $element.data(
                    "$" + controllerDirective.name + "Controller",
                    controllerResult
                  );
                  if (controller.bindingInfo.removeWatches) {
                    controller.bindingInfo.removeWatches();
                  }
                  controller.bindingInfo = initializeDirectiveBindings(
                    controllerScope,
                    attrs,
                    controller.instance,
                    bindings,
                    controllerDirective
                  );
                }
              } else {
                controller.instance = controller();
                $element.data(
                  "$" + controllerDirective.name + "Controller",
                  controller.instance
                );
                controller.bindingInfo = initializeDirectiveBindings(
                  controllerScope,
                  attrs,
                  controller.instance,
                  bindings,
                  controllerDirective
                );
              }
            }
            forEach(controllerDirectives, function (controllerDirective, name) {
              var require = controllerDirective.require;
              if (
                controllerDirective.bindToController &&
                !isArray(require) &&
                isObject(require)
              ) {
                extend(
                  elementControllers[name].instance,
                  getControllers(name, require, $element, elementControllers)
                );
              }
            });
            forEach(elementControllers, function (controller) {
              var controllerInstance = controller.instance;
              if (isFunction(controllerInstance.$onChanges)) {
                try {
                  controllerInstance.$onChanges(
                    controller.bindingInfo.initialChanges
                  );
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              if (isFunction(controllerInstance.$onInit)) {
                try {
                  controllerInstance.$onInit();
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              if (isFunction(controllerInstance.$doCheck)) {
                controllerScope.$watch(function () {
                  controllerInstance.$doCheck();
                });
                controllerInstance.$doCheck();
              }
              if (isFunction(controllerInstance.$onDestroy)) {
                controllerScope.$on("$destroy", function callOnDestroyHook() {
                  controllerInstance.$onDestroy();
                });
              }
            });
            for (i = 0, ii = preLinkFns.length; i < ii; i++) {
              linkFn = preLinkFns[i];
              invokeLinkFn(
                linkFn,
                linkFn.isolateScope ? isolateScope : scope,
                $element,
                attrs,
                linkFn.require &&
                  getControllers(
                    linkFn.directiveName,
                    linkFn.require,
                    $element,
                    elementControllers
                  ),
                transcludeFn
              );
            }
            var scopeToChild = scope;
            if (
              newIsolateScopeDirective &&
              (newIsolateScopeDirective.template ||
                newIsolateScopeDirective.templateUrl === null)
            ) {
              scopeToChild = isolateScope;
            }
            if (childLinkFn) {
              childLinkFn(
                scopeToChild,
                linkNode.childNodes,
                undefined,
                boundTranscludeFn
              );
            }
            for (i = postLinkFns.length - 1; i >= 0; i--) {
              linkFn = postLinkFns[i];
              invokeLinkFn(
                linkFn,
                linkFn.isolateScope ? isolateScope : scope,
                $element,
                attrs,
                linkFn.require &&
                  getControllers(
                    linkFn.directiveName,
                    linkFn.require,
                    $element,
                    elementControllers
                  ),
                transcludeFn
              );
            }
            forEach(elementControllers, function (controller) {
              var controllerInstance = controller.instance;
              if (isFunction(controllerInstance.$postLink)) {
                controllerInstance.$postLink();
              }
            });
            function controllersBoundTransclude(
              scope,
              cloneAttachFn,
              futureParentElement,
              slotName
            ) {
              var transcludeControllers;
              if (!isScope(scope)) {
                slotName = futureParentElement;
                futureParentElement = cloneAttachFn;
                cloneAttachFn = scope;
                scope = undefined;
              }
              if (hasElementTranscludeDirective) {
                transcludeControllers = elementControllers;
              }
              if (!futureParentElement) {
                futureParentElement = hasElementTranscludeDirective
                  ? $element.parent()
                  : $element;
              }
              if (slotName) {
                var slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
                if (slotTranscludeFn) {
                  return slotTranscludeFn(
                    scope,
                    cloneAttachFn,
                    transcludeControllers,
                    futureParentElement,
                    scopeToChild
                  );
                } else if (isUndefined(slotTranscludeFn)) {
                  throw $compileMinErr(
                    "noslot",
                    'No parent directive that requires a transclusion with slot name "{0}". ' +
                      "Element: {1}",
                    slotName,
                    startingTag($element)
                  );
                }
              } else {
                return boundTranscludeFn(
                  scope,
                  cloneAttachFn,
                  transcludeControllers,
                  futureParentElement,
                  scopeToChild
                );
              }
            }
          }
        }
        function getControllers(
          directiveName,
          require,
          $element,
          elementControllers
        ) {
          var value;
          if (isString(require)) {
            var match = require.match(REQUIRE_PREFIX_REGEXP);
            var name = require.substring(match[0].length);
            var inheritType = match[1] || match[3];
            var optional = match[2] === "?";
            if (inheritType === "^^") {
              $element = $element.parent();
            } else {
              value = elementControllers && elementControllers[name];
              value = value && value.instance;
            }
            if (!value) {
              var dataName = "$" + name + "Controller";
              value = inheritType
                ? $element.inheritedData(dataName)
                : $element.data(dataName);
            }
            if (!value && !optional) {
              throw $compileMinErr(
                "ctreq",
                "Controller '{0}', required by directive '{1}', can't be found!",
                name,
                directiveName
              );
            }
          } else if (isArray(require)) {
            value = [];
            for (var i = 0, ii = require.length; i < ii; i++) {
              value[i] = getControllers(
                directiveName,
                require[i],
                $element,
                elementControllers
              );
            }
          } else if (isObject(require)) {
            value = {};
            forEach(require, function (controller, property) {
              value[property] = getControllers(
                directiveName,
                controller,
                $element,
                elementControllers
              );
            });
          }
          return value || null;
        }
        function setupControllers(
          $element,
          attrs,
          transcludeFn,
          controllerDirectives,
          isolateScope,
          scope,
          newIsolateScopeDirective
        ) {
          var elementControllers = createMap();
          for (var controllerKey in controllerDirectives) {
            var directive = controllerDirectives[controllerKey];
            var locals = {
              $scope:
                directive === newIsolateScopeDirective ||
                directive.$$isolateScope
                  ? isolateScope
                  : scope,
              $element: $element,
              $attrs: attrs,
              $transclude: transcludeFn,
            };
            var controller = directive.controller;
            if (controller === "@") {
              controller = attrs[directive.name];
            }
            var controllerInstance = $controller(
              controller,
              locals,
              true,
              directive.controllerAs
            );
            elementControllers[directive.name] = controllerInstance;
            $element.data(
              "$" + directive.name + "Controller",
              controllerInstance.instance
            );
          }
          return elementControllers;
        }
        function markDirectiveScope(directives, isolateScope, newScope) {
          for (var j = 0, jj = directives.length; j < jj; j++) {
            directives[j] = inherit(directives[j], {
              $$isolateScope: isolateScope,
              $$newScope: newScope,
            });
          }
        }
        function addDirective(
          tDirectives,
          name,
          location,
          maxPriority,
          ignoreDirective,
          startAttrName,
          endAttrName
        ) {
          if (name === ignoreDirective) return null;
          var match = null;
          if (hasDirectives.hasOwnProperty(name)) {
            for (
              var directive,
                directives = $injector.get(name + Suffix),
                i = 0,
                ii = directives.length;
              i < ii;
              i++
            ) {
              directive = directives[i];
              if (
                (isUndefined(maxPriority) ||
                  maxPriority > directive.priority) &&
                directive.restrict.indexOf(location) !== -1
              ) {
                if (startAttrName) {
                  directive = inherit(directive, {
                    $$start: startAttrName,
                    $$end: endAttrName,
                  });
                }
                if (!directive.$$bindings) {
                  var bindings = (directive.$$bindings = parseDirectiveBindings(
                    directive,
                    directive.name
                  ));
                  if (isObject(bindings.isolateScope)) {
                    directive.$$isolateBindings = bindings.isolateScope;
                  }
                }
                tDirectives.push(directive);
                match = directive;
              }
            }
          }
          return match;
        }
        function directiveIsMultiElement(name) {
          if (hasDirectives.hasOwnProperty(name)) {
            for (
              var directive,
                directives = $injector.get(name + Suffix),
                i = 0,
                ii = directives.length;
              i < ii;
              i++
            ) {
              directive = directives[i];
              if (directive.multiElement) {
                return true;
              }
            }
          }
          return false;
        }
        function mergeTemplateAttributes(dst, src) {
          var srcAttr = src.$attr,
            dstAttr = dst.$attr;
          forEach(dst, function (value, key) {
            if (key.charAt(0) !== "$") {
              if (src[key] && src[key] !== value) {
                if (value.length) {
                  value += (key === "style" ? ";" : " ") + src[key];
                } else {
                  value = src[key];
                }
              }
              dst.$set(key, value, true, srcAttr[key]);
            }
          });
          forEach(src, function (value, key) {
            if (!dst.hasOwnProperty(key) && key.charAt(0) !== "$") {
              dst[key] = value;
              if (key !== "class" && key !== "style") {
                dstAttr[key] = srcAttr[key];
              }
            }
          });
        }
        function compileTemplateUrl(
          directives,
          $compileNode,
          tAttrs,
          $rootElement,
          childTranscludeFn,
          preLinkFns,
          postLinkFns,
          previousCompileContext
        ) {
          var linkQueue = [],
            afterTemplateNodeLinkFn,
            afterTemplateChildLinkFn,
            beforeTemplateCompileNode = $compileNode[0],
            origAsyncDirective = directives.shift(),
            derivedSyncDirective = inherit(origAsyncDirective, {
              templateUrl: null,
              transclude: null,
              replace: null,
              $$originalDirective: origAsyncDirective,
            }),
            templateUrl = isFunction(origAsyncDirective.templateUrl)
              ? origAsyncDirective.templateUrl($compileNode, tAttrs)
              : origAsyncDirective.templateUrl,
            templateNamespace = origAsyncDirective.templateNamespace;
          $compileNode.empty();
          $templateRequest(templateUrl)
            .then(function (content) {
              var compileNode,
                tempTemplateAttrs,
                $template,
                childBoundTranscludeFn;
              content = denormalizeTemplate(content);
              if (origAsyncDirective.replace) {
                if (jqLiteIsTextNode(content)) {
                  $template = [];
                } else {
                  $template = removeComments(
                    wrapTemplate(templateNamespace, trim(content))
                  );
                }
                compileNode = $template[0];
                if (
                  $template.length !== 1 ||
                  compileNode.nodeType !== NODE_TYPE_ELEMENT
                ) {
                  throw $compileMinErr(
                    "tplrt",
                    "Template for directive '{0}' must have exactly one root element. {1}",
                    origAsyncDirective.name,
                    templateUrl
                  );
                }
                tempTemplateAttrs = { $attr: {} };
                replaceWith($rootElement, $compileNode, compileNode);
                var templateDirectives = collectDirectives(
                  compileNode,
                  [],
                  tempTemplateAttrs
                );
                if (isObject(origAsyncDirective.scope)) {
                  markDirectiveScope(templateDirectives, true);
                }
                directives = templateDirectives.concat(directives);
                mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
              } else {
                compileNode = beforeTemplateCompileNode;
                $compileNode.html(content);
              }
              directives.unshift(derivedSyncDirective);
              afterTemplateNodeLinkFn = applyDirectivesToNode(
                directives,
                compileNode,
                tAttrs,
                childTranscludeFn,
                $compileNode,
                origAsyncDirective,
                preLinkFns,
                postLinkFns,
                previousCompileContext
              );
              forEach($rootElement, function (node, i) {
                if (node === compileNode) {
                  $rootElement[i] = $compileNode[0];
                }
              });
              afterTemplateChildLinkFn = compileNodes(
                $compileNode[0].childNodes,
                childTranscludeFn
              );
              while (linkQueue.length) {
                var scope = linkQueue.shift(),
                  beforeTemplateLinkNode = linkQueue.shift(),
                  linkRootElement = linkQueue.shift(),
                  boundTranscludeFn = linkQueue.shift(),
                  linkNode = $compileNode[0];
                if (scope.$$destroyed) continue;
                if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                  var oldClasses = beforeTemplateLinkNode.className;
                  if (
                    !(
                      previousCompileContext.hasElementTranscludeDirective &&
                      origAsyncDirective.replace
                    )
                  ) {
                    linkNode = jqLiteClone(compileNode);
                  }
                  replaceWith(
                    linkRootElement,
                    jqLite(beforeTemplateLinkNode),
                    linkNode
                  );
                  safeAddClass(jqLite(linkNode), oldClasses);
                }
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(
                    scope,
                    afterTemplateNodeLinkFn.transclude,
                    boundTranscludeFn
                  );
                } else {
                  childBoundTranscludeFn = boundTranscludeFn;
                }
                afterTemplateNodeLinkFn(
                  afterTemplateChildLinkFn,
                  scope,
                  linkNode,
                  $rootElement,
                  childBoundTranscludeFn
                );
              }
              linkQueue = null;
            })
            .catch(function (error) {
              if (error instanceof Error) {
                $exceptionHandler(error);
              }
            })
            .catch(noop);
          return function delayedNodeLinkFn(
            ignoreChildLinkFn,
            scope,
            node,
            rootElement,
            boundTranscludeFn
          ) {
            var childBoundTranscludeFn = boundTranscludeFn;
            if (scope.$$destroyed) return;
            if (linkQueue) {
              linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
            } else {
              if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                childBoundTranscludeFn = createBoundTranscludeFn(
                  scope,
                  afterTemplateNodeLinkFn.transclude,
                  boundTranscludeFn
                );
              }
              afterTemplateNodeLinkFn(
                afterTemplateChildLinkFn,
                scope,
                node,
                rootElement,
                childBoundTranscludeFn
              );
            }
          };
        }
        function byPriority(a, b) {
          var diff = b.priority - a.priority;
          if (diff !== 0) return diff;
          if (a.name !== b.name) return a.name < b.name ? -1 : 1;
          return a.index - b.index;
        }
        function assertNoDuplicate(
          what,
          previousDirective,
          directive,
          element
        ) {
          function wrapModuleNameIfDefined(moduleName) {
            return moduleName ? " (module: " + moduleName + ")" : "";
          }
          if (previousDirective) {
            throw $compileMinErr(
              "multidir",
              "Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}",
              previousDirective.name,
              wrapModuleNameIfDefined(previousDirective.$$moduleName),
              directive.name,
              wrapModuleNameIfDefined(directive.$$moduleName),
              what,
              startingTag(element)
            );
          }
        }
        function addTextInterpolateDirective(directives, text) {
          var interpolateFn = $interpolate(text, true);
          if (interpolateFn) {
            directives.push({
              priority: 0,
              compile: function textInterpolateCompileFn(templateNode) {
                var templateNodeParent = templateNode.parent(),
                  hasCompileParent = !!templateNodeParent.length;
                if (hasCompileParent)
                  compile.$$addBindingClass(templateNodeParent);
                return function textInterpolateLinkFn(scope, node) {
                  var parent = node.parent();
                  if (!hasCompileParent) compile.$$addBindingClass(parent);
                  compile.$$addBindingInfo(parent, interpolateFn.expressions);
                  scope.$watch(
                    interpolateFn,
                    function interpolateFnWatchAction(value) {
                      node[0].nodeValue = value;
                    }
                  );
                };
              },
            });
          }
        }
        function wrapTemplate(type, template) {
          type = lowercase(type || "html");
          switch (type) {
            case "svg":
            case "math":
              var wrapper = window.document.createElement("div");
              wrapper.innerHTML =
                "<" + type + ">" + template + "</" + type + ">";
              return wrapper.childNodes[0].childNodes;
            default:
              return template;
          }
        }
        function getTrustedContext(node, attrNormalizedName) {
          if (attrNormalizedName === "srcdoc") {
            return $sce.HTML;
          }
          var tag = nodeName_(node);
          if (attrNormalizedName === "src" || attrNormalizedName === "ngSrc") {
            if (
              ["img", "video", "audio", "source", "track"].indexOf(tag) === -1
            ) {
              return $sce.RESOURCE_URL;
            }
          } else if (
            attrNormalizedName === "xlinkHref" ||
            (tag === "form" && attrNormalizedName === "action") ||
            (tag === "link" && attrNormalizedName === "href")
          ) {
            return $sce.RESOURCE_URL;
          }
        }
        function addAttrInterpolateDirective(
          node,
          directives,
          value,
          name,
          isNgAttr
        ) {
          var trustedContext = getTrustedContext(node, name);
          var mustHaveExpression = !isNgAttr;
          var allOrNothing = ALL_OR_NOTHING_ATTRS[name] || isNgAttr;
          var interpolateFn = $interpolate(
            value,
            mustHaveExpression,
            trustedContext,
            allOrNothing
          );
          if (!interpolateFn) return;
          if (name === "multiple" && nodeName_(node) === "select") {
            throw $compileMinErr(
              "selmulti",
              "Binding to the 'multiple' attribute is not supported. Element: {0}",
              startingTag(node)
            );
          }
          if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
            throw $compileMinErr(
              "nodomevents",
              "Interpolations for HTML DOM event attributes are disallowed.  Please use the " +
                "ng- versions (such as ng-click instead of onclick) instead."
            );
          }
          directives.push({
            priority: 100,
            compile: function () {
              return {
                pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                  var $$observers =
                    attr.$$observers || (attr.$$observers = createMap());
                  var newValue = attr[name];
                  if (newValue !== value) {
                    interpolateFn =
                      newValue &&
                      $interpolate(
                        newValue,
                        true,
                        trustedContext,
                        allOrNothing
                      );
                    value = newValue;
                  }
                  if (!interpolateFn) return;
                  attr[name] = interpolateFn(scope);
                  (
                    $$observers[name] || ($$observers[name] = [])
                  ).$$inter = true;
                  (
                    (attr.$$observers && attr.$$observers[name].$$scope) ||
                    scope
                  ).$watch(
                    interpolateFn,
                    function interpolateFnWatchAction(newValue, oldValue) {
                      if (name === "class" && newValue !== oldValue) {
                        attr.$updateClass(newValue, oldValue);
                      } else {
                        attr.$set(name, newValue);
                      }
                    }
                  );
                },
              };
            },
          });
        }
        function replaceWith($rootElement, elementsToRemove, newNode) {
          var firstElementToRemove = elementsToRemove[0],
            removeCount = elementsToRemove.length,
            parent = firstElementToRemove.parentNode,
            i,
            ii;
          if ($rootElement) {
            for (i = 0, ii = $rootElement.length; i < ii; i++) {
              if ($rootElement[i] === firstElementToRemove) {
                $rootElement[i++] = newNode;
                for (
                  var j = i, j2 = j + removeCount - 1, jj = $rootElement.length;
                  j < jj;
                  j++, j2++
                ) {
                  if (j2 < jj) {
                    $rootElement[j] = $rootElement[j2];
                  } else {
                    delete $rootElement[j];
                  }
                }
                $rootElement.length -= removeCount - 1;
                if ($rootElement.context === firstElementToRemove) {
                  $rootElement.context = newNode;
                }
                break;
              }
            }
          }
          if (parent) {
            parent.replaceChild(newNode, firstElementToRemove);
          }
          var fragment = window.document.createDocumentFragment();
          for (i = 0; i < removeCount; i++) {
            fragment.appendChild(elementsToRemove[i]);
          }
          if (jqLite.hasData(firstElementToRemove)) {
            jqLite.data(newNode, jqLite.data(firstElementToRemove));
            jqLite(firstElementToRemove).off("$destroy");
          }
          jqLite.cleanData(fragment.querySelectorAll("*"));
          for (i = 1; i < removeCount; i++) {
            delete elementsToRemove[i];
          }
          elementsToRemove[0] = newNode;
          elementsToRemove.length = 1;
        }
        function cloneAndAnnotateFn(fn, annotation) {
          return extend(
            function () {
              return fn.apply(null, arguments);
            },
            fn,
            annotation
          );
        }
        function invokeLinkFn(
          linkFn,
          scope,
          $element,
          attrs,
          controllers,
          transcludeFn
        ) {
          try {
            linkFn(scope, $element, attrs, controllers, transcludeFn);
          } catch (e) {
            $exceptionHandler(e, startingTag($element));
          }
        }
        function initializeDirectiveBindings(
          scope,
          attrs,
          destination,
          bindings,
          directive
        ) {
          var removeWatchCollection = [];
          var initialChanges = {};
          var changes;
          forEach(bindings, function initializeBinding(definition, scopeName) {
            var attrName = definition.attrName,
              optional = definition.optional,
              mode = definition.mode,
              lastValue,
              parentGet,
              parentSet,
              compare,
              removeWatch;
            switch (mode) {
              case "@":
                if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                  destination[scopeName] = attrs[attrName] = undefined;
                }
                removeWatch = attrs.$observe(attrName, function (value) {
                  if (isString(value) || isBoolean(value)) {
                    var oldValue = destination[scopeName];
                    recordChanges(scopeName, value, oldValue);
                    destination[scopeName] = value;
                  }
                });
                attrs.$$observers[attrName].$$scope = scope;
                lastValue = attrs[attrName];
                if (isString(lastValue)) {
                  destination[scopeName] = $interpolate(lastValue)(scope);
                } else if (isBoolean(lastValue)) {
                  destination[scopeName] = lastValue;
                }
                initialChanges[scopeName] = new SimpleChange(
                  _UNINITIALIZED_VALUE,
                  destination[scopeName]
                );
                removeWatchCollection.push(removeWatch);
                break;
              case "=":
                if (!hasOwnProperty.call(attrs, attrName)) {
                  if (optional) break;
                  attrs[attrName] = undefined;
                }
                if (optional && !attrs[attrName]) break;
                parentGet = $parse(attrs[attrName]);
                if (parentGet.literal) {
                  compare = equals;
                } else {
                  compare = function simpleCompare(a, b) {
                    return a === b || (a !== a && b !== b);
                  };
                }
                parentSet =
                  parentGet.assign ||
                  function () {
                    lastValue = destination[scopeName] = parentGet(scope);
                    throw $compileMinErr(
                      "nonassign",
                      "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!",
                      attrs[attrName],
                      attrName,
                      directive.name
                    );
                  };
                lastValue = destination[scopeName] = parentGet(scope);
                var parentValueWatch = function parentValueWatch(parentValue) {
                  if (!compare(parentValue, destination[scopeName])) {
                    if (!compare(parentValue, lastValue)) {
                      destination[scopeName] = parentValue;
                    } else {
                      parentSet(scope, (parentValue = destination[scopeName]));
                    }
                  }
                  lastValue = parentValue;
                  return lastValue;
                };
                parentValueWatch.$stateful = true;
                if (definition.collection) {
                  removeWatch = scope.$watchCollection(
                    attrs[attrName],
                    parentValueWatch
                  );
                } else {
                  removeWatch = scope.$watch(
                    $parse(attrs[attrName], parentValueWatch),
                    null,
                    parentGet.literal
                  );
                }
                removeWatchCollection.push(removeWatch);
                break;
              case "<":
                if (!hasOwnProperty.call(attrs, attrName)) {
                  if (optional) break;
                  attrs[attrName] = undefined;
                }
                if (optional && !attrs[attrName]) break;
                parentGet = $parse(attrs[attrName]);
                var deepWatch = parentGet.literal;
                var initialValue = (destination[scopeName] = parentGet(scope));
                initialChanges[scopeName] = new SimpleChange(
                  _UNINITIALIZED_VALUE,
                  destination[scopeName]
                );
                removeWatch = scope.$watch(
                  parentGet,
                  function parentValueWatchAction(newValue, oldValue) {
                    if (oldValue === newValue) {
                      if (
                        oldValue === initialValue ||
                        (deepWatch && equals(oldValue, initialValue))
                      ) {
                        return;
                      }
                      oldValue = initialValue;
                    }
                    recordChanges(scopeName, newValue, oldValue);
                    destination[scopeName] = newValue;
                  },
                  deepWatch
                );
                removeWatchCollection.push(removeWatch);
                break;
              case "&":
                parentGet = attrs.hasOwnProperty(attrName)
                  ? $parse(attrs[attrName])
                  : noop;
                if (parentGet === noop && optional) break;
                destination[scopeName] = function (locals) {
                  return parentGet(scope, locals);
                };
                break;
            }
          });
          function recordChanges(key, currentValue, previousValue) {
            if (
              isFunction(destination.$onChanges) &&
              currentValue !== previousValue &&
              (currentValue === currentValue || previousValue === previousValue)
            ) {
              if (!onChangesQueue) {
                scope.$$postDigest(flushOnChangesQueue);
                onChangesQueue = [];
              }
              if (!changes) {
                changes = {};
                onChangesQueue.push(triggerOnChangesHook);
              }
              if (changes[key]) {
                previousValue = changes[key].previousValue;
              }
              changes[key] = new SimpleChange(previousValue, currentValue);
            }
          }
          function triggerOnChangesHook() {
            destination.$onChanges(changes);
            changes = undefined;
          }
          return {
            initialChanges: initialChanges,
            removeWatches:
              removeWatchCollection.length &&
              function removeWatches() {
                for (
                  var i = 0, ii = removeWatchCollection.length;
                  i < ii;
                  ++i
                ) {
                  removeWatchCollection[i]();
                }
              },
          };
        }
      },
    ];
  }
  function SimpleChange(previous, current) {
    this.previousValue = previous;
    this.currentValue = current;
  }
  SimpleChange.prototype.isFirstChange = function () {
    return this.previousValue === _UNINITIALIZED_VALUE;
  };
  var PREFIX_REGEXP = /^((?:x|data)[:\-_])/i;
  var SPECIAL_CHARS_REGEXP = /[:\-_]+(.)/g;
  function directiveNormalize(name) {
    return name
      .replace(PREFIX_REGEXP, "")
      .replace(SPECIAL_CHARS_REGEXP, fnCamelCaseReplace);
  }
  function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {}
  function directiveLinkingFn(
    nodesetLinkingFn,
    scope,
    node,
    rootElement,
    boundTranscludeFn
  ) {}
  function tokenDifference(str1, str2) {
    var values = "",
      tokens1 = str1.split(/\s+/),
      tokens2 = str2.split(/\s+/);
    outer: for (var i = 0; i < tokens1.length; i++) {
      var token = tokens1[i];
      for (var j = 0; j < tokens2.length; j++) {
        if (token === tokens2[j]) continue outer;
      }
      values += (values.length > 0 ? " " : "") + token;
    }
    return values;
  }
  function removeComments(jqNodes) {
    jqNodes = jqLite(jqNodes);
    var i = jqNodes.length;
    if (i <= 1) {
      return jqNodes;
    }
    while (i--) {
      var node = jqNodes[i];
      if (
        node.nodeType === NODE_TYPE_COMMENT ||
        (node.nodeType === NODE_TYPE_TEXT && node.nodeValue.trim() === "")
      ) {
        splice.call(jqNodes, i, 1);
      }
    }
    return jqNodes;
  }
  var $controllerMinErr = minErr("$controller");
  var CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/;
  function identifierForController(controller, ident) {
    if (ident && isString(ident)) return ident;
    if (isString(controller)) {
      var match = CNTRL_REG.exec(controller);
      if (match) return match[3];
    }
  }
  function $ControllerProvider() {
    var controllers = {},
      globals = false;
    this.has = function (name) {
      return controllers.hasOwnProperty(name);
    };
    this.register = function (name, constructor) {
      assertNotHasOwnProperty(name, "controller");
      if (isObject(name)) {
        extend(controllers, name);
      } else {
        controllers[name] = constructor;
      }
    };
    this.allowGlobals = function () {
      globals = true;
    };
    this.$get = [
      "$injector",
      "$window",
      function ($injector, $window) {
        return function $controller(expression, locals, later, ident) {
          var instance, match, constructor, identifier;
          later = later === true;
          if (ident && isString(ident)) {
            identifier = ident;
          }
          if (isString(expression)) {
            match = expression.match(CNTRL_REG);
            if (!match) {
              throw $controllerMinErr(
                "ctrlfmt",
                "Badly formed controller string '{0}'. " +
                  "Must match `__name__ as __id__` or `__name__`.",
                expression
              );
            }
            constructor = match[1];
            identifier = identifier || match[3];
            expression = controllers.hasOwnProperty(constructor)
              ? controllers[constructor]
              : getter(locals.$scope, constructor, true) ||
                (globals ? getter($window, constructor, true) : undefined);
            if (!expression) {
              throw $controllerMinErr(
                "ctrlreg",
                "The controller with the name '{0}' is not registered.",
                constructor
              );
            }
            assertArgFn(expression, constructor, true);
          }
          if (later) {
            var controllerPrototype = (
              isArray(expression)
                ? expression[expression.length - 1]
                : expression
            ).prototype;
            instance = Object.create(controllerPrototype || null);
            if (identifier) {
              addIdentifier(
                locals,
                identifier,
                instance,
                constructor || expression.name
              );
            }
            return extend(
              function $controllerInit() {
                var result = $injector.invoke(
                  expression,
                  instance,
                  locals,
                  constructor
                );
                if (
                  result !== instance &&
                  (isObject(result) || isFunction(result))
                ) {
                  instance = result;
                  if (identifier) {
                    addIdentifier(
                      locals,
                      identifier,
                      instance,
                      constructor || expression.name
                    );
                  }
                }
                return instance;
              },
              { instance: instance, identifier: identifier }
            );
          }
          instance = $injector.instantiate(expression, locals, constructor);
          if (identifier) {
            addIdentifier(
              locals,
              identifier,
              instance,
              constructor || expression.name
            );
          }
          return instance;
        };
        function addIdentifier(locals, identifier, instance, name) {
          if (!(locals && isObject(locals.$scope))) {
            throw minErr("$controller")(
              "noscp",
              "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.",
              name,
              identifier
            );
          }
          locals.$scope[identifier] = instance;
        }
      },
    ];
  }
  function $DocumentProvider() {
    this.$get = [
      "$window",
      function (window) {
        return jqLite(window.document);
      },
    ];
  }
  function $$IsDocumentHiddenProvider() {
    this.$get = [
      "$document",
      "$rootScope",
      function ($document, $rootScope) {
        var doc = $document[0];
        var hidden = doc && doc.hidden;
        $document.on("visibilitychange", changeListener);
        $rootScope.$on("$destroy", function () {
          $document.off("visibilitychange", changeListener);
        });
        function changeListener() {
          hidden = doc.hidden;
        }
        return function () {
          return hidden;
        };
      },
    ];
  }
  function $ExceptionHandlerProvider() {
    this.$get = [
      "$log",
      function ($log) {
        return function (exception, cause) {
          $log.error.apply($log, arguments);
        };
      },
    ];
  }
  var $$ForceReflowProvider = function () {
    this.$get = [
      "$document",
      function ($document) {
        return function (domNode) {
          if (domNode) {
            if (!domNode.nodeType && domNode instanceof jqLite) {
              domNode = domNode[0];
            }
          } else {
            domNode = $document[0].body;
          }
          return domNode.offsetWidth + 1;
        };
      },
    ];
  };
  var APPLICATION_JSON = "application/json";
  var CONTENT_TYPE_APPLICATION_JSON = {
    "Content-Type": APPLICATION_JSON + ";charset=utf-8",
  };
  var JSON_START = /^\[|^\{(?!\{)/;
  var JSON_ENDS = { "[": /]$/, "{": /}$/ };
  var JSON_PROTECTION_PREFIX = /^\)]\}',?\n/;
  var $httpMinErr = minErr("$http");
  function serializeValue(v) {
    if (isObject(v)) {
      return isDate(v) ? v.toISOString() : toJson(v);
    }
    return v;
  }
  function $HttpParamSerializerProvider() {
    this.$get = function () {
      return function ngParamSerializer(params) {
        if (!params) return "";
        var parts = [];
        forEachSorted(params, function (value, key) {
          if (value === null || isUndefined(value)) return;
          if (isArray(value)) {
            forEach(value, function (v) {
              parts.push(
                encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(v))
              );
            });
          } else {
            parts.push(
              encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(value))
            );
          }
        });
        return parts.join("&");
      };
    };
  }
  function $HttpParamSerializerJQLikeProvider() {
    this.$get = function () {
      return function jQueryLikeParamSerializer(params) {
        if (!params) return "";
        var parts = [];
        serialize(params, "", true);
        return parts.join("&");
        function serialize(toSerialize, prefix, topLevel) {
          if (toSerialize === null || isUndefined(toSerialize)) return;
          if (isArray(toSerialize)) {
            forEach(toSerialize, function (value, index) {
              serialize(
                value,
                prefix + "[" + (isObject(value) ? index : "") + "]"
              );
            });
          } else if (isObject(toSerialize) && !isDate(toSerialize)) {
            forEachSorted(toSerialize, function (value, key) {
              serialize(
                value,
                prefix + (topLevel ? "" : "[") + key + (topLevel ? "" : "]")
              );
            });
          } else {
            parts.push(
              encodeUriQuery(prefix) +
                "=" +
                encodeUriQuery(serializeValue(toSerialize))
            );
          }
        }
      };
    };
  }
  function defaultHttpResponseTransform(data, headers) {
    if (isString(data)) {
      var tempData = data.replace(JSON_PROTECTION_PREFIX, "").trim();
      if (tempData) {
        var contentType = headers("Content-Type");
        if (
          (contentType && contentType.indexOf(APPLICATION_JSON) === 0) ||
          isJsonLike(tempData)
        ) {
          data = fromJson(tempData);
        }
      }
    }
    return data;
  }
  function isJsonLike(str) {
    var jsonStart = str.match(JSON_START);
    return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
  }
  function parseHeaders(headers) {
    var parsed = createMap(),
      i;
    function fillInParsed(key, val) {
      if (key) {
        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
      }
    }
    if (isString(headers)) {
      forEach(headers.split("\n"), function (line) {
        i = line.indexOf(":");
        fillInParsed(
          lowercase(trim(line.substr(0, i))),
          trim(line.substr(i + 1))
        );
      });
    } else if (isObject(headers)) {
      forEach(headers, function (headerVal, headerKey) {
        fillInParsed(lowercase(headerKey), trim(headerVal));
      });
    }
    return parsed;
  }
  function headersGetter(headers) {
    var headersObj;
    return function (name) {
      if (!headersObj) headersObj = parseHeaders(headers);
      if (name) {
        var value = headersObj[lowercase(name)];
        if (value === undefined) {
          value = null;
        }
        return value;
      }
      return headersObj;
    };
  }
  function transformData(data, headers, status, fns) {
    if (isFunction(fns)) {
      return fns(data, headers, status);
    }
    forEach(fns, function (fn) {
      data = fn(data, headers, status);
    });
    return data;
  }
  function isSuccess(status) {
    return 200 <= status && status < 300;
  }
  function $HttpProvider() {
    var defaults = (this.defaults = {
      transformResponse: [defaultHttpResponseTransform],
      transformRequest: [
        function (d) {
          return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d)
            ? toJson(d)
            : d;
        },
      ],
      headers: {
        common: { Accept: "application/json, text/plain, */*" },
        post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
        put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
        patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
      },
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      paramSerializer: "$httpParamSerializer",
      jsonpCallbackParam: "callback",
    });
    var useApplyAsync = false;
    this.useApplyAsync = function (value) {
      if (isDefined(value)) {
        useApplyAsync = !!value;
        return this;
      }
      return useApplyAsync;
    };
    var interceptorFactories = (this.interceptors = []);
    this.$get = [
      "$browser",
      "$httpBackend",
      "$$cookieReader",
      "$cacheFactory",
      "$rootScope",
      "$q",
      "$injector",
      "$sce",
      function (
        $browser,
        $httpBackend,
        $$cookieReader,
        $cacheFactory,
        $rootScope,
        $q,
        $injector,
        $sce
      ) {
        var defaultCache = $cacheFactory("$http");
        defaults.paramSerializer = isString(defaults.paramSerializer)
          ? $injector.get(defaults.paramSerializer)
          : defaults.paramSerializer;
        var reversedInterceptors = [];
        forEach(interceptorFactories, function (interceptorFactory) {
          reversedInterceptors.unshift(
            isString(interceptorFactory)
              ? $injector.get(interceptorFactory)
              : $injector.invoke(interceptorFactory)
          );
        });
        function $http(requestConfig) {
          if (!isObject(requestConfig)) {
            throw minErr("$http")(
              "badreq",
              "Http request configuration must be an object.  Received: {0}",
              requestConfig
            );
          }
          if (!isString($sce.valueOf(requestConfig.url))) {
            throw minErr("$http")(
              "badreq",
              "Http request configuration url must be a string or a $sce trusted object.  Received: {0}",
              requestConfig.url
            );
          }
          var config = extend(
            {
              method: "get",
              transformRequest: defaults.transformRequest,
              transformResponse: defaults.transformResponse,
              paramSerializer: defaults.paramSerializer,
              jsonpCallbackParam: defaults.jsonpCallbackParam,
            },
            requestConfig
          );
          config.headers = mergeHeaders(requestConfig);
          config.method = uppercase(config.method);
          config.paramSerializer = isString(config.paramSerializer)
            ? $injector.get(config.paramSerializer)
            : config.paramSerializer;
          $browser.$$incOutstandingRequestCount();
          var requestInterceptors = [];
          var responseInterceptors = [];
          var promise = $q.resolve(config);
          forEach(reversedInterceptors, function (interceptor) {
            if (interceptor.request || interceptor.requestError) {
              requestInterceptors.unshift(
                interceptor.request,
                interceptor.requestError
              );
            }
            if (interceptor.response || interceptor.responseError) {
              responseInterceptors.push(
                interceptor.response,
                interceptor.responseError
              );
            }
          });
          promise = chainInterceptors(promise, requestInterceptors);
          promise = promise.then(serverRequest);
          promise = chainInterceptors(promise, responseInterceptors);
          promise = promise.finally(completeOutstandingRequest);
          return promise;
          function chainInterceptors(promise, interceptors) {
            for (var i = 0, ii = interceptors.length; i < ii; ) {
              var thenFn = interceptors[i++];
              var rejectFn = interceptors[i++];
              promise = promise.then(thenFn, rejectFn);
            }
            interceptors.length = 0;
            return promise;
          }
          function completeOutstandingRequest() {
            $browser.$$completeOutstandingRequest(noop);
          }
          function executeHeaderFns(headers, config) {
            var headerContent,
              processedHeaders = {};
            forEach(headers, function (headerFn, header) {
              if (isFunction(headerFn)) {
                headerContent = headerFn(config);
                if (headerContent != null) {
                  processedHeaders[header] = headerContent;
                }
              } else {
                processedHeaders[header] = headerFn;
              }
            });
            return processedHeaders;
          }
          function mergeHeaders(config) {
            var defHeaders = defaults.headers,
              reqHeaders = extend({}, config.headers),
              defHeaderName,
              lowercaseDefHeaderName,
              reqHeaderName;
            defHeaders = extend(
              {},
              defHeaders.common,
              defHeaders[lowercase(config.method)]
            );
            defaultHeadersIteration: for (defHeaderName in defHeaders) {
              lowercaseDefHeaderName = lowercase(defHeaderName);
              for (reqHeaderName in reqHeaders) {
                if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                  continue defaultHeadersIteration;
                }
              }
              reqHeaders[defHeaderName] = defHeaders[defHeaderName];
            }
            return executeHeaderFns(reqHeaders, shallowCopy(config));
          }
          function serverRequest(config) {
            var headers = config.headers;
            var reqData = transformData(
              config.data,
              headersGetter(headers),
              undefined,
              config.transformRequest
            );
            if (isUndefined(reqData)) {
              forEach(headers, function (value, header) {
                if (lowercase(header) === "content-type") {
                  delete headers[header];
                }
              });
            }
            if (
              isUndefined(config.withCredentials) &&
              !isUndefined(defaults.withCredentials)
            ) {
              config.withCredentials = defaults.withCredentials;
            }
            return sendReq(config, reqData).then(
              transformResponse,
              transformResponse
            );
          }
          function transformResponse(response) {
            var resp = extend({}, response);
            resp.data = transformData(
              response.data,
              response.headers,
              response.status,
              config.transformResponse
            );
            return isSuccess(response.status) ? resp : $q.reject(resp);
          }
        }
        $http.pendingRequests = [];
        createShortMethods("get", "delete", "head", "jsonp");
        createShortMethodsWithData("post", "put", "patch");
        $http.defaults = defaults;
        return $http;
        function createShortMethods(names) {
          forEach(arguments, function (name) {
            $http[name] = function (url, config) {
              return $http(
                extend({}, config || {}, { method: name, url: url })
              );
            };
          });
        }
        function createShortMethodsWithData(name) {
          forEach(arguments, function (name) {
            $http[name] = function (url, data, config) {
              return $http(
                extend({}, config || {}, { method: name, url: url, data: data })
              );
            };
          });
        }
        function sendReq(config, reqData) {
          var deferred = $q.defer(),
            promise = deferred.promise,
            cache,
            cachedResp,
            reqHeaders = config.headers,
            isJsonp = lowercase(config.method) === "jsonp",
            url = config.url;
          if (isJsonp) {
            url = $sce.getTrustedResourceUrl(url);
          } else if (!isString(url)) {
            url = $sce.valueOf(url);
          }
          url = buildUrl(url, config.paramSerializer(config.params));
          if (isJsonp) {
            url = sanitizeJsonpCallbackParam(url, config.jsonpCallbackParam);
          }
          $http.pendingRequests.push(config);
          promise.then(removePendingReq, removePendingReq);
          if (
            (config.cache || defaults.cache) &&
            config.cache !== false &&
            (config.method === "GET" || config.method === "JSONP")
          ) {
            cache = isObject(config.cache)
              ? config.cache
              : isObject(defaults.cache)
              ? defaults.cache
              : defaultCache;
          }
          if (cache) {
            cachedResp = cache.get(url);
            if (isDefined(cachedResp)) {
              if (isPromiseLike(cachedResp)) {
                cachedResp.then(
                  resolvePromiseWithResult,
                  resolvePromiseWithResult
                );
              } else {
                if (isArray(cachedResp)) {
                  resolvePromise(
                    cachedResp[1],
                    cachedResp[0],
                    shallowCopy(cachedResp[2]),
                    cachedResp[3]
                  );
                } else {
                  resolvePromise(cachedResp, 200, {}, "OK");
                }
              }
            } else {
              cache.put(url, promise);
            }
          }
          if (isUndefined(cachedResp)) {
            var xsrfValue = urlIsSameOrigin(config.url)
              ? $$cookieReader()[
                  config.xsrfCookieName || defaults.xsrfCookieName
                ]
              : undefined;
            if (xsrfValue) {
              reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] =
                xsrfValue;
            }
            $httpBackend(
              config.method,
              url,
              reqData,
              done,
              reqHeaders,
              config.timeout,
              config.withCredentials,
              config.responseType,
              createApplyHandlers(config.eventHandlers),
              createApplyHandlers(config.uploadEventHandlers)
            );
          }
          return promise;
          function createApplyHandlers(eventHandlers) {
            if (eventHandlers) {
              var applyHandlers = {};
              forEach(eventHandlers, function (eventHandler, key) {
                applyHandlers[key] = function (event) {
                  if (useApplyAsync) {
                    $rootScope.$applyAsync(callEventHandler);
                  } else if ($rootScope.$$phase) {
                    callEventHandler();
                  } else {
                    $rootScope.$apply(callEventHandler);
                  }
                  function callEventHandler() {
                    eventHandler(event);
                  }
                };
              });
              return applyHandlers;
            }
          }
          function done(status, response, headersString, statusText) {
            if (cache) {
              if (isSuccess(status)) {
                cache.put(url, [
                  status,
                  response,
                  parseHeaders(headersString),
                  statusText,
                ]);
              } else {
                cache.remove(url);
              }
            }
            function resolveHttpPromise() {
              resolvePromise(response, status, headersString, statusText);
            }
            if (useApplyAsync) {
              $rootScope.$applyAsync(resolveHttpPromise);
            } else {
              resolveHttpPromise();
              if (!$rootScope.$$phase) $rootScope.$apply();
            }
          }
          function resolvePromise(response, status, headers, statusText) {
            status = status >= -1 ? status : 0;
            (isSuccess(status) ? deferred.resolve : deferred.reject)({
              data: response,
              status: status,
              headers: headersGetter(headers),
              config: config,
              statusText: statusText,
            });
          }
          function resolvePromiseWithResult(result) {
            resolvePromise(
              result.data,
              result.status,
              shallowCopy(result.headers()),
              result.statusText
            );
          }
          function removePendingReq() {
            var idx = $http.pendingRequests.indexOf(config);
            if (idx !== -1) $http.pendingRequests.splice(idx, 1);
          }
        }
        function buildUrl(url, serializedParams) {
          if (serializedParams.length > 0) {
            url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
          }
          return url;
        }
        function sanitizeJsonpCallbackParam(url, key) {
          if (/[&?][^=]+=JSON_CALLBACK/.test(url)) {
            throw $httpMinErr(
              "badjsonp",
              'Illegal use of JSON_CALLBACK in url, "{0}"',
              url
            );
          }
          var callbackParamRegex = new RegExp("[&?]" + key + "=");
          if (callbackParamRegex.test(url)) {
            throw $httpMinErr(
              "badjsonp",
              'Illegal use of callback param, "{0}", in url, "{1}"',
              key,
              url
            );
          }
          url += (url.indexOf("?") === -1 ? "?" : "&") + key + "=JSON_CALLBACK";
          return url;
        }
      },
    ];
  }
  function $xhrFactoryProvider() {
    this.$get = function () {
      return function createXhr() {
        return new window.XMLHttpRequest();
      };
    };
  }
  function $HttpBackendProvider() {
    this.$get = [
      "$browser",
      "$jsonpCallbacks",
      "$document",
      "$xhrFactory",
      function ($browser, $jsonpCallbacks, $document, $xhrFactory) {
        return createHttpBackend(
          $browser,
          $xhrFactory,
          $browser.defer,
          $jsonpCallbacks,
          $document[0]
        );
      },
    ];
  }
  function createHttpBackend(
    $browser,
    createXhr,
    $browserDefer,
    callbacks,
    rawDocument
  ) {
    return function (
      method,
      url,
      post,
      callback,
      headers,
      timeout,
      withCredentials,
      responseType,
      eventHandlers,
      uploadEventHandlers
    ) {
      url = url || $browser.url();
      if (lowercase(method) === "jsonp") {
        var callbackPath = callbacks.createCallback(url);
        var jsonpDone = jsonpReq(url, callbackPath, function (status, text) {
          var response = status === 200 && callbacks.getResponse(callbackPath);
          completeRequest(callback, status, response, "", text);
          callbacks.removeCallback(callbackPath);
        });
      } else {
        var xhr = createXhr(method, url);
        xhr.open(method, url, true);
        forEach(headers, function (value, key) {
          if (isDefined(value)) {
            xhr.setRequestHeader(key, value);
          }
        });
        xhr.onload = function requestLoaded() {
          var statusText = xhr.statusText || "";
          var response = "response" in xhr ? xhr.response : xhr.responseText;
          var status = xhr.status === 1223 ? 204 : xhr.status;
          if (status === 0) {
            status = response
              ? 200
              : urlResolve(url).protocol === "file"
              ? 404
              : 0;
          }
          completeRequest(
            callback,
            status,
            response,
            xhr.getAllResponseHeaders(),
            statusText
          );
        };
        var requestError = function () {
          completeRequest(callback, -1, null, null, "");
        };
        xhr.onerror = requestError;
        xhr.onabort = requestError;
        xhr.ontimeout = requestError;
        forEach(eventHandlers, function (value, key) {
          xhr.addEventListener(key, value);
        });
        forEach(uploadEventHandlers, function (value, key) {
          xhr.upload.addEventListener(key, value);
        });
        if (withCredentials) {
          xhr.withCredentials = true;
        }
        if (responseType) {
          try {
            xhr.responseType = responseType;
          } catch (e) {
            if (responseType !== "json") {
              throw e;
            }
          }
        }
        xhr.send(isUndefined(post) ? null : post);
      }
      if (timeout > 0) {
        var timeoutId = $browserDefer(timeoutRequest, timeout);
      } else if (isPromiseLike(timeout)) {
        timeout.then(timeoutRequest);
      }
      function timeoutRequest() {
        if (jsonpDone) {
          jsonpDone();
        }
        if (xhr) {
          xhr.abort();
        }
      }
      function completeRequest(
        callback,
        status,
        response,
        headersString,
        statusText
      ) {
        if (isDefined(timeoutId)) {
          $browserDefer.cancel(timeoutId);
        }
        jsonpDone = xhr = null;
        callback(status, response, headersString, statusText);
      }
    };
    function jsonpReq(url, callbackPath, done) {
      url = url.replace("JSON_CALLBACK", callbackPath);
      var script = rawDocument.createElement("script"),
        callback = null;
      script.type = "text/javascript";
      script.src = url;
      script.async = true;
      callback = function (event) {
        script.removeEventListener("load", callback);
        script.removeEventListener("error", callback);
        rawDocument.body.removeChild(script);
        script = null;
        var status = -1;
        var text = "unknown";
        if (event) {
          if (event.type === "load" && !callbacks.wasCalled(callbackPath)) {
            event = { type: "error" };
          }
          text = event.type;
          status = event.type === "error" ? 404 : 200;
        }
        if (done) {
          done(status, text);
        }
      };
      script.addEventListener("load", callback);
      script.addEventListener("error", callback);
      rawDocument.body.appendChild(script);
      return callback;
    }
  }
  var $interpolateMinErr = (angular.$interpolateMinErr =
    minErr("$interpolate"));
  $interpolateMinErr.throwNoconcat = function (text) {
    throw $interpolateMinErr(
      "noconcat",
      "Error while interpolating: {0}\nStrict Contextual Escaping disallows " +
        "interpolations that concatenate multiple expressions when a trusted value is " +
        "required.  See http://docs.angularjs.org/api/ng.$sce",
      text
    );
  };
  $interpolateMinErr.interr = function (text, err) {
    return $interpolateMinErr(
      "interr",
      "Can't interpolate: {0}\n{1}",
      text,
      err.toString()
    );
  };
  function $InterpolateProvider() {
    var startSymbol = "{{";
    var endSymbol = "}}";
    this.startSymbol = function (value) {
      if (value) {
        startSymbol = value;
        return this;
      } else {
        return startSymbol;
      }
    };
    this.endSymbol = function (value) {
      if (value) {
        endSymbol = value;
        return this;
      } else {
        return endSymbol;
      }
    };
    this.$get = [
      "$parse",
      "$exceptionHandler",
      "$sce",
      function ($parse, $exceptionHandler, $sce) {
        var startSymbolLength = startSymbol.length,
          endSymbolLength = endSymbol.length,
          escapedStartRegexp = new RegExp(
            startSymbol.replace(/./g, escape),
            "g"
          ),
          escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), "g");
        function escape(ch) {
          return "\\\\\\" + ch;
        }
        function unescapeText(text) {
          return text
            .replace(escapedStartRegexp, startSymbol)
            .replace(escapedEndRegexp, endSymbol);
        }
        function constantWatchDelegate(
          scope,
          listener,
          objectEquality,
          constantInterp
        ) {
          var unwatch = scope.$watch(
            function constantInterpolateWatch(scope) {
              unwatch();
              return constantInterp(scope);
            },
            listener,
            objectEquality
          );
          return unwatch;
        }
        function $interpolate(
          text,
          mustHaveExpression,
          trustedContext,
          allOrNothing
        ) {
          if (!text.length || text.indexOf(startSymbol) === -1) {
            var constantInterp;
            if (!mustHaveExpression) {
              var unescapedText = unescapeText(text);
              constantInterp = valueFn(unescapedText);
              constantInterp.exp = text;
              constantInterp.expressions = [];
              constantInterp.$$watchDelegate = constantWatchDelegate;
            }
            return constantInterp;
          }
          allOrNothing = !!allOrNothing;
          var startIndex,
            endIndex,
            index = 0,
            expressions = [],
            parseFns = [],
            textLength = text.length,
            exp,
            concat = [],
            expressionPositions = [];
          while (index < textLength) {
            if (
              (startIndex = text.indexOf(startSymbol, index)) !== -1 &&
              (endIndex = text.indexOf(
                endSymbol,
                startIndex + startSymbolLength
              )) !== -1
            ) {
              if (index !== startIndex) {
                concat.push(unescapeText(text.substring(index, startIndex)));
              }
              exp = text.substring(startIndex + startSymbolLength, endIndex);
              expressions.push(exp);
              parseFns.push($parse(exp, parseStringifyInterceptor));
              index = endIndex + endSymbolLength;
              expressionPositions.push(concat.length);
              concat.push("");
            } else {
              if (index !== textLength) {
                concat.push(unescapeText(text.substring(index)));
              }
              break;
            }
          }
          if (trustedContext && concat.length > 1) {
            $interpolateMinErr.throwNoconcat(text);
          }
          if (!mustHaveExpression || expressions.length) {
            var compute = function (values) {
              for (var i = 0, ii = expressions.length; i < ii; i++) {
                if (allOrNothing && isUndefined(values[i])) return;
                concat[expressionPositions[i]] = values[i];
              }
              return concat.join("");
            };
            var getValue = function (value) {
              return trustedContext
                ? $sce.getTrusted(trustedContext, value)
                : $sce.valueOf(value);
            };
            return extend(
              function interpolationFn(context) {
                var i = 0;
                var ii = expressions.length;
                var values = new Array(ii);
                try {
                  for (; i < ii; i++) {
                    values[i] = parseFns[i](context);
                  }
                  return compute(values);
                } catch (err) {
                  $exceptionHandler($interpolateMinErr.interr(text, err));
                }
              },
              {
                exp: text,
                expressions: expressions,
                $$watchDelegate: function (scope, listener) {
                  var lastValue;
                  return scope.$watchGroup(
                    parseFns,
                    function interpolateFnWatcher(values, oldValues) {
                      var currValue = compute(values);
                      if (isFunction(listener)) {
                        listener.call(
                          this,
                          currValue,
                          values !== oldValues ? lastValue : currValue,
                          scope
                        );
                      }
                      lastValue = currValue;
                    }
                  );
                },
              }
            );
          }
          function parseStringifyInterceptor(value) {
            try {
              value = getValue(value);
              return allOrNothing && !isDefined(value)
                ? value
                : stringify(value);
            } catch (err) {
              $exceptionHandler($interpolateMinErr.interr(text, err));
            }
          }
        }
        $interpolate.startSymbol = function () {
          return startSymbol;
        };
        $interpolate.endSymbol = function () {
          return endSymbol;
        };
        return $interpolate;
      },
    ];
  }
  function $IntervalProvider() {
    this.$get = [
      "$rootScope",
      "$window",
      "$q",
      "$$q",
      "$browser",
      function ($rootScope, $window, $q, $$q, $browser) {
        var intervals = {};
        function interval(fn, delay, count, invokeApply) {
          var hasParams = arguments.length > 4,
            args = hasParams ? sliceArgs(arguments, 4) : [],
            setInterval = $window.setInterval,
            clearInterval = $window.clearInterval,
            iteration = 0,
            skipApply = isDefined(invokeApply) && !invokeApply,
            deferred = (skipApply ? $$q : $q).defer(),
            promise = deferred.promise;
          count = isDefined(count) ? count : 0;
          promise.$$intervalId = setInterval(function tick() {
            if (skipApply) {
              $browser.defer(callback);
            } else {
              $rootScope.$evalAsync(callback);
            }
            deferred.notify(iteration++);
            if (count > 0 && iteration >= count) {
              deferred.resolve(iteration);
              clearInterval(promise.$$intervalId);
              delete intervals[promise.$$intervalId];
            }
            if (!skipApply) $rootScope.$apply();
          }, delay);
          intervals[promise.$$intervalId] = deferred;
          return promise;
          function callback() {
            if (!hasParams) {
              fn(iteration);
            } else {
              fn.apply(null, args);
            }
          }
        }
        interval.cancel = function (promise) {
          if (promise && promise.$$intervalId in intervals) {
            intervals[promise.$$intervalId].promise.catch(noop);
            intervals[promise.$$intervalId].reject("canceled");
            $window.clearInterval(promise.$$intervalId);
            delete intervals[promise.$$intervalId];
            return true;
          }
          return false;
        };
        return interval;
      },
    ];
  }
  var $jsonpCallbacksProvider = function () {
    this.$get = [
      "$window",
      function ($window) {
        var callbacks = $window.angular.callbacks;
        var callbackMap = {};
        function createCallback(callbackId) {
          var callback = function (data) {
            callback.data = data;
            callback.called = true;
          };
          callback.id = callbackId;
          return callback;
        }
        return {
          createCallback: function (url) {
            var callbackId = "_" + (callbacks.$$counter++).toString(36);
            var callbackPath = "angular.callbacks." + callbackId;
            var callback = createCallback(callbackId);
            callbackMap[callbackPath] = callbacks[callbackId] = callback;
            return callbackPath;
          },
          wasCalled: function (callbackPath) {
            return callbackMap[callbackPath].called;
          },
          getResponse: function (callbackPath) {
            return callbackMap[callbackPath].data;
          },
          removeCallback: function (callbackPath) {
            var callback = callbackMap[callbackPath];
            delete callbacks[callback.id];
            delete callbackMap[callbackPath];
          },
        };
      },
    ];
  };
  var PATH_MATCH = /^([^?#]*)(\?([^#]*))?(#(.*))?$/,
    DEFAULT_PORTS = { http: 80, https: 443, ftp: 21 };
  var $locationMinErr = minErr("$location");
  function encodePath(path) {
    var segments = path.split("/"),
      i = segments.length;
    while (i--) {
      segments[i] = encodeUriSegment(segments[i]);
    }
    return segments.join("/");
  }
  function parseAbsoluteUrl(absoluteUrl, locationObj) {
    var parsedUrl = urlResolve(absoluteUrl);
    locationObj.$$protocol = parsedUrl.protocol;
    locationObj.$$host = parsedUrl.hostname;
    locationObj.$$port =
      toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
  }
  var DOUBLE_SLASH_REGEX = /^\s*[\\\/]{2,}/;
  function parseAppUrl(url, locationObj) {
    if (DOUBLE_SLASH_REGEX.test(url)) {
      throw $locationMinErr("badpath", 'Invalid url "{0}".', url);
    }
    var prefixed = url.charAt(0) !== "/";
    if (prefixed) {
      url = "/" + url;
    }
    var match = urlResolve(url);
    locationObj.$$path = decodeURIComponent(
      prefixed && match.pathname.charAt(0) === "/"
        ? match.pathname.substring(1)
        : match.pathname
    );
    locationObj.$$search = parseKeyValue(match.search);
    locationObj.$$hash = decodeURIComponent(match.hash);
    if (locationObj.$$path && locationObj.$$path.charAt(0) !== "/") {
      locationObj.$$path = "/" + locationObj.$$path;
    }
  }
  function startsWith(str, search) {
    return str.slice(0, search.length) === search;
  }
  function stripBaseUrl(base, url) {
    if (startsWith(url, base)) {
      return url.substr(base.length);
    }
  }
  function stripHash(url) {
    var index = url.indexOf("#");
    return index === -1 ? url : url.substr(0, index);
  }
  function trimEmptyHash(url) {
    return url.replace(/(#.+)|#$/, "$1");
  }
  function stripFile(url) {
    return url.substr(0, stripHash(url).lastIndexOf("/") + 1);
  }
  function serverBase(url) {
    return url.substring(0, url.indexOf("/", url.indexOf("//") + 2));
  }
  function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
    this.$$html5 = true;
    basePrefix = basePrefix || "";
    parseAbsoluteUrl(appBase, this);
    this.$$parse = function (url) {
      var pathUrl = stripBaseUrl(appBaseNoFile, url);
      if (!isString(pathUrl)) {
        throw $locationMinErr(
          "ipthprfx",
          'Invalid url "{0}", missing path prefix "{1}".',
          url,
          appBaseNoFile
        );
      }
      parseAppUrl(pathUrl, this);
      if (!this.$$path) {
        this.$$path = "/";
      }
      this.$$compose();
    };
    this.$$compose = function () {
      var search = toKeyValue(this.$$search),
        hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
      this.$$url =
        encodePath(this.$$path) + (search ? "?" + search : "") + hash;
      this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
    };
    this.$$parseLinkUrl = function (url, relHref) {
      if (relHref && relHref[0] === "#") {
        this.hash(relHref.slice(1));
        return true;
      }
      var appUrl, prevAppUrl;
      var rewrittenUrl;
      if (isDefined((appUrl = stripBaseUrl(appBase, url)))) {
        prevAppUrl = appUrl;
        if (
          basePrefix &&
          isDefined((appUrl = stripBaseUrl(basePrefix, appUrl)))
        ) {
          rewrittenUrl = appBaseNoFile + (stripBaseUrl("/", appUrl) || appUrl);
        } else {
          rewrittenUrl = appBase + prevAppUrl;
        }
      } else if (isDefined((appUrl = stripBaseUrl(appBaseNoFile, url)))) {
        rewrittenUrl = appBaseNoFile + appUrl;
      } else if (appBaseNoFile === url + "/") {
        rewrittenUrl = appBaseNoFile;
      }
      if (rewrittenUrl) {
        this.$$parse(rewrittenUrl);
      }
      return !!rewrittenUrl;
    };
  }
  function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
    parseAbsoluteUrl(appBase, this);
    this.$$parse = function (url) {
      var withoutBaseUrl =
        stripBaseUrl(appBase, url) || stripBaseUrl(appBaseNoFile, url);
      var withoutHashUrl;
      if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === "#") {
        withoutHashUrl = stripBaseUrl(hashPrefix, withoutBaseUrl);
        if (isUndefined(withoutHashUrl)) {
          withoutHashUrl = withoutBaseUrl;
        }
      } else {
        if (this.$$html5) {
          withoutHashUrl = withoutBaseUrl;
        } else {
          withoutHashUrl = "";
          if (isUndefined(withoutBaseUrl)) {
            appBase = url;
            this.replace();
          }
        }
      }
      parseAppUrl(withoutHashUrl, this);
      this.$$path = removeWindowsDriveName(
        this.$$path,
        withoutHashUrl,
        appBase
      );
      this.$$compose();
      function removeWindowsDriveName(path, url, base) {
        var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
        var firstPathSegmentMatch;
        if (startsWith(url, base)) {
          url = url.replace(base, "");
        }
        if (windowsFilePathExp.exec(url)) {
          return path;
        }
        firstPathSegmentMatch = windowsFilePathExp.exec(path);
        return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
      }
    };
    this.$$compose = function () {
      var search = toKeyValue(this.$$search),
        hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
      this.$$url =
        encodePath(this.$$path) + (search ? "?" + search : "") + hash;
      this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : "");
    };
    this.$$parseLinkUrl = function (url, relHref) {
      if (stripHash(appBase) === stripHash(url)) {
        this.$$parse(url);
        return true;
      }
      return false;
    };
  }
  function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
    this.$$html5 = true;
    LocationHashbangUrl.apply(this, arguments);
    this.$$parseLinkUrl = function (url, relHref) {
      if (relHref && relHref[0] === "#") {
        this.hash(relHref.slice(1));
        return true;
      }
      var rewrittenUrl;
      var appUrl;
      if (appBase === stripHash(url)) {
        rewrittenUrl = url;
      } else if ((appUrl = stripBaseUrl(appBaseNoFile, url))) {
        rewrittenUrl = appBase + hashPrefix + appUrl;
      } else if (appBaseNoFile === url + "/") {
        rewrittenUrl = appBaseNoFile;
      }
      if (rewrittenUrl) {
        this.$$parse(rewrittenUrl);
      }
      return !!rewrittenUrl;
    };
    this.$$compose = function () {
      var search = toKeyValue(this.$$search),
        hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
      this.$$url =
        encodePath(this.$$path) + (search ? "?" + search : "") + hash;
      this.$$absUrl = appBase + hashPrefix + this.$$url;
    };
  }
  var locationPrototype = {
    $$absUrl: "",
    $$html5: false,
    $$replace: false,
    absUrl: locationGetter("$$absUrl"),
    url: function (url) {
      if (isUndefined(url)) {
        return this.$$url;
      }
      var match = PATH_MATCH.exec(url);
      if (match[1] || url === "") this.path(decodeURIComponent(match[1]));
      if (match[2] || match[1] || url === "") this.search(match[3] || "");
      this.hash(match[5] || "");
      return this;
    },
    protocol: locationGetter("$$protocol"),
    host: locationGetter("$$host"),
    port: locationGetter("$$port"),
    path: locationGetterSetter("$$path", function (path) {
      path = path !== null ? path.toString() : "";
      return path.charAt(0) === "/" ? path : "/" + path;
    }),
    search: function (search, paramValue) {
      switch (arguments.length) {
        case 0:
          return this.$$search;
        case 1:
          if (isString(search) || isNumber(search)) {
            search = search.toString();
            this.$$search = parseKeyValue(search);
          } else if (isObject(search)) {
            search = copy(search, {});
            forEach(search, function (value, key) {
              if (value == null) delete search[key];
            });
            this.$$search = search;
          } else {
            throw $locationMinErr(
              "isrcharg",
              "The first argument of the `$location#search()` call must be a string or an object."
            );
          }
          break;
        default:
          if (isUndefined(paramValue) || paramValue === null) {
            delete this.$$search[search];
          } else {
            this.$$search[search] = paramValue;
          }
      }
      this.$$compose();
      return this;
    },
    hash: locationGetterSetter("$$hash", function (hash) {
      return hash !== null ? hash.toString() : "";
    }),
    replace: function () {
      this.$$replace = true;
      return this;
    },
  };
  forEach(
    [LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url],
    function (Location) {
      Location.prototype = Object.create(locationPrototype);
      Location.prototype.state = function (state) {
        if (!arguments.length) {
          return this.$$state;
        }
        if (Location !== LocationHtml5Url || !this.$$html5) {
          throw $locationMinErr(
            "nostate",
            "History API state support is available only " +
              "in HTML5 mode and only in browsers supporting HTML5 History API"
          );
        }
        this.$$state = isUndefined(state) ? null : state;
        return this;
      };
    }
  );
  function locationGetter(property) {
    return function () {
      return this[property];
    };
  }
  function locationGetterSetter(property, preprocess) {
    return function (value) {
      if (isUndefined(value)) {
        return this[property];
      }
      this[property] = preprocess(value);
      this.$$compose();
      return this;
    };
  }
  function $LocationProvider() {
    var hashPrefix = "!",
      html5Mode = { enabled: false, requireBase: true, rewriteLinks: true };
    this.hashPrefix = function (prefix) {
      if (isDefined(prefix)) {
        hashPrefix = prefix;
        return this;
      } else {
        return hashPrefix;
      }
    };
    this.html5Mode = function (mode) {
      if (isBoolean(mode)) {
        html5Mode.enabled = mode;
        return this;
      } else if (isObject(mode)) {
        if (isBoolean(mode.enabled)) {
          html5Mode.enabled = mode.enabled;
        }
        if (isBoolean(mode.requireBase)) {
          html5Mode.requireBase = mode.requireBase;
        }
        if (isBoolean(mode.rewriteLinks) || isString(mode.rewriteLinks)) {
          html5Mode.rewriteLinks = mode.rewriteLinks;
        }
        return this;
      } else {
        return html5Mode;
      }
    };
    this.$get = [
      "$rootScope",
      "$browser",
      "$sniffer",
      "$rootElement",
      "$window",
      function ($rootScope, $browser, $sniffer, $rootElement, $window) {
        var $location,
          LocationMode,
          baseHref = $browser.baseHref(),
          initialUrl = $browser.url(),
          appBase;
        if (html5Mode.enabled) {
          if (!baseHref && html5Mode.requireBase) {
            throw $locationMinErr(
              "nobase",
              "$location in HTML5 mode requires a <base> tag to be present!"
            );
          }
          appBase = serverBase(initialUrl) + (baseHref || "/");
          LocationMode = $sniffer.history
            ? LocationHtml5Url
            : LocationHashbangInHtml5Url;
        } else {
          appBase = stripHash(initialUrl);
          LocationMode = LocationHashbangUrl;
        }
        var appBaseNoFile = stripFile(appBase);
        $location = new LocationMode(appBase, appBaseNoFile, "#" + hashPrefix);
        $location.$$parseLinkUrl(initialUrl, initialUrl);
        $location.$$state = $browser.state();
        var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
        function setBrowserUrlWithFallback(url, replace, state) {
          var oldUrl = $location.url();
          var oldState = $location.$$state;
          try {
            $browser.url(url, replace, state);
            $location.$$state = $browser.state();
          } catch (e) {
            $location.url(oldUrl);
            $location.$$state = oldState;
            throw e;
          }
        }
        $rootElement.on("click", function (event) {
          var rewriteLinks = html5Mode.rewriteLinks;
          if (
            !rewriteLinks ||
            event.ctrlKey ||
            event.metaKey ||
            event.shiftKey ||
            event.which === 2 ||
            event.button === 2
          )
            return;
          var elm = jqLite(event.target);
          while (nodeName_(elm[0]) !== "a") {
            if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
          }
          if (isString(rewriteLinks) && isUndefined(elm.attr(rewriteLinks)))
            return;
          var absHref = elm.prop("href");
          var relHref = elm.attr("href") || elm.attr("xlink:href");
          if (
            isObject(absHref) &&
            absHref.toString() === "[object SVGAnimatedString]"
          ) {
            absHref = urlResolve(absHref.animVal).href;
          }
          if (IGNORE_URI_REGEXP.test(absHref)) return;
          if (absHref && !elm.attr("target") && !event.isDefaultPrevented()) {
            if ($location.$$parseLinkUrl(absHref, relHref)) {
              event.preventDefault();
              if ($location.absUrl() !== $browser.url()) {
                $rootScope.$apply();
                $window.angular["ff-684208-preventDefault"] = true;
              }
            }
          }
        });
        if (trimEmptyHash($location.absUrl()) !== trimEmptyHash(initialUrl)) {
          $browser.url($location.absUrl(), true);
        }
        var initializing = true;
        $browser.onUrlChange(function (newUrl, newState) {
          if (!startsWith(newUrl, appBaseNoFile)) {
            $window.location.href = newUrl;
            return;
          }
          $rootScope.$evalAsync(function () {
            var oldUrl = $location.absUrl();
            var oldState = $location.$$state;
            var defaultPrevented;
            newUrl = trimEmptyHash(newUrl);
            $location.$$parse(newUrl);
            $location.$$state = newState;
            defaultPrevented = $rootScope.$broadcast(
              "$locationChangeStart",
              newUrl,
              oldUrl,
              newState,
              oldState
            ).defaultPrevented;
            if ($location.absUrl() !== newUrl) return;
            if (defaultPrevented) {
              $location.$$parse(oldUrl);
              $location.$$state = oldState;
              setBrowserUrlWithFallback(oldUrl, false, oldState);
            } else {
              initializing = false;
              afterLocationChange(oldUrl, oldState);
            }
          });
          if (!$rootScope.$$phase) $rootScope.$digest();
        });
        $rootScope.$watch(function $locationWatch() {
          var oldUrl = trimEmptyHash($browser.url());
          var newUrl = trimEmptyHash($location.absUrl());
          var oldState = $browser.state();
          var currentReplace = $location.$$replace;
          var urlOrStateChanged =
            oldUrl !== newUrl ||
            ($location.$$html5 &&
              $sniffer.history &&
              oldState !== $location.$$state);
          if (initializing || urlOrStateChanged) {
            initializing = false;
            $rootScope.$evalAsync(function () {
              var newUrl = $location.absUrl();
              var defaultPrevented = $rootScope.$broadcast(
                "$locationChangeStart",
                newUrl,
                oldUrl,
                $location.$$state,
                oldState
              ).defaultPrevented;
              if ($location.absUrl() !== newUrl) return;
              if (defaultPrevented) {
                $location.$$parse(oldUrl);
                $location.$$state = oldState;
              } else {
                if (urlOrStateChanged) {
                  setBrowserUrlWithFallback(
                    newUrl,
                    currentReplace,
                    oldState === $location.$$state ? null : $location.$$state
                  );
                }
                afterLocationChange(oldUrl, oldState);
              }
            });
          }
          $location.$$replace = false;
        });
        return $location;
        function afterLocationChange(oldUrl, oldState) {
          $rootScope.$broadcast(
            "$locationChangeSuccess",
            $location.absUrl(),
            oldUrl,
            $location.$$state,
            oldState
          );
        }
      },
    ];
  }
  function $LogProvider() {
    var debug = true,
      self = this;
    this.debugEnabled = function (flag) {
      if (isDefined(flag)) {
        debug = flag;
        return this;
      } else {
        return debug;
      }
    };
    this.$get = [
      "$window",
      function ($window) {
        return {
          log: consoleLog("log"),
          info: consoleLog("info"),
          warn: consoleLog("warn"),
          error: consoleLog("error"),
          debug: (function () {
            var fn = consoleLog("debug");
            return function () {
              if (debug) {
                fn.apply(self, arguments);
              }
            };
          })(),
        };
        function formatError(arg) {
          if (arg instanceof Error) {
            if (arg.stack) {
              arg =
                arg.message && arg.stack.indexOf(arg.message) === -1
                  ? "Error: " + arg.message + "\n" + arg.stack
                  : arg.stack;
            } else if (arg.sourceURL) {
              arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line;
            }
          }
          return arg;
        }
        function consoleLog(type) {
          var console = $window.console || {},
            logFn = console[type] || console.log || noop,
            hasApply = false;
          try {
            hasApply = !!logFn.apply;
          } catch (e) {}
          if (hasApply) {
            return function () {
              var args = [];
              forEach(arguments, function (arg) {
                args.push(formatError(arg));
              });
              return logFn.apply(console, args);
            };
          }
          return function (arg1, arg2) {
            logFn(arg1, arg2 == null ? "" : arg2);
          };
        }
      },
    ];
  }
  var $parseMinErr = minErr("$parse");
  var objectValueOf = {}.constructor.prototype.valueOf;
  function getStringValue(name) {
    return name + "";
  }
  var OPERATORS = createMap();
  forEach(
    "+ - * / % === !== == != < > <= >= && || ! = |".split(" "),
    function (operator) {
      OPERATORS[operator] = true;
    }
  );
  var ESCAPE = {
    n: "\n",
    f: "\f",
    r: "\r",
    t: "\t",
    v: "\v",
    "'": "'",
    '"': '"',
  };
  var Lexer = function Lexer(options) {
    this.options = options;
  };
  Lexer.prototype = {
    constructor: Lexer,
    lex: function (text) {
      this.text = text;
      this.index = 0;
      this.tokens = [];
      while (this.index < this.text.length) {
        var ch = this.text.charAt(this.index);
        if (ch === '"' || ch === "'") {
          this.readString(ch);
        } else if (
          this.isNumber(ch) ||
          (ch === "." && this.isNumber(this.peek()))
        ) {
          this.readNumber();
        } else if (this.isIdentifierStart(this.peekMultichar())) {
          this.readIdent();
        } else if (this.is(ch, "(){}[].,;:?")) {
          this.tokens.push({ index: this.index, text: ch });
          this.index++;
        } else if (this.isWhitespace(ch)) {
          this.index++;
        } else {
          var ch2 = ch + this.peek();
          var ch3 = ch2 + this.peek(2);
          var op1 = OPERATORS[ch];
          var op2 = OPERATORS[ch2];
          var op3 = OPERATORS[ch3];
          if (op1 || op2 || op3) {
            var token = op3 ? ch3 : op2 ? ch2 : ch;
            this.tokens.push({
              index: this.index,
              text: token,
              operator: true,
            });
            this.index += token.length;
          } else {
            this.throwError(
              "Unexpected next character ",
              this.index,
              this.index + 1
            );
          }
        }
      }
      return this.tokens;
    },
    is: function (ch, chars) {
      return chars.indexOf(ch) !== -1;
    },
    peek: function (i) {
      var num = i || 1;
      return this.index + num < this.text.length
        ? this.text.charAt(this.index + num)
        : false;
    },
    isNumber: function (ch) {
      return "0" <= ch && ch <= "9" && typeof ch === "string";
    },
    isWhitespace: function (ch) {
      return (
        ch === " " ||
        ch === "\r" ||
        ch === "\t" ||
        ch === "\n" ||
        ch === "\v" ||
        ch === ""
      );
    },
    isIdentifierStart: function (ch) {
      return this.options.isIdentifierStart
        ? this.options.isIdentifierStart(ch, this.codePointAt(ch))
        : this.isValidIdentifierStart(ch);
    },
    isValidIdentifierStart: function (ch) {
      return (
        ("a" <= ch && ch <= "z") ||
        ("A" <= ch && ch <= "Z") ||
        "_" === ch ||
        ch === "$"
      );
    },
    isIdentifierContinue: function (ch) {
      return this.options.isIdentifierContinue
        ? this.options.isIdentifierContinue(ch, this.codePointAt(ch))
        : this.isValidIdentifierContinue(ch);
    },
    isValidIdentifierContinue: function (ch, cp) {
      return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);
    },
    codePointAt: function (ch) {
      if (ch.length === 1) return ch.charCodeAt(0);
      return (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 56613888;
    },
    peekMultichar: function () {
      var ch = this.text.charAt(this.index);
      var peek = this.peek();
      if (!peek) {
        return ch;
      }
      var cp1 = ch.charCodeAt(0);
      var cp2 = peek.charCodeAt(0);
      if (cp1 >= 55296 && cp1 <= 56319 && cp2 >= 56320 && cp2 <= 57343) {
        return ch + peek;
      }
      return ch;
    },
    isExpOperator: function (ch) {
      return ch === "-" || ch === "+" || this.isNumber(ch);
    },
    throwError: function (error, start, end) {
      end = end || this.index;
      var colStr = isDefined(start)
        ? "s " +
          start +
          "-" +
          this.index +
          " [" +
          this.text.substring(start, end) +
          "]"
        : " " + end;
      throw $parseMinErr(
        "lexerr",
        "Lexer Error: {0} at column{1} in expression [{2}].",
        error,
        colStr,
        this.text
      );
    },
    readNumber: function () {
      var number = "";
      var start = this.index;
      while (this.index < this.text.length) {
        var ch = lowercase(this.text.charAt(this.index));
        if (ch === "." || this.isNumber(ch)) {
          number += ch;
        } else {
          var peekCh = this.peek();
          if (ch === "e" && this.isExpOperator(peekCh)) {
            number += ch;
          } else if (
            this.isExpOperator(ch) &&
            peekCh &&
            this.isNumber(peekCh) &&
            number.charAt(number.length - 1) === "e"
          ) {
            number += ch;
          } else if (
            this.isExpOperator(ch) &&
            (!peekCh || !this.isNumber(peekCh)) &&
            number.charAt(number.length - 1) === "e"
          ) {
            this.throwError("Invalid exponent");
          } else {
            break;
          }
        }
        this.index++;
      }
      this.tokens.push({
        index: start,
        text: number,
        constant: true,
        value: Number(number),
      });
    },
    readIdent: function () {
      var start = this.index;
      this.index += this.peekMultichar().length;
      while (this.index < this.text.length) {
        var ch = this.peekMultichar();
        if (!this.isIdentifierContinue(ch)) {
          break;
        }
        this.index += ch.length;
      }
      this.tokens.push({
        index: start,
        text: this.text.slice(start, this.index),
        identifier: true,
      });
    },
    readString: function (quote) {
      var start = this.index;
      this.index++;
      var string = "";
      var rawString = quote;
      var escape = false;
      while (this.index < this.text.length) {
        var ch = this.text.charAt(this.index);
        rawString += ch;
        if (escape) {
          if (ch === "u") {
            var hex = this.text.substring(this.index + 1, this.index + 5);
            if (!hex.match(/[\da-f]{4}/i)) {
              this.throwError("Invalid unicode escape [\\u" + hex + "]");
            }
            this.index += 4;
            string += String.fromCharCode(parseInt(hex, 16));
          } else {
            var rep = ESCAPE[ch];
            string = string + (rep || ch);
          }
          escape = false;
        } else if (ch === "\\") {
          escape = true;
        } else if (ch === quote) {
          this.index++;
          this.tokens.push({
            index: start,
            text: rawString,
            constant: true,
            value: string,
          });
          return;
        } else {
          string += ch;
        }
        this.index++;
      }
      this.throwError("Unterminated quote", start);
    },
  };
  var AST = function AST(lexer, options) {
    this.lexer = lexer;
    this.options = options;
  };
  AST.Program = "Program";
  AST.ExpressionStatement = "ExpressionStatement";
  AST.AssignmentExpression = "AssignmentExpression";
  AST.ConditionalExpression = "ConditionalExpression";
  AST.LogicalExpression = "LogicalExpression";
  AST.BinaryExpression = "BinaryExpression";
  AST.UnaryExpression = "UnaryExpression";
  AST.CallExpression = "CallExpression";
  AST.MemberExpression = "MemberExpression";
  AST.Identifier = "Identifier";
  AST.Literal = "Literal";
  AST.ArrayExpression = "ArrayExpression";
  AST.Property = "Property";
  AST.ObjectExpression = "ObjectExpression";
  AST.ThisExpression = "ThisExpression";
  AST.LocalsExpression = "LocalsExpression";
  AST.NGValueParameter = "NGValueParameter";
  AST.prototype = {
    ast: function (text) {
      this.text = text;
      this.tokens = this.lexer.lex(text);
      var value = this.program();
      if (this.tokens.length !== 0) {
        this.throwError("is an unexpected token", this.tokens[0]);
      }
      return value;
    },
    program: function () {
      var body = [];
      while (true) {
        if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]"))
          body.push(this.expressionStatement());
        if (!this.expect(";")) {
          return { type: AST.Program, body: body };
        }
      }
    },
    expressionStatement: function () {
      return { type: AST.ExpressionStatement, expression: this.filterChain() };
    },
    filterChain: function () {
      var left = this.expression();
      while (this.expect("|")) {
        left = this.filter(left);
      }
      return left;
    },
    expression: function () {
      return this.assignment();
    },
    assignment: function () {
      var result = this.ternary();
      if (this.expect("=")) {
        if (!isAssignable(result)) {
          throw $parseMinErr(
            "lval",
            "Trying to assign a value to a non l-value"
          );
        }
        result = {
          type: AST.AssignmentExpression,
          left: result,
          right: this.assignment(),
          operator: "=",
        };
      }
      return result;
    },
    ternary: function () {
      var test = this.logicalOR();
      var alternate;
      var consequent;
      if (this.expect("?")) {
        alternate = this.expression();
        if (this.consume(":")) {
          consequent = this.expression();
          return {
            type: AST.ConditionalExpression,
            test: test,
            alternate: alternate,
            consequent: consequent,
          };
        }
      }
      return test;
    },
    logicalOR: function () {
      var left = this.logicalAND();
      while (this.expect("||")) {
        left = {
          type: AST.LogicalExpression,
          operator: "||",
          left: left,
          right: this.logicalAND(),
        };
      }
      return left;
    },
    logicalAND: function () {
      var left = this.equality();
      while (this.expect("&&")) {
        left = {
          type: AST.LogicalExpression,
          operator: "&&",
          left: left,
          right: this.equality(),
        };
      }
      return left;
    },
    equality: function () {
      var left = this.relational();
      var token;
      while ((token = this.expect("==", "!=", "===", "!=="))) {
        left = {
          type: AST.BinaryExpression,
          operator: token.text,
          left: left,
          right: this.relational(),
        };
      }
      return left;
    },
    relational: function () {
      var left = this.additive();
      var token;
      while ((token = this.expect("<", ">", "<=", ">="))) {
        left = {
          type: AST.BinaryExpression,
          operator: token.text,
          left: left,
          right: this.additive(),
        };
      }
      return left;
    },
    additive: function () {
      var left = this.multiplicative();
      var token;
      while ((token = this.expect("+", "-"))) {
        left = {
          type: AST.BinaryExpression,
          operator: token.text,
          left: left,
          right: this.multiplicative(),
        };
      }
      return left;
    },
    multiplicative: function () {
      var left = this.unary();
      var token;
      while ((token = this.expect("*", "/", "%"))) {
        left = {
          type: AST.BinaryExpression,
          operator: token.text,
          left: left,
          right: this.unary(),
        };
      }
      return left;
    },
    unary: function () {
      var token;
      if ((token = this.expect("+", "-", "!"))) {
        return {
          type: AST.UnaryExpression,
          operator: token.text,
          prefix: true,
          argument: this.unary(),
        };
      } else {
        return this.primary();
      }
    },
    primary: function () {
      var primary;
      if (this.expect("(")) {
        primary = this.filterChain();
        this.consume(")");
      } else if (this.expect("[")) {
        primary = this.arrayDeclaration();
      } else if (this.expect("{")) {
        primary = this.object();
      } else if (this.selfReferential.hasOwnProperty(this.peek().text)) {
        primary = copy(this.selfReferential[this.consume().text]);
      } else if (this.options.literals.hasOwnProperty(this.peek().text)) {
        primary = {
          type: AST.Literal,
          value: this.options.literals[this.consume().text],
        };
      } else if (this.peek().identifier) {
        primary = this.identifier();
      } else if (this.peek().constant) {
        primary = this.constant();
      } else {
        this.throwError("not a primary expression", this.peek());
      }
      var next;
      while ((next = this.expect("(", "[", "."))) {
        if (next.text === "(") {
          primary = {
            type: AST.CallExpression,
            callee: primary,
            arguments: this.parseArguments(),
          };
          this.consume(")");
        } else if (next.text === "[") {
          primary = {
            type: AST.MemberExpression,
            object: primary,
            property: this.expression(),
            computed: true,
          };
          this.consume("]");
        } else if (next.text === ".") {
          primary = {
            type: AST.MemberExpression,
            object: primary,
            property: this.identifier(),
            computed: false,
          };
        } else {
          this.throwError("IMPOSSIBLE");
        }
      }
      return primary;
    },
    filter: function (baseExpression) {
      var args = [baseExpression];
      var result = {
        type: AST.CallExpression,
        callee: this.identifier(),
        arguments: args,
        filter: true,
      };
      while (this.expect(":")) {
        args.push(this.expression());
      }
      return result;
    },
    parseArguments: function () {
      var args = [];
      if (this.peekToken().text !== ")") {
        do {
          args.push(this.filterChain());
        } while (this.expect(","));
      }
      return args;
    },
    identifier: function () {
      var token = this.consume();
      if (!token.identifier) {
        this.throwError("is not a valid identifier", token);
      }
      return { type: AST.Identifier, name: token.text };
    },
    constant: function () {
      return { type: AST.Literal, value: this.consume().value };
    },
    arrayDeclaration: function () {
      var elements = [];
      if (this.peekToken().text !== "]") {
        do {
          if (this.peek("]")) {
            break;
          }
          elements.push(this.expression());
        } while (this.expect(","));
      }
      this.consume("]");
      return { type: AST.ArrayExpression, elements: elements };
    },
    object: function () {
      var properties = [],
        property;
      if (this.peekToken().text !== "}") {
        do {
          if (this.peek("}")) {
            break;
          }
          property = { type: AST.Property, kind: "init" };
          if (this.peek().constant) {
            property.key = this.constant();
            property.computed = false;
            this.consume(":");
            property.value = this.expression();
          } else if (this.peek().identifier) {
            property.key = this.identifier();
            property.computed = false;
            if (this.peek(":")) {
              this.consume(":");
              property.value = this.expression();
            } else {
              property.value = property.key;
            }
          } else if (this.peek("[")) {
            this.consume("[");
            property.key = this.expression();
            this.consume("]");
            property.computed = true;
            this.consume(":");
            property.value = this.expression();
          } else {
            this.throwError("invalid key", this.peek());
          }
          properties.push(property);
        } while (this.expect(","));
      }
      this.consume("}");
      return { type: AST.ObjectExpression, properties: properties };
    },
    throwError: function (msg, token) {
      throw $parseMinErr(
        "syntax",
        "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].",
        token.text,
        msg,
        token.index + 1,
        this.text,
        this.text.substring(token.index)
      );
    },
    consume: function (e1) {
      if (this.tokens.length === 0) {
        throw $parseMinErr(
          "ueoe",
          "Unexpected end of expression: {0}",
          this.text
        );
      }
      var token = this.expect(e1);
      if (!token) {
        this.throwError("is unexpected, expecting [" + e1 + "]", this.peek());
      }
      return token;
    },
    peekToken: function () {
      if (this.tokens.length === 0) {
        throw $parseMinErr(
          "ueoe",
          "Unexpected end of expression: {0}",
          this.text
        );
      }
      return this.tokens[0];
    },
    peek: function (e1, e2, e3, e4) {
      return this.peekAhead(0, e1, e2, e3, e4);
    },
    peekAhead: function (i, e1, e2, e3, e4) {
      if (this.tokens.length > i) {
        var token = this.tokens[i];
        var t = token.text;
        if (
          t === e1 ||
          t === e2 ||
          t === e3 ||
          t === e4 ||
          (!e1 && !e2 && !e3 && !e4)
        ) {
          return token;
        }
      }
      return false;
    },
    expect: function (e1, e2, e3, e4) {
      var token = this.peek(e1, e2, e3, e4);
      if (token) {
        this.tokens.shift();
        return token;
      }
      return false;
    },
    selfReferential: {
      this: { type: AST.ThisExpression },
      $locals: { type: AST.LocalsExpression },
    },
  };
  function ifDefined(v, d) {
    return typeof v !== "undefined" ? v : d;
  }
  function plusFn(l, r) {
    if (typeof l === "undefined") return r;
    if (typeof r === "undefined") return l;
    return l + r;
  }
  function isStateless($filter, filterName) {
    var fn = $filter(filterName);
    return !fn.$stateful;
  }
  function findConstantAndWatchExpressions(ast, $filter) {
    var allConstants;
    var argsToWatch;
    var isStatelessFilter;
    switch (ast.type) {
      case AST.Program:
        allConstants = true;
        forEach(ast.body, function (expr) {
          findConstantAndWatchExpressions(expr.expression, $filter);
          allConstants = allConstants && expr.expression.constant;
        });
        ast.constant = allConstants;
        break;
      case AST.Literal:
        ast.constant = true;
        ast.toWatch = [];
        break;
      case AST.UnaryExpression:
        findConstantAndWatchExpressions(ast.argument, $filter);
        ast.constant = ast.argument.constant;
        ast.toWatch = ast.argument.toWatch;
        break;
      case AST.BinaryExpression:
        findConstantAndWatchExpressions(ast.left, $filter);
        findConstantAndWatchExpressions(ast.right, $filter);
        ast.constant = ast.left.constant && ast.right.constant;
        ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
        break;
      case AST.LogicalExpression:
        findConstantAndWatchExpressions(ast.left, $filter);
        findConstantAndWatchExpressions(ast.right, $filter);
        ast.constant = ast.left.constant && ast.right.constant;
        ast.toWatch = ast.constant ? [] : [ast];
        break;
      case AST.ConditionalExpression:
        findConstantAndWatchExpressions(ast.test, $filter);
        findConstantAndWatchExpressions(ast.alternate, $filter);
        findConstantAndWatchExpressions(ast.consequent, $filter);
        ast.constant =
          ast.test.constant &&
          ast.alternate.constant &&
          ast.consequent.constant;
        ast.toWatch = ast.constant ? [] : [ast];
        break;
      case AST.Identifier:
        ast.constant = false;
        ast.toWatch = [ast];
        break;
      case AST.MemberExpression:
        findConstantAndWatchExpressions(ast.object, $filter);
        if (ast.computed) {
          findConstantAndWatchExpressions(ast.property, $filter);
        }
        ast.constant =
          ast.object.constant && (!ast.computed || ast.property.constant);
        ast.toWatch = [ast];
        break;
      case AST.CallExpression:
        isStatelessFilter = ast.filter
          ? isStateless($filter, ast.callee.name)
          : false;
        allConstants = isStatelessFilter;
        argsToWatch = [];
        forEach(ast.arguments, function (expr) {
          findConstantAndWatchExpressions(expr, $filter);
          allConstants = allConstants && expr.constant;
          if (!expr.constant) {
            argsToWatch.push.apply(argsToWatch, expr.toWatch);
          }
        });
        ast.constant = allConstants;
        ast.toWatch = isStatelessFilter ? argsToWatch : [ast];
        break;
      case AST.AssignmentExpression:
        findConstantAndWatchExpressions(ast.left, $filter);
        findConstantAndWatchExpressions(ast.right, $filter);
        ast.constant = ast.left.constant && ast.right.constant;
        ast.toWatch = [ast];
        break;
      case AST.ArrayExpression:
        allConstants = true;
        argsToWatch = [];
        forEach(ast.elements, function (expr) {
          findConstantAndWatchExpressions(expr, $filter);
          allConstants = allConstants && expr.constant;
          if (!expr.constant) {
            argsToWatch.push.apply(argsToWatch, expr.toWatch);
          }
        });
        ast.constant = allConstants;
        ast.toWatch = argsToWatch;
        break;
      case AST.ObjectExpression:
        allConstants = true;
        argsToWatch = [];
        forEach(ast.properties, function (property) {
          findConstantAndWatchExpressions(property.value, $filter);
          allConstants =
            allConstants && property.value.constant && !property.computed;
          if (!property.value.constant) {
            argsToWatch.push.apply(argsToWatch, property.value.toWatch);
          }
        });
        ast.constant = allConstants;
        ast.toWatch = argsToWatch;
        break;
      case AST.ThisExpression:
        ast.constant = false;
        ast.toWatch = [];
        break;
      case AST.LocalsExpression:
        ast.constant = false;
        ast.toWatch = [];
        break;
    }
  }
  function getInputs(body) {
    if (body.length !== 1) return;
    var lastExpression = body[0].expression;
    var candidate = lastExpression.toWatch;
    if (candidate.length !== 1) return candidate;
    return candidate[0] !== lastExpression ? candidate : undefined;
  }
  function isAssignable(ast) {
    return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
  }
  function assignableAST(ast) {
    if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
      return {
        type: AST.AssignmentExpression,
        left: ast.body[0].expression,
        right: { type: AST.NGValueParameter },
        operator: "=",
      };
    }
  }
  function isLiteral(ast) {
    return (
      ast.body.length === 0 ||
      (ast.body.length === 1 &&
        (ast.body[0].expression.type === AST.Literal ||
          ast.body[0].expression.type === AST.ArrayExpression ||
          ast.body[0].expression.type === AST.ObjectExpression))
    );
  }
  function isConstant(ast) {
    return ast.constant;
  }
  function ASTCompiler(astBuilder, $filter) {
    this.astBuilder = astBuilder;
    this.$filter = $filter;
  }
  ASTCompiler.prototype = {
    compile: function (expression) {
      var self = this;
      var ast = this.astBuilder.ast(expression);
      this.state = {
        nextId: 0,
        filters: {},
        fn: { vars: [], body: [], own: {} },
        assign: { vars: [], body: [], own: {} },
        inputs: [],
      };
      findConstantAndWatchExpressions(ast, self.$filter);
      var extra = "";
      var assignable;
      this.stage = "assign";
      if ((assignable = assignableAST(ast))) {
        this.state.computing = "assign";
        var result = this.nextId();
        this.recurse(assignable, result);
        this.return_(result);
        extra = "fn.assign=" + this.generateFunction("assign", "s,v,l");
      }
      var toWatch = getInputs(ast.body);
      self.stage = "inputs";
      forEach(toWatch, function (watch, key) {
        var fnKey = "fn" + key;
        self.state[fnKey] = { vars: [], body: [], own: {} };
        self.state.computing = fnKey;
        var intoId = self.nextId();
        self.recurse(watch, intoId);
        self.return_(intoId);
        self.state.inputs.push(fnKey);
        watch.watchId = key;
      });
      this.state.computing = "fn";
      this.stage = "main";
      this.recurse(ast);
      var fnString =
        '"' +
        this.USE +
        " " +
        this.STRICT +
        '";\n' +
        this.filterPrefix() +
        "var fn=" +
        this.generateFunction("fn", "s,l,a,i") +
        extra +
        this.watchFns() +
        "return fn;";
      var fn = new Function(
        "$filter",
        "getStringValue",
        "ifDefined",
        "plus",
        fnString
      )(this.$filter, getStringValue, ifDefined, plusFn);
      this.state = this.stage = undefined;
      fn.literal = isLiteral(ast);
      fn.constant = isConstant(ast);
      return fn;
    },
    USE: "use",
    STRICT: "strict",
    watchFns: function () {
      var result = [];
      var fns = this.state.inputs;
      var self = this;
      forEach(fns, function (name) {
        result.push("var " + name + "=" + self.generateFunction(name, "s"));
      });
      if (fns.length) {
        result.push("fn.inputs=[" + fns.join(",") + "];");
      }
      return result.join("");
    },
    generateFunction: function (name, params) {
      return (
        "function(" +
        params +
        "){" +
        this.varsPrefix(name) +
        this.body(name) +
        "};"
      );
    },
    filterPrefix: function () {
      var parts = [];
      var self = this;
      forEach(this.state.filters, function (id, filter) {
        parts.push(id + "=$filter(" + self.escape(filter) + ")");
      });
      if (parts.length) return "var " + parts.join(",") + ";";
      return "";
    },
    varsPrefix: function (section) {
      return this.state[section].vars.length
        ? "var " + this.state[section].vars.join(",") + ";"
        : "";
    },
    body: function (section) {
      return this.state[section].body.join("");
    },
    recurse: function (
      ast,
      intoId,
      nameId,
      recursionFn,
      create,
      skipWatchIdCheck
    ) {
      var left,
        right,
        self = this,
        args,
        expression,
        computed;
      recursionFn = recursionFn || noop;
      if (!skipWatchIdCheck && isDefined(ast.watchId)) {
        intoId = intoId || this.nextId();
        this.if_(
          "i",
          this.lazyAssign(intoId, this.computedMember("i", ast.watchId)),
          this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true)
        );
        return;
      }
      switch (ast.type) {
        case AST.Program:
          forEach(ast.body, function (expression, pos) {
            self.recurse(
              expression.expression,
              undefined,
              undefined,
              function (expr) {
                right = expr;
              }
            );
            if (pos !== ast.body.length - 1) {
              self.current().body.push(right, ";");
            } else {
              self.return_(right);
            }
          });
          break;
        case AST.Literal:
          expression = this.escape(ast.value);
          this.assign(intoId, expression);
          recursionFn(intoId || expression);
          break;
        case AST.UnaryExpression:
          this.recurse(ast.argument, undefined, undefined, function (expr) {
            right = expr;
          });
          expression = ast.operator + "(" + this.ifDefined(right, 0) + ")";
          this.assign(intoId, expression);
          recursionFn(expression);
          break;
        case AST.BinaryExpression:
          this.recurse(ast.left, undefined, undefined, function (expr) {
            left = expr;
          });
          this.recurse(ast.right, undefined, undefined, function (expr) {
            right = expr;
          });
          if (ast.operator === "+") {
            expression = this.plus(left, right);
          } else if (ast.operator === "-") {
            expression =
              this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
          } else {
            expression = "(" + left + ")" + ast.operator + "(" + right + ")";
          }
          this.assign(intoId, expression);
          recursionFn(expression);
          break;
        case AST.LogicalExpression:
          intoId = intoId || this.nextId();
          self.recurse(ast.left, intoId);
          self.if_(
            ast.operator === "&&" ? intoId : self.not(intoId),
            self.lazyRecurse(ast.right, intoId)
          );
          recursionFn(intoId);
          break;
        case AST.ConditionalExpression:
          intoId = intoId || this.nextId();
          self.recurse(ast.test, intoId);
          self.if_(
            intoId,
            self.lazyRecurse(ast.alternate, intoId),
            self.lazyRecurse(ast.consequent, intoId)
          );
          recursionFn(intoId);
          break;
        case AST.Identifier:
          intoId = intoId || this.nextId();
          if (nameId) {
            nameId.context =
              self.stage === "inputs"
                ? "s"
                : this.assign(
                    this.nextId(),
                    this.getHasOwnProperty("l", ast.name) + "?l:s"
                  );
            nameId.computed = false;
            nameId.name = ast.name;
          }
          self.if_(
            self.stage === "inputs" ||
              self.not(self.getHasOwnProperty("l", ast.name)),
            function () {
              self.if_(self.stage === "inputs" || "s", function () {
                if (create && create !== 1) {
                  self.if_(
                    self.isNull(self.nonComputedMember("s", ast.name)),
                    self.lazyAssign(self.nonComputedMember("s", ast.name), "{}")
                  );
                }
                self.assign(intoId, self.nonComputedMember("s", ast.name));
              });
            },
            intoId &&
              self.lazyAssign(intoId, self.nonComputedMember("l", ast.name))
          );
          recursionFn(intoId);
          break;
        case AST.MemberExpression:
          left = (nameId && (nameId.context = this.nextId())) || this.nextId();
          intoId = intoId || this.nextId();
          self.recurse(
            ast.object,
            left,
            undefined,
            function () {
              self.if_(
                self.notNull(left),
                function () {
                  if (ast.computed) {
                    right = self.nextId();
                    self.recurse(ast.property, right);
                    self.getStringValue(right);
                    if (create && create !== 1) {
                      self.if_(
                        self.not(self.computedMember(left, right)),
                        self.lazyAssign(self.computedMember(left, right), "{}")
                      );
                    }
                    expression = self.computedMember(left, right);
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = true;
                      nameId.name = right;
                    }
                  } else {
                    if (create && create !== 1) {
                      self.if_(
                        self.isNull(
                          self.nonComputedMember(left, ast.property.name)
                        ),
                        self.lazyAssign(
                          self.nonComputedMember(left, ast.property.name),
                          "{}"
                        )
                      );
                    }
                    expression = self.nonComputedMember(
                      left,
                      ast.property.name
                    );
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = false;
                      nameId.name = ast.property.name;
                    }
                  }
                },
                function () {
                  self.assign(intoId, "undefined");
                }
              );
              recursionFn(intoId);
            },
            !!create
          );
          break;
        case AST.CallExpression:
          intoId = intoId || this.nextId();
          if (ast.filter) {
            right = self.filter(ast.callee.name);
            args = [];
            forEach(ast.arguments, function (expr) {
              var argument = self.nextId();
              self.recurse(expr, argument);
              args.push(argument);
            });
            expression = right + "(" + args.join(",") + ")";
            self.assign(intoId, expression);
            recursionFn(intoId);
          } else {
            right = self.nextId();
            left = {};
            args = [];
            self.recurse(ast.callee, right, left, function () {
              self.if_(
                self.notNull(right),
                function () {
                  forEach(ast.arguments, function (expr) {
                    self.recurse(
                      expr,
                      ast.constant ? undefined : self.nextId(),
                      undefined,
                      function (argument) {
                        args.push(argument);
                      }
                    );
                  });
                  if (left.name) {
                    expression =
                      self.member(left.context, left.name, left.computed) +
                      "(" +
                      args.join(",") +
                      ")";
                  } else {
                    expression = right + "(" + args.join(",") + ")";
                  }
                  self.assign(intoId, expression);
                },
                function () {
                  self.assign(intoId, "undefined");
                }
              );
              recursionFn(intoId);
            });
          }
          break;
        case AST.AssignmentExpression:
          right = this.nextId();
          left = {};
          this.recurse(
            ast.left,
            undefined,
            left,
            function () {
              self.if_(self.notNull(left.context), function () {
                self.recurse(ast.right, right);
                expression =
                  self.member(left.context, left.name, left.computed) +
                  ast.operator +
                  right;
                self.assign(intoId, expression);
                recursionFn(intoId || expression);
              });
            },
            1
          );
          break;
        case AST.ArrayExpression:
          args = [];
          forEach(ast.elements, function (expr) {
            self.recurse(
              expr,
              ast.constant ? undefined : self.nextId(),
              undefined,
              function (argument) {
                args.push(argument);
              }
            );
          });
          expression = "[" + args.join(",") + "]";
          this.assign(intoId, expression);
          recursionFn(intoId || expression);
          break;
        case AST.ObjectExpression:
          args = [];
          computed = false;
          forEach(ast.properties, function (property) {
            if (property.computed) {
              computed = true;
            }
          });
          if (computed) {
            intoId = intoId || this.nextId();
            this.assign(intoId, "{}");
            forEach(ast.properties, function (property) {
              if (property.computed) {
                left = self.nextId();
                self.recurse(property.key, left);
              } else {
                left =
                  property.key.type === AST.Identifier
                    ? property.key.name
                    : "" + property.key.value;
              }
              right = self.nextId();
              self.recurse(property.value, right);
              self.assign(self.member(intoId, left, property.computed), right);
            });
          } else {
            forEach(ast.properties, function (property) {
              self.recurse(
                property.value,
                ast.constant ? undefined : self.nextId(),
                undefined,
                function (expr) {
                  args.push(
                    self.escape(
                      property.key.type === AST.Identifier
                        ? property.key.name
                        : "" + property.key.value
                    ) +
                      ":" +
                      expr
                  );
                }
              );
            });
            expression = "{" + args.join(",") + "}";
            this.assign(intoId, expression);
          }
          recursionFn(intoId || expression);
          break;
        case AST.ThisExpression:
          this.assign(intoId, "s");
          recursionFn(intoId || "s");
          break;
        case AST.LocalsExpression:
          this.assign(intoId, "l");
          recursionFn(intoId || "l");
          break;
        case AST.NGValueParameter:
          this.assign(intoId, "v");
          recursionFn(intoId || "v");
          break;
      }
    },
    getHasOwnProperty: function (element, property) {
      var key = element + "." + property;
      var own = this.current().own;
      if (!own.hasOwnProperty(key)) {
        own[key] = this.nextId(
          false,
          element + "&&(" + this.escape(property) + " in " + element + ")"
        );
      }
      return own[key];
    },
    assign: function (id, value) {
      if (!id) return;
      this.current().body.push(id, "=", value, ";");
      return id;
    },
    filter: function (filterName) {
      if (!this.state.filters.hasOwnProperty(filterName)) {
        this.state.filters[filterName] = this.nextId(true);
      }
      return this.state.filters[filterName];
    },
    ifDefined: function (id, defaultValue) {
      return "ifDefined(" + id + "," + this.escape(defaultValue) + ")";
    },
    plus: function (left, right) {
      return "plus(" + left + "," + right + ")";
    },
    return_: function (id) {
      this.current().body.push("return ", id, ";");
    },
    if_: function (test, alternate, consequent) {
      if (test === true) {
        alternate();
      } else {
        var body = this.current().body;
        body.push("if(", test, "){");
        alternate();
        body.push("}");
        if (consequent) {
          body.push("else{");
          consequent();
          body.push("}");
        }
      }
    },
    not: function (expression) {
      return "!(" + expression + ")";
    },
    isNull: function (expression) {
      return expression + "==null";
    },
    notNull: function (expression) {
      return expression + "!=null";
    },
    nonComputedMember: function (left, right) {
      var SAFE_IDENTIFIER = /^[$_a-zA-Z][$_a-zA-Z0-9]*$/;
      var UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;
      if (SAFE_IDENTIFIER.test(right)) {
        return left + "." + right;
      } else {
        return (
          left +
          '["' +
          right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn) +
          '"]'
        );
      }
    },
    computedMember: function (left, right) {
      return left + "[" + right + "]";
    },
    member: function (left, right, computed) {
      if (computed) return this.computedMember(left, right);
      return this.nonComputedMember(left, right);
    },
    getStringValue: function (item) {
      this.assign(item, "getStringValue(" + item + ")");
    },
    lazyRecurse: function (
      ast,
      intoId,
      nameId,
      recursionFn,
      create,
      skipWatchIdCheck
    ) {
      var self = this;
      return function () {
        self.recurse(
          ast,
          intoId,
          nameId,
          recursionFn,
          create,
          skipWatchIdCheck
        );
      };
    },
    lazyAssign: function (id, value) {
      var self = this;
      return function () {
        self.assign(id, value);
      };
    },
    stringEscapeRegex: /[^ a-zA-Z0-9]/g,
    stringEscapeFn: function (c) {
      return "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4);
    },
    escape: function (value) {
      if (isString(value))
        return (
          "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'"
        );
      if (isNumber(value)) return value.toString();
      if (value === true) return "true";
      if (value === false) return "false";
      if (value === null) return "null";
      if (typeof value === "undefined") return "undefined";
      throw $parseMinErr("esc", "IMPOSSIBLE");
    },
    nextId: function (skip, init) {
      var id = "v" + this.state.nextId++;
      if (!skip) {
        this.current().vars.push(id + (init ? "=" + init : ""));
      }
      return id;
    },
    current: function () {
      return this.state[this.state.computing];
    },
  };
  function ASTInterpreter(astBuilder, $filter) {
    this.astBuilder = astBuilder;
    this.$filter = $filter;
  }
  ASTInterpreter.prototype = {
    compile: function (expression) {
      var self = this;
      var ast = this.astBuilder.ast(expression);
      findConstantAndWatchExpressions(ast, self.$filter);
      var assignable;
      var assign;
      if ((assignable = assignableAST(ast))) {
        assign = this.recurse(assignable);
      }
      var toWatch = getInputs(ast.body);
      var inputs;
      if (toWatch) {
        inputs = [];
        forEach(toWatch, function (watch, key) {
          var input = self.recurse(watch);
          watch.input = input;
          inputs.push(input);
          watch.watchId = key;
        });
      }
      var expressions = [];
      forEach(ast.body, function (expression) {
        expressions.push(self.recurse(expression.expression));
      });
      var fn =
        ast.body.length === 0
          ? noop
          : ast.body.length === 1
          ? expressions[0]
          : function (scope, locals) {
              var lastValue;
              forEach(expressions, function (exp) {
                lastValue = exp(scope, locals);
              });
              return lastValue;
            };
      if (assign) {
        fn.assign = function (scope, value, locals) {
          return assign(scope, locals, value);
        };
      }
      if (inputs) {
        fn.inputs = inputs;
      }
      fn.literal = isLiteral(ast);
      fn.constant = isConstant(ast);
      return fn;
    },
    recurse: function (ast, context, create) {
      var left,
        right,
        self = this,
        args;
      if (ast.input) {
        return this.inputs(ast.input, ast.watchId);
      }
      switch (ast.type) {
        case AST.Literal:
          return this.value(ast.value, context);
        case AST.UnaryExpression:
          right = this.recurse(ast.argument);
          return this["unary" + ast.operator](right, context);
        case AST.BinaryExpression:
          left = this.recurse(ast.left);
          right = this.recurse(ast.right);
          return this["binary" + ast.operator](left, right, context);
        case AST.LogicalExpression:
          left = this.recurse(ast.left);
          right = this.recurse(ast.right);
          return this["binary" + ast.operator](left, right, context);
        case AST.ConditionalExpression:
          return this["ternary?:"](
            this.recurse(ast.test),
            this.recurse(ast.alternate),
            this.recurse(ast.consequent),
            context
          );
        case AST.Identifier:
          return self.identifier(ast.name, context, create);
        case AST.MemberExpression:
          left = this.recurse(ast.object, false, !!create);
          if (!ast.computed) {
            right = ast.property.name;
          }
          if (ast.computed) right = this.recurse(ast.property);
          return ast.computed
            ? this.computedMember(left, right, context, create)
            : this.nonComputedMember(left, right, context, create);
        case AST.CallExpression:
          args = [];
          forEach(ast.arguments, function (expr) {
            args.push(self.recurse(expr));
          });
          if (ast.filter) right = this.$filter(ast.callee.name);
          if (!ast.filter) right = this.recurse(ast.callee, true);
          return ast.filter
            ? function (scope, locals, assign, inputs) {
                var values = [];
                for (var i = 0; i < args.length; ++i) {
                  values.push(args[i](scope, locals, assign, inputs));
                }
                var value = right.apply(undefined, values, inputs);
                return context
                  ? { context: undefined, name: undefined, value: value }
                  : value;
              }
            : function (scope, locals, assign, inputs) {
                var rhs = right(scope, locals, assign, inputs);
                var value;
                if (rhs.value != null) {
                  var values = [];
                  for (var i = 0; i < args.length; ++i) {
                    values.push(args[i](scope, locals, assign, inputs));
                  }
                  value = rhs.value.apply(rhs.context, values);
                }
                return context ? { value: value } : value;
              };
        case AST.AssignmentExpression:
          left = this.recurse(ast.left, true, 1);
          right = this.recurse(ast.right);
          return function (scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            lhs.context[lhs.name] = rhs;
            return context ? { value: rhs } : rhs;
          };
        case AST.ArrayExpression:
          args = [];
          forEach(ast.elements, function (expr) {
            args.push(self.recurse(expr));
          });
          return function (scope, locals, assign, inputs) {
            var value = [];
            for (var i = 0; i < args.length; ++i) {
              value.push(args[i](scope, locals, assign, inputs));
            }
            return context ? { value: value } : value;
          };
        case AST.ObjectExpression:
          args = [];
          forEach(ast.properties, function (property) {
            if (property.computed) {
              args.push({
                key: self.recurse(property.key),
                computed: true,
                value: self.recurse(property.value),
              });
            } else {
              args.push({
                key:
                  property.key.type === AST.Identifier
                    ? property.key.name
                    : "" + property.key.value,
                computed: false,
                value: self.recurse(property.value),
              });
            }
          });
          return function (scope, locals, assign, inputs) {
            var value = {};
            for (var i = 0; i < args.length; ++i) {
              if (args[i].computed) {
                value[args[i].key(scope, locals, assign, inputs)] = args[
                  i
                ].value(scope, locals, assign, inputs);
              } else {
                value[args[i].key] = args[i].value(
                  scope,
                  locals,
                  assign,
                  inputs
                );
              }
            }
            return context ? { value: value } : value;
          };
        case AST.ThisExpression:
          return function (scope) {
            return context ? { value: scope } : scope;
          };
        case AST.LocalsExpression:
          return function (scope, locals) {
            return context ? { value: locals } : locals;
          };
        case AST.NGValueParameter:
          return function (scope, locals, assign) {
            return context ? { value: assign } : assign;
          };
      }
    },
    "unary+": function (argument, context) {
      return function (scope, locals, assign, inputs) {
        var arg = argument(scope, locals, assign, inputs);
        if (isDefined(arg)) {
          arg = +arg;
        } else {
          arg = 0;
        }
        return context ? { value: arg } : arg;
      };
    },
    "unary-": function (argument, context) {
      return function (scope, locals, assign, inputs) {
        var arg = argument(scope, locals, assign, inputs);
        if (isDefined(arg)) {
          arg = -arg;
        } else {
          arg = -0;
        }
        return context ? { value: arg } : arg;
      };
    },
    "unary!": function (argument, context) {
      return function (scope, locals, assign, inputs) {
        var arg = !argument(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    "binary+": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var lhs = left(scope, locals, assign, inputs);
        var rhs = right(scope, locals, assign, inputs);
        var arg = plusFn(lhs, rhs);
        return context ? { value: arg } : arg;
      };
    },
    "binary-": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var lhs = left(scope, locals, assign, inputs);
        var rhs = right(scope, locals, assign, inputs);
        var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
        return context ? { value: arg } : arg;
      };
    },
    "binary*": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var arg =
          left(scope, locals, assign, inputs) *
          right(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    "binary/": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var arg =
          left(scope, locals, assign, inputs) /
          right(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    "binary%": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var arg =
          left(scope, locals, assign, inputs) %
          right(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    "binary===": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var arg =
          left(scope, locals, assign, inputs) ===
          right(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    "binary!==": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var arg =
          left(scope, locals, assign, inputs) !==
          right(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    "binary==": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var arg =
          left(scope, locals, assign, inputs) ==
          right(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    "binary!=": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var arg =
          left(scope, locals, assign, inputs) !=
          right(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    "binary<": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var arg =
          left(scope, locals, assign, inputs) <
          right(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    "binary>": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var arg =
          left(scope, locals, assign, inputs) >
          right(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    "binary<=": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var arg =
          left(scope, locals, assign, inputs) <=
          right(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    "binary>=": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var arg =
          left(scope, locals, assign, inputs) >=
          right(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    "binary&&": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var arg =
          left(scope, locals, assign, inputs) &&
          right(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    "binary||": function (left, right, context) {
      return function (scope, locals, assign, inputs) {
        var arg =
          left(scope, locals, assign, inputs) ||
          right(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    "ternary?:": function (test, alternate, consequent, context) {
      return function (scope, locals, assign, inputs) {
        var arg = test(scope, locals, assign, inputs)
          ? alternate(scope, locals, assign, inputs)
          : consequent(scope, locals, assign, inputs);
        return context ? { value: arg } : arg;
      };
    },
    value: function (value, context) {
      return function () {
        return context
          ? { context: undefined, name: undefined, value: value }
          : value;
      };
    },
    identifier: function (name, context, create) {
      return function (scope, locals, assign, inputs) {
        var base = locals && name in locals ? locals : scope;
        if (create && create !== 1 && base && base[name] == null) {
          base[name] = {};
        }
        var value = base ? base[name] : undefined;
        if (context) {
          return { context: base, name: name, value: value };
        } else {
          return value;
        }
      };
    },
    computedMember: function (left, right, context, create) {
      return function (scope, locals, assign, inputs) {
        var lhs = left(scope, locals, assign, inputs);
        var rhs;
        var value;
        if (lhs != null) {
          rhs = right(scope, locals, assign, inputs);
          rhs = getStringValue(rhs);
          if (create && create !== 1) {
            if (lhs && !lhs[rhs]) {
              lhs[rhs] = {};
            }
          }
          value = lhs[rhs];
        }
        if (context) {
          return { context: lhs, name: rhs, value: value };
        } else {
          return value;
        }
      };
    },
    nonComputedMember: function (left, right, context, create) {
      return function (scope, locals, assign, inputs) {
        var lhs = left(scope, locals, assign, inputs);
        if (create && create !== 1) {
          if (lhs && lhs[right] == null) {
            lhs[right] = {};
          }
        }
        var value = lhs != null ? lhs[right] : undefined;
        if (context) {
          return { context: lhs, name: right, value: value };
        } else {
          return value;
        }
      };
    },
    inputs: function (input, watchId) {
      return function (scope, value, locals, inputs) {
        if (inputs) return inputs[watchId];
        return input(scope, value, locals);
      };
    },
  };
  var Parser = function Parser(lexer, $filter, options) {
    this.lexer = lexer;
    this.$filter = $filter;
    this.options = options;
    this.ast = new AST(lexer, options);
    this.astCompiler = options.csp
      ? new ASTInterpreter(this.ast, $filter)
      : new ASTCompiler(this.ast, $filter);
  };
  Parser.prototype = {
    constructor: Parser,
    parse: function (text) {
      return this.astCompiler.compile(text);
    },
  };
  function getValueOf(value) {
    return isFunction(value.valueOf)
      ? value.valueOf()
      : objectValueOf.call(value);
  }
  function $ParseProvider() {
    var cache = createMap();
    var literals = {
      true: true,
      false: false,
      null: null,
      undefined: undefined,
    };
    var identStart, identContinue;
    this.addLiteral = function (literalName, literalValue) {
      literals[literalName] = literalValue;
    };
    this.setIdentifierFns = function (identifierStart, identifierContinue) {
      identStart = identifierStart;
      identContinue = identifierContinue;
      return this;
    };
    this.$get = [
      "$filter",
      function ($filter) {
        var noUnsafeEval = csp().noUnsafeEval;
        var $parseOptions = {
          csp: noUnsafeEval,
          literals: copy(literals),
          isIdentifierStart: isFunction(identStart) && identStart,
          isIdentifierContinue: isFunction(identContinue) && identContinue,
        };
        return $parse;
        function $parse(exp, interceptorFn) {
          var parsedExpression, oneTime, cacheKey;
          switch (typeof exp) {
            case "string":
              exp = exp.trim();
              cacheKey = exp;
              parsedExpression = cache[cacheKey];
              if (!parsedExpression) {
                if (exp.charAt(0) === ":" && exp.charAt(1) === ":") {
                  oneTime = true;
                  exp = exp.substring(2);
                }
                var lexer = new Lexer($parseOptions);
                var parser = new Parser(lexer, $filter, $parseOptions);
                parsedExpression = parser.parse(exp);
                if (parsedExpression.constant) {
                  parsedExpression.$$watchDelegate = constantWatchDelegate;
                } else if (oneTime) {
                  parsedExpression.$$watchDelegate = parsedExpression.literal
                    ? oneTimeLiteralWatchDelegate
                    : oneTimeWatchDelegate;
                } else if (parsedExpression.inputs) {
                  parsedExpression.$$watchDelegate = inputsWatchDelegate;
                }
                cache[cacheKey] = parsedExpression;
              }
              return addInterceptor(parsedExpression, interceptorFn);
            case "function":
              return addInterceptor(exp, interceptorFn);
            default:
              return addInterceptor(noop, interceptorFn);
          }
        }
        function expressionInputDirtyCheck(newValue, oldValueOfValue) {
          if (newValue == null || oldValueOfValue == null) {
            return newValue === oldValueOfValue;
          }
          if (typeof newValue === "object") {
            newValue = getValueOf(newValue);
            if (typeof newValue === "object") {
              return false;
            }
          }
          return (
            newValue === oldValueOfValue ||
            (newValue !== newValue && oldValueOfValue !== oldValueOfValue)
          );
        }
        function inputsWatchDelegate(
          scope,
          listener,
          objectEquality,
          parsedExpression,
          prettyPrintExpression
        ) {
          var inputExpressions = parsedExpression.inputs;
          var lastResult;
          if (inputExpressions.length === 1) {
            var oldInputValueOf = expressionInputDirtyCheck;
            inputExpressions = inputExpressions[0];
            return scope.$watch(
              function expressionInputWatch(scope) {
                var newInputValue = inputExpressions(scope);
                if (
                  !expressionInputDirtyCheck(newInputValue, oldInputValueOf)
                ) {
                  lastResult = parsedExpression(scope, undefined, undefined, [
                    newInputValue,
                  ]);
                  oldInputValueOf = newInputValue && getValueOf(newInputValue);
                }
                return lastResult;
              },
              listener,
              objectEquality,
              prettyPrintExpression
            );
          }
          var oldInputValueOfValues = [];
          var oldInputValues = [];
          for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
            oldInputValueOfValues[i] = expressionInputDirtyCheck;
            oldInputValues[i] = null;
          }
          return scope.$watch(
            function expressionInputsWatch(scope) {
              var changed = false;
              for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                var newInputValue = inputExpressions[i](scope);
                if (
                  changed ||
                  (changed = !expressionInputDirtyCheck(
                    newInputValue,
                    oldInputValueOfValues[i]
                  ))
                ) {
                  oldInputValues[i] = newInputValue;
                  oldInputValueOfValues[i] =
                    newInputValue && getValueOf(newInputValue);
                }
              }
              if (changed) {
                lastResult = parsedExpression(
                  scope,
                  undefined,
                  undefined,
                  oldInputValues
                );
              }
              return lastResult;
            },
            listener,
            objectEquality,
            prettyPrintExpression
          );
        }
        function oneTimeWatchDelegate(
          scope,
          listener,
          objectEquality,
          parsedExpression,
          prettyPrintExpression
        ) {
          var unwatch, lastValue;
          if (parsedExpression.inputs) {
            unwatch = inputsWatchDelegate(
              scope,
              oneTimeListener,
              objectEquality,
              parsedExpression,
              prettyPrintExpression
            );
          } else {
            unwatch = scope.$watch(
              oneTimeWatch,
              oneTimeListener,
              objectEquality
            );
          }
          return unwatch;
          function oneTimeWatch(scope) {
            return parsedExpression(scope);
          }
          function oneTimeListener(value, old, scope) {
            lastValue = value;
            if (isFunction(listener)) {
              listener(value, old, scope);
            }
            if (isDefined(value)) {
              scope.$$postDigest(function () {
                if (isDefined(lastValue)) {
                  unwatch();
                }
              });
            }
          }
        }
        function oneTimeLiteralWatchDelegate(
          scope,
          listener,
          objectEquality,
          parsedExpression
        ) {
          var unwatch, lastValue;
          unwatch = scope.$watch(
            function oneTimeWatch(scope) {
              return parsedExpression(scope);
            },
            function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener(value, old, scope);
              }
              if (isAllDefined(value)) {
                scope.$$postDigest(function () {
                  if (isAllDefined(lastValue)) unwatch();
                });
              }
            },
            objectEquality
          );
          return unwatch;
          function isAllDefined(value) {
            var allDefined = true;
            forEach(value, function (val) {
              if (!isDefined(val)) allDefined = false;
            });
            return allDefined;
          }
        }
        function constantWatchDelegate(
          scope,
          listener,
          objectEquality,
          parsedExpression
        ) {
          var unwatch = scope.$watch(
            function constantWatch(scope) {
              unwatch();
              return parsedExpression(scope);
            },
            listener,
            objectEquality
          );
          return unwatch;
        }
        function addInterceptor(parsedExpression, interceptorFn) {
          if (!interceptorFn) return parsedExpression;
          var watchDelegate = parsedExpression.$$watchDelegate;
          var useInputs = false;
          var regularWatch =
            watchDelegate !== oneTimeLiteralWatchDelegate &&
            watchDelegate !== oneTimeWatchDelegate;
          var fn = regularWatch
            ? function regularInterceptedExpression(
                scope,
                locals,
                assign,
                inputs
              ) {
                var value =
                  useInputs && inputs
                    ? inputs[0]
                    : parsedExpression(scope, locals, assign, inputs);
                return interceptorFn(value, scope, locals);
              }
            : function oneTimeInterceptedExpression(
                scope,
                locals,
                assign,
                inputs
              ) {
                var value = parsedExpression(scope, locals, assign, inputs);
                var result = interceptorFn(value, scope, locals);
                return isDefined(value) ? result : value;
              };
          useInputs = !parsedExpression.inputs;
          if (
            parsedExpression.$$watchDelegate &&
            parsedExpression.$$watchDelegate !== inputsWatchDelegate
          ) {
            fn.$$watchDelegate = parsedExpression.$$watchDelegate;
            fn.inputs = parsedExpression.inputs;
          } else if (!interceptorFn.$stateful) {
            fn.$$watchDelegate = inputsWatchDelegate;
            fn.inputs = parsedExpression.inputs
              ? parsedExpression.inputs
              : [parsedExpression];
          }
          return fn;
        }
      },
    ];
  }
  function $QProvider() {
    var errorOnUnhandledRejections = true;
    this.$get = [
      "$rootScope",
      "$exceptionHandler",
      function ($rootScope, $exceptionHandler) {
        return qFactory(
          function (callback) {
            $rootScope.$evalAsync(callback);
          },
          $exceptionHandler,
          errorOnUnhandledRejections
        );
      },
    ];
    this.errorOnUnhandledRejections = function (value) {
      if (isDefined(value)) {
        errorOnUnhandledRejections = value;
        return this;
      } else {
        return errorOnUnhandledRejections;
      }
    };
  }
  function $$QProvider() {
    var errorOnUnhandledRejections = true;
    this.$get = [
      "$browser",
      "$exceptionHandler",
      function ($browser, $exceptionHandler) {
        return qFactory(
          function (callback) {
            $browser.defer(callback);
          },
          $exceptionHandler,
          errorOnUnhandledRejections
        );
      },
    ];
    this.errorOnUnhandledRejections = function (value) {
      if (isDefined(value)) {
        errorOnUnhandledRejections = value;
        return this;
      } else {
        return errorOnUnhandledRejections;
      }
    };
  }
  function qFactory(nextTick, exceptionHandler, errorOnUnhandledRejections) {
    var $qMinErr = minErr("$q", TypeError);
    var queueSize = 0;
    var checkQueue = [];
    function defer() {
      return new Deferred();
    }
    function Deferred() {
      var promise = (this.promise = new Promise());
      this.resolve = function (val) {
        resolvePromise(promise, val);
      };
      this.reject = function (reason) {
        rejectPromise(promise, reason);
      };
      this.notify = function (progress) {
        notifyPromise(promise, progress);
      };
    }
    function Promise() {
      this.$$state = { status: 0 };
    }
    extend(Promise.prototype, {
      then: function (onFulfilled, onRejected, progressBack) {
        if (
          isUndefined(onFulfilled) &&
          isUndefined(onRejected) &&
          isUndefined(progressBack)
        ) {
          return this;
        }
        var result = new Promise();
        this.$$state.pending = this.$$state.pending || [];
        this.$$state.pending.push([
          result,
          onFulfilled,
          onRejected,
          progressBack,
        ]);
        if (this.$$state.status > 0) scheduleProcessQueue(this.$$state);
        return result;
      },
      catch: function (callback) {
        return this.then(null, callback);
      },
      finally: function (callback, progressBack) {
        return this.then(
          function (value) {
            return handleCallback(value, resolve, callback);
          },
          function (error) {
            return handleCallback(error, reject, callback);
          },
          progressBack
        );
      },
    });
    function processQueue(state) {
      var fn, promise, pending;
      pending = state.pending;
      state.processScheduled = false;
      state.pending = undefined;
      try {
        for (var i = 0, ii = pending.length; i < ii; ++i) {
          state.pur = true;
          promise = pending[i][0];
          fn = pending[i][state.status];
          try {
            if (isFunction(fn)) {
              resolvePromise(promise, fn(state.value));
            } else if (state.status === 1) {
              resolvePromise(promise, state.value);
            } else {
              rejectPromise(promise, state.value);
            }
          } catch (e) {
            rejectPromise(promise, e);
          }
        }
      } finally {
        --queueSize;
        if (errorOnUnhandledRejections && queueSize === 0) {
          nextTick(processChecks);
        }
      }
    }
    function processChecks() {
      while (!queueSize && checkQueue.length) {
        var toCheck = checkQueue.shift();
        if (!toCheck.pur) {
          toCheck.pur = true;
          var errorMessage =
            "Possibly unhandled rejection: " + toDebugString(toCheck.value);
          if (toCheck.value instanceof Error) {
            exceptionHandler(toCheck.value, errorMessage);
          } else {
            exceptionHandler(errorMessage);
          }
        }
      }
    }
    function scheduleProcessQueue(state) {
      if (
        errorOnUnhandledRejections &&
        !state.pending &&
        state.status === 2 &&
        !state.pur
      ) {
        if (queueSize === 0 && checkQueue.length === 0) {
          nextTick(processChecks);
        }
        checkQueue.push(state);
      }
      if (state.processScheduled || !state.pending) return;
      state.processScheduled = true;
      ++queueSize;
      nextTick(function () {
        processQueue(state);
      });
    }
    function resolvePromise(promise, val) {
      if (promise.$$state.status) return;
      if (val === promise) {
        $$reject(
          promise,
          $qMinErr(
            "qcycle",
            "Expected promise to be resolved with value other than itself '{0}'",
            val
          )
        );
      } else {
        $$resolve(promise, val);
      }
    }
    function $$resolve(promise, val) {
      var then;
      var done = false;
      try {
        if (isObject(val) || isFunction(val)) then = val.then;
        if (isFunction(then)) {
          promise.$$state.status = -1;
          then.call(val, doResolve, doReject, doNotify);
        } else {
          promise.$$state.value = val;
          promise.$$state.status = 1;
          scheduleProcessQueue(promise.$$state);
        }
      } catch (e) {
        doReject(e);
      }
      function doResolve(val) {
        if (done) return;
        done = true;
        $$resolve(promise, val);
      }
      function doReject(val) {
        if (done) return;
        done = true;
        $$reject(promise, val);
      }
      function doNotify(progress) {
        notifyPromise(promise, progress);
      }
    }
    function rejectPromise(promise, reason) {
      if (promise.$$state.status) return;
      $$reject(promise, reason);
    }
    function $$reject(promise, reason) {
      promise.$$state.value = reason;
      promise.$$state.status = 2;
      scheduleProcessQueue(promise.$$state);
    }
    function notifyPromise(promise, progress) {
      var callbacks = promise.$$state.pending;
      if (promise.$$state.status <= 0 && callbacks && callbacks.length) {
        nextTick(function () {
          var callback, result;
          for (var i = 0, ii = callbacks.length; i < ii; i++) {
            result = callbacks[i][0];
            callback = callbacks[i][3];
            try {
              notifyPromise(
                result,
                isFunction(callback) ? callback(progress) : progress
              );
            } catch (e) {
              exceptionHandler(e);
            }
          }
        });
      }
    }
    function reject(reason) {
      var result = new Promise();
      rejectPromise(result, reason);
      return result;
    }
    function handleCallback(value, resolver, callback) {
      var callbackOutput = null;
      try {
        if (isFunction(callback)) callbackOutput = callback();
      } catch (e) {
        return reject(e);
      }
      if (isPromiseLike(callbackOutput)) {
        return callbackOutput.then(function () {
          return resolver(value);
        }, reject);
      } else {
        return resolver(value);
      }
    }
    function when(value, callback, errback, progressBack) {
      var result = new Promise();
      resolvePromise(result, value);
      return result.then(callback, errback, progressBack);
    }
    var resolve = when;
    function all(promises) {
      var result = new Promise(),
        counter = 0,
        results = isArray(promises) ? [] : {};
      forEach(promises, function (promise, key) {
        counter++;
        when(promise).then(
          function (value) {
            results[key] = value;
            if (!--counter) resolvePromise(result, results);
          },
          function (reason) {
            rejectPromise(result, reason);
          }
        );
      });
      if (counter === 0) {
        resolvePromise(result, results);
      }
      return result;
    }
    function race(promises) {
      var deferred = defer();
      forEach(promises, function (promise) {
        when(promise).then(deferred.resolve, deferred.reject);
      });
      return deferred.promise;
    }
    function $Q(resolver) {
      if (!isFunction(resolver)) {
        throw $qMinErr("norslvr", "Expected resolverFn, got '{0}'", resolver);
      }
      var promise = new Promise();
      function resolveFn(value) {
        resolvePromise(promise, value);
      }
      function rejectFn(reason) {
        rejectPromise(promise, reason);
      }
      resolver(resolveFn, rejectFn);
      return promise;
    }
    $Q.prototype = Promise.prototype;
    $Q.defer = defer;
    $Q.reject = reject;
    $Q.when = when;
    $Q.resolve = resolve;
    $Q.all = all;
    $Q.race = race;
    return $Q;
  }
  function $$RAFProvider() {
    this.$get = [
      "$window",
      "$timeout",
      function ($window, $timeout) {
        var requestAnimationFrame =
          $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
        var cancelAnimationFrame =
          $window.cancelAnimationFrame ||
          $window.webkitCancelAnimationFrame ||
          $window.webkitCancelRequestAnimationFrame;
        var rafSupported = !!requestAnimationFrame;
        var raf = rafSupported
          ? function (fn) {
              var id = requestAnimationFrame(fn);
              return function () {
                cancelAnimationFrame(id);
              };
            }
          : function (fn) {
              var timer = $timeout(fn, 16.66, false);
              return function () {
                $timeout.cancel(timer);
              };
            };
        raf.supported = rafSupported;
        return raf;
      },
    ];
  }
  function $RootScopeProvider() {
    var TTL = 10;
    var $rootScopeMinErr = minErr("$rootScope");
    var lastDirtyWatch = null;
    var applyAsyncId = null;
    this.digestTtl = function (value) {
      if (arguments.length) {
        TTL = value;
      }
      return TTL;
    };
    function createChildScopeClass(parent) {
      function ChildScope() {
        this.$$watchers =
          this.$$nextSibling =
          this.$$childHead =
          this.$$childTail =
            null;
        this.$$listeners = {};
        this.$$listenerCount = {};
        this.$$watchersCount = 0;
        this.$id = nextUid();
        this.$$ChildScope = null;
      }
      ChildScope.prototype = parent;
      return ChildScope;
    }
    this.$get = [
      "$exceptionHandler",
      "$parse",
      "$browser",
      function ($exceptionHandler, $parse, $browser) {
        function destroyChildScope($event) {
          $event.currentScope.$$destroyed = true;
        }
        function cleanUpScope($scope) {
          if (msie === 9) {
            if ($scope.$$childHead) {
              cleanUpScope($scope.$$childHead);
            }
            if ($scope.$$nextSibling) {
              cleanUpScope($scope.$$nextSibling);
            }
          }
          $scope.$parent =
            $scope.$$nextSibling =
            $scope.$$prevSibling =
            $scope.$$childHead =
            $scope.$$childTail =
            $scope.$root =
            $scope.$$watchers =
              null;
        }
        function Scope() {
          this.$id = nextUid();
          this.$$phase =
            this.$parent =
            this.$$watchers =
            this.$$nextSibling =
            this.$$prevSibling =
            this.$$childHead =
            this.$$childTail =
              null;
          this.$root = this;
          this.$$destroyed = false;
          this.$$listeners = {};
          this.$$listenerCount = {};
          this.$$watchersCount = 0;
          this.$$isolateBindings = null;
        }
        Scope.prototype = {
          constructor: Scope,
          $new: function (isolate, parent) {
            var child;
            parent = parent || this;
            if (isolate) {
              child = new Scope();
              child.$root = this.$root;
            } else {
              if (!this.$$ChildScope) {
                this.$$ChildScope = createChildScopeClass(this);
              }
              child = new this.$$ChildScope();
            }
            child.$parent = parent;
            child.$$prevSibling = parent.$$childTail;
            if (parent.$$childHead) {
              parent.$$childTail.$$nextSibling = child;
              parent.$$childTail = child;
            } else {
              parent.$$childHead = parent.$$childTail = child;
            }
            if (isolate || parent !== this)
              child.$on("$destroy", destroyChildScope);
            return child;
          },
          $watch: function (
            watchExp,
            listener,
            objectEquality,
            prettyPrintExpression
          ) {
            var get = $parse(watchExp);
            if (get.$$watchDelegate) {
              return get.$$watchDelegate(
                this,
                listener,
                objectEquality,
                get,
                watchExp
              );
            }
            var scope = this,
              array = scope.$$watchers,
              watcher = {
                fn: listener,
                last: initWatchVal,
                get: get,
                exp: prettyPrintExpression || watchExp,
                eq: !!objectEquality,
              };
            lastDirtyWatch = null;
            if (!isFunction(listener)) {
              watcher.fn = noop;
            }
            if (!array) {
              array = scope.$$watchers = [];
              array.$$digestWatchIndex = -1;
            }
            array.unshift(watcher);
            array.$$digestWatchIndex++;
            incrementWatchersCount(this, 1);
            return function deregisterWatch() {
              var index = arrayRemove(array, watcher);
              if (index >= 0) {
                incrementWatchersCount(scope, -1);
                if (index < array.$$digestWatchIndex) {
                  array.$$digestWatchIndex--;
                }
              }
              lastDirtyWatch = null;
            };
          },
          $watchGroup: function (watchExpressions, listener) {
            var oldValues = new Array(watchExpressions.length);
            var newValues = new Array(watchExpressions.length);
            var deregisterFns = [];
            var self = this;
            var changeReactionScheduled = false;
            var firstRun = true;
            if (!watchExpressions.length) {
              var shouldCall = true;
              self.$evalAsync(function () {
                if (shouldCall) listener(newValues, newValues, self);
              });
              return function deregisterWatchGroup() {
                shouldCall = false;
              };
            }
            if (watchExpressions.length === 1) {
              return this.$watch(
                watchExpressions[0],
                function watchGroupAction(value, oldValue, scope) {
                  newValues[0] = value;
                  oldValues[0] = oldValue;
                  listener(
                    newValues,
                    value === oldValue ? newValues : oldValues,
                    scope
                  );
                }
              );
            }
            forEach(watchExpressions, function (expr, i) {
              var unwatchFn = self.$watch(
                expr,
                function watchGroupSubAction(value, oldValue) {
                  newValues[i] = value;
                  oldValues[i] = oldValue;
                  if (!changeReactionScheduled) {
                    changeReactionScheduled = true;
                    self.$evalAsync(watchGroupAction);
                  }
                }
              );
              deregisterFns.push(unwatchFn);
            });
            function watchGroupAction() {
              changeReactionScheduled = false;
              if (firstRun) {
                firstRun = false;
                listener(newValues, newValues, self);
              } else {
                listener(newValues, oldValues, self);
              }
            }
            return function deregisterWatchGroup() {
              while (deregisterFns.length) {
                deregisterFns.shift()();
              }
            };
          },
          $watchCollection: function (obj, listener) {
            $watchCollectionInterceptor.$stateful = true;
            var self = this;
            var newValue;
            var oldValue;
            var veryOldValue;
            var trackVeryOldValue = listener.length > 1;
            var changeDetected = 0;
            var changeDetector = $parse(obj, $watchCollectionInterceptor);
            var internalArray = [];
            var internalObject = {};
            var initRun = true;
            var oldLength = 0;
            function $watchCollectionInterceptor(_value) {
              newValue = _value;
              var newLength, key, bothNaN, newItem, oldItem;
              if (isUndefined(newValue)) return;
              if (!isObject(newValue)) {
                if (oldValue !== newValue) {
                  oldValue = newValue;
                  changeDetected++;
                }
              } else if (isArrayLike(newValue)) {
                if (oldValue !== internalArray) {
                  oldValue = internalArray;
                  oldLength = oldValue.length = 0;
                  changeDetected++;
                }
                newLength = newValue.length;
                if (oldLength !== newLength) {
                  changeDetected++;
                  oldValue.length = oldLength = newLength;
                }
                for (var i = 0; i < newLength; i++) {
                  oldItem = oldValue[i];
                  newItem = newValue[i];
                  bothNaN = oldItem !== oldItem && newItem !== newItem;
                  if (!bothNaN && oldItem !== newItem) {
                    changeDetected++;
                    oldValue[i] = newItem;
                  }
                }
              } else {
                if (oldValue !== internalObject) {
                  oldValue = internalObject = {};
                  oldLength = 0;
                  changeDetected++;
                }
                newLength = 0;
                for (key in newValue) {
                  if (hasOwnProperty.call(newValue, key)) {
                    newLength++;
                    newItem = newValue[key];
                    oldItem = oldValue[key];
                    if (key in oldValue) {
                      bothNaN = oldItem !== oldItem && newItem !== newItem;
                      if (!bothNaN && oldItem !== newItem) {
                        changeDetected++;
                        oldValue[key] = newItem;
                      }
                    } else {
                      oldLength++;
                      oldValue[key] = newItem;
                      changeDetected++;
                    }
                  }
                }
                if (oldLength > newLength) {
                  changeDetected++;
                  for (key in oldValue) {
                    if (!hasOwnProperty.call(newValue, key)) {
                      oldLength--;
                      delete oldValue[key];
                    }
                  }
                }
              }
              return changeDetected;
            }
            function $watchCollectionAction() {
              if (initRun) {
                initRun = false;
                listener(newValue, newValue, self);
              } else {
                listener(newValue, veryOldValue, self);
              }
              if (trackVeryOldValue) {
                if (!isObject(newValue)) {
                  veryOldValue = newValue;
                } else if (isArrayLike(newValue)) {
                  veryOldValue = new Array(newValue.length);
                  for (var i = 0; i < newValue.length; i++) {
                    veryOldValue[i] = newValue[i];
                  }
                } else {
                  veryOldValue = {};
                  for (var key in newValue) {
                    if (hasOwnProperty.call(newValue, key)) {
                      veryOldValue[key] = newValue[key];
                    }
                  }
                }
              }
            }
            return this.$watch(changeDetector, $watchCollectionAction);
          },
          $digest: function () {
            var watch,
              value,
              last,
              fn,
              get,
              watchers,
              dirty,
              ttl = TTL,
              next,
              current,
              target = this,
              watchLog = [],
              logIdx,
              asyncTask;
            beginPhase("$digest");
            $browser.$$checkUrlChange();
            if (this === $rootScope && applyAsyncId !== null) {
              $browser.defer.cancel(applyAsyncId);
              flushApplyAsync();
            }
            lastDirtyWatch = null;
            do {
              dirty = false;
              current = target;
              for (
                var asyncQueuePosition = 0;
                asyncQueuePosition < asyncQueue.length;
                asyncQueuePosition++
              ) {
                try {
                  asyncTask = asyncQueue[asyncQueuePosition];
                  asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                } catch (e) {
                  $exceptionHandler(e);
                }
                lastDirtyWatch = null;
              }
              asyncQueue.length = 0;
              traverseScopesLoop: do {
                if ((watchers = current.$$watchers)) {
                  watchers.$$digestWatchIndex = watchers.length;
                  while (watchers.$$digestWatchIndex--) {
                    try {
                      watch = watchers[watchers.$$digestWatchIndex];
                      if (watch) {
                        get = watch.get;
                        if (
                          (value = get(current)) !== (last = watch.last) &&
                          !(watch.eq
                            ? equals(value, last)
                            : isNumberNaN(value) && isNumberNaN(last))
                        ) {
                          dirty = true;
                          lastDirtyWatch = watch;
                          watch.last = watch.eq ? copy(value, null) : value;
                          fn = watch.fn;
                          fn(
                            value,
                            last === initWatchVal ? value : last,
                            current
                          );
                          if (ttl < 5) {
                            logIdx = 4 - ttl;
                            if (!watchLog[logIdx]) watchLog[logIdx] = [];
                            watchLog[logIdx].push({
                              msg: isFunction(watch.exp)
                                ? "fn: " +
                                  (watch.exp.name || watch.exp.toString())
                                : watch.exp,
                              newVal: value,
                              oldVal: last,
                            });
                          }
                        } else if (watch === lastDirtyWatch) {
                          dirty = false;
                          break traverseScopesLoop;
                        }
                      }
                    } catch (e) {
                      $exceptionHandler(e);
                    }
                  }
                }
                if (
                  !(next =
                    (current.$$watchersCount && current.$$childHead) ||
                    (current !== target && current.$$nextSibling))
                ) {
                  while (
                    current !== target &&
                    !(next = current.$$nextSibling)
                  ) {
                    current = current.$parent;
                  }
                }
              } while ((current = next));
              if ((dirty || asyncQueue.length) && !ttl--) {
                clearPhase();
                throw $rootScopeMinErr(
                  "infdig",
                  "{0} $digest() iterations reached. Aborting!\n" +
                    "Watchers fired in the last 5 iterations: {1}",
                  TTL,
                  watchLog
                );
              }
            } while (dirty || asyncQueue.length);
            clearPhase();
            while (postDigestQueuePosition < postDigestQueue.length) {
              try {
                postDigestQueue[postDigestQueuePosition++]();
              } catch (e) {
                $exceptionHandler(e);
              }
            }
            postDigestQueue.length = postDigestQueuePosition = 0;
          },
          $destroy: function () {
            if (this.$$destroyed) return;
            var parent = this.$parent;
            this.$broadcast("$destroy");
            this.$$destroyed = true;
            if (this === $rootScope) {
              $browser.$$applicationDestroyed();
            }
            incrementWatchersCount(this, -this.$$watchersCount);
            for (var eventName in this.$$listenerCount) {
              decrementListenerCount(
                this,
                this.$$listenerCount[eventName],
                eventName
              );
            }
            if (parent && parent.$$childHead === this)
              parent.$$childHead = this.$$nextSibling;
            if (parent && parent.$$childTail === this)
              parent.$$childTail = this.$$prevSibling;
            if (this.$$prevSibling)
              this.$$prevSibling.$$nextSibling = this.$$nextSibling;
            if (this.$$nextSibling)
              this.$$nextSibling.$$prevSibling = this.$$prevSibling;
            this.$destroy =
              this.$digest =
              this.$apply =
              this.$evalAsync =
              this.$applyAsync =
                noop;
            this.$on =
              this.$watch =
              this.$watchGroup =
                function () {
                  return noop;
                };
            this.$$listeners = {};
            this.$$nextSibling = null;
            cleanUpScope(this);
          },
          $eval: function (expr, locals) {
            return $parse(expr)(this, locals);
          },
          $evalAsync: function (expr, locals) {
            if (!$rootScope.$$phase && !asyncQueue.length) {
              $browser.defer(function () {
                if (asyncQueue.length) {
                  $rootScope.$digest();
                }
              });
            }
            asyncQueue.push({
              scope: this,
              expression: $parse(expr),
              locals: locals,
            });
          },
          $$postDigest: function (fn) {
            postDigestQueue.push(fn);
          },
          $apply: function (expr) {
            try {
              beginPhase("$apply");
              try {
                return this.$eval(expr);
              } finally {
                clearPhase();
              }
            } catch (e) {
              $exceptionHandler(e);
            } finally {
              try {
                $rootScope.$digest();
              } catch (e) {
                $exceptionHandler(e);
                throw e;
              }
            }
          },
          $applyAsync: function (expr) {
            var scope = this;
            if (expr) {
              applyAsyncQueue.push($applyAsyncExpression);
            }
            expr = $parse(expr);
            scheduleApplyAsync();
            function $applyAsyncExpression() {
              scope.$eval(expr);
            }
          },
          $on: function (name, listener) {
            var namedListeners = this.$$listeners[name];
            if (!namedListeners) {
              this.$$listeners[name] = namedListeners = [];
            }
            namedListeners.push(listener);
            var current = this;
            do {
              if (!current.$$listenerCount[name]) {
                current.$$listenerCount[name] = 0;
              }
              current.$$listenerCount[name]++;
            } while ((current = current.$parent));
            var self = this;
            return function () {
              var indexOfListener = namedListeners.indexOf(listener);
              if (indexOfListener !== -1) {
                namedListeners[indexOfListener] = null;
                decrementListenerCount(self, 1, name);
              }
            };
          },
          $emit: function (name, args) {
            var empty = [],
              namedListeners,
              scope = this,
              stopPropagation = false,
              event = {
                name: name,
                targetScope: scope,
                stopPropagation: function () {
                  stopPropagation = true;
                },
                preventDefault: function () {
                  event.defaultPrevented = true;
                },
                defaultPrevented: false,
              },
              listenerArgs = concat([event], arguments, 1),
              i,
              length;
            do {
              namedListeners = scope.$$listeners[name] || empty;
              event.currentScope = scope;
              for (i = 0, length = namedListeners.length; i < length; i++) {
                if (!namedListeners[i]) {
                  namedListeners.splice(i, 1);
                  i--;
                  length--;
                  continue;
                }
                try {
                  namedListeners[i].apply(null, listenerArgs);
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              if (stopPropagation) {
                event.currentScope = null;
                return event;
              }
              scope = scope.$parent;
            } while (scope);
            event.currentScope = null;
            return event;
          },
          $broadcast: function (name, args) {
            var target = this,
              current = target,
              next = target,
              event = {
                name: name,
                targetScope: target,
                preventDefault: function () {
                  event.defaultPrevented = true;
                },
                defaultPrevented: false,
              };
            if (!target.$$listenerCount[name]) return event;
            var listenerArgs = concat([event], arguments, 1),
              listeners,
              i,
              length;
            while ((current = next)) {
              event.currentScope = current;
              listeners = current.$$listeners[name] || [];
              for (i = 0, length = listeners.length; i < length; i++) {
                if (!listeners[i]) {
                  listeners.splice(i, 1);
                  i--;
                  length--;
                  continue;
                }
                try {
                  listeners[i].apply(null, listenerArgs);
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              if (
                !(next =
                  (current.$$listenerCount[name] && current.$$childHead) ||
                  (current !== target && current.$$nextSibling))
              ) {
                while (current !== target && !(next = current.$$nextSibling)) {
                  current = current.$parent;
                }
              }
            }
            event.currentScope = null;
            return event;
          },
        };
        var $rootScope = new Scope();
        var asyncQueue = ($rootScope.$$asyncQueue = []);
        var postDigestQueue = ($rootScope.$$postDigestQueue = []);
        var applyAsyncQueue = ($rootScope.$$applyAsyncQueue = []);
        var postDigestQueuePosition = 0;
        return $rootScope;
        function beginPhase(phase) {
          if ($rootScope.$$phase) {
            throw $rootScopeMinErr(
              "inprog",
              "{0} already in progress",
              $rootScope.$$phase
            );
          }
          $rootScope.$$phase = phase;
        }
        function clearPhase() {
          $rootScope.$$phase = null;
        }
        function incrementWatchersCount(current, count) {
          do {
            current.$$watchersCount += count;
          } while ((current = current.$parent));
        }
        function decrementListenerCount(current, count, name) {
          do {
            current.$$listenerCount[name] -= count;
            if (current.$$listenerCount[name] === 0) {
              delete current.$$listenerCount[name];
            }
          } while ((current = current.$parent));
        }
        function initWatchVal() {}
        function flushApplyAsync() {
          while (applyAsyncQueue.length) {
            try {
              applyAsyncQueue.shift()();
            } catch (e) {
              $exceptionHandler(e);
            }
          }
          applyAsyncId = null;
        }
        function scheduleApplyAsync() {
          if (applyAsyncId === null) {
            applyAsyncId = $browser.defer(function () {
              $rootScope.$apply(flushApplyAsync);
            });
          }
        }
      },
    ];
  }
  function $$SanitizeUriProvider() {
    var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,
      imgSrcSanitizationWhitelist =
        /^\s*((https?|ftp|file|blob):|data:image\/)/;
    this.aHrefSanitizationWhitelist = function (regexp) {
      if (isDefined(regexp)) {
        aHrefSanitizationWhitelist = regexp;
        return this;
      }
      return aHrefSanitizationWhitelist;
    };
    this.imgSrcSanitizationWhitelist = function (regexp) {
      if (isDefined(regexp)) {
        imgSrcSanitizationWhitelist = regexp;
        return this;
      }
      return imgSrcSanitizationWhitelist;
    };
    this.$get = function () {
      return function sanitizeUri(uri, isImage) {
        var regex = isImage
          ? imgSrcSanitizationWhitelist
          : aHrefSanitizationWhitelist;
        var normalizedVal;
        normalizedVal = urlResolve(uri).href;
        if (normalizedVal !== "" && !normalizedVal.match(regex)) {
          return "unsafe:" + normalizedVal;
        }
        return uri;
      };
    };
  }
  var $sceMinErr = minErr("$sce");
  var SCE_CONTEXTS = {
    HTML: "html",
    CSS: "css",
    URL: "url",
    RESOURCE_URL: "resourceUrl",
    JS: "js",
  };
  var UNDERSCORE_LOWERCASE_REGEXP = /_([a-z])/g;
  function snakeToCamel(name) {
    return name.replace(UNDERSCORE_LOWERCASE_REGEXP, fnCamelCaseReplace);
  }
  function adjustMatcher(matcher) {
    if (matcher === "self") {
      return matcher;
    } else if (isString(matcher)) {
      if (matcher.indexOf("***") > -1) {
        throw $sceMinErr(
          "iwcard",
          "Illegal sequence *** in string matcher.  String: {0}",
          matcher
        );
      }
      matcher = escapeForRegexp(matcher)
        .replace(/\\\*\\\*/g, ".*")
        .replace(/\\\*/g, "[^:/.?&;]*");
      return new RegExp("^" + matcher + "$");
    } else if (isRegExp(matcher)) {
      return new RegExp("^" + matcher.source + "$");
    } else {
      throw $sceMinErr(
        "imatcher",
        'Matchers may only be "self", string patterns or RegExp objects'
      );
    }
  }
  function adjustMatchers(matchers) {
    var adjustedMatchers = [];
    if (isDefined(matchers)) {
      forEach(matchers, function (matcher) {
        adjustedMatchers.push(adjustMatcher(matcher));
      });
    }
    return adjustedMatchers;
  }
  function $SceDelegateProvider() {
    this.SCE_CONTEXTS = SCE_CONTEXTS;
    var resourceUrlWhitelist = ["self"],
      resourceUrlBlacklist = [];
    this.resourceUrlWhitelist = function (value) {
      if (arguments.length) {
        resourceUrlWhitelist = adjustMatchers(value);
      }
      return resourceUrlWhitelist;
    };
    this.resourceUrlBlacklist = function (value) {
      if (arguments.length) {
        resourceUrlBlacklist = adjustMatchers(value);
      }
      return resourceUrlBlacklist;
    };
    this.$get = [
      "$injector",
      function ($injector) {
        var htmlSanitizer = function htmlSanitizer(html) {
          throw $sceMinErr(
            "unsafe",
            "Attempting to use an unsafe value in a safe context."
          );
        };
        if ($injector.has("$sanitize")) {
          htmlSanitizer = $injector.get("$sanitize");
        }
        function matchUrl(matcher, parsedUrl) {
          if (matcher === "self") {
            return urlIsSameOrigin(parsedUrl);
          } else {
            return !!matcher.exec(parsedUrl.href);
          }
        }
        function isResourceUrlAllowedByPolicy(url) {
          var parsedUrl = urlResolve(url.toString());
          var i,
            n,
            allowed = false;
          for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
            if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
              allowed = true;
              break;
            }
          }
          if (allowed) {
            for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
              if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                allowed = false;
                break;
              }
            }
          }
          return allowed;
        }
        function generateHolderType(Base) {
          var holderType = function TrustedValueHolderType(trustedValue) {
            this.$$unwrapTrustedValue = function () {
              return trustedValue;
            };
          };
          if (Base) {
            holderType.prototype = new Base();
          }
          holderType.prototype.valueOf = function sceValueOf() {
            return this.$$unwrapTrustedValue();
          };
          holderType.prototype.toString = function sceToString() {
            return this.$$unwrapTrustedValue().toString();
          };
          return holderType;
        }
        var trustedValueHolderBase = generateHolderType(),
          byType = {};
        byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
        byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
        byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
        byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
        byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(
          byType[SCE_CONTEXTS.URL]
        );
        function trustAs(type, trustedValue) {
          var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
          if (!Constructor) {
            throw $sceMinErr(
              "icontext",
              "Attempted to trust a value in invalid context. Context: {0}; Value: {1}",
              type,
              trustedValue
            );
          }
          if (
            trustedValue === null ||
            isUndefined(trustedValue) ||
            trustedValue === ""
          ) {
            return trustedValue;
          }
          if (typeof trustedValue !== "string") {
            throw $sceMinErr(
              "itype",
              "Attempted to trust a non-string value in a content requiring a string: Context: {0}",
              type
            );
          }
          return new Constructor(trustedValue);
        }
        function valueOf(maybeTrusted) {
          if (maybeTrusted instanceof trustedValueHolderBase) {
            return maybeTrusted.$$unwrapTrustedValue();
          } else {
            return maybeTrusted;
          }
        }
        function getTrusted(type, maybeTrusted) {
          if (
            maybeTrusted === null ||
            isUndefined(maybeTrusted) ||
            maybeTrusted === ""
          ) {
            return maybeTrusted;
          }
          var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
          if (constructor && maybeTrusted instanceof constructor) {
            return maybeTrusted.$$unwrapTrustedValue();
          }
          if (type === SCE_CONTEXTS.RESOURCE_URL) {
            if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
              return maybeTrusted;
            } else {
              throw $sceMinErr(
                "insecurl",
                "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}",
                maybeTrusted.toString()
              );
            }
          } else if (type === SCE_CONTEXTS.HTML) {
            return htmlSanitizer(maybeTrusted);
          }
          throw $sceMinErr(
            "unsafe",
            "Attempting to use an unsafe value in a safe context."
          );
        }
        return { trustAs: trustAs, getTrusted: getTrusted, valueOf: valueOf };
      },
    ];
  }
  function $SceProvider() {
    var enabled = true;
    this.enabled = function (value) {
      if (arguments.length) {
        enabled = !!value;
      }
      return enabled;
    };
    this.$get = [
      "$parse",
      "$sceDelegate",
      function ($parse, $sceDelegate) {
        if (enabled && msie < 8) {
          throw $sceMinErr(
            "iequirks",
            "Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks " +
              "mode.  You can fix this by adding the text <!doctype html> to the top of your HTML " +
              "document.  See http://docs.angularjs.org/api/ng.$sce for more information."
          );
        }
        var sce = shallowCopy(SCE_CONTEXTS);
        sce.isEnabled = function () {
          return enabled;
        };
        sce.trustAs = $sceDelegate.trustAs;
        sce.getTrusted = $sceDelegate.getTrusted;
        sce.valueOf = $sceDelegate.valueOf;
        if (!enabled) {
          sce.trustAs = sce.getTrusted = function (type, value) {
            return value;
          };
          sce.valueOf = identity;
        }
        sce.parseAs = function sceParseAs(type, expr) {
          var parsed = $parse(expr);
          if (parsed.literal && parsed.constant) {
            return parsed;
          } else {
            return $parse(expr, function (value) {
              return sce.getTrusted(type, value);
            });
          }
        };
        var parse = sce.parseAs,
          getTrusted = sce.getTrusted,
          trustAs = sce.trustAs;
        forEach(SCE_CONTEXTS, function (enumValue, name) {
          var lName = lowercase(name);
          sce[snakeToCamel("parse_as_" + lName)] = function (expr) {
            return parse(enumValue, expr);
          };
          sce[snakeToCamel("get_trusted_" + lName)] = function (value) {
            return getTrusted(enumValue, value);
          };
          sce[snakeToCamel("trust_as_" + lName)] = function (value) {
            return trustAs(enumValue, value);
          };
        });
        return sce;
      },
    ];
  }
  function $SnifferProvider() {
    this.$get = [
      "$window",
      "$document",
      function ($window, $document) {
        var eventSupport = {},
          isChromePackagedApp =
            $window.chrome &&
            (($window.chrome.app && $window.chrome.app.runtime) ||
              (!$window.chrome.app &&
                $window.chrome.runtime &&
                $window.chrome.runtime.id)),
          hasHistoryPushState =
            !isChromePackagedApp &&
            $window.history &&
            $window.history.pushState,
          android = toInt(
            (/android (\d+)/.exec(
              lowercase(($window.navigator || {}).userAgent)
            ) || [])[1]
          ),
          boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
          document = $document[0] || {},
          bodyStyle = document.body && document.body.style,
          transitions = false,
          animations = false;
        if (bodyStyle) {
          transitions = !!(
            "transition" in bodyStyle || "webkitTransition" in bodyStyle
          );
          animations = !!(
            "animation" in bodyStyle || "webkitAnimation" in bodyStyle
          );
        }
        return {
          history: !!(hasHistoryPushState && !(android < 4) && !boxee),
          hasEvent: function (event) {
            if (event === "input" && msie) return false;
            if (isUndefined(eventSupport[event])) {
              var divElm = document.createElement("div");
              eventSupport[event] = "on" + event in divElm;
            }
            return eventSupport[event];
          },
          csp: csp(),
          transitions: transitions,
          animations: animations,
          android: android,
        };
      },
    ];
  }
  var $templateRequestMinErr = minErr("$compile");
  function $TemplateRequestProvider() {
    var httpOptions;
    this.httpOptions = function (val) {
      if (val) {
        httpOptions = val;
        return this;
      }
      return httpOptions;
    };
    this.$get = [
      "$exceptionHandler",
      "$templateCache",
      "$http",
      "$q",
      "$sce",
      function ($exceptionHandler, $templateCache, $http, $q, $sce) {
        function handleRequestFn(tpl, ignoreRequestError) {
          handleRequestFn.totalPendingRequests++;
          if (!isString(tpl) || isUndefined($templateCache.get(tpl))) {
            tpl = $sce.getTrustedResourceUrl(tpl);
          }
          var transformResponse =
            $http.defaults && $http.defaults.transformResponse;
          if (isArray(transformResponse)) {
            transformResponse = transformResponse.filter(function (
              transformer
            ) {
              return transformer !== defaultHttpResponseTransform;
            });
          } else if (transformResponse === defaultHttpResponseTransform) {
            transformResponse = null;
          }
          return $http
            .get(
              tpl,
              extend(
                { cache: $templateCache, transformResponse: transformResponse },
                httpOptions
              )
            )
            .finally(function () {
              handleRequestFn.totalPendingRequests--;
            })
            .then(function (response) {
              $templateCache.put(tpl, response.data);
              return response.data;
            }, handleError);
          function handleError(resp) {
            if (!ignoreRequestError) {
              resp = $templateRequestMinErr(
                "tpload",
                "Failed to load template: {0} (HTTP status: {1} {2})",
                tpl,
                resp.status,
                resp.statusText
              );
              $exceptionHandler(resp);
            }
            return $q.reject(resp);
          }
        }
        handleRequestFn.totalPendingRequests = 0;
        return handleRequestFn;
      },
    ];
  }
  function $$TestabilityProvider() {
    this.$get = [
      "$rootScope",
      "$browser",
      "$location",
      function ($rootScope, $browser, $location) {
        var testability = {};
        testability.findBindings = function (
          element,
          expression,
          opt_exactMatch
        ) {
          var bindings = element.getElementsByClassName("ng-binding");
          var matches = [];
          forEach(bindings, function (binding) {
            var dataBinding = angular.element(binding).data("$binding");
            if (dataBinding) {
              forEach(dataBinding, function (bindingName) {
                if (opt_exactMatch) {
                  var matcher = new RegExp(
                    "(^|\\s)" + escapeForRegexp(expression) + "(\\s|\\||$)"
                  );
                  if (matcher.test(bindingName)) {
                    matches.push(binding);
                  }
                } else {
                  if (bindingName.indexOf(expression) !== -1) {
                    matches.push(binding);
                  }
                }
              });
            }
          });
          return matches;
        };
        testability.findModels = function (
          element,
          expression,
          opt_exactMatch
        ) {
          var prefixes = ["ng-", "data-ng-", "ng\\:"];
          for (var p = 0; p < prefixes.length; ++p) {
            var attributeEquals = opt_exactMatch ? "=" : "*=";
            var selector =
              "[" +
              prefixes[p] +
              "model" +
              attributeEquals +
              '"' +
              expression +
              '"]';
            var elements = element.querySelectorAll(selector);
            if (elements.length) {
              return elements;
            }
          }
        };
        testability.getLocation = function () {
          return $location.url();
        };
        testability.setLocation = function (url) {
          if (url !== $location.url()) {
            $location.url(url);
            $rootScope.$digest();
          }
        };
        testability.whenStable = function (callback) {
          $browser.notifyWhenNoOutstandingRequests(callback);
        };
        return testability;
      },
    ];
  }
  function $TimeoutProvider() {
    this.$get = [
      "$rootScope",
      "$browser",
      "$q",
      "$$q",
      "$exceptionHandler",
      function ($rootScope, $browser, $q, $$q, $exceptionHandler) {
        var deferreds = {};
        function timeout(fn, delay, invokeApply) {
          if (!isFunction(fn)) {
            invokeApply = delay;
            delay = fn;
            fn = noop;
          }
          var args = sliceArgs(arguments, 3),
            skipApply = isDefined(invokeApply) && !invokeApply,
            deferred = (skipApply ? $$q : $q).defer(),
            promise = deferred.promise,
            timeoutId;
          timeoutId = $browser.defer(function () {
            try {
              deferred.resolve(fn.apply(null, args));
            } catch (e) {
              deferred.reject(e);
              $exceptionHandler(e);
            } finally {
              delete deferreds[promise.$$timeoutId];
            }
            if (!skipApply) $rootScope.$apply();
          }, delay);
          promise.$$timeoutId = timeoutId;
          deferreds[timeoutId] = deferred;
          return promise;
        }
        timeout.cancel = function (promise) {
          if (promise && promise.$$timeoutId in deferreds) {
            deferreds[promise.$$timeoutId].promise.catch(noop);
            deferreds[promise.$$timeoutId].reject("canceled");
            delete deferreds[promise.$$timeoutId];
            return $browser.defer.cancel(promise.$$timeoutId);
          }
          return false;
        };
        return timeout;
      },
    ];
  }
  var urlParsingNode = window.document.createElement("a");
  var originUrl = urlResolve(window.location.href);
  function urlResolve(url) {
    var href = url;
    if (msie) {
      urlParsingNode.setAttribute("href", href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute("href", href);
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol
        ? urlParsingNode.protocol.replace(/:$/, "")
        : "",
      host: urlParsingNode.host,
      search: urlParsingNode.search
        ? urlParsingNode.search.replace(/^\?/, "")
        : "",
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname:
        urlParsingNode.pathname.charAt(0) === "/"
          ? urlParsingNode.pathname
          : "/" + urlParsingNode.pathname,
    };
  }
  function urlIsSameOrigin(requestUrl) {
    var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
    return (
      parsed.protocol === originUrl.protocol && parsed.host === originUrl.host
    );
  }
  function $WindowProvider() {
    this.$get = valueFn(window);
  }
  function $$CookieReader($document) {
    var rawDocument = $document[0] || {};
    var lastCookies = {};
    var lastCookieString = "";
    function safeGetCookie(rawDocument) {
      try {
        return rawDocument.cookie || "";
      } catch (e) {
        return "";
      }
    }
    function safeDecodeURIComponent(str) {
      try {
        return decodeURIComponent(str);
      } catch (e) {
        return str;
      }
    }
    return function () {
      var cookieArray, cookie, i, index, name;
      var currentCookieString = safeGetCookie(rawDocument);
      if (currentCookieString !== lastCookieString) {
        lastCookieString = currentCookieString;
        cookieArray = lastCookieString.split("; ");
        lastCookies = {};
        for (i = 0; i < cookieArray.length; i++) {
          cookie = cookieArray[i];
          index = cookie.indexOf("=");
          if (index > 0) {
            name = safeDecodeURIComponent(cookie.substring(0, index));
            if (isUndefined(lastCookies[name])) {
              lastCookies[name] = safeDecodeURIComponent(
                cookie.substring(index + 1)
              );
            }
          }
        }
      }
      return lastCookies;
    };
  }
  $$CookieReader.$inject = ["$document"];
  function $$CookieReaderProvider() {
    this.$get = $$CookieReader;
  }
  $FilterProvider.$inject = ["$provide"];
  function $FilterProvider($provide) {
    var suffix = "Filter";
    function register(name, factory) {
      if (isObject(name)) {
        var filters = {};
        forEach(name, function (filter, key) {
          filters[key] = register(key, filter);
        });
        return filters;
      } else {
        return $provide.factory(name + suffix, factory);
      }
    }
    this.register = register;
    this.$get = [
      "$injector",
      function ($injector) {
        return function (name) {
          return $injector.get(name + suffix);
        };
      },
    ];
    register("currency", currencyFilter);
    register("date", dateFilter);
    register("filter", filterFilter);
    register("json", jsonFilter);
    register("limitTo", limitToFilter);
    register("lowercase", lowercaseFilter);
    register("number", numberFilter);
    register("orderBy", orderByFilter);
    register("uppercase", uppercaseFilter);
  }
  function filterFilter() {
    return function (array, expression, comparator, anyPropertyKey) {
      if (!isArrayLike(array)) {
        if (array == null) {
          return array;
        } else {
          throw minErr("filter")(
            "notarray",
            "Expected array but received: {0}",
            array
          );
        }
      }
      anyPropertyKey = anyPropertyKey || "$";
      var expressionType = getTypeForFilter(expression);
      var predicateFn;
      var matchAgainstAnyProp;
      switch (expressionType) {
        case "function":
          predicateFn = expression;
          break;
        case "boolean":
        case "null":
        case "number":
        case "string":
          matchAgainstAnyProp = true;
        case "object":
          predicateFn = createPredicateFn(
            expression,
            comparator,
            anyPropertyKey,
            matchAgainstAnyProp
          );
          break;
        default:
          return array;
      }
      return Array.prototype.filter.call(array, predicateFn);
    };
  }
  function createPredicateFn(
    expression,
    comparator,
    anyPropertyKey,
    matchAgainstAnyProp
  ) {
    var shouldMatchPrimitives =
      isObject(expression) && anyPropertyKey in expression;
    var predicateFn;
    if (comparator === true) {
      comparator = equals;
    } else if (!isFunction(comparator)) {
      comparator = function (actual, expected) {
        if (isUndefined(actual)) {
          return false;
        }
        if (actual === null || expected === null) {
          return actual === expected;
        }
        if (
          isObject(expected) ||
          (isObject(actual) && !hasCustomToString(actual))
        ) {
          return false;
        }
        actual = lowercase("" + actual);
        expected = lowercase("" + expected);
        return actual.indexOf(expected) !== -1;
      };
    }
    predicateFn = function (item) {
      if (shouldMatchPrimitives && !isObject(item)) {
        return deepCompare(
          item,
          expression[anyPropertyKey],
          comparator,
          anyPropertyKey,
          false
        );
      }
      return deepCompare(
        item,
        expression,
        comparator,
        anyPropertyKey,
        matchAgainstAnyProp
      );
    };
    return predicateFn;
  }
  function deepCompare(
    actual,
    expected,
    comparator,
    anyPropertyKey,
    matchAgainstAnyProp,
    dontMatchWholeObject
  ) {
    var actualType = getTypeForFilter(actual);
    var expectedType = getTypeForFilter(expected);
    if (expectedType === "string" && expected.charAt(0) === "!") {
      return !deepCompare(
        actual,
        expected.substring(1),
        comparator,
        anyPropertyKey,
        matchAgainstAnyProp
      );
    } else if (isArray(actual)) {
      return actual.some(function (item) {
        return deepCompare(
          item,
          expected,
          comparator,
          anyPropertyKey,
          matchAgainstAnyProp
        );
      });
    }
    switch (actualType) {
      case "object":
        var key;
        if (matchAgainstAnyProp) {
          for (key in actual) {
            if (
              key.charAt(0) !== "$" &&
              deepCompare(
                actual[key],
                expected,
                comparator,
                anyPropertyKey,
                true
              )
            ) {
              return true;
            }
          }
          return dontMatchWholeObject
            ? false
            : deepCompare(actual, expected, comparator, anyPropertyKey, false);
        } else if (expectedType === "object") {
          for (key in expected) {
            var expectedVal = expected[key];
            if (isFunction(expectedVal) || isUndefined(expectedVal)) {
              continue;
            }
            var matchAnyProperty = key === anyPropertyKey;
            var actualVal = matchAnyProperty ? actual : actual[key];
            if (
              !deepCompare(
                actualVal,
                expectedVal,
                comparator,
                anyPropertyKey,
                matchAnyProperty,
                matchAnyProperty
              )
            ) {
              return false;
            }
          }
          return true;
        } else {
          return comparator(actual, expected);
        }
      case "function":
        return false;
      default:
        return comparator(actual, expected);
    }
  }
  function getTypeForFilter(val) {
    return val === null ? "null" : typeof val;
  }
  var MAX_DIGITS = 22;
  var DECIMAL_SEP = ".";
  var ZERO_CHAR = "0";
  currencyFilter.$inject = ["$locale"];
  function currencyFilter($locale) {
    var formats = $locale.NUMBER_FORMATS;
    return function (amount, currencySymbol, fractionSize) {
      if (isUndefined(currencySymbol)) {
        currencySymbol = formats.CURRENCY_SYM;
      }
      if (isUndefined(fractionSize)) {
        fractionSize = formats.PATTERNS[1].maxFrac;
      }
      return amount == null
        ? amount
        : formatNumber(
            amount,
            formats.PATTERNS[1],
            formats.GROUP_SEP,
            formats.DECIMAL_SEP,
            fractionSize
          ).replace(/\u00A4/g, currencySymbol);
    };
  }
  numberFilter.$inject = ["$locale"];
  function numberFilter($locale) {
    var formats = $locale.NUMBER_FORMATS;
    return function (number, fractionSize) {
      return number == null
        ? number
        : formatNumber(
            number,
            formats.PATTERNS[0],
            formats.GROUP_SEP,
            formats.DECIMAL_SEP,
            fractionSize
          );
    };
  }
  function parse(numStr) {
    var exponent = 0,
      digits,
      numberOfIntegerDigits;
    var i, j, zeros;
    if ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1) {
      numStr = numStr.replace(DECIMAL_SEP, "");
    }
    if ((i = numStr.search(/e/i)) > 0) {
      if (numberOfIntegerDigits < 0) numberOfIntegerDigits = i;
      numberOfIntegerDigits += +numStr.slice(i + 1);
      numStr = numStr.substring(0, i);
    } else if (numberOfIntegerDigits < 0) {
      numberOfIntegerDigits = numStr.length;
    }
    for (i = 0; numStr.charAt(i) === ZERO_CHAR; i++) {}
    if (i === (zeros = numStr.length)) {
      digits = [0];
      numberOfIntegerDigits = 1;
    } else {
      zeros--;
      while (numStr.charAt(zeros) === ZERO_CHAR) zeros--;
      numberOfIntegerDigits -= i;
      digits = [];
      for (j = 0; i <= zeros; i++, j++) {
        digits[j] = +numStr.charAt(i);
      }
    }
    if (numberOfIntegerDigits > MAX_DIGITS) {
      digits = digits.splice(0, MAX_DIGITS - 1);
      exponent = numberOfIntegerDigits - 1;
      numberOfIntegerDigits = 1;
    }
    return { d: digits, e: exponent, i: numberOfIntegerDigits };
  }
  function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {
    var digits = parsedNumber.d;
    var fractionLen = digits.length - parsedNumber.i;
    fractionSize = isUndefined(fractionSize)
      ? Math.min(Math.max(minFrac, fractionLen), maxFrac)
      : +fractionSize;
    var roundAt = fractionSize + parsedNumber.i;
    var digit = digits[roundAt];
    if (roundAt > 0) {
      digits.splice(Math.max(parsedNumber.i, roundAt));
      for (var j = roundAt; j < digits.length; j++) {
        digits[j] = 0;
      }
    } else {
      fractionLen = Math.max(0, fractionLen);
      parsedNumber.i = 1;
      digits.length = Math.max(1, (roundAt = fractionSize + 1));
      digits[0] = 0;
      for (var i = 1; i < roundAt; i++) digits[i] = 0;
    }
    if (digit >= 5) {
      if (roundAt - 1 < 0) {
        for (var k = 0; k > roundAt; k--) {
          digits.unshift(0);
          parsedNumber.i++;
        }
        digits.unshift(1);
        parsedNumber.i++;
      } else {
        digits[roundAt - 1]++;
      }
    }
    for (; fractionLen < Math.max(0, fractionSize); fractionLen++)
      digits.push(0);
    var carry = digits.reduceRight(function (carry, d, i, digits) {
      d = d + carry;
      digits[i] = d % 10;
      return Math.floor(d / 10);
    }, 0);
    if (carry) {
      digits.unshift(carry);
      parsedNumber.i++;
    }
  }
  function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
    if (!(isString(number) || isNumber(number)) || isNaN(number)) return "";
    var isInfinity = !isFinite(number);
    var isZero = false;
    var numStr = Math.abs(number) + "",
      formattedText = "",
      parsedNumber;
    if (isInfinity) {
      formattedText = "";
    } else {
      parsedNumber = parse(numStr);
      roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);
      var digits = parsedNumber.d;
      var integerLen = parsedNumber.i;
      var exponent = parsedNumber.e;
      var decimals = [];
      isZero = digits.reduce(function (isZero, d) {
        return isZero && !d;
      }, true);
      while (integerLen < 0) {
        digits.unshift(0);
        integerLen++;
      }
      if (integerLen > 0) {
        decimals = digits.splice(integerLen, digits.length);
      } else {
        decimals = digits;
        digits = [0];
      }
      var groups = [];
      if (digits.length >= pattern.lgSize) {
        groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(""));
      }
      while (digits.length > pattern.gSize) {
        groups.unshift(digits.splice(-pattern.gSize, digits.length).join(""));
      }
      if (digits.length) {
        groups.unshift(digits.join(""));
      }
      formattedText = groups.join(groupSep);
      if (decimals.length) {
        formattedText += decimalSep + decimals.join("");
      }
      if (exponent) {
        formattedText += "e+" + exponent;
      }
    }
    if (number < 0 && !isZero) {
      return pattern.negPre + formattedText + pattern.negSuf;
    } else {
      return pattern.posPre + formattedText + pattern.posSuf;
    }
  }
  function padNumber(num, digits, trim, negWrap) {
    var neg = "";
    if (num < 0 || (negWrap && num <= 0)) {
      if (negWrap) {
        num = -num + 1;
      } else {
        num = -num;
        neg = "-";
      }
    }
    num = "" + num;
    while (num.length < digits) num = ZERO_CHAR + num;
    if (trim) {
      num = num.substr(num.length - digits);
    }
    return neg + num;
  }
  function dateGetter(name, size, offset, trim, negWrap) {
    offset = offset || 0;
    return function (date) {
      var value = date["get" + name]();
      if (offset > 0 || value > -offset) {
        value += offset;
      }
      if (value === 0 && offset === -12) value = 12;
      return padNumber(value, size, trim, negWrap);
    };
  }
  function dateStrGetter(name, shortForm, standAlone) {
    return function (date, formats) {
      var value = date["get" + name]();
      var propPrefix =
        (standAlone ? "STANDALONE" : "") + (shortForm ? "SHORT" : "");
      var get = uppercase(propPrefix + name);
      return formats[get][value];
    };
  }
  function timeZoneGetter(date, formats, offset) {
    var zone = -1 * offset;
    var paddedZone = zone >= 0 ? "+" : "";
    paddedZone +=
      padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) +
      padNumber(Math.abs(zone % 60), 2);
    return paddedZone;
  }
  function getFirstThursdayOfYear(year) {
    var dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
    return new Date(
      year,
      0,
      (dayOfWeekOnFirst <= 4 ? 5 : 12) - dayOfWeekOnFirst
    );
  }
  function getThursdayThisWeek(datetime) {
    return new Date(
      datetime.getFullYear(),
      datetime.getMonth(),
      datetime.getDate() + (4 - datetime.getDay())
    );
  }
  function weekGetter(size) {
    return function (date) {
      var firstThurs = getFirstThursdayOfYear(date.getFullYear()),
        thisThurs = getThursdayThisWeek(date);
      var diff = +thisThurs - +firstThurs,
        result = 1 + Math.round(diff / 6048e5);
      return padNumber(result, size);
    };
  }
  function ampmGetter(date, formats) {
    return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
  }
  function eraGetter(date, formats) {
    return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
  }
  function longEraGetter(date, formats) {
    return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
  }
  var DATE_FORMATS = {
    yyyy: dateGetter("FullYear", 4, 0, false, true),
    yy: dateGetter("FullYear", 2, 0, true, true),
    y: dateGetter("FullYear", 1, 0, false, true),
    MMMM: dateStrGetter("Month"),
    MMM: dateStrGetter("Month", true),
    MM: dateGetter("Month", 2, 1),
    M: dateGetter("Month", 1, 1),
    LLLL: dateStrGetter("Month", false, true),
    dd: dateGetter("Date", 2),
    d: dateGetter("Date", 1),
    HH: dateGetter("Hours", 2),
    H: dateGetter("Hours", 1),
    hh: dateGetter("Hours", 2, -12),
    h: dateGetter("Hours", 1, -12),
    mm: dateGetter("Minutes", 2),
    m: dateGetter("Minutes", 1),
    ss: dateGetter("Seconds", 2),
    s: dateGetter("Seconds", 1),
    sss: dateGetter("Milliseconds", 3),
    EEEE: dateStrGetter("Day"),
    EEE: dateStrGetter("Day", true),
    a: ampmGetter,
    Z: timeZoneGetter,
    ww: weekGetter(2),
    w: weekGetter(1),
    G: eraGetter,
    GG: eraGetter,
    GGG: eraGetter,
    GGGG: longEraGetter,
  };
  var DATE_FORMATS_SPLIT =
      /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,
    NUMBER_STRING = /^-?\d+$/;
  dateFilter.$inject = ["$locale"];
  function dateFilter($locale) {
    var R_ISO8601_STR =
      /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
    function jsonStringToDate(string) {
      var match;
      if ((match = string.match(R_ISO8601_STR))) {
        var date = new Date(0),
          tzHour = 0,
          tzMin = 0,
          dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
          timeSetter = match[8] ? date.setUTCHours : date.setHours;
        if (match[9]) {
          tzHour = toInt(match[9] + match[10]);
          tzMin = toInt(match[9] + match[11]);
        }
        dateSetter.call(
          date,
          toInt(match[1]),
          toInt(match[2]) - 1,
          toInt(match[3])
        );
        var h = toInt(match[4] || 0) - tzHour;
        var m = toInt(match[5] || 0) - tzMin;
        var s = toInt(match[6] || 0);
        var ms = Math.round(parseFloat("0." + (match[7] || 0)) * 1e3);
        timeSetter.call(date, h, m, s, ms);
        return date;
      }
      return string;
    }
    return function (date, format, timezone) {
      var text = "",
        parts = [],
        fn,
        match;
      format = format || "mediumDate";
      format = $locale.DATETIME_FORMATS[format] || format;
      if (isString(date)) {
        date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
      }
      if (isNumber(date)) {
        date = new Date(date);
      }
      if (!isDate(date) || !isFinite(date.getTime())) {
        return date;
      }
      while (format) {
        match = DATE_FORMATS_SPLIT.exec(format);
        if (match) {
          parts = concat(parts, match, 1);
          format = parts.pop();
        } else {
          parts.push(format);
          format = null;
        }
      }
      var dateTimezoneOffset = date.getTimezoneOffset();
      if (timezone) {
        dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
        date = convertTimezoneToLocal(date, timezone, true);
      }
      forEach(parts, function (value) {
        fn = DATE_FORMATS[value];
        text += fn
          ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset)
          : value === "''"
          ? "'"
          : value.replace(/(^'|'$)/g, "").replace(/''/g, "'");
      });
      return text;
    };
  }
  function jsonFilter() {
    return function (object, spacing) {
      if (isUndefined(spacing)) {
        spacing = 2;
      }
      return toJson(object, spacing);
    };
  }
  var lowercaseFilter = valueFn(lowercase);
  var uppercaseFilter = valueFn(uppercase);
  function limitToFilter() {
    return function (input, limit, begin) {
      if (Math.abs(Number(limit)) === Infinity) {
        limit = Number(limit);
      } else {
        limit = toInt(limit);
      }
      if (isNumberNaN(limit)) return input;
      if (isNumber(input)) input = input.toString();
      if (!isArrayLike(input)) return input;
      begin = !begin || isNaN(begin) ? 0 : toInt(begin);
      begin = begin < 0 ? Math.max(0, input.length + begin) : begin;
      if (limit >= 0) {
        return sliceFn(input, begin, begin + limit);
      } else {
        if (begin === 0) {
          return sliceFn(input, limit, input.length);
        } else {
          return sliceFn(input, Math.max(0, begin + limit), begin);
        }
      }
    };
  }
  function sliceFn(input, begin, end) {
    if (isString(input)) return input.slice(begin, end);
    return slice.call(input, begin, end);
  }
  orderByFilter.$inject = ["$parse"];
  function orderByFilter($parse) {
    return function (array, sortPredicate, reverseOrder, compareFn) {
      if (array == null) return array;
      if (!isArrayLike(array)) {
        throw minErr("orderBy")(
          "notarray",
          "Expected array but received: {0}",
          array
        );
      }
      if (!isArray(sortPredicate)) {
        sortPredicate = [sortPredicate];
      }
      if (sortPredicate.length === 0) {
        sortPredicate = ["+"];
      }
      var predicates = processPredicates(sortPredicate);
      var descending = reverseOrder ? -1 : 1;
      var compare = isFunction(compareFn) ? compareFn : defaultCompare;
      var compareValues = Array.prototype.map.call(array, getComparisonObject);
      compareValues.sort(doComparison);
      array = compareValues.map(function (item) {
        return item.value;
      });
      return array;
      function getComparisonObject(value, index) {
        return {
          value: value,
          tieBreaker: { value: index, type: "number", index: index },
          predicateValues: predicates.map(function (predicate) {
            return getPredicateValue(predicate.get(value), index);
          }),
        };
      }
      function doComparison(v1, v2) {
        for (var i = 0, ii = predicates.length; i < ii; i++) {
          var result = compare(v1.predicateValues[i], v2.predicateValues[i]);
          if (result) {
            return result * predicates[i].descending * descending;
          }
        }
        return compare(v1.tieBreaker, v2.tieBreaker) * descending;
      }
    };
    function processPredicates(sortPredicates) {
      return sortPredicates.map(function (predicate) {
        var descending = 1,
          get = identity;
        if (isFunction(predicate)) {
          get = predicate;
        } else if (isString(predicate)) {
          if (predicate.charAt(0) === "+" || predicate.charAt(0) === "-") {
            descending = predicate.charAt(0) === "-" ? -1 : 1;
            predicate = predicate.substring(1);
          }
          if (predicate !== "") {
            get = $parse(predicate);
            if (get.constant) {
              var key = get();
              get = function (value) {
                return value[key];
              };
            }
          }
        }
        return { get: get, descending: descending };
      });
    }
    function isPrimitive(value) {
      switch (typeof value) {
        case "number":
        case "boolean":
        case "string":
          return true;
        default:
          return false;
      }
    }
    function objectValue(value) {
      if (isFunction(value.valueOf)) {
        value = value.valueOf();
        if (isPrimitive(value)) return value;
      }
      if (hasCustomToString(value)) {
        value = value.toString();
        if (isPrimitive(value)) return value;
      }
      return value;
    }
    function getPredicateValue(value, index) {
      var type = typeof value;
      if (value === null) {
        type = "string";
        value = "null";
      } else if (type === "object") {
        value = objectValue(value);
      }
      return { value: value, type: type, index: index };
    }
    function defaultCompare(v1, v2) {
      var result = 0;
      var type1 = v1.type;
      var type2 = v2.type;
      if (type1 === type2) {
        var value1 = v1.value;
        var value2 = v2.value;
        if (type1 === "string") {
          value1 = value1.toLowerCase();
          value2 = value2.toLowerCase();
        } else if (type1 === "object") {
          if (isObject(value1)) value1 = v1.index;
          if (isObject(value2)) value2 = v2.index;
        }
        if (value1 !== value2) {
          result = value1 < value2 ? -1 : 1;
        }
      } else {
        result = type1 < type2 ? -1 : 1;
      }
      return result;
    }
  }
  function ngDirective(directive) {
    if (isFunction(directive)) {
      directive = { link: directive };
    }
    directive.restrict = directive.restrict || "AC";
    return valueFn(directive);
  }
  var htmlAnchorDirective = valueFn({
    restrict: "E",
    compile: function (element, attr) {
      if (!attr.href && !attr.xlinkHref) {
        return function (scope, element) {
          if (element[0].nodeName.toLowerCase() !== "a") return;
          var href =
            toString.call(element.prop("href")) === "[object SVGAnimatedString]"
              ? "xlink:href"
              : "href";
          element.on("click", function (event) {
            if (!element.attr(href)) {
              event.preventDefault();
            }
          });
        };
      }
    },
  });
  var ngAttributeAliasDirectives = {};
  forEach(BOOLEAN_ATTR, function (propName, attrName) {
    if (propName === "multiple") return;
    function defaultLinkFn(scope, element, attr) {
      scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
        attr.$set(attrName, !!value);
      });
    }
    var normalized = directiveNormalize("ng-" + attrName);
    var linkFn = defaultLinkFn;
    if (propName === "checked") {
      linkFn = function (scope, element, attr) {
        if (attr.ngModel !== attr[normalized]) {
          defaultLinkFn(scope, element, attr);
        }
      };
    }
    ngAttributeAliasDirectives[normalized] = function () {
      return { restrict: "A", priority: 100, link: linkFn };
    };
  });
  forEach(ALIASED_ATTR, function (htmlAttr, ngAttr) {
    ngAttributeAliasDirectives[ngAttr] = function () {
      return {
        priority: 100,
        link: function (scope, element, attr) {
          if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) === "/") {
            var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
            if (match) {
              attr.$set("ngPattern", new RegExp(match[1], match[2]));
              return;
            }
          }
          scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
            attr.$set(ngAttr, value);
          });
        },
      };
    };
  });
  forEach(["src", "srcset", "href"], function (attrName) {
    var normalized = directiveNormalize("ng-" + attrName);
    ngAttributeAliasDirectives[normalized] = function () {
      return {
        priority: 99,
        link: function (scope, element, attr) {
          var propName = attrName,
            name = attrName;
          if (
            attrName === "href" &&
            toString.call(element.prop("href")) === "[object SVGAnimatedString]"
          ) {
            name = "xlinkHref";
            attr.$attr[name] = "xlink:href";
            propName = null;
          }
          attr.$observe(normalized, function (value) {
            if (!value) {
              if (attrName === "href") {
                attr.$set(name, null);
              }
              return;
            }
            attr.$set(name, value);
            if (msie && propName) element.prop(propName, attr[name]);
          });
        },
      };
    };
  });
  var nullFormCtrl = {
      $addControl: noop,
      $$renameControl: nullFormRenameControl,
      $removeControl: noop,
      $setValidity: noop,
      $setDirty: noop,
      $setPristine: noop,
      $setSubmitted: noop,
    },
    PENDING_CLASS = "ng-pending",
    SUBMITTED_CLASS = "ng-submitted";
  function nullFormRenameControl(control, name) {
    control.$name = name;
  }
  FormController.$inject = [
    "$element",
    "$attrs",
    "$scope",
    "$animate",
    "$interpolate",
  ];
  function FormController($element, $attrs, $scope, $animate, $interpolate) {
    this.$$controls = [];
    this.$error = {};
    this.$$success = {};
    this.$pending = undefined;
    this.$name = $interpolate($attrs.name || $attrs.ngForm || "")($scope);
    this.$dirty = false;
    this.$pristine = true;
    this.$valid = true;
    this.$invalid = false;
    this.$submitted = false;
    this.$$parentForm = nullFormCtrl;
    this.$$element = $element;
    this.$$animate = $animate;
    setupValidity(this);
  }
  FormController.prototype = {
    $rollbackViewValue: function () {
      forEach(this.$$controls, function (control) {
        control.$rollbackViewValue();
      });
    },
    $commitViewValue: function () {
      forEach(this.$$controls, function (control) {
        control.$commitViewValue();
      });
    },
    $addControl: function (control) {
      assertNotHasOwnProperty(control.$name, "input");
      this.$$controls.push(control);
      if (control.$name) {
        this[control.$name] = control;
      }
      control.$$parentForm = this;
    },
    $$renameControl: function (control, newName) {
      var oldName = control.$name;
      if (this[oldName] === control) {
        delete this[oldName];
      }
      this[newName] = control;
      control.$name = newName;
    },
    $removeControl: function (control) {
      if (control.$name && this[control.$name] === control) {
        delete this[control.$name];
      }
      forEach(
        this.$pending,
        function (value, name) {
          this.$setValidity(name, null, control);
        },
        this
      );
      forEach(
        this.$error,
        function (value, name) {
          this.$setValidity(name, null, control);
        },
        this
      );
      forEach(
        this.$$success,
        function (value, name) {
          this.$setValidity(name, null, control);
        },
        this
      );
      arrayRemove(this.$$controls, control);
      control.$$parentForm = nullFormCtrl;
    },
    $setDirty: function () {
      this.$$animate.removeClass(this.$$element, PRISTINE_CLASS);
      this.$$animate.addClass(this.$$element, DIRTY_CLASS);
      this.$dirty = true;
      this.$pristine = false;
      this.$$parentForm.$setDirty();
    },
    $setPristine: function () {
      this.$$animate.setClass(
        this.$$element,
        PRISTINE_CLASS,
        DIRTY_CLASS + " " + SUBMITTED_CLASS
      );
      this.$dirty = false;
      this.$pristine = true;
      this.$submitted = false;
      forEach(this.$$controls, function (control) {
        control.$setPristine();
      });
    },
    $setUntouched: function () {
      forEach(this.$$controls, function (control) {
        control.$setUntouched();
      });
    },
    $setSubmitted: function () {
      this.$$animate.addClass(this.$$element, SUBMITTED_CLASS);
      this.$submitted = true;
      this.$$parentForm.$setSubmitted();
    },
  };
  addSetValidityMethod({
    clazz: FormController,
    set: function (object, property, controller) {
      var list = object[property];
      if (!list) {
        object[property] = [controller];
      } else {
        var index = list.indexOf(controller);
        if (index === -1) {
          list.push(controller);
        }
      }
    },
    unset: function (object, property, controller) {
      var list = object[property];
      if (!list) {
        return;
      }
      arrayRemove(list, controller);
      if (list.length === 0) {
        delete object[property];
      }
    },
  });
  var formDirectiveFactory = function (isNgForm) {
    return [
      "$timeout",
      "$parse",
      function ($timeout, $parse) {
        var formDirective = {
          name: "form",
          restrict: isNgForm ? "EAC" : "E",
          require: ["form", "^^?form"],
          controller: FormController,
          compile: function ngFormCompile(formElement, attr) {
            formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
            var nameAttr = attr.name
              ? "name"
              : isNgForm && attr.ngForm
              ? "ngForm"
              : false;
            return {
              pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
                var controller = ctrls[0];
                if (!("action" in attr)) {
                  var handleFormSubmission = function (event) {
                    scope.$apply(function () {
                      controller.$commitViewValue();
                      controller.$setSubmitted();
                    });
                    event.preventDefault();
                  };
                  formElement[0].addEventListener(
                    "submit",
                    handleFormSubmission
                  );
                  formElement.on("$destroy", function () {
                    $timeout(
                      function () {
                        formElement[0].removeEventListener(
                          "submit",
                          handleFormSubmission
                        );
                      },
                      0,
                      false
                    );
                  });
                }
                var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                parentFormCtrl.$addControl(controller);
                var setter = nameAttr ? getSetter(controller.$name) : noop;
                if (nameAttr) {
                  setter(scope, controller);
                  attr.$observe(nameAttr, function (newValue) {
                    if (controller.$name === newValue) return;
                    setter(scope, undefined);
                    controller.$$parentForm.$$renameControl(
                      controller,
                      newValue
                    );
                    setter = getSetter(controller.$name);
                    setter(scope, controller);
                  });
                }
                formElement.on("$destroy", function () {
                  controller.$$parentForm.$removeControl(controller);
                  setter(scope, undefined);
                  extend(controller, nullFormCtrl);
                });
              },
            };
          },
        };
        return formDirective;
        function getSetter(expression) {
          if (expression === "") {
            return $parse('this[""]').assign;
          }
          return $parse(expression).assign || noop;
        }
      },
    ];
  };
  var formDirective = formDirectiveFactory();
  var ngFormDirective = formDirectiveFactory(true);
  function setupValidity(instance) {
    instance.$$classCache = {};
    instance.$$classCache[INVALID_CLASS] = !(instance.$$classCache[
      VALID_CLASS
    ] = instance.$$element.hasClass(VALID_CLASS));
  }
  function addSetValidityMethod(context) {
    var clazz = context.clazz,
      set = context.set,
      unset = context.unset;
    clazz.prototype.$setValidity = function (
      validationErrorKey,
      state,
      controller
    ) {
      if (isUndefined(state)) {
        createAndSet(this, "$pending", validationErrorKey, controller);
      } else {
        unsetAndCleanup(this, "$pending", validationErrorKey, controller);
      }
      if (!isBoolean(state)) {
        unset(this.$error, validationErrorKey, controller);
        unset(this.$$success, validationErrorKey, controller);
      } else {
        if (state) {
          unset(this.$error, validationErrorKey, controller);
          set(this.$$success, validationErrorKey, controller);
        } else {
          set(this.$error, validationErrorKey, controller);
          unset(this.$$success, validationErrorKey, controller);
        }
      }
      if (this.$pending) {
        cachedToggleClass(this, PENDING_CLASS, true);
        this.$valid = this.$invalid = undefined;
        toggleValidationCss(this, "", null);
      } else {
        cachedToggleClass(this, PENDING_CLASS, false);
        this.$valid = isObjectEmpty(this.$error);
        this.$invalid = !this.$valid;
        toggleValidationCss(this, "", this.$valid);
      }
      var combinedState;
      if (this.$pending && this.$pending[validationErrorKey]) {
        combinedState = undefined;
      } else if (this.$error[validationErrorKey]) {
        combinedState = false;
      } else if (this.$$success[validationErrorKey]) {
        combinedState = true;
      } else {
        combinedState = null;
      }
      toggleValidationCss(this, validationErrorKey, combinedState);
      this.$$parentForm.$setValidity(validationErrorKey, combinedState, this);
    };
    function createAndSet(ctrl, name, value, controller) {
      if (!ctrl[name]) {
        ctrl[name] = {};
      }
      set(ctrl[name], value, controller);
    }
    function unsetAndCleanup(ctrl, name, value, controller) {
      if (ctrl[name]) {
        unset(ctrl[name], value, controller);
      }
      if (isObjectEmpty(ctrl[name])) {
        ctrl[name] = undefined;
      }
    }
    function cachedToggleClass(ctrl, className, switchValue) {
      if (switchValue && !ctrl.$$classCache[className]) {
        ctrl.$$animate.addClass(ctrl.$$element, className);
        ctrl.$$classCache[className] = true;
      } else if (!switchValue && ctrl.$$classCache[className]) {
        ctrl.$$animate.removeClass(ctrl.$$element, className);
        ctrl.$$classCache[className] = false;
      }
    }
    function toggleValidationCss(ctrl, validationErrorKey, isValid) {
      validationErrorKey = validationErrorKey
        ? "-" + snake_case(validationErrorKey, "-")
        : "";
      cachedToggleClass(
        ctrl,
        VALID_CLASS + validationErrorKey,
        isValid === true
      );
      cachedToggleClass(
        ctrl,
        INVALID_CLASS + validationErrorKey,
        isValid === false
      );
    }
  }
  function isObjectEmpty(obj) {
    if (obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          return false;
        }
      }
    }
    return true;
  }
  var ISO_DATE_REGEXP =
    /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/;
  var URL_REGEXP =
    /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:\/?#]+|\[[a-f\d:]+])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i;
  var EMAIL_REGEXP =
    /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;
  var NUMBER_REGEXP = /^\s*(-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
  var DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/;
  var DATETIMELOCAL_REGEXP =
    /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
  var WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/;
  var MONTH_REGEXP = /^(\d{4,})-(\d\d)$/;
  var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
  var PARTIAL_VALIDATION_EVENTS = "keydown wheel mousedown";
  var PARTIAL_VALIDATION_TYPES = createMap();
  forEach("date,datetime-local,month,time,week".split(","), function (type) {
    PARTIAL_VALIDATION_TYPES[type] = true;
  });
  var inputType = {
    text: textInputType,
    date: createDateInputType(
      "date",
      DATE_REGEXP,
      createDateParser(DATE_REGEXP, ["yyyy", "MM", "dd"]),
      "yyyy-MM-dd"
    ),
    "datetime-local": createDateInputType(
      "datetimelocal",
      DATETIMELOCAL_REGEXP,
      createDateParser(DATETIMELOCAL_REGEXP, [
        "yyyy",
        "MM",
        "dd",
        "HH",
        "mm",
        "ss",
        "sss",
      ]),
      "yyyy-MM-ddTHH:mm:ss.sss"
    ),
    time: createDateInputType(
      "time",
      TIME_REGEXP,
      createDateParser(TIME_REGEXP, ["HH", "mm", "ss", "sss"]),
      "HH:mm:ss.sss"
    ),
    week: createDateInputType("week", WEEK_REGEXP, weekParser, "yyyy-Www"),
    month: createDateInputType(
      "month",
      MONTH_REGEXP,
      createDateParser(MONTH_REGEXP, ["yyyy", "MM"]),
      "yyyy-MM"
    ),
    number: numberInputType,
    url: urlInputType,
    email: emailInputType,
    radio: radioInputType,
    range: rangeInputType,
    checkbox: checkboxInputType,
    hidden: noop,
    button: noop,
    submit: noop,
    reset: noop,
    file: noop,
  };
  function stringBasedInputType(ctrl) {
    ctrl.$formatters.push(function (value) {
      return ctrl.$isEmpty(value) ? value : value.toString();
    });
  }
  function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
    stringBasedInputType(ctrl);
  }
  function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    var type = lowercase(element[0].type);
    if (!$sniffer.android) {
      var composing = false;
      element.on("compositionstart", function () {
        composing = true;
      });
      element.on("compositionend", function () {
        composing = false;
        listener();
      });
    }
    var timeout;
    var listener = function (ev) {
      if (timeout) {
        $browser.defer.cancel(timeout);
        timeout = null;
      }
      if (composing) return;
      var value = element.val(),
        event = ev && ev.type;
      if (type !== "password" && (!attr.ngTrim || attr.ngTrim !== "false")) {
        value = trim(value);
      }
      if (
        ctrl.$viewValue !== value ||
        (value === "" && ctrl.$$hasNativeValidators)
      ) {
        ctrl.$setViewValue(value, event);
      }
    };
    if ($sniffer.hasEvent("input")) {
      element.on("input", listener);
    } else {
      var deferListener = function (ev, input, origValue) {
        if (!timeout) {
          timeout = $browser.defer(function () {
            timeout = null;
            if (!input || input.value !== origValue) {
              listener(ev);
            }
          });
        }
      };
      element.on("keydown", function (event) {
        var key = event.keyCode;
        if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40))
          return;
        deferListener(event, this, this.value);
      });
      if ($sniffer.hasEvent("paste")) {
        element.on("paste cut", deferListener);
      }
    }
    element.on("change", listener);
    if (
      PARTIAL_VALIDATION_TYPES[type] &&
      ctrl.$$hasNativeValidators &&
      type === attr.type
    ) {
      element.on(PARTIAL_VALIDATION_EVENTS, function (ev) {
        if (!timeout) {
          var validity = this[VALIDITY_STATE_PROPERTY];
          var origBadInput = validity.badInput;
          var origTypeMismatch = validity.typeMismatch;
          timeout = $browser.defer(function () {
            timeout = null;
            if (
              validity.badInput !== origBadInput ||
              validity.typeMismatch !== origTypeMismatch
            ) {
              listener(ev);
            }
          });
        }
      });
    }
    ctrl.$render = function () {
      var value = ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue;
      if (element.val() !== value) {
        element.val(value);
      }
    };
  }
  function weekParser(isoWeek, existingDate) {
    if (isDate(isoWeek)) {
      return isoWeek;
    }
    if (isString(isoWeek)) {
      WEEK_REGEXP.lastIndex = 0;
      var parts = WEEK_REGEXP.exec(isoWeek);
      if (parts) {
        var year = +parts[1],
          week = +parts[2],
          hours = 0,
          minutes = 0,
          seconds = 0,
          milliseconds = 0,
          firstThurs = getFirstThursdayOfYear(year),
          addDays = (week - 1) * 7;
        if (existingDate) {
          hours = existingDate.getHours();
          minutes = existingDate.getMinutes();
          seconds = existingDate.getSeconds();
          milliseconds = existingDate.getMilliseconds();
        }
        return new Date(
          year,
          0,
          firstThurs.getDate() + addDays,
          hours,
          minutes,
          seconds,
          milliseconds
        );
      }
    }
    return NaN;
  }
  function createDateParser(regexp, mapping) {
    return function (iso, date) {
      var parts, map;
      if (isDate(iso)) {
        return iso;
      }
      if (isString(iso)) {
        if (iso.charAt(0) === '"' && iso.charAt(iso.length - 1) === '"') {
          iso = iso.substring(1, iso.length - 1);
        }
        if (ISO_DATE_REGEXP.test(iso)) {
          return new Date(iso);
        }
        regexp.lastIndex = 0;
        parts = regexp.exec(iso);
        if (parts) {
          parts.shift();
          if (date) {
            map = {
              yyyy: date.getFullYear(),
              MM: date.getMonth() + 1,
              dd: date.getDate(),
              HH: date.getHours(),
              mm: date.getMinutes(),
              ss: date.getSeconds(),
              sss: date.getMilliseconds() / 1e3,
            };
          } else {
            map = { yyyy: 1970, MM: 1, dd: 1, HH: 0, mm: 0, ss: 0, sss: 0 };
          }
          forEach(parts, function (part, index) {
            if (index < mapping.length) {
              map[mapping[index]] = +part;
            }
          });
          return new Date(
            map.yyyy,
            map.MM - 1,
            map.dd,
            map.HH,
            map.mm,
            map.ss || 0,
            map.sss * 1e3 || 0
          );
        }
      }
      return NaN;
    };
  }
  function createDateInputType(type, regexp, parseDate, format) {
    return function dynamicDateInputType(
      scope,
      element,
      attr,
      ctrl,
      $sniffer,
      $browser,
      $filter
    ) {
      badInputChecker(scope, element, attr, ctrl);
      baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
      var timezone = ctrl && ctrl.$options.getOption("timezone");
      var previousDate;
      ctrl.$$parserName = type;
      ctrl.$parsers.push(function (value) {
        if (ctrl.$isEmpty(value)) return null;
        if (regexp.test(value)) {
          var parsedDate = parseDate(value, previousDate);
          if (timezone) {
            parsedDate = convertTimezoneToLocal(parsedDate, timezone);
          }
          return parsedDate;
        }
        return undefined;
      });
      ctrl.$formatters.push(function (value) {
        if (value && !isDate(value)) {
          throw ngModelMinErr("datefmt", "Expected `{0}` to be a date", value);
        }
        if (isValidDate(value)) {
          previousDate = value;
          if (previousDate && timezone) {
            previousDate = convertTimezoneToLocal(previousDate, timezone, true);
          }
          return $filter("date")(value, format, timezone);
        } else {
          previousDate = null;
          return "";
        }
      });
      if (isDefined(attr.min) || attr.ngMin) {
        var minVal;
        ctrl.$validators.min = function (value) {
          return (
            !isValidDate(value) ||
            isUndefined(minVal) ||
            parseDate(value) >= minVal
          );
        };
        attr.$observe("min", function (val) {
          minVal = parseObservedDateValue(val);
          ctrl.$validate();
        });
      }
      if (isDefined(attr.max) || attr.ngMax) {
        var maxVal;
        ctrl.$validators.max = function (value) {
          return (
            !isValidDate(value) ||
            isUndefined(maxVal) ||
            parseDate(value) <= maxVal
          );
        };
        attr.$observe("max", function (val) {
          maxVal = parseObservedDateValue(val);
          ctrl.$validate();
        });
      }
      function isValidDate(value) {
        return value && !(value.getTime && value.getTime() !== value.getTime());
      }
      function parseObservedDateValue(val) {
        return isDefined(val) && !isDate(val)
          ? parseDate(val) || undefined
          : val;
      }
    };
  }
  function badInputChecker(scope, element, attr, ctrl) {
    var node = element[0];
    var nativeValidation = (ctrl.$$hasNativeValidators = isObject(
      node.validity
    ));
    if (nativeValidation) {
      ctrl.$parsers.push(function (value) {
        var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
        return validity.badInput || validity.typeMismatch ? undefined : value;
      });
    }
  }
  function numberFormatterParser(ctrl) {
    ctrl.$$parserName = "number";
    ctrl.$parsers.push(function (value) {
      if (ctrl.$isEmpty(value)) return null;
      if (NUMBER_REGEXP.test(value)) return parseFloat(value);
      return undefined;
    });
    ctrl.$formatters.push(function (value) {
      if (!ctrl.$isEmpty(value)) {
        if (!isNumber(value)) {
          throw ngModelMinErr("numfmt", "Expected `{0}` to be a number", value);
        }
        value = value.toString();
      }
      return value;
    });
  }
  function parseNumberAttrVal(val) {
    if (isDefined(val) && !isNumber(val)) {
      val = parseFloat(val);
    }
    return !isNumberNaN(val) ? val : undefined;
  }
  function isNumberInteger(num) {
    return (num | 0) === num;
  }
  function countDecimals(num) {
    var numString = num.toString();
    var decimalSymbolIndex = numString.indexOf(".");
    if (decimalSymbolIndex === -1) {
      if (-1 < num && num < 1) {
        var match = /e-(\d+)$/.exec(numString);
        if (match) {
          return Number(match[1]);
        }
      }
      return 0;
    }
    return numString.length - decimalSymbolIndex - 1;
  }
  function isValidForStep(viewValue, stepBase, step) {
    var value = Number(viewValue);
    if (
      !isNumberInteger(value) ||
      !isNumberInteger(stepBase) ||
      !isNumberInteger(step)
    ) {
      var decimalCount = Math.max(
        countDecimals(value),
        countDecimals(stepBase),
        countDecimals(step)
      );
      var multiplier = Math.pow(10, decimalCount);
      value = value * multiplier;
      stepBase = stepBase * multiplier;
      step = step * multiplier;
    }
    return (value - stepBase) % step === 0;
  }
  function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    badInputChecker(scope, element, attr, ctrl);
    numberFormatterParser(ctrl);
    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
    var minVal;
    var maxVal;
    if (isDefined(attr.min) || attr.ngMin) {
      ctrl.$validators.min = function (value) {
        return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
      };
      attr.$observe("min", function (val) {
        minVal = parseNumberAttrVal(val);
        ctrl.$validate();
      });
    }
    if (isDefined(attr.max) || attr.ngMax) {
      ctrl.$validators.max = function (value) {
        return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
      };
      attr.$observe("max", function (val) {
        maxVal = parseNumberAttrVal(val);
        ctrl.$validate();
      });
    }
    if (isDefined(attr.step) || attr.ngStep) {
      var stepVal;
      ctrl.$validators.step = function (modelValue, viewValue) {
        return (
          ctrl.$isEmpty(viewValue) ||
          isUndefined(stepVal) ||
          isValidForStep(viewValue, minVal || 0, stepVal)
        );
      };
      attr.$observe("step", function (val) {
        stepVal = parseNumberAttrVal(val);
        ctrl.$validate();
      });
    }
  }
  function rangeInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    badInputChecker(scope, element, attr, ctrl);
    numberFormatterParser(ctrl);
    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
    var supportsRange =
        ctrl.$$hasNativeValidators && element[0].type === "range",
      minVal = supportsRange ? 0 : undefined,
      maxVal = supportsRange ? 100 : undefined,
      stepVal = supportsRange ? 1 : undefined,
      validity = element[0].validity,
      hasMinAttr = isDefined(attr.min),
      hasMaxAttr = isDefined(attr.max),
      hasStepAttr = isDefined(attr.step);
    var originalRender = ctrl.$render;
    ctrl.$render =
      supportsRange &&
      isDefined(validity.rangeUnderflow) &&
      isDefined(validity.rangeOverflow)
        ? function rangeRender() {
            originalRender();
            ctrl.$setViewValue(element.val());
          }
        : originalRender;
    if (hasMinAttr) {
      ctrl.$validators.min = supportsRange
        ? function noopMinValidator() {
            return true;
          }
        : function minValidator(modelValue, viewValue) {
            return (
              ctrl.$isEmpty(viewValue) ||
              isUndefined(minVal) ||
              viewValue >= minVal
            );
          };
      setInitialValueAndObserver("min", minChange);
    }
    if (hasMaxAttr) {
      ctrl.$validators.max = supportsRange
        ? function noopMaxValidator() {
            return true;
          }
        : function maxValidator(modelValue, viewValue) {
            return (
              ctrl.$isEmpty(viewValue) ||
              isUndefined(maxVal) ||
              viewValue <= maxVal
            );
          };
      setInitialValueAndObserver("max", maxChange);
    }
    if (hasStepAttr) {
      ctrl.$validators.step = supportsRange
        ? function nativeStepValidator() {
            return !validity.stepMismatch;
          }
        : function stepValidator(modelValue, viewValue) {
            return (
              ctrl.$isEmpty(viewValue) ||
              isUndefined(stepVal) ||
              isValidForStep(viewValue, minVal || 0, stepVal)
            );
          };
      setInitialValueAndObserver("step", stepChange);
    }
    function setInitialValueAndObserver(htmlAttrName, changeFn) {
      element.attr(htmlAttrName, attr[htmlAttrName]);
      attr.$observe(htmlAttrName, changeFn);
    }
    function minChange(val) {
      minVal = parseNumberAttrVal(val);
      if (isNumberNaN(ctrl.$modelValue)) {
        return;
      }
      if (supportsRange) {
        var elVal = element.val();
        if (minVal > elVal) {
          elVal = minVal;
          element.val(elVal);
        }
        ctrl.$setViewValue(elVal);
      } else {
        ctrl.$validate();
      }
    }
    function maxChange(val) {
      maxVal = parseNumberAttrVal(val);
      if (isNumberNaN(ctrl.$modelValue)) {
        return;
      }
      if (supportsRange) {
        var elVal = element.val();
        if (maxVal < elVal) {
          element.val(maxVal);
          elVal = maxVal < minVal ? minVal : maxVal;
        }
        ctrl.$setViewValue(elVal);
      } else {
        ctrl.$validate();
      }
    }
    function stepChange(val) {
      stepVal = parseNumberAttrVal(val);
      if (isNumberNaN(ctrl.$modelValue)) {
        return;
      }
      if (supportsRange && ctrl.$viewValue !== element.val()) {
        ctrl.$setViewValue(element.val());
      } else {
        ctrl.$validate();
      }
    }
  }
  function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
    stringBasedInputType(ctrl);
    ctrl.$$parserName = "url";
    ctrl.$validators.url = function (modelValue, viewValue) {
      var value = modelValue || viewValue;
      return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
    };
  }
  function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
    stringBasedInputType(ctrl);
    ctrl.$$parserName = "email";
    ctrl.$validators.email = function (modelValue, viewValue) {
      var value = modelValue || viewValue;
      return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
    };
  }
  function radioInputType(scope, element, attr, ctrl) {
    var doTrim = !attr.ngTrim || trim(attr.ngTrim) !== "false";
    if (isUndefined(attr.name)) {
      element.attr("name", nextUid());
    }
    var listener = function (ev) {
      var value;
      if (element[0].checked) {
        value = attr.value;
        if (doTrim) {
          value = trim(value);
        }
        ctrl.$setViewValue(value, ev && ev.type);
      }
    };
    element.on("click", listener);
    ctrl.$render = function () {
      var value = attr.value;
      if (doTrim) {
        value = trim(value);
      }
      element[0].checked = value === ctrl.$viewValue;
    };
    attr.$observe("value", ctrl.$render);
  }
  function parseConstantExpr($parse, context, name, expression, fallback) {
    var parseFn;
    if (isDefined(expression)) {
      parseFn = $parse(expression);
      if (!parseFn.constant) {
        throw ngModelMinErr(
          "constexpr",
          "Expected constant expression for `{0}`, but saw " + "`{1}`.",
          name,
          expression
        );
      }
      return parseFn(context);
    }
    return fallback;
  }
  function checkboxInputType(
    scope,
    element,
    attr,
    ctrl,
    $sniffer,
    $browser,
    $filter,
    $parse
  ) {
    var trueValue = parseConstantExpr(
      $parse,
      scope,
      "ngTrueValue",
      attr.ngTrueValue,
      true
    );
    var falseValue = parseConstantExpr(
      $parse,
      scope,
      "ngFalseValue",
      attr.ngFalseValue,
      false
    );
    var listener = function (ev) {
      ctrl.$setViewValue(element[0].checked, ev && ev.type);
    };
    element.on("click", listener);
    ctrl.$render = function () {
      element[0].checked = ctrl.$viewValue;
    };
    ctrl.$isEmpty = function (value) {
      return value === false;
    };
    ctrl.$formatters.push(function (value) {
      return equals(value, trueValue);
    });
    ctrl.$parsers.push(function (value) {
      return value ? trueValue : falseValue;
    });
  }
  var inputDirective = [
    "$browser",
    "$sniffer",
    "$filter",
    "$parse",
    function ($browser, $sniffer, $filter, $parse) {
      return {
        restrict: "E",
        require: ["?ngModel"],
        link: {
          pre: function (scope, element, attr, ctrls) {
            if (ctrls[0]) {
              (inputType[lowercase(attr.type)] || inputType.text)(
                scope,
                element,
                attr,
                ctrls[0],
                $sniffer,
                $browser,
                $filter,
                $parse
              );
            }
          },
        },
      };
    },
  ];
  var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
  var ngValueDirective = function () {
    function updateElementValue(element, attr, value) {
      element.prop("value", value);
      attr.$set("value", value);
    }
    return {
      restrict: "A",
      priority: 100,
      compile: function (tpl, tplAttr) {
        if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
          return function ngValueConstantLink(scope, elm, attr) {
            var value = scope.$eval(attr.ngValue);
            updateElementValue(elm, attr, value);
          };
        } else {
          return function ngValueLink(scope, elm, attr) {
            scope.$watch(attr.ngValue, function valueWatchAction(value) {
              updateElementValue(elm, attr, value);
            });
          };
        }
      },
    };
  };
  var ngBindDirective = [
    "$compile",
    function ($compile) {
      return {
        restrict: "AC",
        compile: function ngBindCompile(templateElement) {
          $compile.$$addBindingClass(templateElement);
          return function ngBindLink(scope, element, attr) {
            $compile.$$addBindingInfo(element, attr.ngBind);
            element = element[0];
            scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
              element.textContent = stringify(value);
            });
          };
        },
      };
    },
  ];
  var ngBindTemplateDirective = [
    "$interpolate",
    "$compile",
    function ($interpolate, $compile) {
      return {
        compile: function ngBindTemplateCompile(templateElement) {
          $compile.$$addBindingClass(templateElement);
          return function ngBindTemplateLink(scope, element, attr) {
            var interpolateFn = $interpolate(
              element.attr(attr.$attr.ngBindTemplate)
            );
            $compile.$$addBindingInfo(element, interpolateFn.expressions);
            element = element[0];
            attr.$observe("ngBindTemplate", function (value) {
              element.textContent = isUndefined(value) ? "" : value;
            });
          };
        },
      };
    },
  ];
  var ngBindHtmlDirective = [
    "$sce",
    "$parse",
    "$compile",
    function ($sce, $parse, $compile) {
      return {
        restrict: "A",
        compile: function ngBindHtmlCompile(tElement, tAttrs) {
          var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
          var ngBindHtmlWatch = $parse(
            tAttrs.ngBindHtml,
            function sceValueOf(val) {
              return $sce.valueOf(val);
            }
          );
          $compile.$$addBindingClass(tElement);
          return function ngBindHtmlLink(scope, element, attr) {
            $compile.$$addBindingInfo(element, attr.ngBindHtml);
            scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
              var value = ngBindHtmlGetter(scope);
              element.html($sce.getTrustedHtml(value) || "");
            });
          };
        },
      };
    },
  ];
  var ngChangeDirective = valueFn({
    restrict: "A",
    require: "ngModel",
    link: function (scope, element, attr, ctrl) {
      ctrl.$viewChangeListeners.push(function () {
        scope.$eval(attr.ngChange);
      });
    },
  });
  function classDirective(name, selector) {
    name = "ngClass" + name;
    var indexWatchExpression;
    return [
      "$parse",
      function ($parse) {
        return {
          restrict: "AC",
          link: function (scope, element, attr) {
            var expression = attr[name].trim();
            var isOneTime =
              expression.charAt(0) === ":" && expression.charAt(1) === ":";
            var watchInterceptor = isOneTime ? toFlatValue : toClassString;
            var watchExpression = $parse(expression, watchInterceptor);
            var watchAction = isOneTime
              ? ngClassOneTimeWatchAction
              : ngClassWatchAction;
            var classCounts = element.data("$classCounts");
            var oldModulo = true;
            var oldClassString;
            if (!classCounts) {
              classCounts = createMap();
              element.data("$classCounts", classCounts);
            }
            if (name !== "ngClass") {
              if (!indexWatchExpression) {
                indexWatchExpression = $parse(
                  "$index",
                  function moduloTwo($index) {
                    return $index & 1;
                  }
                );
              }
              scope.$watch(indexWatchExpression, ngClassIndexWatchAction);
            }
            scope.$watch(watchExpression, watchAction, isOneTime);
            function addClasses(classString) {
              classString = digestClassCounts(split(classString), 1);
              attr.$addClass(classString);
            }
            function removeClasses(classString) {
              classString = digestClassCounts(split(classString), -1);
              attr.$removeClass(classString);
            }
            function updateClasses(oldClassString, newClassString) {
              var oldClassArray = split(oldClassString);
              var newClassArray = split(newClassString);
              var toRemoveArray = arrayDifference(oldClassArray, newClassArray);
              var toAddArray = arrayDifference(newClassArray, oldClassArray);
              var toRemoveString = digestClassCounts(toRemoveArray, -1);
              var toAddString = digestClassCounts(toAddArray, 1);
              attr.$addClass(toAddString);
              attr.$removeClass(toRemoveString);
            }
            function digestClassCounts(classArray, count) {
              var classesToUpdate = [];
              forEach(classArray, function (className) {
                if (count > 0 || classCounts[className]) {
                  classCounts[className] =
                    (classCounts[className] || 0) + count;
                  if (classCounts[className] === +(count > 0)) {
                    classesToUpdate.push(className);
                  }
                }
              });
              return classesToUpdate.join(" ");
            }
            function ngClassIndexWatchAction(newModulo) {
              if (newModulo === selector) {
                addClasses(oldClassString);
              } else {
                removeClasses(oldClassString);
              }
              oldModulo = newModulo;
            }
            function ngClassOneTimeWatchAction(newClassValue) {
              var newClassString = toClassString(newClassValue);
              if (newClassString !== oldClassString) {
                ngClassWatchAction(newClassString);
              }
            }
            function ngClassWatchAction(newClassString) {
              if (oldModulo === selector) {
                updateClasses(oldClassString, newClassString);
              }
              oldClassString = newClassString;
            }
          },
        };
      },
    ];
    function arrayDifference(tokens1, tokens2) {
      if (!tokens1 || !tokens1.length) return [];
      if (!tokens2 || !tokens2.length) return tokens1;
      var values = [];
      outer: for (var i = 0; i < tokens1.length; i++) {
        var token = tokens1[i];
        for (var j = 0; j < tokens2.length; j++) {
          if (token === tokens2[j]) continue outer;
        }
        values.push(token);
      }
      return values;
    }
    function split(classString) {
      return classString && classString.split(" ");
    }
    function toClassString(classValue) {
      var classString = classValue;
      if (isArray(classValue)) {
        classString = classValue.map(toClassString).join(" ");
      } else if (isObject(classValue)) {
        classString = Object.keys(classValue)
          .filter(function (key) {
            return classValue[key];
          })
          .join(" ");
      }
      return classString;
    }
    function toFlatValue(classValue) {
      var flatValue = classValue;
      if (isArray(classValue)) {
        flatValue = classValue.map(toFlatValue);
      } else if (isObject(classValue)) {
        var hasUndefined = false;
        flatValue = Object.keys(classValue).filter(function (key) {
          var value = classValue[key];
          if (!hasUndefined && isUndefined(value)) {
            hasUndefined = true;
          }
          return value;
        });
        if (hasUndefined) {
          flatValue.push(undefined);
        }
      }
      return flatValue;
    }
  }
  var ngClassDirective = classDirective("", true);
  var ngClassOddDirective = classDirective("Odd", 0);
  var ngClassEvenDirective = classDirective("Even", 1);
  var ngCloakDirective = ngDirective({
    compile: function (element, attr) {
      attr.$set("ngCloak", undefined);
      element.removeClass("ng-cloak");
    },
  });
  var ngControllerDirective = [
    function () {
      return { restrict: "A", scope: true, controller: "@", priority: 500 };
    },
  ];
  var ngEventDirectives = {};
  var forceAsyncEvents = { blur: true, focus: true };
  forEach(
    "click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(
      " "
    ),
    function (eventName) {
      var directiveName = directiveNormalize("ng-" + eventName);
      ngEventDirectives[directiveName] = [
        "$parse",
        "$rootScope",
        function ($parse, $rootScope) {
          return {
            restrict: "A",
            compile: function ($element, attr) {
              var fn = $parse(attr[directiveName], null, true);
              return function ngEventHandler(scope, element) {
                element.on(eventName, function (event) {
                  var callback = function () {
                    fn(scope, { $event: event });
                  };
                  if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                  } else {
                    scope.$apply(callback);
                  }
                });
              };
            },
          };
        },
      ];
    }
  );
  var ngIfDirective = [
    "$animate",
    "$compile",
    function ($animate, $compile) {
      return {
        multiElement: true,
        transclude: "element",
        priority: 600,
        terminal: true,
        restrict: "A",
        $$tlb: true,
        link: function ($scope, $element, $attr, ctrl, $transclude) {
          var block, childScope, previousElements;
          $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
            if (value) {
              if (!childScope) {
                $transclude(function (clone, newScope) {
                  childScope = newScope;
                  clone[clone.length++] = $compile.$$createComment(
                    "end ngIf",
                    $attr.ngIf
                  );
                  block = { clone: clone };
                  $animate.enter(clone, $element.parent(), $element);
                });
              }
            } else {
              if (previousElements) {
                previousElements.remove();
                previousElements = null;
              }
              if (childScope) {
                childScope.$destroy();
                childScope = null;
              }
              if (block) {
                previousElements = getBlockNodes(block.clone);
                $animate.leave(previousElements).done(function (response) {
                  if (response !== false) previousElements = null;
                });
                block = null;
              }
            }
          });
        },
      };
    },
  ];
  var ngIncludeDirective = [
    "$templateRequest",
    "$anchorScroll",
    "$animate",
    function ($templateRequest, $anchorScroll, $animate) {
      return {
        restrict: "ECA",
        priority: 400,
        terminal: true,
        transclude: "element",
        controller: angular.noop,
        compile: function (element, attr) {
          var srcExp = attr.ngInclude || attr.src,
            onloadExp = attr.onload || "",
            autoScrollExp = attr.autoscroll;
          return function (scope, $element, $attr, ctrl, $transclude) {
            var changeCounter = 0,
              currentScope,
              previousElement,
              currentElement;
            var cleanupLastIncludeContent = function () {
              if (previousElement) {
                previousElement.remove();
                previousElement = null;
              }
              if (currentScope) {
                currentScope.$destroy();
                currentScope = null;
              }
              if (currentElement) {
                $animate.leave(currentElement).done(function (response) {
                  if (response !== false) previousElement = null;
                });
                previousElement = currentElement;
                currentElement = null;
              }
            };
            scope.$watch(srcExp, function ngIncludeWatchAction(src) {
              var afterAnimation = function (response) {
                if (
                  response !== false &&
                  isDefined(autoScrollExp) &&
                  (!autoScrollExp || scope.$eval(autoScrollExp))
                ) {
                  $anchorScroll();
                }
              };
              var thisChangeId = ++changeCounter;
              if (src) {
                $templateRequest(src, true).then(
                  function (response) {
                    if (scope.$$destroyed) return;
                    if (thisChangeId !== changeCounter) return;
                    var newScope = scope.$new();
                    ctrl.template = response;
                    var clone = $transclude(newScope, function (clone) {
                      cleanupLastIncludeContent();
                      $animate
                        .enter(clone, null, $element)
                        .done(afterAnimation);
                    });
                    currentScope = newScope;
                    currentElement = clone;
                    currentScope.$emit("$includeContentLoaded", src);
                    scope.$eval(onloadExp);
                  },
                  function () {
                    if (scope.$$destroyed) return;
                    if (thisChangeId === changeCounter) {
                      cleanupLastIncludeContent();
                      scope.$emit("$includeContentError", src);
                    }
                  }
                );
                scope.$emit("$includeContentRequested", src);
              } else {
                cleanupLastIncludeContent();
                ctrl.template = null;
              }
            });
          };
        },
      };
    },
  ];
  var ngIncludeFillContentDirective = [
    "$compile",
    function ($compile) {
      return {
        restrict: "ECA",
        priority: -400,
        require: "ngInclude",
        link: function (scope, $element, $attr, ctrl) {
          if (toString.call($element[0]).match(/SVG/)) {
            $element.empty();
            $compile(
              jqLiteBuildFragment(ctrl.template, window.document).childNodes
            )(
              scope,
              function namespaceAdaptedClone(clone) {
                $element.append(clone);
              },
              { futureParentElement: $element }
            );
            return;
          }
          $element.html(ctrl.template);
          $compile($element.contents())(scope);
        },
      };
    },
  ];
  var ngInitDirective = ngDirective({
    priority: 450,
    compile: function () {
      return {
        pre: function (scope, element, attrs) {
          scope.$eval(attrs.ngInit);
        },
      };
    },
  });
  var ngListDirective = function () {
    return {
      restrict: "A",
      priority: 100,
      require: "ngModel",
      link: function (scope, element, attr, ctrl) {
        var ngList = attr.ngList || ", ";
        var trimValues = attr.ngTrim !== "false";
        var separator = trimValues ? trim(ngList) : ngList;
        var parse = function (viewValue) {
          if (isUndefined(viewValue)) return;
          var list = [];
          if (viewValue) {
            forEach(viewValue.split(separator), function (value) {
              if (value) list.push(trimValues ? trim(value) : value);
            });
          }
          return list;
        };
        ctrl.$parsers.push(parse);
        ctrl.$formatters.push(function (value) {
          if (isArray(value)) {
            return value.join(ngList);
          }
          return undefined;
        });
        ctrl.$isEmpty = function (value) {
          return !value || !value.length;
        };
      },
    };
  };
  var VALID_CLASS = "ng-valid",
    INVALID_CLASS = "ng-invalid",
    PRISTINE_CLASS = "ng-pristine",
    DIRTY_CLASS = "ng-dirty",
    UNTOUCHED_CLASS = "ng-untouched",
    TOUCHED_CLASS = "ng-touched",
    EMPTY_CLASS = "ng-empty",
    NOT_EMPTY_CLASS = "ng-not-empty";
  var ngModelMinErr = minErr("ngModel");
  NgModelController.$inject = [
    "$scope",
    "$exceptionHandler",
    "$attrs",
    "$element",
    "$parse",
    "$animate",
    "$timeout",
    "$q",
    "$interpolate",
  ];
  function NgModelController(
    $scope,
    $exceptionHandler,
    $attr,
    $element,
    $parse,
    $animate,
    $timeout,
    $q,
    $interpolate
  ) {
    this.$viewValue = Number.NaN;
    this.$modelValue = Number.NaN;
    this.$$rawModelValue = undefined;
    this.$validators = {};
    this.$asyncValidators = {};
    this.$parsers = [];
    this.$formatters = [];
    this.$viewChangeListeners = [];
    this.$untouched = true;
    this.$touched = false;
    this.$pristine = true;
    this.$dirty = false;
    this.$valid = true;
    this.$invalid = false;
    this.$error = {};
    this.$$success = {};
    this.$pending = undefined;
    this.$name = $interpolate($attr.name || "", false)($scope);
    this.$$parentForm = nullFormCtrl;
    this.$options = defaultModelOptions;
    this.$$parsedNgModel = $parse($attr.ngModel);
    this.$$parsedNgModelAssign = this.$$parsedNgModel.assign;
    this.$$ngModelGet = this.$$parsedNgModel;
    this.$$ngModelSet = this.$$parsedNgModelAssign;
    this.$$pendingDebounce = null;
    this.$$parserValid = undefined;
    this.$$currentValidationRunId = 0;
    this.$$scope = $scope;
    this.$$attr = $attr;
    this.$$element = $element;
    this.$$animate = $animate;
    this.$$timeout = $timeout;
    this.$$parse = $parse;
    this.$$q = $q;
    this.$$exceptionHandler = $exceptionHandler;
    setupValidity(this);
    setupModelWatcher(this);
  }
  NgModelController.prototype = {
    $$initGetterSetters: function () {
      if (this.$options.getOption("getterSetter")) {
        var invokeModelGetter = this.$$parse(this.$$attr.ngModel + "()"),
          invokeModelSetter = this.$$parse(this.$$attr.ngModel + "($$$p)");
        this.$$ngModelGet = function ($scope) {
          var modelValue = this.$$parsedNgModel($scope);
          if (isFunction(modelValue)) {
            modelValue = invokeModelGetter($scope);
          }
          return modelValue;
        };
        this.$$ngModelSet = function ($scope, newValue) {
          if (isFunction(this.$$parsedNgModel($scope))) {
            invokeModelSetter($scope, { $$$p: newValue });
          } else {
            this.$$parsedNgModelAssign($scope, newValue);
          }
        };
      } else if (!this.$$parsedNgModel.assign) {
        throw ngModelMinErr(
          "nonassign",
          "Expression '{0}' is non-assignable. Element: {1}",
          this.$$attr.ngModel,
          startingTag(this.$$element)
        );
      }
    },
    $render: noop,
    $isEmpty: function (value) {
      return (
        isUndefined(value) || value === "" || value === null || value !== value
      );
    },
    $$updateEmptyClasses: function (value) {
      if (this.$isEmpty(value)) {
        this.$$animate.removeClass(this.$$element, NOT_EMPTY_CLASS);
        this.$$animate.addClass(this.$$element, EMPTY_CLASS);
      } else {
        this.$$animate.removeClass(this.$$element, EMPTY_CLASS);
        this.$$animate.addClass(this.$$element, NOT_EMPTY_CLASS);
      }
    },
    $setPristine: function () {
      this.$dirty = false;
      this.$pristine = true;
      this.$$animate.removeClass(this.$$element, DIRTY_CLASS);
      this.$$animate.addClass(this.$$element, PRISTINE_CLASS);
    },
    $setDirty: function () {
      this.$dirty = true;
      this.$pristine = false;
      this.$$animate.removeClass(this.$$element, PRISTINE_CLASS);
      this.$$animate.addClass(this.$$element, DIRTY_CLASS);
      this.$$parentForm.$setDirty();
    },
    $setUntouched: function () {
      this.$touched = false;
      this.$untouched = true;
      this.$$animate.setClass(this.$$element, UNTOUCHED_CLASS, TOUCHED_CLASS);
    },
    $setTouched: function () {
      this.$touched = true;
      this.$untouched = false;
      this.$$animate.setClass(this.$$element, TOUCHED_CLASS, UNTOUCHED_CLASS);
    },
    $rollbackViewValue: function () {
      this.$$timeout.cancel(this.$$pendingDebounce);
      this.$viewValue = this.$$lastCommittedViewValue;
      this.$render();
    },
    $validate: function () {
      if (isNumberNaN(this.$modelValue)) {
        return;
      }
      var viewValue = this.$$lastCommittedViewValue;
      var modelValue = this.$$rawModelValue;
      var prevValid = this.$valid;
      var prevModelValue = this.$modelValue;
      var allowInvalid = this.$options.getOption("allowInvalid");
      var that = this;
      this.$$runValidators(modelValue, viewValue, function (allValid) {
        if (!allowInvalid && prevValid !== allValid) {
          that.$modelValue = allValid ? modelValue : undefined;
          if (that.$modelValue !== prevModelValue) {
            that.$$writeModelToScope();
          }
        }
      });
    },
    $$runValidators: function (modelValue, viewValue, doneCallback) {
      this.$$currentValidationRunId++;
      var localValidationRunId = this.$$currentValidationRunId;
      var that = this;
      if (!processParseErrors()) {
        validationDone(false);
        return;
      }
      if (!processSyncValidators()) {
        validationDone(false);
        return;
      }
      processAsyncValidators();
      function processParseErrors() {
        var errorKey = that.$$parserName || "parse";
        if (isUndefined(that.$$parserValid)) {
          setValidity(errorKey, null);
        } else {
          if (!that.$$parserValid) {
            forEach(that.$validators, function (v, name) {
              setValidity(name, null);
            });
            forEach(that.$asyncValidators, function (v, name) {
              setValidity(name, null);
            });
          }
          setValidity(errorKey, that.$$parserValid);
          return that.$$parserValid;
        }
        return true;
      }
      function processSyncValidators() {
        var syncValidatorsValid = true;
        forEach(that.$validators, function (validator, name) {
          var result = Boolean(validator(modelValue, viewValue));
          syncValidatorsValid = syncValidatorsValid && result;
          setValidity(name, result);
        });
        if (!syncValidatorsValid) {
          forEach(that.$asyncValidators, function (v, name) {
            setValidity(name, null);
          });
          return false;
        }
        return true;
      }
      function processAsyncValidators() {
        var validatorPromises = [];
        var allValid = true;
        forEach(that.$asyncValidators, function (validator, name) {
          var promise = validator(modelValue, viewValue);
          if (!isPromiseLike(promise)) {
            throw ngModelMinErr(
              "nopromise",
              "Expected asynchronous validator to return a promise but got '{0}' instead.",
              promise
            );
          }
          setValidity(name, undefined);
          validatorPromises.push(
            promise.then(
              function () {
                setValidity(name, true);
              },
              function () {
                allValid = false;
                setValidity(name, false);
              }
            )
          );
        });
        if (!validatorPromises.length) {
          validationDone(true);
        } else {
          that.$$q.all(validatorPromises).then(function () {
            validationDone(allValid);
          }, noop);
        }
      }
      function setValidity(name, isValid) {
        if (localValidationRunId === that.$$currentValidationRunId) {
          that.$setValidity(name, isValid);
        }
      }
      function validationDone(allValid) {
        if (localValidationRunId === that.$$currentValidationRunId) {
          doneCallback(allValid);
        }
      }
    },
    $commitViewValue: function () {
      var viewValue = this.$viewValue;
      this.$$timeout.cancel(this.$$pendingDebounce);
      if (
        this.$$lastCommittedViewValue === viewValue &&
        (viewValue !== "" || !this.$$hasNativeValidators)
      ) {
        return;
      }
      this.$$updateEmptyClasses(viewValue);
      this.$$lastCommittedViewValue = viewValue;
      if (this.$pristine) {
        this.$setDirty();
      }
      this.$$parseAndValidate();
    },
    $$parseAndValidate: function () {
      var viewValue = this.$$lastCommittedViewValue;
      var modelValue = viewValue;
      var that = this;
      this.$$parserValid = isUndefined(modelValue) ? undefined : true;
      if (this.$$parserValid) {
        for (var i = 0; i < this.$parsers.length; i++) {
          modelValue = this.$parsers[i](modelValue);
          if (isUndefined(modelValue)) {
            this.$$parserValid = false;
            break;
          }
        }
      }
      if (isNumberNaN(this.$modelValue)) {
        this.$modelValue = this.$$ngModelGet(this.$$scope);
      }
      var prevModelValue = this.$modelValue;
      var allowInvalid = this.$options.getOption("allowInvalid");
      this.$$rawModelValue = modelValue;
      if (allowInvalid) {
        this.$modelValue = modelValue;
        writeToModelIfNeeded();
      }
      this.$$runValidators(
        modelValue,
        this.$$lastCommittedViewValue,
        function (allValid) {
          if (!allowInvalid) {
            that.$modelValue = allValid ? modelValue : undefined;
            writeToModelIfNeeded();
          }
        }
      );
      function writeToModelIfNeeded() {
        if (that.$modelValue !== prevModelValue) {
          that.$$writeModelToScope();
        }
      }
    },
    $$writeModelToScope: function () {
      this.$$ngModelSet(this.$$scope, this.$modelValue);
      forEach(
        this.$viewChangeListeners,
        function (listener) {
          try {
            listener();
          } catch (e) {
            this.$$exceptionHandler(e);
          }
        },
        this
      );
    },
    $setViewValue: function (value, trigger) {
      this.$viewValue = value;
      if (this.$options.getOption("updateOnDefault")) {
        this.$$debounceViewValueCommit(trigger);
      }
    },
    $$debounceViewValueCommit: function (trigger) {
      var debounceDelay = this.$options.getOption("debounce");
      if (isNumber(debounceDelay[trigger])) {
        debounceDelay = debounceDelay[trigger];
      } else if (isNumber(debounceDelay["default"])) {
        debounceDelay = debounceDelay["default"];
      }
      this.$$timeout.cancel(this.$$pendingDebounce);
      var that = this;
      if (debounceDelay > 0) {
        this.$$pendingDebounce = this.$$timeout(function () {
          that.$commitViewValue();
        }, debounceDelay);
      } else if (this.$$scope.$root.$$phase) {
        this.$commitViewValue();
      } else {
        this.$$scope.$apply(function () {
          that.$commitViewValue();
        });
      }
    },
  };
  function setupModelWatcher(ctrl) {
    ctrl.$$scope.$watch(function ngModelWatch() {
      var modelValue = ctrl.$$ngModelGet(ctrl.$$scope);
      if (
        modelValue !== ctrl.$modelValue &&
        (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)
      ) {
        ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
        ctrl.$$parserValid = undefined;
        var formatters = ctrl.$formatters,
          idx = formatters.length;
        var viewValue = modelValue;
        while (idx--) {
          viewValue = formatters[idx](viewValue);
        }
        if (ctrl.$viewValue !== viewValue) {
          ctrl.$$updateEmptyClasses(viewValue);
          ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
          ctrl.$render();
          ctrl.$$runValidators(ctrl.$modelValue, ctrl.$viewValue, noop);
        }
      }
      return modelValue;
    });
  }
  addSetValidityMethod({
    clazz: NgModelController,
    set: function (object, property) {
      object[property] = true;
    },
    unset: function (object, property) {
      delete object[property];
    },
  });
  var ngModelDirective = [
    "$rootScope",
    function ($rootScope) {
      return {
        restrict: "A",
        require: ["ngModel", "^?form", "^?ngModelOptions"],
        controller: NgModelController,
        priority: 1,
        compile: function ngModelCompile(element) {
          element
            .addClass(PRISTINE_CLASS)
            .addClass(UNTOUCHED_CLASS)
            .addClass(VALID_CLASS);
          return {
            pre: function ngModelPreLink(scope, element, attr, ctrls) {
              var modelCtrl = ctrls[0],
                formCtrl = ctrls[1] || modelCtrl.$$parentForm,
                optionsCtrl = ctrls[2];
              if (optionsCtrl) {
                modelCtrl.$options = optionsCtrl.$options;
              }
              modelCtrl.$$initGetterSetters();
              formCtrl.$addControl(modelCtrl);
              attr.$observe("name", function (newValue) {
                if (modelCtrl.$name !== newValue) {
                  modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                }
              });
              scope.$on("$destroy", function () {
                modelCtrl.$$parentForm.$removeControl(modelCtrl);
              });
            },
            post: function ngModelPostLink(scope, element, attr, ctrls) {
              var modelCtrl = ctrls[0];
              if (modelCtrl.$options.getOption("updateOn")) {
                element.on(
                  modelCtrl.$options.getOption("updateOn"),
                  function (ev) {
                    modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                  }
                );
              }
              function setTouched() {
                modelCtrl.$setTouched();
              }
              element.on("blur", function () {
                if (modelCtrl.$touched) return;
                if ($rootScope.$$phase) {
                  scope.$evalAsync(setTouched);
                } else {
                  scope.$apply(setTouched);
                }
              });
            },
          };
        },
      };
    },
  ];
  var defaultModelOptions;
  var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
  function ModelOptions(options) {
    this.$$options = options;
  }
  ModelOptions.prototype = {
    getOption: function (name) {
      return this.$$options[name];
    },
    createChild: function (options) {
      var inheritAll = false;
      options = extend({}, options);
      forEach(
        options,
        function (option, key) {
          if (option === "$inherit") {
            if (key === "*") {
              inheritAll = true;
            } else {
              options[key] = this.$$options[key];
              if (key === "updateOn") {
                options.updateOnDefault = this.$$options.updateOnDefault;
              }
            }
          } else {
            if (key === "updateOn") {
              options.updateOnDefault = false;
              options[key] = trim(
                option.replace(DEFAULT_REGEXP, function () {
                  options.updateOnDefault = true;
                  return " ";
                })
              );
            }
          }
        },
        this
      );
      if (inheritAll) {
        delete options["*"];
        defaults(options, this.$$options);
      }
      defaults(options, defaultModelOptions.$$options);
      return new ModelOptions(options);
    },
  };
  defaultModelOptions = new ModelOptions({
    updateOn: "",
    updateOnDefault: true,
    debounce: 0,
    getterSetter: false,
    allowInvalid: false,
    timezone: null,
  });
  var ngModelOptionsDirective = function () {
    NgModelOptionsController.$inject = ["$attrs", "$scope"];
    function NgModelOptionsController($attrs, $scope) {
      this.$$attrs = $attrs;
      this.$$scope = $scope;
    }
    NgModelOptionsController.prototype = {
      $onInit: function () {
        var parentOptions = this.parentCtrl
          ? this.parentCtrl.$options
          : defaultModelOptions;
        var modelOptionsDefinition = this.$$scope.$eval(
          this.$$attrs.ngModelOptions
        );
        this.$options = parentOptions.createChild(modelOptionsDefinition);
      },
    };
    return {
      restrict: "A",
      priority: 10,
      require: { parentCtrl: "?^^ngModelOptions" },
      bindToController: true,
      controller: NgModelOptionsController,
    };
  };
  function defaults(dst, src) {
    forEach(src, function (value, key) {
      if (!isDefined(dst[key])) {
        dst[key] = value;
      }
    });
  }
  var ngNonBindableDirective = ngDirective({ terminal: true, priority: 1e3 });
  var ngOptionsMinErr = minErr("ngOptions");
  var NG_OPTIONS_REGEXP =
    /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
  var ngOptionsDirective = [
    "$compile",
    "$document",
    "$parse",
    function ($compile, $document, $parse) {
      function parseOptionsExpression(optionsExp, selectElement, scope) {
        var match = optionsExp.match(NG_OPTIONS_REGEXP);
        if (!match) {
          throw ngOptionsMinErr(
            "iexp",
            "Expected expression in form of " +
              "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" +
              " but got '{0}'. Element: {1}",
            optionsExp,
            startingTag(selectElement)
          );
        }
        var valueName = match[5] || match[7];
        var keyName = match[6];
        var selectAs = / as /.test(match[0]) && match[1];
        var trackBy = match[9];
        var valueFn = $parse(match[2] ? match[1] : valueName);
        var selectAsFn = selectAs && $parse(selectAs);
        var viewValueFn = selectAsFn || valueFn;
        var trackByFn = trackBy && $parse(trackBy);
        var getTrackByValueFn = trackBy
          ? function (value, locals) {
              return trackByFn(scope, locals);
            }
          : function getHashOfValue(value) {
              return hashKey(value);
            };
        var getTrackByValue = function (value, key) {
          return getTrackByValueFn(value, getLocals(value, key));
        };
        var displayFn = $parse(match[2] || match[1]);
        var groupByFn = $parse(match[3] || "");
        var disableWhenFn = $parse(match[4] || "");
        var valuesFn = $parse(match[8]);
        var locals = {};
        var getLocals = keyName
          ? function (value, key) {
              locals[keyName] = key;
              locals[valueName] = value;
              return locals;
            }
          : function (value) {
              locals[valueName] = value;
              return locals;
            };
        function Option(selectValue, viewValue, label, group, disabled) {
          this.selectValue = selectValue;
          this.viewValue = viewValue;
          this.label = label;
          this.group = group;
          this.disabled = disabled;
        }
        function getOptionValuesKeys(optionValues) {
          var optionValuesKeys;
          if (!keyName && isArrayLike(optionValues)) {
            optionValuesKeys = optionValues;
          } else {
            optionValuesKeys = [];
            for (var itemKey in optionValues) {
              if (
                optionValues.hasOwnProperty(itemKey) &&
                itemKey.charAt(0) !== "$"
              ) {
                optionValuesKeys.push(itemKey);
              }
            }
          }
          return optionValuesKeys;
        }
        return {
          trackBy: trackBy,
          getTrackByValue: getTrackByValue,
          getWatchables: $parse(valuesFn, function (optionValues) {
            var watchedArray = [];
            optionValues = optionValues || [];
            var optionValuesKeys = getOptionValuesKeys(optionValues);
            var optionValuesLength = optionValuesKeys.length;
            for (var index = 0; index < optionValuesLength; index++) {
              var key =
                optionValues === optionValuesKeys
                  ? index
                  : optionValuesKeys[index];
              var value = optionValues[key];
              var locals = getLocals(value, key);
              var selectValue = getTrackByValueFn(value, locals);
              watchedArray.push(selectValue);
              if (match[2] || match[1]) {
                var label = displayFn(scope, locals);
                watchedArray.push(label);
              }
              if (match[4]) {
                var disableWhen = disableWhenFn(scope, locals);
                watchedArray.push(disableWhen);
              }
            }
            return watchedArray;
          }),
          getOptions: function () {
            var optionItems = [];
            var selectValueMap = {};
            var optionValues = valuesFn(scope) || [];
            var optionValuesKeys = getOptionValuesKeys(optionValues);
            var optionValuesLength = optionValuesKeys.length;
            for (var index = 0; index < optionValuesLength; index++) {
              var key =
                optionValues === optionValuesKeys
                  ? index
                  : optionValuesKeys[index];
              var value = optionValues[key];
              var locals = getLocals(value, key);
              var viewValue = viewValueFn(scope, locals);
              var selectValue = getTrackByValueFn(viewValue, locals);
              var label = displayFn(scope, locals);
              var group = groupByFn(scope, locals);
              var disabled = disableWhenFn(scope, locals);
              var optionItem = new Option(
                selectValue,
                viewValue,
                label,
                group,
                disabled
              );
              optionItems.push(optionItem);
              selectValueMap[selectValue] = optionItem;
            }
            return {
              items: optionItems,
              selectValueMap: selectValueMap,
              getOptionFromViewValue: function (value) {
                return selectValueMap[getTrackByValue(value)];
              },
              getViewValueFromOption: function (option) {
                return trackBy ? copy(option.viewValue) : option.viewValue;
              },
            };
          },
        };
      }
      var optionTemplate = window.document.createElement("option"),
        optGroupTemplate = window.document.createElement("optgroup");
      function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
        var selectCtrl = ctrls[0];
        var ngModelCtrl = ctrls[1];
        var multiple = attr.multiple;
        for (
          var i = 0, children = selectElement.children(), ii = children.length;
          i < ii;
          i++
        ) {
          if (children[i].value === "") {
            selectCtrl.hasEmptyOption = true;
            selectCtrl.emptyOption = children.eq(i);
            break;
          }
        }
        var providedEmptyOption = !!selectCtrl.emptyOption;
        var unknownOption = jqLite(optionTemplate.cloneNode(false));
        unknownOption.val("?");
        var options;
        var ngOptions = parseOptionsExpression(
          attr.ngOptions,
          selectElement,
          scope
        );
        var listFragment = $document[0].createDocumentFragment();
        selectCtrl.generateUnknownOptionValue = function (val) {
          return "?";
        };
        if (!multiple) {
          selectCtrl.writeValue = function writeNgOptionsValue(value) {
            var selectedOption = options.selectValueMap[selectElement.val()];
            var option = options.getOptionFromViewValue(value);
            if (selectedOption)
              selectedOption.element.removeAttribute("selected");
            if (option) {
              if (selectElement[0].value !== option.selectValue) {
                selectCtrl.removeUnknownOption();
                selectCtrl.unselectEmptyOption();
                selectElement[0].value = option.selectValue;
                option.element.selected = true;
              }
              option.element.setAttribute("selected", "selected");
            } else {
              if (providedEmptyOption) {
                selectCtrl.selectEmptyOption();
              } else if (selectCtrl.unknownOption.parent().length) {
                selectCtrl.updateUnknownOption(value);
              } else {
                selectCtrl.renderUnknownOption(value);
              }
            }
          };
          selectCtrl.readValue = function readNgOptionsValue() {
            var selectedOption = options.selectValueMap[selectElement.val()];
            if (selectedOption && !selectedOption.disabled) {
              selectCtrl.unselectEmptyOption();
              selectCtrl.removeUnknownOption();
              return options.getViewValueFromOption(selectedOption);
            }
            return null;
          };
          if (ngOptions.trackBy) {
            scope.$watch(
              function () {
                return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
              },
              function () {
                ngModelCtrl.$render();
              }
            );
          }
        } else {
          selectCtrl.writeValue = function writeNgOptionsMultiple(values) {
            var selectedOptions =
              (values && values.map(getAndUpdateSelectedOption)) || [];
            options.items.forEach(function (option) {
              if (
                option.element.selected &&
                !includes(selectedOptions, option)
              ) {
                option.element.selected = false;
              }
            });
          };
          selectCtrl.readValue = function readNgOptionsMultiple() {
            var selectedValues = selectElement.val() || [],
              selections = [];
            forEach(selectedValues, function (value) {
              var option = options.selectValueMap[value];
              if (option && !option.disabled)
                selections.push(options.getViewValueFromOption(option));
            });
            return selections;
          };
          if (ngOptions.trackBy) {
            scope.$watchCollection(
              function () {
                if (isArray(ngModelCtrl.$viewValue)) {
                  return ngModelCtrl.$viewValue.map(function (value) {
                    return ngOptions.getTrackByValue(value);
                  });
                }
              },
              function () {
                ngModelCtrl.$render();
              }
            );
          }
        }
        if (providedEmptyOption) {
          selectCtrl.emptyOption.remove();
          $compile(selectCtrl.emptyOption)(scope);
          if (selectCtrl.emptyOption[0].nodeType === NODE_TYPE_COMMENT) {
            selectCtrl.hasEmptyOption = false;
            selectCtrl.registerOption = function (optionScope, optionEl) {
              if (optionEl.val() === "") {
                selectCtrl.hasEmptyOption = true;
                selectCtrl.emptyOption = optionEl;
                selectCtrl.emptyOption.removeClass("ng-scope");
                ngModelCtrl.$render();
                optionEl.on("$destroy", function () {
                  selectCtrl.hasEmptyOption = false;
                  selectCtrl.emptyOption = undefined;
                });
              }
            };
          } else {
            selectCtrl.emptyOption.removeClass("ng-scope");
          }
        }
        selectElement.empty();
        updateOptions();
        scope.$watchCollection(ngOptions.getWatchables, updateOptions);
        function addOptionElement(option, parent) {
          var optionElement = optionTemplate.cloneNode(false);
          parent.appendChild(optionElement);
          updateOptionElement(option, optionElement);
        }
        function getAndUpdateSelectedOption(viewValue) {
          var option = options.getOptionFromViewValue(viewValue);
          var element = option && option.element;
          if (element && !element.selected) element.selected = true;
          return option;
        }
        function updateOptionElement(option, element) {
          option.element = element;
          element.disabled = option.disabled;
          if (option.label !== element.label) {
            element.label = option.label;
            element.textContent = option.label;
          }
          element.value = option.selectValue;
        }
        function updateOptions() {
          var previousValue = options && selectCtrl.readValue();
          if (options) {
            for (var i = options.items.length - 1; i >= 0; i--) {
              var option = options.items[i];
              if (isDefined(option.group)) {
                jqLiteRemove(option.element.parentNode);
              } else {
                jqLiteRemove(option.element);
              }
            }
          }
          options = ngOptions.getOptions();
          var groupElementMap = {};
          if (providedEmptyOption) {
            selectElement.prepend(selectCtrl.emptyOption);
          }
          options.items.forEach(function addOption(option) {
            var groupElement;
            if (isDefined(option.group)) {
              groupElement = groupElementMap[option.group];
              if (!groupElement) {
                groupElement = optGroupTemplate.cloneNode(false);
                listFragment.appendChild(groupElement);
                groupElement.label =
                  option.group === null ? "null" : option.group;
                groupElementMap[option.group] = groupElement;
              }
              addOptionElement(option, groupElement);
            } else {
              addOptionElement(option, listFragment);
            }
          });
          selectElement[0].appendChild(listFragment);
          ngModelCtrl.$render();
          if (!ngModelCtrl.$isEmpty(previousValue)) {
            var nextValue = selectCtrl.readValue();
            var isNotPrimitive = ngOptions.trackBy || multiple;
            if (
              isNotPrimitive
                ? !equals(previousValue, nextValue)
                : previousValue !== nextValue
            ) {
              ngModelCtrl.$setViewValue(nextValue);
              ngModelCtrl.$render();
            }
          }
        }
      }
      return {
        restrict: "A",
        terminal: true,
        require: ["select", "ngModel"],
        link: {
          pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {
            ctrls[0].registerOption = noop;
          },
          post: ngOptionsPostLink,
        },
      };
    },
  ];
  var ngPluralizeDirective = [
    "$locale",
    "$interpolate",
    "$log",
    function ($locale, $interpolate, $log) {
      var BRACE = /{}/g,
        IS_WHEN = /^when(Minus)?(.+)$/;
      return {
        link: function (scope, element, attr) {
          var numberExp = attr.count,
            whenExp = attr.$attr.when && element.attr(attr.$attr.when),
            offset = attr.offset || 0,
            whens = scope.$eval(whenExp) || {},
            whensExpFns = {},
            startSymbol = $interpolate.startSymbol(),
            endSymbol = $interpolate.endSymbol(),
            braceReplacement =
              startSymbol + numberExp + "-" + offset + endSymbol,
            watchRemover = angular.noop,
            lastCount;
          forEach(attr, function (expression, attributeName) {
            var tmpMatch = IS_WHEN.exec(attributeName);
            if (tmpMatch) {
              var whenKey = (tmpMatch[1] ? "-" : "") + lowercase(tmpMatch[2]);
              whens[whenKey] = element.attr(attr.$attr[attributeName]);
            }
          });
          forEach(whens, function (expression, key) {
            whensExpFns[key] = $interpolate(
              expression.replace(BRACE, braceReplacement)
            );
          });
          scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
            var count = parseFloat(newVal);
            var countIsNaN = isNumberNaN(count);
            if (!countIsNaN && !(count in whens)) {
              count = $locale.pluralCat(count - offset);
            }
            if (
              count !== lastCount &&
              !(countIsNaN && isNumberNaN(lastCount))
            ) {
              watchRemover();
              var whenExpFn = whensExpFns[count];
              if (isUndefined(whenExpFn)) {
                if (newVal != null) {
                  $log.debug(
                    "ngPluralize: no rule defined for '" +
                      count +
                      "' in " +
                      whenExp
                  );
                }
                watchRemover = noop;
                updateElementText();
              } else {
                watchRemover = scope.$watch(whenExpFn, updateElementText);
              }
              lastCount = count;
            }
          });
          function updateElementText(newText) {
            element.text(newText || "");
          }
        },
      };
    },
  ];
  var ngRepeatDirective = [
    "$parse",
    "$animate",
    "$compile",
    function ($parse, $animate, $compile) {
      var NG_REMOVED = "$$NG_REMOVED";
      var ngRepeatMinErr = minErr("ngRepeat");
      var updateScope = function (
        scope,
        index,
        valueIdentifier,
        value,
        keyIdentifier,
        key,
        arrayLength
      ) {
        scope[valueIdentifier] = value;
        if (keyIdentifier) scope[keyIdentifier] = key;
        scope.$index = index;
        scope.$first = index === 0;
        scope.$last = index === arrayLength - 1;
        scope.$middle = !(scope.$first || scope.$last);
        scope.$odd = !(scope.$even = (index & 1) === 0);
      };
      var getBlockStart = function (block) {
        return block.clone[0];
      };
      var getBlockEnd = function (block) {
        return block.clone[block.clone.length - 1];
      };
      return {
        restrict: "A",
        multiElement: true,
        transclude: "element",
        priority: 1e3,
        terminal: true,
        $$tlb: true,
        compile: function ngRepeatCompile($element, $attr) {
          var expression = $attr.ngRepeat;
          var ngRepeatEndComment = $compile.$$createComment(
            "end ngRepeat",
            expression
          );
          var match = expression.match(
            /^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/
          );
          if (!match) {
            throw ngRepeatMinErr(
              "iexp",
              "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.",
              expression
            );
          }
          var lhs = match[1];
          var rhs = match[2];
          var aliasAs = match[3];
          var trackByExp = match[4];
          match = lhs.match(
            /^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/
          );
          if (!match) {
            throw ngRepeatMinErr(
              "iidexp",
              "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.",
              lhs
            );
          }
          var valueIdentifier = match[3] || match[1];
          var keyIdentifier = match[2];
          if (
            aliasAs &&
            (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) ||
              /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(
                aliasAs
              ))
          ) {
            throw ngRepeatMinErr(
              "badident",
              "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.",
              aliasAs
            );
          }
          var trackByExpGetter,
            trackByIdExpFn,
            trackByIdArrayFn,
            trackByIdObjFn;
          var hashFnLocals = { $id: hashKey };
          if (trackByExp) {
            trackByExpGetter = $parse(trackByExp);
          } else {
            trackByIdArrayFn = function (key, value) {
              return hashKey(value);
            };
            trackByIdObjFn = function (key) {
              return key;
            };
          }
          return function ngRepeatLink(
            $scope,
            $element,
            $attr,
            ctrl,
            $transclude
          ) {
            if (trackByExpGetter) {
              trackByIdExpFn = function (key, value, index) {
                if (keyIdentifier) hashFnLocals[keyIdentifier] = key;
                hashFnLocals[valueIdentifier] = value;
                hashFnLocals.$index = index;
                return trackByExpGetter($scope, hashFnLocals);
              };
            }
            var lastBlockMap = createMap();
            $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
              var index,
                length,
                previousNode = $element[0],
                nextNode,
                nextBlockMap = createMap(),
                collectionLength,
                key,
                value,
                trackById,
                trackByIdFn,
                collectionKeys,
                block,
                nextBlockOrder,
                elementsToRemove;
              if (aliasAs) {
                $scope[aliasAs] = collection;
              }
              if (isArrayLike(collection)) {
                collectionKeys = collection;
                trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
              } else {
                trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                collectionKeys = [];
                for (var itemKey in collection) {
                  if (
                    hasOwnProperty.call(collection, itemKey) &&
                    itemKey.charAt(0) !== "$"
                  ) {
                    collectionKeys.push(itemKey);
                  }
                }
              }
              collectionLength = collectionKeys.length;
              nextBlockOrder = new Array(collectionLength);
              for (index = 0; index < collectionLength; index++) {
                key =
                  collection === collectionKeys ? index : collectionKeys[index];
                value = collection[key];
                trackById = trackByIdFn(key, value, index);
                if (lastBlockMap[trackById]) {
                  block = lastBlockMap[trackById];
                  delete lastBlockMap[trackById];
                  nextBlockMap[trackById] = block;
                  nextBlockOrder[index] = block;
                } else if (nextBlockMap[trackById]) {
                  forEach(nextBlockOrder, function (block) {
                    if (block && block.scope) lastBlockMap[block.id] = block;
                  });
                  throw ngRepeatMinErr(
                    "dupes",
                    "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}",
                    expression,
                    trackById,
                    value
                  );
                } else {
                  nextBlockOrder[index] = {
                    id: trackById,
                    scope: undefined,
                    clone: undefined,
                  };
                  nextBlockMap[trackById] = true;
                }
              }
              for (var blockKey in lastBlockMap) {
                block = lastBlockMap[blockKey];
                elementsToRemove = getBlockNodes(block.clone);
                $animate.leave(elementsToRemove);
                if (elementsToRemove[0].parentNode) {
                  for (
                    index = 0, length = elementsToRemove.length;
                    index < length;
                    index++
                  ) {
                    elementsToRemove[index][NG_REMOVED] = true;
                  }
                }
                block.scope.$destroy();
              }
              for (index = 0; index < collectionLength; index++) {
                key =
                  collection === collectionKeys ? index : collectionKeys[index];
                value = collection[key];
                block = nextBlockOrder[index];
                if (block.scope) {
                  nextNode = previousNode;
                  do {
                    nextNode = nextNode.nextSibling;
                  } while (nextNode && nextNode[NG_REMOVED]);
                  if (getBlockStart(block) !== nextNode) {
                    $animate.move(
                      getBlockNodes(block.clone),
                      null,
                      previousNode
                    );
                  }
                  previousNode = getBlockEnd(block);
                  updateScope(
                    block.scope,
                    index,
                    valueIdentifier,
                    value,
                    keyIdentifier,
                    key,
                    collectionLength
                  );
                } else {
                  $transclude(function ngRepeatTransclude(clone, scope) {
                    block.scope = scope;
                    var endNode = ngRepeatEndComment.cloneNode(false);
                    clone[clone.length++] = endNode;
                    $animate.enter(clone, null, previousNode);
                    previousNode = endNode;
                    block.clone = clone;
                    nextBlockMap[block.id] = block;
                    updateScope(
                      block.scope,
                      index,
                      valueIdentifier,
                      value,
                      keyIdentifier,
                      key,
                      collectionLength
                    );
                  });
                }
              }
              lastBlockMap = nextBlockMap;
            });
          };
        },
      };
    },
  ];
  var NG_HIDE_CLASS = "ng-hide";
  var NG_HIDE_IN_PROGRESS_CLASS = "ng-hide-animate";
  var ngShowDirective = [
    "$animate",
    function ($animate) {
      return {
        restrict: "A",
        multiElement: true,
        link: function (scope, element, attr) {
          scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
            $animate[value ? "removeClass" : "addClass"](
              element,
              NG_HIDE_CLASS,
              { tempClasses: NG_HIDE_IN_PROGRESS_CLASS }
            );
          });
        },
      };
    },
  ];
  var ngHideDirective = [
    "$animate",
    function ($animate) {
      return {
        restrict: "A",
        multiElement: true,
        link: function (scope, element, attr) {
          scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
            $animate[value ? "addClass" : "removeClass"](
              element,
              NG_HIDE_CLASS,
              { tempClasses: NG_HIDE_IN_PROGRESS_CLASS }
            );
          });
        },
      };
    },
  ];
  var ngStyleDirective = ngDirective(function (scope, element, attr) {
    scope.$watch(
      attr.ngStyle,
      function ngStyleWatchAction(newStyles, oldStyles) {
        if (oldStyles && newStyles !== oldStyles) {
          forEach(oldStyles, function (val, style) {
            element.css(style, "");
          });
        }
        if (newStyles) element.css(newStyles);
      },
      true
    );
  });
  var ngSwitchDirective = [
    "$animate",
    "$compile",
    function ($animate, $compile) {
      return {
        require: "ngSwitch",
        controller: [
          "$scope",
          function NgSwitchController() {
            this.cases = {};
          },
        ],
        link: function (scope, element, attr, ngSwitchController) {
          var watchExpr = attr.ngSwitch || attr.on,
            selectedTranscludes = [],
            selectedElements = [],
            previousLeaveAnimations = [],
            selectedScopes = [];
          var spliceFactory = function (array, index) {
            return function (response) {
              if (response !== false) array.splice(index, 1);
            };
          };
          scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
            var i, ii;
            while (previousLeaveAnimations.length) {
              $animate.cancel(previousLeaveAnimations.pop());
            }
            for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
              var selected = getBlockNodes(selectedElements[i].clone);
              selectedScopes[i].$destroy();
              var runner = (previousLeaveAnimations[i] =
                $animate.leave(selected));
              runner.done(spliceFactory(previousLeaveAnimations, i));
            }
            selectedElements.length = 0;
            selectedScopes.length = 0;
            if (
              (selectedTranscludes =
                ngSwitchController.cases["!" + value] ||
                ngSwitchController.cases["?"])
            ) {
              forEach(selectedTranscludes, function (selectedTransclude) {
                selectedTransclude.transclude(function (
                  caseElement,
                  selectedScope
                ) {
                  selectedScopes.push(selectedScope);
                  var anchor = selectedTransclude.element;
                  caseElement[caseElement.length++] =
                    $compile.$$createComment("end ngSwitchWhen");
                  var block = { clone: caseElement };
                  selectedElements.push(block);
                  $animate.enter(caseElement, anchor.parent(), anchor);
                });
              });
            }
          });
        },
      };
    },
  ];
  var ngSwitchWhenDirective = ngDirective({
    transclude: "element",
    priority: 1200,
    require: "^ngSwitch",
    multiElement: true,
    link: function (scope, element, attrs, ctrl, $transclude) {
      var cases = attrs.ngSwitchWhen
        .split(attrs.ngSwitchWhenSeparator)
        .sort()
        .filter(function (element, index, array) {
          return array[index - 1] !== element;
        });
      forEach(cases, function (whenCase) {
        ctrl.cases["!" + whenCase] = ctrl.cases["!" + whenCase] || [];
        ctrl.cases["!" + whenCase].push({
          transclude: $transclude,
          element: element,
        });
      });
    },
  });
  var ngSwitchDefaultDirective = ngDirective({
    transclude: "element",
    priority: 1200,
    require: "^ngSwitch",
    multiElement: true,
    link: function (scope, element, attr, ctrl, $transclude) {
      ctrl.cases["?"] = ctrl.cases["?"] || [];
      ctrl.cases["?"].push({ transclude: $transclude, element: element });
    },
  });
  var ngTranscludeMinErr = minErr("ngTransclude");
  var ngTranscludeDirective = [
    "$compile",
    function ($compile) {
      return {
        restrict: "EAC",
        terminal: true,
        compile: function ngTranscludeCompile(tElement) {
          var fallbackLinkFn = $compile(tElement.contents());
          tElement.empty();
          return function ngTranscludePostLink(
            $scope,
            $element,
            $attrs,
            controller,
            $transclude
          ) {
            if (!$transclude) {
              throw ngTranscludeMinErr(
                "orphan",
                "Illegal use of ngTransclude directive in the template! " +
                  "No parent directive that requires a transclusion found. " +
                  "Element: {0}",
                startingTag($element)
              );
            }
            if ($attrs.ngTransclude === $attrs.$attr.ngTransclude) {
              $attrs.ngTransclude = "";
            }
            var slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;
            $transclude(ngTranscludeCloneAttachFn, null, slotName);
            if (slotName && !$transclude.isSlotFilled(slotName)) {
              useFallbackContent();
            }
            function ngTranscludeCloneAttachFn(clone, transcludedScope) {
              if (clone.length && notWhitespace(clone)) {
                $element.append(clone);
              } else {
                useFallbackContent();
                transcludedScope.$destroy();
              }
            }
            function useFallbackContent() {
              fallbackLinkFn($scope, function (clone) {
                $element.append(clone);
              });
            }
            function notWhitespace(nodes) {
              for (var i = 0, ii = nodes.length; i < ii; i++) {
                var node = nodes[i];
                if (node.nodeType !== NODE_TYPE_TEXT || node.nodeValue.trim()) {
                  return true;
                }
              }
            }
          };
        },
      };
    },
  ];
  var scriptDirective = [
    "$templateCache",
    function ($templateCache) {
      return {
        restrict: "E",
        terminal: true,
        compile: function (element, attr) {
          if (attr.type === "text/ng-template") {
            var templateUrl = attr.id,
              text = element[0].text;
            $templateCache.put(templateUrl, text);
          }
        },
      };
    },
  ];
  var noopNgModelController = { $setViewValue: noop, $render: noop };
  var SelectController = [
    "$element",
    "$scope",
    function ($element, $scope) {
      var self = this,
        optionsMap = new HashMap();
      self.selectValueMap = {};
      self.ngModelCtrl = noopNgModelController;
      self.multiple = false;
      self.unknownOption = jqLite(window.document.createElement("option"));
      self.hasEmptyOption = false;
      self.emptyOption = undefined;
      self.renderUnknownOption = function (val) {
        var unknownVal = self.generateUnknownOptionValue(val);
        self.unknownOption.val(unknownVal);
        $element.prepend(self.unknownOption);
        setOptionAsSelected(self.unknownOption);
        $element.val(unknownVal);
      };
      self.updateUnknownOption = function (val) {
        var unknownVal = self.generateUnknownOptionValue(val);
        self.unknownOption.val(unknownVal);
        setOptionAsSelected(self.unknownOption);
        $element.val(unknownVal);
      };
      self.generateUnknownOptionValue = function (val) {
        return "? " + hashKey(val) + " ?";
      };
      self.removeUnknownOption = function () {
        if (self.unknownOption.parent()) self.unknownOption.remove();
      };
      self.selectEmptyOption = function () {
        if (self.emptyOption) {
          $element.val("");
          setOptionAsSelected(self.emptyOption);
        }
      };
      self.unselectEmptyOption = function () {
        if (self.hasEmptyOption) {
          self.emptyOption.removeAttr("selected");
        }
      };
      $scope.$on("$destroy", function () {
        self.renderUnknownOption = noop;
      });
      self.readValue = function readSingleValue() {
        var val = $element.val();
        var realVal =
          val in self.selectValueMap ? self.selectValueMap[val] : val;
        if (self.hasOption(realVal)) {
          return realVal;
        }
        return null;
      };
      self.writeValue = function writeSingleValue(value) {
        var currentlySelectedOption =
          $element[0].options[$element[0].selectedIndex];
        if (currentlySelectedOption)
          currentlySelectedOption.removeAttribute("selected");
        if (self.hasOption(value)) {
          self.removeUnknownOption();
          var hashedVal = hashKey(value);
          $element.val(hashedVal in self.selectValueMap ? hashedVal : value);
          var selectedOption = $element[0].options[$element[0].selectedIndex];
          setOptionAsSelected(jqLite(selectedOption));
        } else {
          if (value == null && self.emptyOption) {
            self.removeUnknownOption();
            self.selectEmptyOption();
          } else if (self.unknownOption.parent().length) {
            self.updateUnknownOption(value);
          } else {
            self.renderUnknownOption(value);
          }
        }
      };
      self.addOption = function (value, element) {
        if (element[0].nodeType === NODE_TYPE_COMMENT) return;
        assertNotHasOwnProperty(value, '"option value"');
        if (value === "") {
          self.hasEmptyOption = true;
          self.emptyOption = element;
        }
        var count = optionsMap.get(value) || 0;
        optionsMap.put(value, count + 1);
        scheduleRender();
      };
      self.removeOption = function (value) {
        var count = optionsMap.get(value);
        if (count) {
          if (count === 1) {
            optionsMap.remove(value);
            if (value === "") {
              self.hasEmptyOption = false;
              self.emptyOption = undefined;
            }
          } else {
            optionsMap.put(value, count - 1);
          }
        }
      };
      self.hasOption = function (value) {
        return !!optionsMap.get(value);
      };
      var renderScheduled = false;
      function scheduleRender() {
        if (renderScheduled) return;
        renderScheduled = true;
        $scope.$$postDigest(function () {
          renderScheduled = false;
          self.ngModelCtrl.$render();
        });
      }
      var updateScheduled = false;
      function scheduleViewValueUpdate(renderAfter) {
        if (updateScheduled) return;
        updateScheduled = true;
        $scope.$$postDigest(function () {
          if ($scope.$$destroyed) return;
          updateScheduled = false;
          self.ngModelCtrl.$setViewValue(self.readValue());
          if (renderAfter) self.ngModelCtrl.$render();
        });
      }
      self.registerOption = function (
        optionScope,
        optionElement,
        optionAttrs,
        interpolateValueFn,
        interpolateTextFn
      ) {
        if (optionAttrs.$attr.ngValue) {
          var oldVal,
            hashedVal = NaN;
          optionAttrs.$observe(
            "value",
            function valueAttributeObserveAction(newVal) {
              var removal;
              var previouslySelected = optionElement.prop("selected");
              if (isDefined(hashedVal)) {
                self.removeOption(oldVal);
                delete self.selectValueMap[hashedVal];
                removal = true;
              }
              hashedVal = hashKey(newVal);
              oldVal = newVal;
              self.selectValueMap[hashedVal] = newVal;
              self.addOption(newVal, optionElement);
              optionElement.attr("value", hashedVal);
              if (removal && previouslySelected) {
                scheduleViewValueUpdate();
              }
            }
          );
        } else if (interpolateValueFn) {
          optionAttrs.$observe(
            "value",
            function valueAttributeObserveAction(newVal) {
              self.readValue();
              var removal;
              var previouslySelected = optionElement.prop("selected");
              if (isDefined(oldVal)) {
                self.removeOption(oldVal);
                removal = true;
              }
              oldVal = newVal;
              self.addOption(newVal, optionElement);
              if (removal && previouslySelected) {
                scheduleViewValueUpdate();
              }
            }
          );
        } else if (interpolateTextFn) {
          optionScope.$watch(
            interpolateTextFn,
            function interpolateWatchAction(newVal, oldVal) {
              optionAttrs.$set("value", newVal);
              var previouslySelected = optionElement.prop("selected");
              if (oldVal !== newVal) {
                self.removeOption(oldVal);
              }
              self.addOption(newVal, optionElement);
              if (oldVal && previouslySelected) {
                scheduleViewValueUpdate();
              }
            }
          );
        } else {
          self.addOption(optionAttrs.value, optionElement);
        }
        optionAttrs.$observe("disabled", function (newVal) {
          if (newVal === "true" || (newVal && optionElement.prop("selected"))) {
            if (self.multiple) {
              scheduleViewValueUpdate(true);
            } else {
              self.ngModelCtrl.$setViewValue(null);
              self.ngModelCtrl.$render();
            }
          }
        });
        optionElement.on("$destroy", function () {
          var currentValue = self.readValue();
          var removeValue = optionAttrs.value;
          self.removeOption(removeValue);
          self.ngModelCtrl.$render();
          if (
            (self.multiple &&
              currentValue &&
              currentValue.indexOf(removeValue) !== -1) ||
            currentValue === removeValue
          ) {
            scheduleViewValueUpdate(true);
          }
        });
      };
      function setOptionAsSelected(optionEl) {
        optionEl.prop("selected", true);
        optionEl.attr("selected", true);
      }
    },
  ];
  var selectDirective = function () {
    return {
      restrict: "E",
      require: ["select", "?ngModel"],
      controller: SelectController,
      priority: 1,
      link: { pre: selectPreLink, post: selectPostLink },
    };
    function selectPreLink(scope, element, attr, ctrls) {
      var selectCtrl = ctrls[0];
      var ngModelCtrl = ctrls[1];
      if (!ngModelCtrl) {
        selectCtrl.registerOption = noop;
        return;
      }
      selectCtrl.ngModelCtrl = ngModelCtrl;
      element.on("change", function () {
        selectCtrl.removeUnknownOption();
        scope.$apply(function () {
          ngModelCtrl.$setViewValue(selectCtrl.readValue());
        });
      });
      if (attr.multiple) {
        selectCtrl.multiple = true;
        selectCtrl.readValue = function readMultipleValue() {
          var array = [];
          forEach(element.find("option"), function (option) {
            if (option.selected && !option.disabled) {
              var val = option.value;
              array.push(
                val in selectCtrl.selectValueMap
                  ? selectCtrl.selectValueMap[val]
                  : val
              );
            }
          });
          return array;
        };
        selectCtrl.writeValue = function writeMultipleValue(value) {
          var items = new HashMap(value);
          forEach(element.find("option"), function (option) {
            option.selected =
              isDefined(items.get(option.value)) ||
              isDefined(items.get(selectCtrl.selectValueMap[option.value]));
          });
        };
        var lastView,
          lastViewRef = NaN;
        scope.$watch(function selectMultipleWatch() {
          if (
            lastViewRef === ngModelCtrl.$viewValue &&
            !equals(lastView, ngModelCtrl.$viewValue)
          ) {
            lastView = shallowCopy(ngModelCtrl.$viewValue);
            ngModelCtrl.$render();
          }
          lastViewRef = ngModelCtrl.$viewValue;
        });
        ngModelCtrl.$isEmpty = function (value) {
          return !value || value.length === 0;
        };
      }
    }
    function selectPostLink(scope, element, attrs, ctrls) {
      var ngModelCtrl = ctrls[1];
      if (!ngModelCtrl) return;
      var selectCtrl = ctrls[0];
      ngModelCtrl.$render = function () {
        selectCtrl.writeValue(ngModelCtrl.$viewValue);
      };
    }
  };
  var optionDirective = [
    "$interpolate",
    function ($interpolate) {
      return {
        restrict: "E",
        priority: 100,
        compile: function (element, attr) {
          var interpolateValueFn, interpolateTextFn;
          if (isDefined(attr.ngValue)) {
          } else if (isDefined(attr.value)) {
            interpolateValueFn = $interpolate(attr.value, true);
          } else {
            interpolateTextFn = $interpolate(element.text(), true);
            if (!interpolateTextFn) {
              attr.$set("value", element.text());
            }
          }
          return function (scope, element, attr) {
            var selectCtrlName = "$selectController",
              parent = element.parent(),
              selectCtrl =
                parent.data(selectCtrlName) ||
                parent.parent().data(selectCtrlName);
            if (selectCtrl) {
              selectCtrl.registerOption(
                scope,
                element,
                attr,
                interpolateValueFn,
                interpolateTextFn
              );
            }
          };
        },
      };
    },
  ];
  var requiredDirective = function () {
    return {
      restrict: "A",
      require: "?ngModel",
      link: function (scope, elm, attr, ctrl) {
        if (!ctrl) return;
        attr.required = true;
        ctrl.$validators.required = function (modelValue, viewValue) {
          return !attr.required || !ctrl.$isEmpty(viewValue);
        };
        attr.$observe("required", function () {
          ctrl.$validate();
        });
      },
    };
  };
  var patternDirective = function () {
    return {
      restrict: "A",
      require: "?ngModel",
      link: function (scope, elm, attr, ctrl) {
        if (!ctrl) return;
        var regexp,
          patternExp = attr.ngPattern || attr.pattern;
        attr.$observe("pattern", function (regex) {
          if (isString(regex) && regex.length > 0) {
            regex = new RegExp("^" + regex + "$");
          }
          if (regex && !regex.test) {
            throw minErr("ngPattern")(
              "noregexp",
              "Expected {0} to be a RegExp but was {1}. Element: {2}",
              patternExp,
              regex,
              startingTag(elm)
            );
          }
          regexp = regex || undefined;
          ctrl.$validate();
        });
        ctrl.$validators.pattern = function (modelValue, viewValue) {
          return (
            ctrl.$isEmpty(viewValue) ||
            isUndefined(regexp) ||
            regexp.test(viewValue)
          );
        };
      },
    };
  };
  var maxlengthDirective = function () {
    return {
      restrict: "A",
      require: "?ngModel",
      link: function (scope, elm, attr, ctrl) {
        if (!ctrl) return;
        var maxlength = -1;
        attr.$observe("maxlength", function (value) {
          var intVal = toInt(value);
          maxlength = isNumberNaN(intVal) ? -1 : intVal;
          ctrl.$validate();
        });
        ctrl.$validators.maxlength = function (modelValue, viewValue) {
          return (
            maxlength < 0 ||
            ctrl.$isEmpty(viewValue) ||
            viewValue.length <= maxlength
          );
        };
      },
    };
  };
  var minlengthDirective = function () {
    return {
      restrict: "A",
      require: "?ngModel",
      link: function (scope, elm, attr, ctrl) {
        if (!ctrl) return;
        var minlength = 0;
        attr.$observe("minlength", function (value) {
          minlength = toInt(value) || 0;
          ctrl.$validate();
        });
        ctrl.$validators.minlength = function (modelValue, viewValue) {
          return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
        };
      },
    };
  };
  if (window.angular.bootstrap) {
    if (window.console) {
      console.log("WARNING: Tried to load angular more than once.");
    }
    return;
  }
  bindJQuery();
  publishExternalAPI(angular);
  angular.module(
    "ngLocale",
    [],
    [
      "$provide",
      function ($provide) {
        var PLURAL_CATEGORY = {
          ZERO: "zero",
          ONE: "one",
          TWO: "two",
          FEW: "few",
          MANY: "many",
          OTHER: "other",
        };
        function getDecimals(n) {
          n = n + "";
          var i = n.indexOf(".");
          return i == -1 ? 0 : n.length - i - 1;
        }
        function getVF(n, opt_precision) {
          var v = opt_precision;
          if (undefined === v) {
            v = Math.min(getDecimals(n), 3);
          }
          var base = Math.pow(10, v);
          var f = ((n * base) | 0) % base;
          return { v: v, f: f };
        }
        $provide.value("$locale", {
          DATETIME_FORMATS: {
            AMPMS: ["AM", "PM"],
            DAY: [
              "Sunday",
              "Monday",
              "Tuesday",
              "Wednesday",
              "Thursday",
              "Friday",
              "Saturday",
            ],
            ERANAMES: ["Before Christ", "Anno Domini"],
            ERAS: ["BC", "AD"],
            FIRSTDAYOFWEEK: 6,
            MONTH: [
              "January",
              "February",
              "March",
              "April",
              "May",
              "June",
              "July",
              "August",
              "September",
              "October",
              "November",
              "December",
            ],
            SHORTDAY: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            SHORTMONTH: [
              "Jan",
              "Feb",
              "Mar",
              "Apr",
              "May",
              "Jun",
              "Jul",
              "Aug",
              "Sep",
              "Oct",
              "Nov",
              "Dec",
            ],
            STANDALONEMONTH: [
              "January",
              "February",
              "March",
              "April",
              "May",
              "June",
              "July",
              "August",
              "September",
              "October",
              "November",
              "December",
            ],
            WEEKENDRANGE: [5, 6],
            fullDate: "EEEE, MMMM d, y",
            longDate: "MMMM d, y",
            medium: "MMM d, y h:mm:ss a",
            mediumDate: "MMM d, y",
            mediumTime: "h:mm:ss a",
            short: "M/d/yy h:mm a",
            shortDate: "M/d/yy",
            shortTime: "h:mm a",
          },
          NUMBER_FORMATS: {
            CURRENCY_SYM: "$",
            DECIMAL_SEP: ".",
            GROUP_SEP: ",",
            PATTERNS: [
              {
                gSize: 3,
                lgSize: 3,
                maxFrac: 3,
                minFrac: 0,
                minInt: 1,
                negPre: "-",
                negSuf: "",
                posPre: "",
                posSuf: "",
              },
              {
                gSize: 3,
                lgSize: 3,
                maxFrac: 2,
                minFrac: 2,
                minInt: 1,
                negPre: "-",
                negSuf: "",
                posPre: "",
                posSuf: "",
              },
            ],
          },
          id: "en-us",
          localeID: "en_US",
          pluralCat: function (n, opt_precision) {
            var i = n | 0;
            var vf = getVF(n, opt_precision);
            if (i == 1 && vf.v == 0) {
              return PLURAL_CATEGORY.ONE;
            }
            return PLURAL_CATEGORY.OTHER;
          },
        });
      },
    ]
  );
  jqLite(function () {
    angularInit(window.document, bootstrap);
  });
})(window);
!window.angular.$$csp().noInlineStyle &&
  window.angular
    .element(document.head)
    .prepend(
      '<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>'
    );
(function (window, angular) {
  "use strict";
  var ELEMENT_NODE = 1;
  var COMMENT_NODE = 8;
  var ADD_CLASS_SUFFIX = "-add";
  var REMOVE_CLASS_SUFFIX = "-remove";
  var EVENT_CLASS_PREFIX = "ng-";
  var ACTIVE_CLASS_SUFFIX = "-active";
  var PREPARE_CLASS_SUFFIX = "-prepare";
  var NG_ANIMATE_CLASSNAME = "ng-animate";
  var NG_ANIMATE_CHILDREN_DATA = "$$ngAnimateChildren";
  var CSS_PREFIX = "",
    TRANSITION_PROP,
    TRANSITIONEND_EVENT,
    ANIMATION_PROP,
    ANIMATIONEND_EVENT;
  if (
    window.ontransitionend === undefined &&
    window.onwebkittransitionend !== undefined
  ) {
    CSS_PREFIX = "-webkit-";
    TRANSITION_PROP = "WebkitTransition";
    TRANSITIONEND_EVENT = "webkitTransitionEnd transitionend";
  } else {
    TRANSITION_PROP = "transition";
    TRANSITIONEND_EVENT = "transitionend";
  }
  if (
    window.onanimationend === undefined &&
    window.onwebkitanimationend !== undefined
  ) {
    CSS_PREFIX = "-webkit-";
    ANIMATION_PROP = "WebkitAnimation";
    ANIMATIONEND_EVENT = "webkitAnimationEnd animationend";
  } else {
    ANIMATION_PROP = "animation";
    ANIMATIONEND_EVENT = "animationend";
  }
  var DURATION_KEY = "Duration";
  var PROPERTY_KEY = "Property";
  var DELAY_KEY = "Delay";
  var TIMING_KEY = "TimingFunction";
  var ANIMATION_ITERATION_COUNT_KEY = "IterationCount";
  var ANIMATION_PLAYSTATE_KEY = "PlayState";
  var SAFE_FAST_FORWARD_DURATION_VALUE = 9999;
  var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
  var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
  var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
  var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;
  var ngMinErr = angular.$$minErr("ng");
  function assertArg(arg, name, reason) {
    if (!arg) {
      throw ngMinErr(
        "areq",
        "Argument '{0}' is {1}",
        name || "?",
        reason || "required"
      );
    }
    return arg;
  }
  function mergeClasses(a, b) {
    if (!a && !b) return "";
    if (!a) return b;
    if (!b) return a;
    if (isArray(a)) a = a.join(" ");
    if (isArray(b)) b = b.join(" ");
    return a + " " + b;
  }
  function packageStyles(options) {
    var styles = {};
    if (options && (options.to || options.from)) {
      styles.to = options.to;
      styles.from = options.from;
    }
    return styles;
  }
  function pendClasses(classes, fix, isPrefix) {
    var className = "";
    classes = isArray(classes)
      ? classes
      : classes && isString(classes) && classes.length
      ? classes.split(/\s+/)
      : [];
    forEach(classes, function (klass, i) {
      if (klass && klass.length > 0) {
        className += i > 0 ? " " : "";
        className += isPrefix ? fix + klass : klass + fix;
      }
    });
    return className;
  }
  function removeFromArray(arr, val) {
    var index = arr.indexOf(val);
    if (val >= 0) {
      arr.splice(index, 1);
    }
  }
  function stripCommentsFromElement(element) {
    if (element instanceof jqLite) {
      switch (element.length) {
        case 0:
          return element;
        case 1:
          if (element[0].nodeType === ELEMENT_NODE) {
            return element;
          }
          break;
        default:
          return jqLite(extractElementNode(element));
      }
    }
    if (element.nodeType === ELEMENT_NODE) {
      return jqLite(element);
    }
  }
  function extractElementNode(element) {
    if (!element[0]) return element;
    for (var i = 0; i < element.length; i++) {
      var elm = element[i];
      if (elm.nodeType === ELEMENT_NODE) {
        return elm;
      }
    }
  }
  function $$addClass($$jqLite, element, className) {
    forEach(element, function (elm) {
      $$jqLite.addClass(elm, className);
    });
  }
  function $$removeClass($$jqLite, element, className) {
    forEach(element, function (elm) {
      $$jqLite.removeClass(elm, className);
    });
  }
  function applyAnimationClassesFactory($$jqLite) {
    return function (element, options) {
      if (options.addClass) {
        $$addClass($$jqLite, element, options.addClass);
        options.addClass = null;
      }
      if (options.removeClass) {
        $$removeClass($$jqLite, element, options.removeClass);
        options.removeClass = null;
      }
    };
  }
  function prepareAnimationOptions(options) {
    options = options || {};
    if (!options.$$prepared) {
      var domOperation = options.domOperation || noop;
      options.domOperation = function () {
        options.$$domOperationFired = true;
        domOperation();
        domOperation = noop;
      };
      options.$$prepared = true;
    }
    return options;
  }
  function applyAnimationStyles(element, options) {
    applyAnimationFromStyles(element, options);
    applyAnimationToStyles(element, options);
  }
  function applyAnimationFromStyles(element, options) {
    if (options.from) {
      element.css(options.from);
      options.from = null;
    }
  }
  function applyAnimationToStyles(element, options) {
    if (options.to) {
      element.css(options.to);
      options.to = null;
    }
  }
  function mergeAnimationDetails(element, oldAnimation, newAnimation) {
    var target = oldAnimation.options || {};
    var newOptions = newAnimation.options || {};
    var toAdd = (target.addClass || "") + " " + (newOptions.addClass || "");
    var toRemove =
      (target.removeClass || "") + " " + (newOptions.removeClass || "");
    var classes = resolveElementClasses(element.attr("class"), toAdd, toRemove);
    if (newOptions.preparationClasses) {
      target.preparationClasses = concatWithSpace(
        newOptions.preparationClasses,
        target.preparationClasses
      );
      delete newOptions.preparationClasses;
    }
    var realDomOperation =
      target.domOperation !== noop ? target.domOperation : null;
    extend(target, newOptions);
    if (realDomOperation) {
      target.domOperation = realDomOperation;
    }
    if (classes.addClass) {
      target.addClass = classes.addClass;
    } else {
      target.addClass = null;
    }
    if (classes.removeClass) {
      target.removeClass = classes.removeClass;
    } else {
      target.removeClass = null;
    }
    oldAnimation.addClass = target.addClass;
    oldAnimation.removeClass = target.removeClass;
    return target;
  }
  function resolveElementClasses(existing, toAdd, toRemove) {
    var ADD_CLASS = 1;
    var REMOVE_CLASS = -1;
    var flags = {};
    existing = splitClassesToLookup(existing);
    toAdd = splitClassesToLookup(toAdd);
    forEach(toAdd, function (value, key) {
      flags[key] = ADD_CLASS;
    });
    toRemove = splitClassesToLookup(toRemove);
    forEach(toRemove, function (value, key) {
      flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
    });
    var classes = { addClass: "", removeClass: "" };
    forEach(flags, function (val, klass) {
      var prop, allow;
      if (val === ADD_CLASS) {
        prop = "addClass";
        allow = !existing[klass] || existing[klass + REMOVE_CLASS_SUFFIX];
      } else if (val === REMOVE_CLASS) {
        prop = "removeClass";
        allow = existing[klass] || existing[klass + ADD_CLASS_SUFFIX];
      }
      if (allow) {
        if (classes[prop].length) {
          classes[prop] += " ";
        }
        classes[prop] += klass;
      }
    });
    function splitClassesToLookup(classes) {
      if (isString(classes)) {
        classes = classes.split(" ");
      }
      var obj = {};
      forEach(classes, function (klass) {
        if (klass.length) {
          obj[klass] = true;
        }
      });
      return obj;
    }
    return classes;
  }
  function getDomNode(element) {
    return element instanceof jqLite ? element[0] : element;
  }
  function applyGeneratedPreparationClasses(element, event, options) {
    var classes = "";
    if (event) {
      classes = pendClasses(event, EVENT_CLASS_PREFIX, true);
    }
    if (options.addClass) {
      classes = concatWithSpace(
        classes,
        pendClasses(options.addClass, ADD_CLASS_SUFFIX)
      );
    }
    if (options.removeClass) {
      classes = concatWithSpace(
        classes,
        pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX)
      );
    }
    if (classes.length) {
      options.preparationClasses = classes;
      element.addClass(classes);
    }
  }
  function clearGeneratedClasses(element, options) {
    if (options.preparationClasses) {
      element.removeClass(options.preparationClasses);
      options.preparationClasses = null;
    }
    if (options.activeClasses) {
      element.removeClass(options.activeClasses);
      options.activeClasses = null;
    }
  }
  function blockTransitions(node, duration) {
    var value = duration ? "-" + duration + "s" : "";
    applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);
    return [TRANSITION_DELAY_PROP, value];
  }
  function blockKeyframeAnimations(node, applyBlock) {
    var value = applyBlock ? "paused" : "";
    var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
    applyInlineStyle(node, [key, value]);
    return [key, value];
  }
  function applyInlineStyle(node, styleTuple) {
    var prop = styleTuple[0];
    var value = styleTuple[1];
    node.style[prop] = value;
  }
  function concatWithSpace(a, b) {
    if (!a) return b;
    if (!b) return a;
    return a + " " + b;
  }
  var $$rAFSchedulerFactory = [
    "$$rAF",
    function ($$rAF) {
      var queue, cancelFn;
      function scheduler(tasks) {
        queue = queue.concat(tasks);
        nextTick();
      }
      queue = scheduler.queue = [];
      scheduler.waitUntilQuiet = function (fn) {
        if (cancelFn) cancelFn();
        cancelFn = $$rAF(function () {
          cancelFn = null;
          fn();
          nextTick();
        });
      };
      return scheduler;
      function nextTick() {
        if (!queue.length) return;
        var items = queue.shift();
        for (var i = 0; i < items.length; i++) {
          items[i]();
        }
        if (!cancelFn) {
          $$rAF(function () {
            if (!cancelFn) nextTick();
          });
        }
      }
    },
  ];
  var $$AnimateChildrenDirective = [
    "$interpolate",
    function ($interpolate) {
      return {
        link: function (scope, element, attrs) {
          var val = attrs.ngAnimateChildren;
          if (isString(val) && val.length === 0) {
            element.data(NG_ANIMATE_CHILDREN_DATA, true);
          } else {
            setData($interpolate(val)(scope));
            attrs.$observe("ngAnimateChildren", setData);
          }
          function setData(value) {
            value = value === "on" || value === "true";
            element.data(NG_ANIMATE_CHILDREN_DATA, value);
          }
        },
      };
    },
  ];
  var ANIMATE_TIMER_KEY = "$$animateCss";
  var ONE_SECOND = 1e3;
  var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
  var CLOSING_TIME_BUFFER = 1.5;
  var DETECT_CSS_PROPERTIES = {
    transitionDuration: TRANSITION_DURATION_PROP,
    transitionDelay: TRANSITION_DELAY_PROP,
    transitionProperty: TRANSITION_PROP + PROPERTY_KEY,
    animationDuration: ANIMATION_DURATION_PROP,
    animationDelay: ANIMATION_DELAY_PROP,
    animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY,
  };
  var DETECT_STAGGER_CSS_PROPERTIES = {
    transitionDuration: TRANSITION_DURATION_PROP,
    transitionDelay: TRANSITION_DELAY_PROP,
    animationDuration: ANIMATION_DURATION_PROP,
    animationDelay: ANIMATION_DELAY_PROP,
  };
  function getCssKeyframeDurationStyle(duration) {
    return [ANIMATION_DURATION_PROP, duration + "s"];
  }
  function getCssDelayStyle(delay, isKeyframeAnimation) {
    var prop = isKeyframeAnimation
      ? ANIMATION_DELAY_PROP
      : TRANSITION_DELAY_PROP;
    return [prop, delay + "s"];
  }
  function computeCssStyles($window, element, properties) {
    var styles = Object.create(null);
    var detectedStyles = $window.getComputedStyle(element) || {};
    forEach(properties, function (formalStyleName, actualStyleName) {
      var val = detectedStyles[formalStyleName];
      if (val) {
        var c = val.charAt(0);
        if (c === "-" || c === "+" || c >= 0) {
          val = parseMaxTime(val);
        }
        if (val === 0) {
          val = null;
        }
        styles[actualStyleName] = val;
      }
    });
    return styles;
  }
  function parseMaxTime(str) {
    var maxValue = 0;
    var values = str.split(/\s*,\s*/);
    forEach(values, function (value) {
      if (value.charAt(value.length - 1) === "s") {
        value = value.substring(0, value.length - 1);
      }
      value = parseFloat(value) || 0;
      maxValue = maxValue ? Math.max(value, maxValue) : value;
    });
    return maxValue;
  }
  function truthyTimingValue(val) {
    return val === 0 || val != null;
  }
  function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
    var style = TRANSITION_PROP;
    var value = duration + "s";
    if (applyOnlyDuration) {
      style += DURATION_KEY;
    } else {
      value += " linear all";
    }
    return [style, value];
  }
  function createLocalCacheLookup() {
    var cache = Object.create(null);
    return {
      flush: function () {
        cache = Object.create(null);
      },
      count: function (key) {
        var entry = cache[key];
        return entry ? entry.total : 0;
      },
      get: function (key) {
        var entry = cache[key];
        return entry && entry.value;
      },
      put: function (key, value) {
        if (!cache[key]) {
          cache[key] = { total: 1, value: value };
        } else {
          cache[key].total++;
        }
      },
    };
  }
  function registerRestorableStyles(backup, node, properties) {
    forEach(properties, function (prop) {
      backup[prop] = isDefined(backup[prop])
        ? backup[prop]
        : node.style.getPropertyValue(prop);
    });
  }
  var $AnimateCssProvider = [
    "$animateProvider",
    function ($animateProvider) {
      var gcsLookup = createLocalCacheLookup();
      var gcsStaggerLookup = createLocalCacheLookup();
      this.$get = [
        "$window",
        "$$jqLite",
        "$$AnimateRunner",
        "$timeout",
        "$$forceReflow",
        "$sniffer",
        "$$rAFScheduler",
        "$$animateQueue",
        function (
          $window,
          $$jqLite,
          $$AnimateRunner,
          $timeout,
          $$forceReflow,
          $sniffer,
          $$rAFScheduler,
          $$animateQueue
        ) {
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          var parentCounter = 0;
          function gcsHashFn(node, extraClasses) {
            var KEY = "$$ngAnimateParentKey";
            var parentNode = node.parentNode;
            var parentID =
              parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
            return (
              parentID + "-" + node.getAttribute("class") + "-" + extraClasses
            );
          }
          function computeCachedCssStyles(
            node,
            className,
            cacheKey,
            properties
          ) {
            var timings = gcsLookup.get(cacheKey);
            if (!timings) {
              timings = computeCssStyles($window, node, properties);
              if (timings.animationIterationCount === "infinite") {
                timings.animationIterationCount = 1;
              }
            }
            gcsLookup.put(cacheKey, timings);
            return timings;
          }
          function computeCachedCssStaggerStyles(
            node,
            className,
            cacheKey,
            properties
          ) {
            var stagger;
            if (gcsLookup.count(cacheKey) > 0) {
              stagger = gcsStaggerLookup.get(cacheKey);
              if (!stagger) {
                var staggerClassName = pendClasses(className, "-stagger");
                $$jqLite.addClass(node, staggerClassName);
                stagger = computeCssStyles($window, node, properties);
                stagger.animationDuration = Math.max(
                  stagger.animationDuration,
                  0
                );
                stagger.transitionDuration = Math.max(
                  stagger.transitionDuration,
                  0
                );
                $$jqLite.removeClass(node, staggerClassName);
                gcsStaggerLookup.put(cacheKey, stagger);
              }
            }
            return stagger || {};
          }
          var rafWaitQueue = [];
          function waitUntilQuiet(callback) {
            rafWaitQueue.push(callback);
            $$rAFScheduler.waitUntilQuiet(function () {
              gcsLookup.flush();
              gcsStaggerLookup.flush();
              var pageWidth = $$forceReflow();
              for (var i = 0; i < rafWaitQueue.length; i++) {
                rafWaitQueue[i](pageWidth);
              }
              rafWaitQueue.length = 0;
            });
          }
          function computeTimings(node, className, cacheKey) {
            var timings = computeCachedCssStyles(
              node,
              className,
              cacheKey,
              DETECT_CSS_PROPERTIES
            );
            var aD = timings.animationDelay;
            var tD = timings.transitionDelay;
            timings.maxDelay = aD && tD ? Math.max(aD, tD) : aD || tD;
            timings.maxDuration = Math.max(
              timings.animationDuration * timings.animationIterationCount,
              timings.transitionDuration
            );
            return timings;
          }
          return function init(element, initialOptions) {
            var options = initialOptions || {};
            if (!options.$$prepared) {
              options = prepareAnimationOptions(copy(options));
            }
            var restoreStyles = {};
            var node = getDomNode(element);
            if (!node || !node.parentNode || !$$animateQueue.enabled()) {
              return closeAndReturnNoopAnimator();
            }
            var temporaryStyles = [];
            var classes = element.attr("class");
            var styles = packageStyles(options);
            var animationClosed;
            var animationPaused;
            var animationCompleted;
            var runner;
            var runnerHost;
            var maxDelay;
            var maxDelayTime;
            var maxDuration;
            var maxDurationTime;
            var startTime;
            var events = [];
            if (
              options.duration === 0 ||
              (!$sniffer.animations && !$sniffer.transitions)
            ) {
              return closeAndReturnNoopAnimator();
            }
            var method =
              options.event && isArray(options.event)
                ? options.event.join(" ")
                : options.event;
            var isStructural = method && options.structural;
            var structuralClassName = "";
            var addRemoveClassName = "";
            if (isStructural) {
              structuralClassName = pendClasses(
                method,
                EVENT_CLASS_PREFIX,
                true
              );
            } else if (method) {
              structuralClassName = method;
            }
            if (options.addClass) {
              addRemoveClassName += pendClasses(
                options.addClass,
                ADD_CLASS_SUFFIX
              );
            }
            if (options.removeClass) {
              if (addRemoveClassName.length) {
                addRemoveClassName += " ";
              }
              addRemoveClassName += pendClasses(
                options.removeClass,
                REMOVE_CLASS_SUFFIX
              );
            }
            if (options.applyClassesEarly && addRemoveClassName.length) {
              applyAnimationClasses(element, options);
            }
            var preparationClasses = [structuralClassName, addRemoveClassName]
              .join(" ")
              .trim();
            var fullClassName = classes + " " + preparationClasses;
            var activeClasses = pendClasses(
              preparationClasses,
              ACTIVE_CLASS_SUFFIX
            );
            var hasToStyles = styles.to && Object.keys(styles.to).length > 0;
            var containsKeyframeAnimation =
              (options.keyframeStyle || "").length > 0;
            if (
              !containsKeyframeAnimation &&
              !hasToStyles &&
              !preparationClasses
            ) {
              return closeAndReturnNoopAnimator();
            }
            var cacheKey, stagger;
            if (options.stagger > 0) {
              var staggerVal = parseFloat(options.stagger);
              stagger = {
                transitionDelay: staggerVal,
                animationDelay: staggerVal,
                transitionDuration: 0,
                animationDuration: 0,
              };
            } else {
              cacheKey = gcsHashFn(node, fullClassName);
              stagger = computeCachedCssStaggerStyles(
                node,
                preparationClasses,
                cacheKey,
                DETECT_STAGGER_CSS_PROPERTIES
              );
            }
            if (!options.$$skipPreparationClasses) {
              $$jqLite.addClass(element, preparationClasses);
            }
            var applyOnlyDuration;
            if (options.transitionStyle) {
              var transitionStyle = [TRANSITION_PROP, options.transitionStyle];
              applyInlineStyle(node, transitionStyle);
              temporaryStyles.push(transitionStyle);
            }
            if (options.duration >= 0) {
              applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
              var durationStyle = getCssTransitionDurationStyle(
                options.duration,
                applyOnlyDuration
              );
              applyInlineStyle(node, durationStyle);
              temporaryStyles.push(durationStyle);
            }
            if (options.keyframeStyle) {
              var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];
              applyInlineStyle(node, keyframeStyle);
              temporaryStyles.push(keyframeStyle);
            }
            var itemIndex = stagger
              ? options.staggerIndex >= 0
                ? options.staggerIndex
                : gcsLookup.count(cacheKey)
              : 0;
            var isFirst = itemIndex === 0;
            if (isFirst && !options.skipBlocking) {
              blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
            }
            var timings = computeTimings(node, fullClassName, cacheKey);
            var relativeDelay = timings.maxDelay;
            maxDelay = Math.max(relativeDelay, 0);
            maxDuration = timings.maxDuration;
            var flags = {};
            flags.hasTransitions = timings.transitionDuration > 0;
            flags.hasAnimations = timings.animationDuration > 0;
            flags.hasTransitionAll =
              flags.hasTransitions && timings.transitionProperty === "all";
            flags.applyTransitionDuration =
              hasToStyles &&
              ((flags.hasTransitions && !flags.hasTransitionAll) ||
                (flags.hasAnimations && !flags.hasTransitions));
            flags.applyAnimationDuration =
              options.duration && flags.hasAnimations;
            flags.applyTransitionDelay =
              truthyTimingValue(options.delay) &&
              (flags.applyTransitionDuration || flags.hasTransitions);
            flags.applyAnimationDelay =
              truthyTimingValue(options.delay) && flags.hasAnimations;
            flags.recalculateTimingStyles = addRemoveClassName.length > 0;
            if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
              maxDuration = options.duration
                ? parseFloat(options.duration)
                : maxDuration;
              if (flags.applyTransitionDuration) {
                flags.hasTransitions = true;
                timings.transitionDuration = maxDuration;
                applyOnlyDuration =
                  node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;
                temporaryStyles.push(
                  getCssTransitionDurationStyle(maxDuration, applyOnlyDuration)
                );
              }
              if (flags.applyAnimationDuration) {
                flags.hasAnimations = true;
                timings.animationDuration = maxDuration;
                temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
              }
            }
            if (maxDuration === 0 && !flags.recalculateTimingStyles) {
              return closeAndReturnNoopAnimator();
            }
            if (options.delay != null) {
              var delayStyle;
              if (typeof options.delay !== "boolean") {
                delayStyle = parseFloat(options.delay);
                maxDelay = Math.max(delayStyle, 0);
              }
              if (flags.applyTransitionDelay) {
                temporaryStyles.push(getCssDelayStyle(delayStyle));
              }
              if (flags.applyAnimationDelay) {
                temporaryStyles.push(getCssDelayStyle(delayStyle, true));
              }
            }
            if (options.duration == null && timings.transitionDuration > 0) {
              flags.recalculateTimingStyles =
                flags.recalculateTimingStyles || isFirst;
            }
            maxDelayTime = maxDelay * ONE_SECOND;
            maxDurationTime = maxDuration * ONE_SECOND;
            if (!options.skipBlocking) {
              flags.blockTransition = timings.transitionDuration > 0;
              flags.blockKeyframeAnimation =
                timings.animationDuration > 0 &&
                stagger.animationDelay > 0 &&
                stagger.animationDuration === 0;
            }
            if (options.from) {
              if (options.cleanupStyles) {
                registerRestorableStyles(
                  restoreStyles,
                  node,
                  Object.keys(options.from)
                );
              }
              applyAnimationFromStyles(element, options);
            }
            if (flags.blockTransition || flags.blockKeyframeAnimation) {
              applyBlocking(maxDuration);
            } else if (!options.skipBlocking) {
              blockTransitions(node, false);
            }
            return {
              $$willAnimate: true,
              end: endFn,
              start: function () {
                if (animationClosed) return;
                runnerHost = {
                  end: endFn,
                  cancel: cancelFn,
                  resume: null,
                  pause: null,
                };
                runner = new $$AnimateRunner(runnerHost);
                waitUntilQuiet(start);
                return runner;
              },
            };
            function endFn() {
              close();
            }
            function cancelFn() {
              close(true);
            }
            function close(rejected) {
              if (animationClosed || (animationCompleted && animationPaused))
                return;
              animationClosed = true;
              animationPaused = false;
              if (!options.$$skipPreparationClasses) {
                $$jqLite.removeClass(element, preparationClasses);
              }
              $$jqLite.removeClass(element, activeClasses);
              blockKeyframeAnimations(node, false);
              blockTransitions(node, false);
              forEach(temporaryStyles, function (entry) {
                node.style[entry[0]] = "";
              });
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              if (Object.keys(restoreStyles).length) {
                forEach(restoreStyles, function (value, prop) {
                  if (value) {
                    node.style.setProperty(prop, value);
                  } else {
                    node.style.removeProperty(prop);
                  }
                });
              }
              if (options.onDone) {
                options.onDone();
              }
              if (events && events.length) {
                element.off(events.join(" "), onAnimationProgress);
              }
              var animationTimerData = element.data(ANIMATE_TIMER_KEY);
              if (animationTimerData) {
                $timeout.cancel(animationTimerData[0].timer);
                element.removeData(ANIMATE_TIMER_KEY);
              }
              if (runner) {
                runner.complete(!rejected);
              }
            }
            function applyBlocking(duration) {
              if (flags.blockTransition) {
                blockTransitions(node, duration);
              }
              if (flags.blockKeyframeAnimation) {
                blockKeyframeAnimations(node, !!duration);
              }
            }
            function closeAndReturnNoopAnimator() {
              runner = new $$AnimateRunner({ end: endFn, cancel: cancelFn });
              waitUntilQuiet(noop);
              close();
              return {
                $$willAnimate: false,
                start: function () {
                  return runner;
                },
                end: endFn,
              };
            }
            function onAnimationProgress(event) {
              event.stopPropagation();
              var ev = event.originalEvent || event;
              var timeStamp = ev.$manualTimeStamp || Date.now();
              var elapsedTime = parseFloat(
                ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES)
              );
              if (
                Math.max(timeStamp - startTime, 0) >= maxDelayTime &&
                elapsedTime >= maxDuration
              ) {
                animationCompleted = true;
                close();
              }
            }
            function start() {
              if (animationClosed) return;
              if (!node.parentNode) {
                close();
                return;
              }
              var playPause = function (playAnimation) {
                if (!animationCompleted) {
                  animationPaused = !playAnimation;
                  if (timings.animationDuration) {
                    var value = blockKeyframeAnimations(node, animationPaused);
                    if (animationPaused) {
                      temporaryStyles.push(value);
                    } else {
                      removeFromArray(temporaryStyles, value);
                    }
                  }
                } else if (animationPaused && playAnimation) {
                  animationPaused = false;
                  close();
                }
              };
              var maxStagger =
                itemIndex > 0 &&
                ((timings.transitionDuration &&
                  stagger.transitionDuration === 0) ||
                  (timings.animationDuration &&
                    stagger.animationDuration === 0)) &&
                Math.max(stagger.animationDelay, stagger.transitionDelay);
              if (maxStagger) {
                $timeout(
                  triggerAnimationStart,
                  Math.floor(maxStagger * itemIndex * ONE_SECOND),
                  false
                );
              } else {
                triggerAnimationStart();
              }
              runnerHost.resume = function () {
                playPause(true);
              };
              runnerHost.pause = function () {
                playPause(false);
              };
              function triggerAnimationStart() {
                if (animationClosed) return;
                applyBlocking(false);
                forEach(temporaryStyles, function (entry) {
                  var key = entry[0];
                  var value = entry[1];
                  node.style[key] = value;
                });
                applyAnimationClasses(element, options);
                $$jqLite.addClass(element, activeClasses);
                if (flags.recalculateTimingStyles) {
                  fullClassName =
                    node.getAttribute("class") + " " + preparationClasses;
                  cacheKey = gcsHashFn(node, fullClassName);
                  timings = computeTimings(node, fullClassName, cacheKey);
                  relativeDelay = timings.maxDelay;
                  maxDelay = Math.max(relativeDelay, 0);
                  maxDuration = timings.maxDuration;
                  if (maxDuration === 0) {
                    close();
                    return;
                  }
                  flags.hasTransitions = timings.transitionDuration > 0;
                  flags.hasAnimations = timings.animationDuration > 0;
                }
                if (flags.applyAnimationDelay) {
                  relativeDelay =
                    typeof options.delay !== "boolean" &&
                    truthyTimingValue(options.delay)
                      ? parseFloat(options.delay)
                      : relativeDelay;
                  maxDelay = Math.max(relativeDelay, 0);
                  timings.animationDelay = relativeDelay;
                  delayStyle = getCssDelayStyle(relativeDelay, true);
                  temporaryStyles.push(delayStyle);
                  node.style[delayStyle[0]] = delayStyle[1];
                }
                maxDelayTime = maxDelay * ONE_SECOND;
                maxDurationTime = maxDuration * ONE_SECOND;
                if (options.easing) {
                  var easeProp,
                    easeVal = options.easing;
                  if (flags.hasTransitions) {
                    easeProp = TRANSITION_PROP + TIMING_KEY;
                    temporaryStyles.push([easeProp, easeVal]);
                    node.style[easeProp] = easeVal;
                  }
                  if (flags.hasAnimations) {
                    easeProp = ANIMATION_PROP + TIMING_KEY;
                    temporaryStyles.push([easeProp, easeVal]);
                    node.style[easeProp] = easeVal;
                  }
                }
                if (timings.transitionDuration) {
                  events.push(TRANSITIONEND_EVENT);
                }
                if (timings.animationDuration) {
                  events.push(ANIMATIONEND_EVENT);
                }
                startTime = Date.now();
                var timerTime =
                  maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;
                var endTime = startTime + timerTime;
                var animationsData = element.data(ANIMATE_TIMER_KEY) || [];
                var setupFallbackTimer = true;
                if (animationsData.length) {
                  var currentTimerData = animationsData[0];
                  setupFallbackTimer =
                    endTime > currentTimerData.expectedEndTime;
                  if (setupFallbackTimer) {
                    $timeout.cancel(currentTimerData.timer);
                  } else {
                    animationsData.push(close);
                  }
                }
                if (setupFallbackTimer) {
                  var timer = $timeout(onAnimationExpired, timerTime, false);
                  animationsData[0] = {
                    timer: timer,
                    expectedEndTime: endTime,
                  };
                  animationsData.push(close);
                  element.data(ANIMATE_TIMER_KEY, animationsData);
                }
                if (events.length) {
                  element.on(events.join(" "), onAnimationProgress);
                }
                if (options.to) {
                  if (options.cleanupStyles) {
                    registerRestorableStyles(
                      restoreStyles,
                      node,
                      Object.keys(options.to)
                    );
                  }
                  applyAnimationToStyles(element, options);
                }
              }
              function onAnimationExpired() {
                var animationsData = element.data(ANIMATE_TIMER_KEY);
                if (animationsData) {
                  for (var i = 1; i < animationsData.length; i++) {
                    animationsData[i]();
                  }
                  element.removeData(ANIMATE_TIMER_KEY);
                }
              }
            }
          };
        },
      ];
    },
  ];
  var $$AnimateCssDriverProvider = [
    "$$animationProvider",
    function ($$animationProvider) {
      $$animationProvider.drivers.push("$$animateCssDriver");
      var NG_ANIMATE_SHIM_CLASS_NAME = "ng-animate-shim";
      var NG_ANIMATE_ANCHOR_CLASS_NAME = "ng-anchor";
      var NG_OUT_ANCHOR_CLASS_NAME = "ng-anchor-out";
      var NG_IN_ANCHOR_CLASS_NAME = "ng-anchor-in";
      function isDocumentFragment(node) {
        return node.parentNode && node.parentNode.nodeType === 11;
      }
      this.$get = [
        "$animateCss",
        "$rootScope",
        "$$AnimateRunner",
        "$rootElement",
        "$sniffer",
        "$$jqLite",
        "$document",
        function (
          $animateCss,
          $rootScope,
          $$AnimateRunner,
          $rootElement,
          $sniffer,
          $$jqLite,
          $document
        ) {
          if (!$sniffer.animations && !$sniffer.transitions) return noop;
          var bodyNode = $document[0].body;
          var rootNode = getDomNode($rootElement);
          var rootBodyElement = jqLite(
            isDocumentFragment(rootNode) || bodyNode.contains(rootNode)
              ? rootNode
              : bodyNode
          );
          return function initDriverFn(animationDetails) {
            return animationDetails.from && animationDetails.to
              ? prepareFromToAnchorAnimation(
                  animationDetails.from,
                  animationDetails.to,
                  animationDetails.classes,
                  animationDetails.anchors
                )
              : prepareRegularAnimation(animationDetails);
          };
          function filterCssClasses(classes) {
            return classes.replace(/\bng-\S+\b/g, "");
          }
          function getUniqueValues(a, b) {
            if (isString(a)) a = a.split(" ");
            if (isString(b)) b = b.split(" ");
            return a
              .filter(function (val) {
                return b.indexOf(val) === -1;
              })
              .join(" ");
          }
          function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
            var clone = jqLite(getDomNode(outAnchor).cloneNode(true));
            var startingClasses = filterCssClasses(getClassVal(clone));
            outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
            inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
            clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);
            rootBodyElement.append(clone);
            var animatorIn,
              animatorOut = prepareOutAnimation();
            if (!animatorOut) {
              animatorIn = prepareInAnimation();
              if (!animatorIn) {
                return end();
              }
            }
            var startingAnimator = animatorOut || animatorIn;
            return {
              start: function () {
                var runner;
                var currentAnimation = startingAnimator.start();
                currentAnimation.done(function () {
                  currentAnimation = null;
                  if (!animatorIn) {
                    animatorIn = prepareInAnimation();
                    if (animatorIn) {
                      currentAnimation = animatorIn.start();
                      currentAnimation.done(function () {
                        currentAnimation = null;
                        end();
                        runner.complete();
                      });
                      return currentAnimation;
                    }
                  }
                  end();
                  runner.complete();
                });
                runner = new $$AnimateRunner({ end: endFn, cancel: endFn });
                return runner;
                function endFn() {
                  if (currentAnimation) {
                    currentAnimation.end();
                  }
                }
              },
            };
            function calculateAnchorStyles(anchor) {
              var styles = {};
              var coords = getDomNode(anchor).getBoundingClientRect();
              forEach(["width", "height", "top", "left"], function (key) {
                var value = coords[key];
                switch (key) {
                  case "top":
                    value += bodyNode.scrollTop;
                    break;
                  case "left":
                    value += bodyNode.scrollLeft;
                    break;
                }
                styles[key] = Math.floor(value) + "px";
              });
              return styles;
            }
            function prepareOutAnimation() {
              var animator = $animateCss(clone, {
                addClass: NG_OUT_ANCHOR_CLASS_NAME,
                delay: true,
                from: calculateAnchorStyles(outAnchor),
              });
              return animator.$$willAnimate ? animator : null;
            }
            function getClassVal(element) {
              return element.attr("class") || "";
            }
            function prepareInAnimation() {
              var endingClasses = filterCssClasses(getClassVal(inAnchor));
              var toAdd = getUniqueValues(endingClasses, startingClasses);
              var toRemove = getUniqueValues(startingClasses, endingClasses);
              var animator = $animateCss(clone, {
                to: calculateAnchorStyles(inAnchor),
                addClass: NG_IN_ANCHOR_CLASS_NAME + " " + toAdd,
                removeClass: NG_OUT_ANCHOR_CLASS_NAME + " " + toRemove,
                delay: true,
              });
              return animator.$$willAnimate ? animator : null;
            }
            function end() {
              clone.remove();
              outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
              inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
            }
          }
          function prepareFromToAnchorAnimation(from, to, classes, anchors) {
            var fromAnimation = prepareRegularAnimation(from, noop);
            var toAnimation = prepareRegularAnimation(to, noop);
            var anchorAnimations = [];
            forEach(anchors, function (anchor) {
              var outElement = anchor["out"];
              var inElement = anchor["in"];
              var animator = prepareAnchoredAnimation(
                classes,
                outElement,
                inElement
              );
              if (animator) {
                anchorAnimations.push(animator);
              }
            });
            if (!fromAnimation && !toAnimation && anchorAnimations.length === 0)
              return;
            return {
              start: function () {
                var animationRunners = [];
                if (fromAnimation) {
                  animationRunners.push(fromAnimation.start());
                }
                if (toAnimation) {
                  animationRunners.push(toAnimation.start());
                }
                forEach(anchorAnimations, function (animation) {
                  animationRunners.push(animation.start());
                });
                var runner = new $$AnimateRunner({ end: endFn, cancel: endFn });
                $$AnimateRunner.all(animationRunners, function (status) {
                  runner.complete(status);
                });
                return runner;
                function endFn() {
                  forEach(animationRunners, function (runner) {
                    runner.end();
                  });
                }
              },
            };
          }
          function prepareRegularAnimation(animationDetails) {
            var element = animationDetails.element;
            var options = animationDetails.options || {};
            if (animationDetails.structural) {
              options.event = animationDetails.event;
              options.structural = true;
              options.applyClassesEarly = true;
              if (animationDetails.event === "leave") {
                options.onDone = options.domOperation;
              }
            }
            if (options.preparationClasses) {
              options.event = concatWithSpace(
                options.event,
                options.preparationClasses
              );
            }
            var animator = $animateCss(element, options);
            return animator.$$willAnimate ? animator : null;
          }
        },
      ];
    },
  ];
  var $$AnimateJsProvider = [
    "$animateProvider",
    function ($animateProvider) {
      this.$get = [
        "$injector",
        "$$AnimateRunner",
        "$$jqLite",
        function ($injector, $$AnimateRunner, $$jqLite) {
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          return function (element, event, classes, options) {
            var animationClosed = false;
            if (arguments.length === 3 && isObject(classes)) {
              options = classes;
              classes = null;
            }
            options = prepareAnimationOptions(options);
            if (!classes) {
              classes = element.attr("class") || "";
              if (options.addClass) {
                classes += " " + options.addClass;
              }
              if (options.removeClass) {
                classes += " " + options.removeClass;
              }
            }
            var classesToAdd = options.addClass;
            var classesToRemove = options.removeClass;
            var animations = lookupAnimations(classes);
            var before, after;
            if (animations.length) {
              var afterFn, beforeFn;
              if (event === "leave") {
                beforeFn = "leave";
                afterFn = "afterLeave";
              } else {
                beforeFn =
                  "before" + event.charAt(0).toUpperCase() + event.substr(1);
                afterFn = event;
              }
              if (event !== "enter" && event !== "move") {
                before = packageAnimations(
                  element,
                  event,
                  options,
                  animations,
                  beforeFn
                );
              }
              after = packageAnimations(
                element,
                event,
                options,
                animations,
                afterFn
              );
            }
            if (!before && !after) return;
            function applyOptions() {
              options.domOperation();
              applyAnimationClasses(element, options);
            }
            function close() {
              animationClosed = true;
              applyOptions();
              applyAnimationStyles(element, options);
            }
            var runner;
            return {
              $$willAnimate: true,
              end: function () {
                if (runner) {
                  runner.end();
                } else {
                  close();
                  runner = new $$AnimateRunner();
                  runner.complete(true);
                }
                return runner;
              },
              start: function () {
                if (runner) {
                  return runner;
                }
                runner = new $$AnimateRunner();
                var closeActiveAnimations;
                var chain = [];
                if (before) {
                  chain.push(function (fn) {
                    closeActiveAnimations = before(fn);
                  });
                }
                if (chain.length) {
                  chain.push(function (fn) {
                    applyOptions();
                    fn(true);
                  });
                } else {
                  applyOptions();
                }
                if (after) {
                  chain.push(function (fn) {
                    closeActiveAnimations = after(fn);
                  });
                }
                runner.setHost({
                  end: function () {
                    endAnimations();
                  },
                  cancel: function () {
                    endAnimations(true);
                  },
                });
                $$AnimateRunner.chain(chain, onComplete);
                return runner;
                function onComplete(success) {
                  close(success);
                  runner.complete(success);
                }
                function endAnimations(cancelled) {
                  if (!animationClosed) {
                    (closeActiveAnimations || noop)(cancelled);
                    onComplete(cancelled);
                  }
                }
              },
            };
            function executeAnimationFn(fn, element, event, options, onDone) {
              var args;
              switch (event) {
                case "animate":
                  args = [element, options.from, options.to, onDone];
                  break;
                case "setClass":
                  args = [element, classesToAdd, classesToRemove, onDone];
                  break;
                case "addClass":
                  args = [element, classesToAdd, onDone];
                  break;
                case "removeClass":
                  args = [element, classesToRemove, onDone];
                  break;
                default:
                  args = [element, onDone];
                  break;
              }
              args.push(options);
              var value = fn.apply(fn, args);
              if (value) {
                if (isFunction(value.start)) {
                  value = value.start();
                }
                if (value instanceof $$AnimateRunner) {
                  value.done(onDone);
                } else if (isFunction(value)) {
                  return value;
                }
              }
              return noop;
            }
            function groupEventedAnimations(
              element,
              event,
              options,
              animations,
              fnName
            ) {
              var operations = [];
              forEach(animations, function (ani) {
                var animation = ani[fnName];
                if (!animation) return;
                operations.push(function () {
                  var runner;
                  var endProgressCb;
                  var resolved = false;
                  var onAnimationComplete = function (rejected) {
                    if (!resolved) {
                      resolved = true;
                      (endProgressCb || noop)(rejected);
                      runner.complete(!rejected);
                    }
                  };
                  runner = new $$AnimateRunner({
                    end: function () {
                      onAnimationComplete();
                    },
                    cancel: function () {
                      onAnimationComplete(true);
                    },
                  });
                  endProgressCb = executeAnimationFn(
                    animation,
                    element,
                    event,
                    options,
                    function (result) {
                      var cancelled = result === false;
                      onAnimationComplete(cancelled);
                    }
                  );
                  return runner;
                });
              });
              return operations;
            }
            function packageAnimations(
              element,
              event,
              options,
              animations,
              fnName
            ) {
              var operations = groupEventedAnimations(
                element,
                event,
                options,
                animations,
                fnName
              );
              if (operations.length === 0) {
                var a, b;
                if (fnName === "beforeSetClass") {
                  a = groupEventedAnimations(
                    element,
                    "removeClass",
                    options,
                    animations,
                    "beforeRemoveClass"
                  );
                  b = groupEventedAnimations(
                    element,
                    "addClass",
                    options,
                    animations,
                    "beforeAddClass"
                  );
                } else if (fnName === "setClass") {
                  a = groupEventedAnimations(
                    element,
                    "removeClass",
                    options,
                    animations,
                    "removeClass"
                  );
                  b = groupEventedAnimations(
                    element,
                    "addClass",
                    options,
                    animations,
                    "addClass"
                  );
                }
                if (a) {
                  operations = operations.concat(a);
                }
                if (b) {
                  operations = operations.concat(b);
                }
              }
              if (operations.length === 0) return;
              return function startAnimation(callback) {
                var runners = [];
                if (operations.length) {
                  forEach(operations, function (animateFn) {
                    runners.push(animateFn());
                  });
                }
                if (runners.length) {
                  $$AnimateRunner.all(runners, callback);
                } else {
                  callback();
                }
                return function endFn(reject) {
                  forEach(runners, function (runner) {
                    if (reject) {
                      runner.cancel();
                    } else {
                      runner.end();
                    }
                  });
                };
              };
            }
          };
          function lookupAnimations(classes) {
            classes = isArray(classes) ? classes : classes.split(" ");
            var matches = [],
              flagMap = {};
            for (var i = 0; i < classes.length; i++) {
              var klass = classes[i],
                animationFactory =
                  $animateProvider.$$registeredAnimations[klass];
              if (animationFactory && !flagMap[klass]) {
                matches.push($injector.get(animationFactory));
                flagMap[klass] = true;
              }
            }
            return matches;
          }
        },
      ];
    },
  ];
  var $$AnimateJsDriverProvider = [
    "$$animationProvider",
    function ($$animationProvider) {
      $$animationProvider.drivers.push("$$animateJsDriver");
      this.$get = [
        "$$animateJs",
        "$$AnimateRunner",
        function ($$animateJs, $$AnimateRunner) {
          return function initDriverFn(animationDetails) {
            if (animationDetails.from && animationDetails.to) {
              var fromAnimation = prepareAnimation(animationDetails.from);
              var toAnimation = prepareAnimation(animationDetails.to);
              if (!fromAnimation && !toAnimation) return;
              return {
                start: function () {
                  var animationRunners = [];
                  if (fromAnimation) {
                    animationRunners.push(fromAnimation.start());
                  }
                  if (toAnimation) {
                    animationRunners.push(toAnimation.start());
                  }
                  $$AnimateRunner.all(animationRunners, done);
                  var runner = new $$AnimateRunner({
                    end: endFnFactory(),
                    cancel: endFnFactory(),
                  });
                  return runner;
                  function endFnFactory() {
                    return function () {
                      forEach(animationRunners, function (runner) {
                        runner.end();
                      });
                    };
                  }
                  function done(status) {
                    runner.complete(status);
                  }
                },
              };
            } else {
              return prepareAnimation(animationDetails);
            }
          };
          function prepareAnimation(animationDetails) {
            var element = animationDetails.element;
            var event = animationDetails.event;
            var options = animationDetails.options;
            var classes = animationDetails.classes;
            return $$animateJs(element, event, classes, options);
          }
        },
      ];
    },
  ];
  var NG_ANIMATE_ATTR_NAME = "data-ng-animate";
  var NG_ANIMATE_PIN_DATA = "$ngAnimatePin";
  var $$AnimateQueueProvider = [
    "$animateProvider",
    function ($animateProvider) {
      var PRE_DIGEST_STATE = 1;
      var RUNNING_STATE = 2;
      var ONE_SPACE = " ";
      var rules = (this.rules = { skip: [], cancel: [], join: [] });
      function makeTruthyCssClassMap(classString) {
        if (!classString) {
          return null;
        }
        var keys = classString.split(ONE_SPACE);
        var map = Object.create(null);
        forEach(keys, function (key) {
          map[key] = true;
        });
        return map;
      }
      function hasMatchingClasses(newClassString, currentClassString) {
        if (newClassString && currentClassString) {
          var currentClassMap = makeTruthyCssClassMap(currentClassString);
          return newClassString.split(ONE_SPACE).some(function (className) {
            return currentClassMap[className];
          });
        }
      }
      function isAllowed(
        ruleType,
        element,
        currentAnimation,
        previousAnimation
      ) {
        return rules[ruleType].some(function (fn) {
          return fn(element, currentAnimation, previousAnimation);
        });
      }
      function hasAnimationClasses(animation, and) {
        var a = (animation.addClass || "").length > 0;
        var b = (animation.removeClass || "").length > 0;
        return and ? a && b : a || b;
      }
      rules.join.push(function (element, newAnimation, currentAnimation) {
        return !newAnimation.structural && hasAnimationClasses(newAnimation);
      });
      rules.skip.push(function (element, newAnimation, currentAnimation) {
        return !newAnimation.structural && !hasAnimationClasses(newAnimation);
      });
      rules.skip.push(function (element, newAnimation, currentAnimation) {
        return currentAnimation.event === "leave" && newAnimation.structural;
      });
      rules.skip.push(function (element, newAnimation, currentAnimation) {
        return (
          currentAnimation.structural &&
          currentAnimation.state === RUNNING_STATE &&
          !newAnimation.structural
        );
      });
      rules.cancel.push(function (element, newAnimation, currentAnimation) {
        return currentAnimation.structural && newAnimation.structural;
      });
      rules.cancel.push(function (element, newAnimation, currentAnimation) {
        return (
          currentAnimation.state === RUNNING_STATE && newAnimation.structural
        );
      });
      rules.cancel.push(function (element, newAnimation, currentAnimation) {
        if (currentAnimation.structural) return false;
        var nA = newAnimation.addClass;
        var nR = newAnimation.removeClass;
        var cA = currentAnimation.addClass;
        var cR = currentAnimation.removeClass;
        if (
          (isUndefined(nA) && isUndefined(nR)) ||
          (isUndefined(cA) && isUndefined(cR))
        ) {
          return false;
        }
        return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);
      });
      this.$get = [
        "$$rAF",
        "$rootScope",
        "$rootElement",
        "$document",
        "$$HashMap",
        "$$animation",
        "$$AnimateRunner",
        "$templateRequest",
        "$$jqLite",
        "$$forceReflow",
        "$$isDocumentHidden",
        function (
          $$rAF,
          $rootScope,
          $rootElement,
          $document,
          $$HashMap,
          $$animation,
          $$AnimateRunner,
          $templateRequest,
          $$jqLite,
          $$forceReflow,
          $$isDocumentHidden
        ) {
          var activeAnimationsLookup = new $$HashMap();
          var disabledElementsLookup = new $$HashMap();
          var animationsEnabled = null;
          function postDigestTaskFactory() {
            var postDigestCalled = false;
            return function (fn) {
              if (postDigestCalled) {
                fn();
              } else {
                $rootScope.$$postDigest(function () {
                  postDigestCalled = true;
                  fn();
                });
              }
            };
          }
          var deregisterWatch = $rootScope.$watch(
            function () {
              return $templateRequest.totalPendingRequests === 0;
            },
            function (isEmpty) {
              if (!isEmpty) return;
              deregisterWatch();
              $rootScope.$$postDigest(function () {
                $rootScope.$$postDigest(function () {
                  if (animationsEnabled === null) {
                    animationsEnabled = true;
                  }
                });
              });
            }
          );
          var callbackRegistry = Object.create(null);
          var classNameFilter = $animateProvider.classNameFilter();
          var isAnimatableClassName = !classNameFilter
            ? function () {
                return true;
              }
            : function (className) {
                return classNameFilter.test(className);
              };
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          function normalizeAnimationDetails(element, animation) {
            return mergeAnimationDetails(element, animation, {});
          }
          var contains =
            window.Node.prototype.contains ||
            function (arg) {
              return this === arg || !!(this.compareDocumentPosition(arg) & 16);
            };
          function findCallbacks(parent, element, event) {
            var targetNode = getDomNode(element);
            var targetParentNode = getDomNode(parent);
            var matches = [];
            var entries = callbackRegistry[event];
            if (entries) {
              forEach(entries, function (entry) {
                if (contains.call(entry.node, targetNode)) {
                  matches.push(entry.callback);
                } else if (
                  event === "leave" &&
                  contains.call(entry.node, targetParentNode)
                ) {
                  matches.push(entry.callback);
                }
              });
            }
            return matches;
          }
          function filterFromRegistry(list, matchContainer, matchCallback) {
            var containerNode = extractElementNode(matchContainer);
            return list.filter(function (entry) {
              var isMatch =
                entry.node === containerNode &&
                (!matchCallback || entry.callback === matchCallback);
              return !isMatch;
            });
          }
          function cleanupEventListeners(phase, element) {
            if (phase === "close" && !element[0].parentNode) {
              $animate.off(element);
            }
          }
          var $animate = {
            on: function (event, container, callback) {
              var node = extractElementNode(container);
              callbackRegistry[event] = callbackRegistry[event] || [];
              callbackRegistry[event].push({ node: node, callback: callback });
              jqLite(container).on("$destroy", function () {
                var animationDetails = activeAnimationsLookup.get(node);
                if (!animationDetails) {
                  $animate.off(event, container, callback);
                }
              });
            },
            off: function (event, container, callback) {
              if (arguments.length === 1 && !isString(arguments[0])) {
                container = arguments[0];
                for (var eventType in callbackRegistry) {
                  callbackRegistry[eventType] = filterFromRegistry(
                    callbackRegistry[eventType],
                    container
                  );
                }
                return;
              }
              var entries = callbackRegistry[event];
              if (!entries) return;
              callbackRegistry[event] =
                arguments.length === 1
                  ? null
                  : filterFromRegistry(entries, container, callback);
            },
            pin: function (element, parentElement) {
              assertArg(isElement(element), "element", "not an element");
              assertArg(
                isElement(parentElement),
                "parentElement",
                "not an element"
              );
              element.data(NG_ANIMATE_PIN_DATA, parentElement);
            },
            push: function (element, event, options, domOperation) {
              options = options || {};
              options.domOperation = domOperation;
              return queueAnimation(element, event, options);
            },
            enabled: function (element, bool) {
              var argCount = arguments.length;
              if (argCount === 0) {
                bool = !!animationsEnabled;
              } else {
                var hasElement = isElement(element);
                if (!hasElement) {
                  bool = animationsEnabled = !!element;
                } else {
                  var node = getDomNode(element);
                  if (argCount === 1) {
                    bool = !disabledElementsLookup.get(node);
                  } else {
                    disabledElementsLookup.put(node, !bool);
                  }
                }
              }
              return bool;
            },
          };
          return $animate;
          function queueAnimation(element, event, initialOptions) {
            var options = copy(initialOptions);
            var node, parent;
            element = stripCommentsFromElement(element);
            if (element) {
              node = getDomNode(element);
              parent = element.parent();
            }
            options = prepareAnimationOptions(options);
            var runner = new $$AnimateRunner();
            var runInNextPostDigestOrNow = postDigestTaskFactory();
            if (isArray(options.addClass)) {
              options.addClass = options.addClass.join(" ");
            }
            if (options.addClass && !isString(options.addClass)) {
              options.addClass = null;
            }
            if (isArray(options.removeClass)) {
              options.removeClass = options.removeClass.join(" ");
            }
            if (options.removeClass && !isString(options.removeClass)) {
              options.removeClass = null;
            }
            if (options.from && !isObject(options.from)) {
              options.from = null;
            }
            if (options.to && !isObject(options.to)) {
              options.to = null;
            }
            if (!node) {
              close();
              return runner;
            }
            var className = [
              node.getAttribute("class"),
              options.addClass,
              options.removeClass,
            ].join(" ");
            if (!isAnimatableClassName(className)) {
              close();
              return runner;
            }
            var isStructural = ["enter", "move", "leave"].indexOf(event) >= 0;
            var documentHidden = $$isDocumentHidden();
            var skipAnimations =
              !animationsEnabled ||
              documentHidden ||
              disabledElementsLookup.get(node);
            var existingAnimation =
              (!skipAnimations && activeAnimationsLookup.get(node)) || {};
            var hasExistingAnimation = !!existingAnimation.state;
            if (
              !skipAnimations &&
              (!hasExistingAnimation ||
                existingAnimation.state !== PRE_DIGEST_STATE)
            ) {
              skipAnimations = !areAnimationsAllowed(element, parent, event);
            }
            if (skipAnimations) {
              if (documentHidden) notifyProgress(runner, event, "start");
              close();
              if (documentHidden) notifyProgress(runner, event, "close");
              return runner;
            }
            if (isStructural) {
              closeChildAnimations(element);
            }
            var newAnimation = {
              structural: isStructural,
              element: element,
              event: event,
              addClass: options.addClass,
              removeClass: options.removeClass,
              close: close,
              options: options,
              runner: runner,
            };
            if (hasExistingAnimation) {
              var skipAnimationFlag = isAllowed(
                "skip",
                element,
                newAnimation,
                existingAnimation
              );
              if (skipAnimationFlag) {
                if (existingAnimation.state === RUNNING_STATE) {
                  close();
                  return runner;
                } else {
                  mergeAnimationDetails(
                    element,
                    existingAnimation,
                    newAnimation
                  );
                  return existingAnimation.runner;
                }
              }
              var cancelAnimationFlag = isAllowed(
                "cancel",
                element,
                newAnimation,
                existingAnimation
              );
              if (cancelAnimationFlag) {
                if (existingAnimation.state === RUNNING_STATE) {
                  existingAnimation.runner.end();
                } else if (existingAnimation.structural) {
                  existingAnimation.close();
                } else {
                  mergeAnimationDetails(
                    element,
                    existingAnimation,
                    newAnimation
                  );
                  return existingAnimation.runner;
                }
              } else {
                var joinAnimationFlag = isAllowed(
                  "join",
                  element,
                  newAnimation,
                  existingAnimation
                );
                if (joinAnimationFlag) {
                  if (existingAnimation.state === RUNNING_STATE) {
                    normalizeAnimationDetails(element, newAnimation);
                  } else {
                    applyGeneratedPreparationClasses(
                      element,
                      isStructural ? event : null,
                      options
                    );
                    event = newAnimation.event = existingAnimation.event;
                    options = mergeAnimationDetails(
                      element,
                      existingAnimation,
                      newAnimation
                    );
                    return existingAnimation.runner;
                  }
                }
              }
            } else {
              normalizeAnimationDetails(element, newAnimation);
            }
            var isValidAnimation = newAnimation.structural;
            if (!isValidAnimation) {
              isValidAnimation =
                (newAnimation.event === "animate" &&
                  Object.keys(newAnimation.options.to || {}).length > 0) ||
                hasAnimationClasses(newAnimation);
            }
            if (!isValidAnimation) {
              close();
              clearElementAnimationState(element);
              return runner;
            }
            var counter = (existingAnimation.counter || 0) + 1;
            newAnimation.counter = counter;
            markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);
            $rootScope.$$postDigest(function () {
              var animationDetails = activeAnimationsLookup.get(node);
              var animationCancelled = !animationDetails;
              animationDetails = animationDetails || {};
              var parentElement = element.parent() || [];
              var isValidAnimation =
                parentElement.length > 0 &&
                (animationDetails.event === "animate" ||
                  animationDetails.structural ||
                  hasAnimationClasses(animationDetails));
              if (
                animationCancelled ||
                animationDetails.counter !== counter ||
                !isValidAnimation
              ) {
                if (animationCancelled) {
                  applyAnimationClasses(element, options);
                  applyAnimationStyles(element, options);
                }
                if (
                  animationCancelled ||
                  (isStructural && animationDetails.event !== event)
                ) {
                  options.domOperation();
                  runner.end();
                }
                if (!isValidAnimation) {
                  clearElementAnimationState(element);
                }
                return;
              }
              event =
                !animationDetails.structural &&
                hasAnimationClasses(animationDetails, true)
                  ? "setClass"
                  : animationDetails.event;
              markElementAnimationState(element, RUNNING_STATE);
              var realRunner = $$animation(
                element,
                event,
                animationDetails.options
              );
              runner.setHost(realRunner);
              notifyProgress(runner, event, "start", {});
              realRunner.done(function (status) {
                close(!status);
                var animationDetails = activeAnimationsLookup.get(node);
                if (animationDetails && animationDetails.counter === counter) {
                  clearElementAnimationState(getDomNode(element));
                }
                notifyProgress(runner, event, "close", {});
              });
            });
            return runner;
            function notifyProgress(runner, event, phase, data) {
              runInNextPostDigestOrNow(function () {
                var callbacks = findCallbacks(parent, element, event);
                if (callbacks.length) {
                  $$rAF(function () {
                    forEach(callbacks, function (callback) {
                      callback(element, phase, data);
                    });
                    cleanupEventListeners(phase, element);
                  });
                } else {
                  cleanupEventListeners(phase, element);
                }
              });
              runner.progress(event, phase, data);
            }
            function close(reject) {
              clearGeneratedClasses(element, options);
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              options.domOperation();
              runner.complete(!reject);
            }
          }
          function closeChildAnimations(element) {
            var node = getDomNode(element);
            var children = node.querySelectorAll(
              "[" + NG_ANIMATE_ATTR_NAME + "]"
            );
            forEach(children, function (child) {
              var state = parseInt(
                child.getAttribute(NG_ANIMATE_ATTR_NAME),
                10
              );
              var animationDetails = activeAnimationsLookup.get(child);
              if (animationDetails) {
                switch (state) {
                  case RUNNING_STATE:
                    animationDetails.runner.end();
                  case PRE_DIGEST_STATE:
                    activeAnimationsLookup.remove(child);
                    break;
                }
              }
            });
          }
          function clearElementAnimationState(element) {
            var node = getDomNode(element);
            node.removeAttribute(NG_ANIMATE_ATTR_NAME);
            activeAnimationsLookup.remove(node);
          }
          function isMatchingElement(nodeOrElmA, nodeOrElmB) {
            return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);
          }
          function areAnimationsAllowed(element, parentElement, event) {
            var bodyElement = jqLite($document[0].body);
            var bodyElementDetected =
              isMatchingElement(element, bodyElement) ||
              element[0].nodeName === "HTML";
            var rootElementDetected = isMatchingElement(element, $rootElement);
            var parentAnimationDetected = false;
            var animateChildren;
            var elementDisabled = disabledElementsLookup.get(
              getDomNode(element)
            );
            var parentHost = jqLite.data(element[0], NG_ANIMATE_PIN_DATA);
            if (parentHost) {
              parentElement = parentHost;
            }
            parentElement = getDomNode(parentElement);
            while (parentElement) {
              if (!rootElementDetected) {
                rootElementDetected = isMatchingElement(
                  parentElement,
                  $rootElement
                );
              }
              if (parentElement.nodeType !== ELEMENT_NODE) {
                break;
              }
              var details = activeAnimationsLookup.get(parentElement) || {};
              if (!parentAnimationDetected) {
                var parentElementDisabled =
                  disabledElementsLookup.get(parentElement);
                if (
                  parentElementDisabled === true &&
                  elementDisabled !== false
                ) {
                  elementDisabled = true;
                  break;
                } else if (parentElementDisabled === false) {
                  elementDisabled = false;
                }
                parentAnimationDetected = details.structural;
              }
              if (isUndefined(animateChildren) || animateChildren === true) {
                var value = jqLite.data(
                  parentElement,
                  NG_ANIMATE_CHILDREN_DATA
                );
                if (isDefined(value)) {
                  animateChildren = value;
                }
              }
              if (parentAnimationDetected && animateChildren === false) break;
              if (!bodyElementDetected) {
                bodyElementDetected = isMatchingElement(
                  parentElement,
                  bodyElement
                );
              }
              if (bodyElementDetected && rootElementDetected) {
                break;
              }
              if (!rootElementDetected) {
                parentHost = jqLite.data(parentElement, NG_ANIMATE_PIN_DATA);
                if (parentHost) {
                  parentElement = getDomNode(parentHost);
                  continue;
                }
              }
              parentElement = parentElement.parentNode;
            }
            var allowAnimation =
              (!parentAnimationDetected || animateChildren) &&
              elementDisabled !== true;
            return allowAnimation && rootElementDetected && bodyElementDetected;
          }
          function markElementAnimationState(element, state, details) {
            details = details || {};
            details.state = state;
            var node = getDomNode(element);
            node.setAttribute(NG_ANIMATE_ATTR_NAME, state);
            var oldValue = activeAnimationsLookup.get(node);
            var newValue = oldValue ? extend(oldValue, details) : details;
            activeAnimationsLookup.put(node, newValue);
          }
        },
      ];
    },
  ];
  var $$AnimationProvider = [
    "$animateProvider",
    function ($animateProvider) {
      var NG_ANIMATE_REF_ATTR = "ng-animate-ref";
      var drivers = (this.drivers = []);
      var RUNNER_STORAGE_KEY = "$$animationRunner";
      function setRunner(element, runner) {
        element.data(RUNNER_STORAGE_KEY, runner);
      }
      function removeRunner(element) {
        element.removeData(RUNNER_STORAGE_KEY);
      }
      function getRunner(element) {
        return element.data(RUNNER_STORAGE_KEY);
      }
      this.$get = [
        "$$jqLite",
        "$rootScope",
        "$injector",
        "$$AnimateRunner",
        "$$HashMap",
        "$$rAFScheduler",
        function (
          $$jqLite,
          $rootScope,
          $injector,
          $$AnimateRunner,
          $$HashMap,
          $$rAFScheduler
        ) {
          var animationQueue = [];
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          function sortAnimations(animations) {
            var tree = { children: [] };
            var i,
              lookup = new $$HashMap();
            for (i = 0; i < animations.length; i++) {
              var animation = animations[i];
              lookup.put(
                animation.domNode,
                (animations[i] = {
                  domNode: animation.domNode,
                  fn: animation.fn,
                  children: [],
                })
              );
            }
            for (i = 0; i < animations.length; i++) {
              processNode(animations[i]);
            }
            return flatten(tree);
            function processNode(entry) {
              if (entry.processed) return entry;
              entry.processed = true;
              var elementNode = entry.domNode;
              var parentNode = elementNode.parentNode;
              lookup.put(elementNode, entry);
              var parentEntry;
              while (parentNode) {
                parentEntry = lookup.get(parentNode);
                if (parentEntry) {
                  if (!parentEntry.processed) {
                    parentEntry = processNode(parentEntry);
                  }
                  break;
                }
                parentNode = parentNode.parentNode;
              }
              (parentEntry || tree).children.push(entry);
              return entry;
            }
            function flatten(tree) {
              var result = [];
              var queue = [];
              var i;
              for (i = 0; i < tree.children.length; i++) {
                queue.push(tree.children[i]);
              }
              var remainingLevelEntries = queue.length;
              var nextLevelEntries = 0;
              var row = [];
              for (i = 0; i < queue.length; i++) {
                var entry = queue[i];
                if (remainingLevelEntries <= 0) {
                  remainingLevelEntries = nextLevelEntries;
                  nextLevelEntries = 0;
                  result.push(row);
                  row = [];
                }
                row.push(entry.fn);
                entry.children.forEach(function (childEntry) {
                  nextLevelEntries++;
                  queue.push(childEntry);
                });
                remainingLevelEntries--;
              }
              if (row.length) {
                result.push(row);
              }
              return result;
            }
          }
          return function (element, event, options) {
            options = prepareAnimationOptions(options);
            var isStructural = ["enter", "move", "leave"].indexOf(event) >= 0;
            var runner = new $$AnimateRunner({
              end: function () {
                close();
              },
              cancel: function () {
                close(true);
              },
            });
            if (!drivers.length) {
              close();
              return runner;
            }
            setRunner(element, runner);
            var classes = mergeClasses(
              element.attr("class"),
              mergeClasses(options.addClass, options.removeClass)
            );
            var tempClasses = options.tempClasses;
            if (tempClasses) {
              classes += " " + tempClasses;
              options.tempClasses = null;
            }
            var prepareClassName;
            if (isStructural) {
              prepareClassName = "ng-" + event + PREPARE_CLASS_SUFFIX;
              $$jqLite.addClass(element, prepareClassName);
            }
            animationQueue.push({
              element: element,
              classes: classes,
              event: event,
              structural: isStructural,
              options: options,
              beforeStart: beforeStart,
              close: close,
            });
            element.on("$destroy", handleDestroyedElement);
            if (animationQueue.length > 1) return runner;
            $rootScope.$$postDigest(function () {
              var animations = [];
              forEach(animationQueue, function (entry) {
                if (getRunner(entry.element)) {
                  animations.push(entry);
                } else {
                  entry.close();
                }
              });
              animationQueue.length = 0;
              var groupedAnimations = groupAnimations(animations);
              var toBeSortedAnimations = [];
              forEach(groupedAnimations, function (animationEntry) {
                toBeSortedAnimations.push({
                  domNode: getDomNode(
                    animationEntry.from
                      ? animationEntry.from.element
                      : animationEntry.element
                  ),
                  fn: function triggerAnimationStart() {
                    animationEntry.beforeStart();
                    var startAnimationFn,
                      closeFn = animationEntry.close;
                    var targetElement = animationEntry.anchors
                      ? animationEntry.from.element || animationEntry.to.element
                      : animationEntry.element;
                    if (getRunner(targetElement)) {
                      var operation = invokeFirstDriver(animationEntry);
                      if (operation) {
                        startAnimationFn = operation.start;
                      }
                    }
                    if (!startAnimationFn) {
                      closeFn();
                    } else {
                      var animationRunner = startAnimationFn();
                      animationRunner.done(function (status) {
                        closeFn(!status);
                      });
                      updateAnimationRunners(animationEntry, animationRunner);
                    }
                  },
                });
              });
              $$rAFScheduler(sortAnimations(toBeSortedAnimations));
            });
            return runner;
            function getAnchorNodes(node) {
              var SELECTOR = "[" + NG_ANIMATE_REF_ATTR + "]";
              var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)
                ? [node]
                : node.querySelectorAll(SELECTOR);
              var anchors = [];
              forEach(items, function (node) {
                var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
                if (attr && attr.length) {
                  anchors.push(node);
                }
              });
              return anchors;
            }
            function groupAnimations(animations) {
              var preparedAnimations = [];
              var refLookup = {};
              forEach(animations, function (animation, index) {
                var element = animation.element;
                var node = getDomNode(element);
                var event = animation.event;
                var enterOrMove = ["enter", "move"].indexOf(event) >= 0;
                var anchorNodes = animation.structural
                  ? getAnchorNodes(node)
                  : [];
                if (anchorNodes.length) {
                  var direction = enterOrMove ? "to" : "from";
                  forEach(anchorNodes, function (anchor) {
                    var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
                    refLookup[key] = refLookup[key] || {};
                    refLookup[key][direction] = {
                      animationID: index,
                      element: jqLite(anchor),
                    };
                  });
                } else {
                  preparedAnimations.push(animation);
                }
              });
              var usedIndicesLookup = {};
              var anchorGroups = {};
              forEach(refLookup, function (operations, key) {
                var from = operations.from;
                var to = operations.to;
                if (!from || !to) {
                  var index = from ? from.animationID : to.animationID;
                  var indexKey = index.toString();
                  if (!usedIndicesLookup[indexKey]) {
                    usedIndicesLookup[indexKey] = true;
                    preparedAnimations.push(animations[index]);
                  }
                  return;
                }
                var fromAnimation = animations[from.animationID];
                var toAnimation = animations[to.animationID];
                var lookupKey = from.animationID.toString();
                if (!anchorGroups[lookupKey]) {
                  var group = (anchorGroups[lookupKey] = {
                    structural: true,
                    beforeStart: function () {
                      fromAnimation.beforeStart();
                      toAnimation.beforeStart();
                    },
                    close: function () {
                      fromAnimation.close();
                      toAnimation.close();
                    },
                    classes: cssClassesIntersection(
                      fromAnimation.classes,
                      toAnimation.classes
                    ),
                    from: fromAnimation,
                    to: toAnimation,
                    anchors: [],
                  });
                  if (group.classes.length) {
                    preparedAnimations.push(group);
                  } else {
                    preparedAnimations.push(fromAnimation);
                    preparedAnimations.push(toAnimation);
                  }
                }
                anchorGroups[lookupKey].anchors.push({
                  out: from.element,
                  in: to.element,
                });
              });
              return preparedAnimations;
            }
            function cssClassesIntersection(a, b) {
              a = a.split(" ");
              b = b.split(" ");
              var matches = [];
              for (var i = 0; i < a.length; i++) {
                var aa = a[i];
                if (aa.substring(0, 3) === "ng-") continue;
                for (var j = 0; j < b.length; j++) {
                  if (aa === b[j]) {
                    matches.push(aa);
                    break;
                  }
                }
              }
              return matches.join(" ");
            }
            function invokeFirstDriver(animationDetails) {
              for (var i = drivers.length - 1; i >= 0; i--) {
                var driverName = drivers[i];
                var factory = $injector.get(driverName);
                var driver = factory(animationDetails);
                if (driver) {
                  return driver;
                }
              }
            }
            function beforeStart() {
              element.addClass(NG_ANIMATE_CLASSNAME);
              if (tempClasses) {
                $$jqLite.addClass(element, tempClasses);
              }
              if (prepareClassName) {
                $$jqLite.removeClass(element, prepareClassName);
                prepareClassName = null;
              }
            }
            function updateAnimationRunners(animation, newRunner) {
              if (animation.from && animation.to) {
                update(animation.from.element);
                update(animation.to.element);
              } else {
                update(animation.element);
              }
              function update(element) {
                var runner = getRunner(element);
                if (runner) runner.setHost(newRunner);
              }
            }
            function handleDestroyedElement() {
              var runner = getRunner(element);
              if (
                runner &&
                (event !== "leave" || !options.$$domOperationFired)
              ) {
                runner.end();
              }
            }
            function close(rejected) {
              element.off("$destroy", handleDestroyedElement);
              removeRunner(element);
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              options.domOperation();
              if (tempClasses) {
                $$jqLite.removeClass(element, tempClasses);
              }
              element.removeClass(NG_ANIMATE_CLASSNAME);
              runner.complete(!rejected);
            }
          };
        },
      ];
    },
  ];
  var ngAnimateSwapDirective = [
    "$animate",
    "$rootScope",
    function ($animate, $rootScope) {
      return {
        restrict: "A",
        transclude: "element",
        terminal: true,
        priority: 600,
        link: function (scope, $element, attrs, ctrl, $transclude) {
          var previousElement, previousScope;
          scope.$watchCollection(
            attrs.ngAnimateSwap || attrs["for"],
            function (value) {
              if (previousElement) {
                $animate.leave(previousElement);
              }
              if (previousScope) {
                previousScope.$destroy();
                previousScope = null;
              }
              if (value || value === 0) {
                previousScope = scope.$new();
                $transclude(previousScope, function (element) {
                  previousElement = element;
                  $animate.enter(element, null, $element);
                });
              }
            }
          );
        },
      };
    },
  ];
  var copy;
  var extend;
  var forEach;
  var isArray;
  var isDefined;
  var isElement;
  var isFunction;
  var isObject;
  var isString;
  var isUndefined;
  var jqLite;
  var noop;
  angular
    .module("ngAnimate", [], function initAngularHelpers() {
      noop = angular.noop;
      copy = angular.copy;
      extend = angular.extend;
      jqLite = angular.element;
      forEach = angular.forEach;
      isArray = angular.isArray;
      isString = angular.isString;
      isObject = angular.isObject;
      isUndefined = angular.isUndefined;
      isDefined = angular.isDefined;
      isFunction = angular.isFunction;
      isElement = angular.isElement;
    })
    .directive("ngAnimateSwap", ngAnimateSwapDirective)
    .directive("ngAnimateChildren", $$AnimateChildrenDirective)
    .factory("$$rAFScheduler", $$rAFSchedulerFactory)
    .provider("$$animateQueue", $$AnimateQueueProvider)
    .provider("$$animation", $$AnimationProvider)
    .provider("$animateCss", $AnimateCssProvider)
    .provider("$$animateCssDriver", $$AnimateCssDriverProvider)
    .provider("$$animateJs", $$AnimateJsProvider)
    .provider("$$animateJsDriver", $$AnimateJsDriverProvider);
})(window, window.angular);
(function (window, angular) {
  "use strict";
  function shallowCopy(src, dst) {
    if (isArray(src)) {
      dst = dst || [];
      for (var i = 0, ii = src.length; i < ii; i++) {
        dst[i] = src[i];
      }
    } else if (isObject(src)) {
      dst = dst || {};
      for (var key in src) {
        if (!(key.charAt(0) === "$" && key.charAt(1) === "$")) {
          dst[key] = src[key];
        }
      }
    }
    return dst || src;
  }
  var isArray;
  var isObject;
  var isDefined;
  var ngRouteModule = angular
    .module("ngRoute", [])
    .provider("$route", $RouteProvider)
    .run(instantiateRoute);
  var $routeMinErr = angular.$$minErr("ngRoute");
  var isEagerInstantiationEnabled;
  function $RouteProvider() {
    isArray = angular.isArray;
    isObject = angular.isObject;
    isDefined = angular.isDefined;
    function inherit(parent, extra) {
      return angular.extend(Object.create(parent), extra);
    }
    var routes = {};
    this.when = function (path, route) {
      var routeCopy = shallowCopy(route);
      if (angular.isUndefined(routeCopy.reloadOnSearch)) {
        routeCopy.reloadOnSearch = true;
      }
      if (angular.isUndefined(routeCopy.caseInsensitiveMatch)) {
        routeCopy.caseInsensitiveMatch = this.caseInsensitiveMatch;
      }
      routes[path] = angular.extend(
        routeCopy,
        path && pathRegExp(path, routeCopy)
      );
      if (path) {
        var redirectPath =
          path[path.length - 1] === "/"
            ? path.substr(0, path.length - 1)
            : path + "/";
        routes[redirectPath] = angular.extend(
          { redirectTo: path },
          pathRegExp(redirectPath, routeCopy)
        );
      }
      return this;
    };
    this.caseInsensitiveMatch = false;
    function pathRegExp(path, opts) {
      var insensitive = opts.caseInsensitiveMatch,
        ret = { originalPath: path, regexp: path },
        keys = (ret.keys = []);
      path = path
        .replace(/([().])/g, "\\$1")
        .replace(/(\/)?:(\w+)(\*\?|[?*])?/g, function (_, slash, key, option) {
          var optional = option === "?" || option === "*?" ? "?" : null;
          var star = option === "*" || option === "*?" ? "*" : null;
          keys.push({ name: key, optional: !!optional });
          slash = slash || "";
          return (
            "" +
            (optional ? "" : slash) +
            "(?:" +
            (optional ? slash : "") +
            ((star && "(.+?)") || "([^/]+)") +
            (optional || "") +
            ")" +
            (optional || "")
          );
        })
        .replace(/([\/$*])/g, "\\$1");
      ret.regexp = new RegExp("^" + path + "$", insensitive ? "i" : "");
      return ret;
    }
    this.otherwise = function (params) {
      if (typeof params === "string") {
        params = { redirectTo: params };
      }
      this.when(null, params);
      return this;
    };
    isEagerInstantiationEnabled = true;
    this.eagerInstantiationEnabled = function eagerInstantiationEnabled(
      enabled
    ) {
      if (isDefined(enabled)) {
        isEagerInstantiationEnabled = enabled;
        return this;
      }
      return isEagerInstantiationEnabled;
    };
    this.$get = [
      "$rootScope",
      "$location",
      "$routeParams",
      "$q",
      "$injector",
      "$templateRequest",
      "$sce",
      function (
        $rootScope,
        $location,
        $routeParams,
        $q,
        $injector,
        $templateRequest,
        $sce
      ) {
        var forceReload = false,
          preparedRoute,
          preparedRouteIsUpdateOnly,
          $route = {
            routes: routes,
            reload: function () {
              forceReload = true;
              var fakeLocationEvent = {
                defaultPrevented: false,
                preventDefault: function fakePreventDefault() {
                  this.defaultPrevented = true;
                  forceReload = false;
                },
              };
              $rootScope.$evalAsync(function () {
                prepareRoute(fakeLocationEvent);
                if (!fakeLocationEvent.defaultPrevented) commitRoute();
              });
            },
            updateParams: function (newParams) {
              if (this.current && this.current.$$route) {
                newParams = angular.extend({}, this.current.params, newParams);
                $location.path(
                  interpolate(this.current.$$route.originalPath, newParams)
                );
                $location.search(newParams);
              } else {
                throw $routeMinErr(
                  "norout",
                  "Tried updating route when with no current route"
                );
              }
            },
          };
        $rootScope.$on("$locationChangeStart", prepareRoute);
        $rootScope.$on("$locationChangeSuccess", commitRoute);
        return $route;
        function switchRouteMatcher(on, route) {
          var keys = route.keys,
            params = {};
          if (!route.regexp) return null;
          var m = route.regexp.exec(on);
          if (!m) return null;
          for (var i = 1, len = m.length; i < len; ++i) {
            var key = keys[i - 1];
            var val = m[i];
            if (key && val) {
              params[key.name] = val;
            }
          }
          return params;
        }
        function prepareRoute($locationEvent) {
          var lastRoute = $route.current;
          preparedRoute = parseRoute();
          preparedRouteIsUpdateOnly =
            preparedRoute &&
            lastRoute &&
            preparedRoute.$$route === lastRoute.$$route &&
            angular.equals(preparedRoute.pathParams, lastRoute.pathParams) &&
            !preparedRoute.reloadOnSearch &&
            !forceReload;
          if (!preparedRouteIsUpdateOnly && (lastRoute || preparedRoute)) {
            if (
              $rootScope.$broadcast(
                "$routeChangeStart",
                preparedRoute,
                lastRoute
              ).defaultPrevented
            ) {
              if ($locationEvent) {
                $locationEvent.preventDefault();
              }
            }
          }
        }
        function commitRoute() {
          var lastRoute = $route.current;
          var nextRoute = preparedRoute;
          if (preparedRouteIsUpdateOnly) {
            lastRoute.params = nextRoute.params;
            angular.copy(lastRoute.params, $routeParams);
            $rootScope.$broadcast("$routeUpdate", lastRoute);
          } else if (nextRoute || lastRoute) {
            forceReload = false;
            $route.current = nextRoute;
            var nextRoutePromise = $q.resolve(nextRoute);
            nextRoutePromise
              .then(getRedirectionData)
              .then(handlePossibleRedirection)
              .then(function (keepProcessingRoute) {
                return (
                  keepProcessingRoute &&
                  nextRoutePromise.then(resolveLocals).then(function (locals) {
                    if (nextRoute === $route.current) {
                      if (nextRoute) {
                        nextRoute.locals = locals;
                        angular.copy(nextRoute.params, $routeParams);
                      }
                      $rootScope.$broadcast(
                        "$routeChangeSuccess",
                        nextRoute,
                        lastRoute
                      );
                    }
                  })
                );
              })
              .catch(function (error) {
                if (nextRoute === $route.current) {
                  $rootScope.$broadcast(
                    "$routeChangeError",
                    nextRoute,
                    lastRoute,
                    error
                  );
                }
              });
          }
        }
        function getRedirectionData(route) {
          var data = { route: route, hasRedirection: false };
          if (route) {
            if (route.redirectTo) {
              if (angular.isString(route.redirectTo)) {
                data.path = interpolate(route.redirectTo, route.params);
                data.search = route.params;
                data.hasRedirection = true;
              } else {
                var oldPath = $location.path();
                var oldSearch = $location.search();
                var newUrl = route.redirectTo(
                  route.pathParams,
                  oldPath,
                  oldSearch
                );
                if (angular.isDefined(newUrl)) {
                  data.url = newUrl;
                  data.hasRedirection = true;
                }
              }
            } else if (route.resolveRedirectTo) {
              return $q
                .resolve($injector.invoke(route.resolveRedirectTo))
                .then(function (newUrl) {
                  if (angular.isDefined(newUrl)) {
                    data.url = newUrl;
                    data.hasRedirection = true;
                  }
                  return data;
                });
            }
          }
          return data;
        }
        function handlePossibleRedirection(data) {
          var keepProcessingRoute = true;
          if (data.route !== $route.current) {
            keepProcessingRoute = false;
          } else if (data.hasRedirection) {
            var oldUrl = $location.url();
            var newUrl = data.url;
            if (newUrl) {
              $location.url(newUrl).replace();
            } else {
              newUrl = $location
                .path(data.path)
                .search(data.search)
                .replace()
                .url();
            }
            if (newUrl !== oldUrl) {
              keepProcessingRoute = false;
            }
          }
          return keepProcessingRoute;
        }
        function resolveLocals(route) {
          if (route) {
            var locals = angular.extend({}, route.resolve);
            angular.forEach(locals, function (value, key) {
              locals[key] = angular.isString(value)
                ? $injector.get(value)
                : $injector.invoke(value, null, null, key);
            });
            var template = getTemplateFor(route);
            if (angular.isDefined(template)) {
              locals["$template"] = template;
            }
            return $q.all(locals);
          }
        }
        function getTemplateFor(route) {
          var template, templateUrl;
          if (angular.isDefined((template = route.template))) {
            if (angular.isFunction(template)) {
              template = template(route.params);
            }
          } else if (angular.isDefined((templateUrl = route.templateUrl))) {
            if (angular.isFunction(templateUrl)) {
              templateUrl = templateUrl(route.params);
            }
            if (angular.isDefined(templateUrl)) {
              route.loadedTemplateUrl = $sce.valueOf(templateUrl);
              template = $templateRequest(templateUrl);
            }
          }
          return template;
        }
        function parseRoute() {
          var params, match;
          angular.forEach(routes, function (route, path) {
            if (
              !match &&
              (params = switchRouteMatcher($location.path(), route))
            ) {
              match = inherit(route, {
                params: angular.extend({}, $location.search(), params),
                pathParams: params,
              });
              match.$$route = route;
            }
          });
          return (
            match ||
            (routes[null] &&
              inherit(routes[null], { params: {}, pathParams: {} }))
          );
        }
        function interpolate(string, params) {
          var result = [];
          angular.forEach((string || "").split(":"), function (segment, i) {
            if (i === 0) {
              result.push(segment);
            } else {
              var segmentMatch = segment.match(/(\w+)(?:[?*])?(.*)/);
              var key = segmentMatch[1];
              result.push(params[key]);
              result.push(segmentMatch[2] || "");
              delete params[key];
            }
          });
          return result.join("");
        }
      },
    ];
  }
  instantiateRoute.$inject = ["$injector"];
  function instantiateRoute($injector) {
    if (isEagerInstantiationEnabled) {
      $injector.get("$route");
    }
  }
  ngRouteModule.provider("$routeParams", $RouteParamsProvider);
  function $RouteParamsProvider() {
    this.$get = function () {
      return {};
    };
  }
  ngRouteModule.directive("ngView", ngViewFactory);
  ngRouteModule.directive("ngView", ngViewFillContentFactory);
  ngViewFactory.$inject = ["$route", "$anchorScroll", "$animate"];
  function ngViewFactory($route, $anchorScroll, $animate) {
    return {
      restrict: "ECA",
      terminal: true,
      priority: 400,
      transclude: "element",
      link: function (scope, $element, attr, ctrl, $transclude) {
        var currentScope,
          currentElement,
          previousLeaveAnimation,
          autoScrollExp = attr.autoscroll,
          onloadExp = attr.onload || "";
        scope.$on("$routeChangeSuccess", update);
        update();
        function cleanupLastView() {
          if (previousLeaveAnimation) {
            $animate.cancel(previousLeaveAnimation);
            previousLeaveAnimation = null;
          }
          if (currentScope) {
            currentScope.$destroy();
            currentScope = null;
          }
          if (currentElement) {
            previousLeaveAnimation = $animate.leave(currentElement);
            previousLeaveAnimation.done(function (response) {
              if (response !== false) previousLeaveAnimation = null;
            });
            currentElement = null;
          }
        }
        function update() {
          var locals = $route.current && $route.current.locals,
            template = locals && locals.$template;
          if (angular.isDefined(template)) {
            var newScope = scope.$new();
            var current = $route.current;
            var clone = $transclude(newScope, function (clone) {
              $animate
                .enter(clone, null, currentElement || $element)
                .done(function onNgViewEnter(response) {
                  if (
                    response !== false &&
                    angular.isDefined(autoScrollExp) &&
                    (!autoScrollExp || scope.$eval(autoScrollExp))
                  ) {
                    $anchorScroll();
                  }
                });
              cleanupLastView();
            });
            currentElement = clone;
            currentScope = current.scope = newScope;
            currentScope.$emit("$viewContentLoaded");
            currentScope.$eval(onloadExp);
          } else {
            cleanupLastView();
          }
        }
      },
    };
  }
  ngViewFillContentFactory.$inject = ["$compile", "$controller", "$route"];
  function ngViewFillContentFactory($compile, $controller, $route) {
    return {
      restrict: "ECA",
      priority: -400,
      link: function (scope, $element) {
        var current = $route.current,
          locals = current.locals;
        $element.html(locals.$template);
        var link = $compile($element.contents());
        if (current.controller) {
          locals.$scope = scope;
          var controller = $controller(current.controller, locals);
          if (current.controllerAs) {
            scope[current.controllerAs] = controller;
          }
          $element.data("$ngControllerController", controller);
          $element.children().data("$ngControllerController", controller);
        }
        scope[current.resolveAs || "$resolve"] = locals;
        link(scope);
      },
    };
  }
})(window, window.angular);
(function (window, angular) {
  "use strict";
  angular.module("ngCookies", ["ng"]).provider("$cookies", [
    function $CookiesProvider() {
      var defaults = (this.defaults = {});
      function calcOptions(options) {
        return options ? angular.extend({}, defaults, options) : defaults;
      }
      this.$get = [
        "$$cookieReader",
        "$$cookieWriter",
        function ($$cookieReader, $$cookieWriter) {
          return {
            get: function (key) {
              return $$cookieReader()[key];
            },
            getObject: function (key) {
              var value = this.get(key);
              return value ? angular.fromJson(value) : value;
            },
            getAll: function () {
              return $$cookieReader();
            },
            put: function (key, value, options) {
              $$cookieWriter(key, value, calcOptions(options));
            },
            putObject: function (key, value, options) {
              this.put(key, angular.toJson(value), options);
            },
            remove: function (key, options) {
              $$cookieWriter(key, undefined, calcOptions(options));
            },
          };
        },
      ];
    },
  ]);
  angular.module("ngCookies").factory("$cookieStore", [
    "$cookies",
    function ($cookies) {
      return {
        get: function (key) {
          return $cookies.getObject(key);
        },
        put: function (key, value) {
          $cookies.putObject(key, value);
        },
        remove: function (key) {
          $cookies.remove(key);
        },
      };
    },
  ]);
  function $$CookieWriter($document, $log, $browser) {
    var cookiePath = $browser.baseHref();
    var rawDocument = $document[0];
    function buildCookieString(name, value, options) {
      var path, expires;
      options = options || {};
      expires = options.expires;
      path = angular.isDefined(options.path) ? options.path : cookiePath;
      if (angular.isUndefined(value)) {
        expires = "Thu, 01 Jan 1970 00:00:00 GMT";
        value = "";
      }
      if (angular.isString(expires)) {
        expires = new Date(expires);
      }
      var str = encodeURIComponent(name) + "=" + encodeURIComponent(value);
      str += path ? ";path=" + path : "";
      str += options.domain ? ";domain=" + options.domain : "";
      str += expires ? ";expires=" + expires.toUTCString() : "";
      str += options.secure ? ";secure" : "";
      var cookieLength = str.length + 1;
      if (cookieLength > 4096) {
        $log.warn(
          "Cookie '" +
            name +
            "' possibly not set or overflowed because it was too large (" +
            cookieLength +
            " > 4096 bytes)!"
        );
      }
      return str;
    }
    return function (name, value, options) {
      rawDocument.cookie = buildCookieString(name, value, options);
    };
  }
  $$CookieWriter.$inject = ["$document", "$log", "$browser"];
  angular
    .module("ngCookies")
    .provider("$$cookieWriter", function $$CookieWriterProvider() {
      this.$get = $$CookieWriter;
    });
})(window, window.angular);
(function (root, factory) {
  if (typeof define === "function" && define.amd) {
    define([], function () {
      return factory();
    });
  } else if (typeof exports === "object") {
    module.exports = factory();
  } else {
    factory();
  }
})(this, function () {
  runTranslate.$inject = ["$translate"];
  $translate.$inject = [
    "$STORAGE_KEY",
    "$windowProvider",
    "$translateSanitizationProvider",
    "pascalprechtTranslateOverrider",
  ];
  $translateDefaultInterpolation.$inject = [
    "$interpolate",
    "$translateSanitization",
  ];
  translateDirective.$inject = [
    "$translate",
    "$interpolate",
    "$compile",
    "$parse",
    "$rootScope",
  ];
  translateAttrDirective.$inject = ["$translate", "$rootScope"];
  translateCloakDirective.$inject = ["$translate", "$rootScope"];
  translateFilterFactory.$inject = ["$parse", "$translate"];
  $translationCache.$inject = ["$cacheFactory"];
  angular.module("pascalprecht.translate", ["ng"]).run(runTranslate);
  function runTranslate($translate) {
    "use strict";
    var key = $translate.storageKey(),
      storage = $translate.storage();
    var fallbackFromIncorrectStorageValue = function () {
      var preferred = $translate.preferredLanguage();
      if (angular.isString(preferred)) {
        $translate.use(preferred);
      } else {
        storage.put(key, $translate.use());
      }
    };
    fallbackFromIncorrectStorageValue.displayName =
      "fallbackFromIncorrectStorageValue";
    if (storage) {
      if (!storage.get(key)) {
        fallbackFromIncorrectStorageValue();
      } else {
        $translate
          .use(storage.get(key))
          ["catch"](fallbackFromIncorrectStorageValue);
      }
    } else if (angular.isString($translate.preferredLanguage())) {
      $translate.use($translate.preferredLanguage());
    }
  }
  runTranslate.displayName = "runTranslate";
  angular
    .module("pascalprecht.translate")
    .provider("$translateSanitization", $translateSanitizationProvider);
  function $translateSanitizationProvider() {
    "use strict";
    var $sanitize,
      $sce,
      currentStrategy = null,
      hasConfiguredStrategy = false,
      hasShownNoStrategyConfiguredWarning = false,
      strategies;
    strategies = {
      sanitize: function (value, mode) {
        if (mode === "text") {
          value = htmlSanitizeValue(value);
        }
        return value;
      },
      escape: function (value, mode) {
        if (mode === "text") {
          value = htmlEscapeValue(value);
        }
        return value;
      },
      sanitizeParameters: function (value, mode) {
        if (mode === "params") {
          value = mapInterpolationParameters(value, htmlSanitizeValue);
        }
        return value;
      },
      escapeParameters: function (value, mode) {
        if (mode === "params") {
          value = mapInterpolationParameters(value, htmlEscapeValue);
        }
        return value;
      },
      sce: function (value, mode, context) {
        if (mode === "text") {
          value = htmlTrustValue(value);
        } else if (mode === "params") {
          if (context !== "filter") {
            value = mapInterpolationParameters(value, htmlEscapeValue);
          }
        }
        return value;
      },
      sceParameters: function (value, mode) {
        if (mode === "params") {
          value = mapInterpolationParameters(value, htmlTrustValue);
        }
        return value;
      },
    };
    strategies.escaped = strategies.escapeParameters;
    this.addStrategy = function (strategyName, strategyFunction) {
      strategies[strategyName] = strategyFunction;
      return this;
    };
    this.removeStrategy = function (strategyName) {
      delete strategies[strategyName];
      return this;
    };
    this.useStrategy = function (strategy) {
      hasConfiguredStrategy = true;
      currentStrategy = strategy;
      return this;
    };
    this.$get = [
      "$injector",
      "$log",
      function ($injector, $log) {
        var cachedStrategyMap = {};
        var applyStrategies = function (
          value,
          mode,
          context,
          selectedStrategies
        ) {
          angular.forEach(selectedStrategies, function (selectedStrategy) {
            if (angular.isFunction(selectedStrategy)) {
              value = selectedStrategy(value, mode, context);
            } else if (angular.isFunction(strategies[selectedStrategy])) {
              value = strategies[selectedStrategy](value, mode, context);
            } else if (angular.isString(strategies[selectedStrategy])) {
              if (!cachedStrategyMap[strategies[selectedStrategy]]) {
                try {
                  cachedStrategyMap[strategies[selectedStrategy]] =
                    $injector.get(strategies[selectedStrategy]);
                } catch (e) {
                  cachedStrategyMap[strategies[selectedStrategy]] =
                    function () {};
                  throw new Error(
                    "pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: '" +
                      selectedStrategy +
                      "'"
                  );
                }
              }
              value = cachedStrategyMap[strategies[selectedStrategy]](
                value,
                mode,
                context
              );
            } else {
              throw new Error(
                "pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: '" +
                  selectedStrategy +
                  "'"
              );
            }
          });
          return value;
        };
        var showNoStrategyConfiguredWarning = function () {
          if (!hasConfiguredStrategy && !hasShownNoStrategyConfiguredWarning) {
            $log.warn(
              "pascalprecht.translate.$translateSanitization: No sanitization strategy has been configured. This can have serious security implications. See http://angular-translate.github.io/docs/#/guide/19_security for details."
            );
            hasShownNoStrategyConfiguredWarning = true;
          }
        };
        if ($injector.has("$sanitize")) {
          $sanitize = $injector.get("$sanitize");
        }
        if ($injector.has("$sce")) {
          $sce = $injector.get("$sce");
        }
        return {
          useStrategy: (function (self) {
            return function (strategy) {
              self.useStrategy(strategy);
            };
          })(this),
          sanitize: function (value, mode, strategy, context) {
            if (!currentStrategy) {
              showNoStrategyConfiguredWarning();
            }
            if (!strategy && strategy !== null) {
              strategy = currentStrategy;
            }
            if (!strategy) {
              return value;
            }
            if (!context) {
              context = "service";
            }
            var selectedStrategies = angular.isArray(strategy)
              ? strategy
              : [strategy];
            return applyStrategies(value, mode, context, selectedStrategies);
          },
        };
      },
    ];
    var htmlEscapeValue = function (value) {
      var element = angular.element("<div></div>");
      element.text(value);
      return element.html();
    };
    var htmlSanitizeValue = function (value) {
      if (!$sanitize) {
        throw new Error(
          "pascalprecht.translate.$translateSanitization: Error cannot find $sanitize service. Either include the ngSanitize module (https://docs.angularjs.org/api/ngSanitize) or use a sanitization strategy which does not depend on $sanitize, such as 'escape'."
        );
      }
      return $sanitize(value);
    };
    var htmlTrustValue = function (value) {
      if (!$sce) {
        throw new Error(
          "pascalprecht.translate.$translateSanitization: Error cannot find $sce service."
        );
      }
      return $sce.trustAsHtml(value);
    };
    var mapInterpolationParameters = function (value, iteratee, stack) {
      if (angular.isDate(value)) {
        return value;
      } else if (angular.isObject(value)) {
        var result = angular.isArray(value) ? [] : {};
        if (!stack) {
          stack = [];
        } else {
          if (stack.indexOf(value) > -1) {
            throw new Error(
              "pascalprecht.translate.$translateSanitization: Error cannot interpolate parameter due recursive object"
            );
          }
        }
        stack.push(value);
        angular.forEach(value, function (propertyValue, propertyKey) {
          if (angular.isFunction(propertyValue)) {
            return;
          }
          result[propertyKey] = mapInterpolationParameters(
            propertyValue,
            iteratee,
            stack
          );
        });
        stack.splice(-1, 1);
        return result;
      } else if (angular.isNumber(value)) {
        return value;
      } else {
        return iteratee(value);
      }
    };
  }
  angular
    .module("pascalprecht.translate")
    .constant("pascalprechtTranslateOverrider", {})
    .provider("$translate", $translate);
  function $translate(
    $STORAGE_KEY,
    $windowProvider,
    $translateSanitizationProvider,
    pascalprechtTranslateOverrider
  ) {
    "use strict";
    var $translationTable = {},
      $preferredLanguage,
      $availableLanguageKeys = [],
      $languageKeyAliases,
      $fallbackLanguage,
      $fallbackWasString,
      $uses,
      $nextLang,
      $storageFactory,
      $storageKey = $STORAGE_KEY,
      $storagePrefix,
      $missingTranslationHandlerFactory,
      $interpolationFactory,
      $interpolatorFactories = [],
      $loaderFactory,
      $cloakClassName = "translate-cloak",
      $loaderOptions,
      $notFoundIndicatorLeft,
      $notFoundIndicatorRight,
      $postCompilingEnabled = false,
      $forceAsyncReloadEnabled = false,
      $nestedObjectDelimeter = ".",
      $isReady = false,
      $keepContent = false,
      loaderCache,
      directivePriority = 0,
      statefulFilter = true,
      postProcessFn,
      uniformLanguageTagResolver = "default",
      languageTagResolver = {
        default: function (tag) {
          return (tag || "").split("-").join("_");
        },
        java: function (tag) {
          var temp = (tag || "").split("-").join("_");
          var parts = temp.split("_");
          return parts.length > 1
            ? parts[0].toLowerCase() + "_" + parts[1].toUpperCase()
            : temp;
        },
        bcp47: function (tag) {
          var temp = (tag || "").split("_").join("-");
          var parts = temp.split("-");
          return parts.length > 1
            ? parts[0].toLowerCase() + "-" + parts[1].toUpperCase()
            : temp;
        },
        "iso639-1": function (tag) {
          var temp = (tag || "").split("_").join("-");
          var parts = temp.split("-");
          return parts[0].toLowerCase();
        },
      };
    var version = "2.13.1";
    var getFirstBrowserLanguage = function () {
      if (angular.isFunction(pascalprechtTranslateOverrider.getLocale)) {
        return pascalprechtTranslateOverrider.getLocale();
      }
      var nav = $windowProvider.$get().navigator,
        browserLanguagePropertyKeys = [
          "language",
          "browserLanguage",
          "systemLanguage",
          "userLanguage",
        ],
        i,
        language;
      if (angular.isArray(nav.languages)) {
        for (i = 0; i < nav.languages.length; i++) {
          language = nav.languages[i];
          if (language && language.length) {
            return language;
          }
        }
      }
      for (i = 0; i < browserLanguagePropertyKeys.length; i++) {
        language = nav[browserLanguagePropertyKeys[i]];
        if (language && language.length) {
          return language;
        }
      }
      return null;
    };
    getFirstBrowserLanguage.displayName =
      "angular-translate/service: getFirstBrowserLanguage";
    var getLocale = function () {
      var locale = getFirstBrowserLanguage() || "";
      if (languageTagResolver[uniformLanguageTagResolver]) {
        locale = languageTagResolver[uniformLanguageTagResolver](locale);
      }
      return locale;
    };
    getLocale.displayName = "angular-translate/service: getLocale";
    var indexOf = function (array, searchElement) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (array[i] === searchElement) {
          return i;
        }
      }
      return -1;
    };
    var trim = function () {
      return this.toString().replace(/^\s+|\s+$/g, "");
    };
    var negotiateLocale = function (preferred) {
      if (!preferred) {
        return;
      }
      var avail = [],
        locale = angular.lowercase(preferred),
        i = 0,
        n = $availableLanguageKeys.length;
      for (; i < n; i++) {
        avail.push(angular.lowercase($availableLanguageKeys[i]));
      }
      if (indexOf(avail, locale) > -1) {
        return preferred;
      }
      if ($languageKeyAliases) {
        var alias;
        for (var langKeyAlias in $languageKeyAliases) {
          if ($languageKeyAliases.hasOwnProperty(langKeyAlias)) {
            var hasWildcardKey = false;
            var hasExactKey =
              Object.prototype.hasOwnProperty.call(
                $languageKeyAliases,
                langKeyAlias
              ) &&
              angular.lowercase(langKeyAlias) === angular.lowercase(preferred);
            if (langKeyAlias.slice(-1) === "*") {
              hasWildcardKey =
                langKeyAlias.slice(0, -1) ===
                preferred.slice(0, langKeyAlias.length - 1);
            }
            if (hasExactKey || hasWildcardKey) {
              alias = $languageKeyAliases[langKeyAlias];
              if (indexOf(avail, angular.lowercase(alias)) > -1) {
                return alias;
              }
            }
          }
        }
      }
      var parts = preferred.split("_");
      if (
        parts.length > 1 &&
        indexOf(avail, angular.lowercase(parts[0])) > -1
      ) {
        return parts[0];
      }
      return;
    };
    var translations = function (langKey, translationTable) {
      if (!langKey && !translationTable) {
        return $translationTable;
      }
      if (langKey && !translationTable) {
        if (angular.isString(langKey)) {
          return $translationTable[langKey];
        }
      } else {
        if (!angular.isObject($translationTable[langKey])) {
          $translationTable[langKey] = {};
        }
        angular.extend(
          $translationTable[langKey],
          flatObject(translationTable)
        );
      }
      return this;
    };
    this.translations = translations;
    this.cloakClassName = function (name) {
      if (!name) {
        return $cloakClassName;
      }
      $cloakClassName = name;
      return this;
    };
    this.nestedObjectDelimeter = function (delimiter) {
      if (!delimiter) {
        return $nestedObjectDelimeter;
      }
      $nestedObjectDelimeter = delimiter;
      return this;
    };
    var flatObject = function (data, path, result, prevKey) {
      var key, keyWithPath, keyWithShortPath, val;
      if (!path) {
        path = [];
      }
      if (!result) {
        result = {};
      }
      for (key in data) {
        if (!Object.prototype.hasOwnProperty.call(data, key)) {
          continue;
        }
        val = data[key];
        if (angular.isObject(val)) {
          flatObject(val, path.concat(key), result, key);
        } else {
          keyWithPath = path.length
            ? "" +
              path.join($nestedObjectDelimeter) +
              $nestedObjectDelimeter +
              key
            : key;
          if (path.length && key === prevKey) {
            keyWithShortPath = "" + path.join($nestedObjectDelimeter);
            result[keyWithShortPath] = "@:" + keyWithPath;
          }
          result[keyWithPath] = val;
        }
      }
      return result;
    };
    flatObject.displayName = "flatObject";
    this.addInterpolation = function (factory) {
      $interpolatorFactories.push(factory);
      return this;
    };
    this.useMessageFormatInterpolation = function () {
      return this.useInterpolation("$translateMessageFormatInterpolation");
    };
    this.useInterpolation = function (factory) {
      $interpolationFactory = factory;
      return this;
    };
    this.useSanitizeValueStrategy = function (value) {
      $translateSanitizationProvider.useStrategy(value);
      return this;
    };
    this.preferredLanguage = function (langKey) {
      if (langKey) {
        setupPreferredLanguage(langKey);
        return this;
      }
      return $preferredLanguage;
    };
    var setupPreferredLanguage = function (langKey) {
      if (langKey) {
        $preferredLanguage = langKey;
      }
      return $preferredLanguage;
    };
    this.translationNotFoundIndicator = function (indicator) {
      this.translationNotFoundIndicatorLeft(indicator);
      this.translationNotFoundIndicatorRight(indicator);
      return this;
    };
    this.translationNotFoundIndicatorLeft = function (indicator) {
      if (!indicator) {
        return $notFoundIndicatorLeft;
      }
      $notFoundIndicatorLeft = indicator;
      return this;
    };
    this.translationNotFoundIndicatorRight = function (indicator) {
      if (!indicator) {
        return $notFoundIndicatorRight;
      }
      $notFoundIndicatorRight = indicator;
      return this;
    };
    this.fallbackLanguage = function (langKey) {
      fallbackStack(langKey);
      return this;
    };
    var fallbackStack = function (langKey) {
      if (langKey) {
        if (angular.isString(langKey)) {
          $fallbackWasString = true;
          $fallbackLanguage = [langKey];
        } else if (angular.isArray(langKey)) {
          $fallbackWasString = false;
          $fallbackLanguage = langKey;
        }
        if (
          angular.isString($preferredLanguage) &&
          indexOf($fallbackLanguage, $preferredLanguage) < 0
        ) {
          $fallbackLanguage.push($preferredLanguage);
        }
        return this;
      } else {
        if ($fallbackWasString) {
          return $fallbackLanguage[0];
        } else {
          return $fallbackLanguage;
        }
      }
    };
    this.use = function (langKey) {
      if (langKey) {
        if (!$translationTable[langKey] && !$loaderFactory) {
          throw new Error(
            "$translateProvider couldn't find translationTable for langKey: '" +
              langKey +
              "'"
          );
        }
        $uses = langKey;
        return this;
      }
      return $uses;
    };
    this.resolveClientLocale = function () {
      return getLocale();
    };
    var storageKey = function (key) {
      if (!key) {
        if ($storagePrefix) {
          return $storagePrefix + $storageKey;
        }
        return $storageKey;
      }
      $storageKey = key;
      return this;
    };
    this.storageKey = storageKey;
    this.useUrlLoader = function (url, options) {
      return this.useLoader(
        "$translateUrlLoader",
        angular.extend({ url: url }, options)
      );
    };
    this.useStaticFilesLoader = function (options) {
      return this.useLoader("$translateStaticFilesLoader", options);
    };
    this.useLoader = function (loaderFactory, options) {
      $loaderFactory = loaderFactory;
      $loaderOptions = options || {};
      return this;
    };
    this.useLocalStorage = function () {
      return this.useStorage("$translateLocalStorage");
    };
    this.useCookieStorage = function () {
      return this.useStorage("$translateCookieStorage");
    };
    this.useStorage = function (storageFactory) {
      $storageFactory = storageFactory;
      return this;
    };
    this.storagePrefix = function (prefix) {
      if (!prefix) {
        return prefix;
      }
      $storagePrefix = prefix;
      return this;
    };
    this.useMissingTranslationHandlerLog = function () {
      return this.useMissingTranslationHandler(
        "$translateMissingTranslationHandlerLog"
      );
    };
    this.useMissingTranslationHandler = function (factory) {
      $missingTranslationHandlerFactory = factory;
      return this;
    };
    this.usePostCompiling = function (value) {
      $postCompilingEnabled = !!value;
      return this;
    };
    this.forceAsyncReload = function (value) {
      $forceAsyncReloadEnabled = !!value;
      return this;
    };
    this.uniformLanguageTag = function (options) {
      if (!options) {
        options = {};
      } else if (angular.isString(options)) {
        options = { standard: options };
      }
      uniformLanguageTagResolver = options.standard;
      return this;
    };
    this.determinePreferredLanguage = function (fn) {
      var locale = fn && angular.isFunction(fn) ? fn() : getLocale();
      if (!$availableLanguageKeys.length) {
        $preferredLanguage = locale;
      } else {
        $preferredLanguage = negotiateLocale(locale) || locale;
      }
      return this;
    };
    this.registerAvailableLanguageKeys = function (languageKeys, aliases) {
      if (languageKeys) {
        $availableLanguageKeys = languageKeys;
        if (aliases) {
          $languageKeyAliases = aliases;
        }
        return this;
      }
      return $availableLanguageKeys;
    };
    this.useLoaderCache = function (cache) {
      if (cache === false) {
        loaderCache = undefined;
      } else if (cache === true) {
        loaderCache = true;
      } else if (typeof cache === "undefined") {
        loaderCache = "$translationCache";
      } else if (cache) {
        loaderCache = cache;
      }
      return this;
    };
    this.directivePriority = function (priority) {
      if (priority === undefined) {
        return directivePriority;
      } else {
        directivePriority = priority;
        return this;
      }
    };
    this.statefulFilter = function (state) {
      if (state === undefined) {
        return statefulFilter;
      } else {
        statefulFilter = state;
        return this;
      }
    };
    this.postProcess = function (fn) {
      if (fn) {
        postProcessFn = fn;
      } else {
        postProcessFn = undefined;
      }
      return this;
    };
    this.keepContent = function (value) {
      $keepContent = !!value;
      return this;
    };
    this.$get = [
      "$log",
      "$injector",
      "$rootScope",
      "$q",
      function ($log, $injector, $rootScope, $q) {
        var Storage,
          defaultInterpolator = $injector.get(
            $interpolationFactory || "$translateDefaultInterpolation"
          ),
          pendingLoader = false,
          interpolatorHashMap = {},
          langPromises = {},
          fallbackIndex,
          startFallbackIteration;
        var $translate = function (
          translationId,
          interpolateParams,
          interpolationId,
          defaultTranslationText,
          forceLanguage
        ) {
          if (!$uses && $preferredLanguage) {
            $uses = $preferredLanguage;
          }
          var uses =
            forceLanguage && forceLanguage !== $uses
              ? negotiateLocale(forceLanguage) || forceLanguage
              : $uses;
          if (forceLanguage) {
            loadTranslationsIfMissing(forceLanguage);
          }
          if (angular.isArray(translationId)) {
            var translateAll = function (translationIds) {
              var results = {};
              var promises = [];
              var translate = function (translationId) {
                var deferred = $q.defer();
                var regardless = function (value) {
                  results[translationId] = value;
                  deferred.resolve([translationId, value]);
                };
                $translate(
                  translationId,
                  interpolateParams,
                  interpolationId,
                  defaultTranslationText,
                  forceLanguage
                ).then(regardless, regardless);
                return deferred.promise;
              };
              for (var i = 0, c = translationIds.length; i < c; i++) {
                promises.push(translate(translationIds[i]));
              }
              return $q.all(promises).then(function () {
                return results;
              });
            };
            return translateAll(translationId);
          }
          var deferred = $q.defer();
          if (translationId) {
            translationId = trim.apply(translationId);
          }
          var promiseToWaitFor = (function () {
            var promise = $preferredLanguage
              ? langPromises[$preferredLanguage]
              : langPromises[uses];
            fallbackIndex = 0;
            if ($storageFactory && !promise) {
              var langKey = Storage.get($storageKey);
              promise = langPromises[langKey];
              if ($fallbackLanguage && $fallbackLanguage.length) {
                var index = indexOf($fallbackLanguage, langKey);
                fallbackIndex = index === 0 ? 1 : 0;
                if (indexOf($fallbackLanguage, $preferredLanguage) < 0) {
                  $fallbackLanguage.push($preferredLanguage);
                }
              }
            }
            return promise;
          })();
          if (!promiseToWaitFor) {
            determineTranslation(
              translationId,
              interpolateParams,
              interpolationId,
              defaultTranslationText,
              uses
            ).then(deferred.resolve, deferred.reject);
          } else {
            var promiseResolved = function () {
              if (!forceLanguage) {
                uses = $uses;
              }
              determineTranslation(
                translationId,
                interpolateParams,
                interpolationId,
                defaultTranslationText,
                uses
              ).then(deferred.resolve, deferred.reject);
            };
            promiseResolved.displayName = "promiseResolved";
            promiseToWaitFor["finally"](promiseResolved);
          }
          return deferred.promise;
        };
        var applyNotFoundIndicators = function (translationId) {
          if ($notFoundIndicatorLeft) {
            translationId = [$notFoundIndicatorLeft, translationId].join(" ");
          }
          if ($notFoundIndicatorRight) {
            translationId = [translationId, $notFoundIndicatorRight].join(" ");
          }
          return translationId;
        };
        var useLanguage = function (key) {
          $uses = key;
          if ($storageFactory) {
            Storage.put($translate.storageKey(), $uses);
          }
          $rootScope.$emit("$translateChangeSuccess", { language: key });
          defaultInterpolator.setLocale($uses);
          var eachInterpolator = function (interpolator, id) {
            interpolatorHashMap[id].setLocale($uses);
          };
          eachInterpolator.displayName = "eachInterpolatorLocaleSetter";
          angular.forEach(interpolatorHashMap, eachInterpolator);
          $rootScope.$emit("$translateChangeEnd", { language: key });
        };
        var loadAsync = function (key) {
          if (!key) {
            throw "No language key specified for loading.";
          }
          var deferred = $q.defer();
          $rootScope.$emit("$translateLoadingStart", { language: key });
          pendingLoader = true;
          var cache = loaderCache;
          if (typeof cache === "string") {
            cache = $injector.get(cache);
          }
          var loaderOptions = angular.extend({}, $loaderOptions, {
            key: key,
            $http: angular.extend({}, { cache: cache }, $loaderOptions.$http),
          });
          var onLoaderSuccess = function (data) {
            var translationTable = {};
            $rootScope.$emit("$translateLoadingSuccess", { language: key });
            if (angular.isArray(data)) {
              angular.forEach(data, function (table) {
                angular.extend(translationTable, flatObject(table));
              });
            } else {
              angular.extend(translationTable, flatObject(data));
            }
            pendingLoader = false;
            deferred.resolve({ key: key, table: translationTable });
            $rootScope.$emit("$translateLoadingEnd", { language: key });
          };
          onLoaderSuccess.displayName = "onLoaderSuccess";
          var onLoaderError = function (key) {
            $rootScope.$emit("$translateLoadingError", { language: key });
            deferred.reject(key);
            $rootScope.$emit("$translateLoadingEnd", { language: key });
          };
          onLoaderError.displayName = "onLoaderError";
          $injector
            .get($loaderFactory)(loaderOptions)
            .then(onLoaderSuccess, onLoaderError);
          return deferred.promise;
        };
        if ($storageFactory) {
          Storage = $injector.get($storageFactory);
          if (!Storage.get || !Storage.put) {
            throw new Error(
              "Couldn't use storage '" +
                $storageFactory +
                "', missing get() or put() method!"
            );
          }
        }
        if ($interpolatorFactories.length) {
          var eachInterpolationFactory = function (interpolatorFactory) {
            var interpolator = $injector.get(interpolatorFactory);
            interpolator.setLocale($preferredLanguage || $uses);
            interpolatorHashMap[interpolator.getInterpolationIdentifier()] =
              interpolator;
          };
          eachInterpolationFactory.displayName = "interpolationFactoryAdder";
          angular.forEach($interpolatorFactories, eachInterpolationFactory);
        }
        var getTranslationTable = function (langKey) {
          var deferred = $q.defer();
          if (
            Object.prototype.hasOwnProperty.call($translationTable, langKey)
          ) {
            deferred.resolve($translationTable[langKey]);
          } else if (langPromises[langKey]) {
            var onResolve = function (data) {
              translations(data.key, data.table);
              deferred.resolve(data.table);
            };
            onResolve.displayName = "translationTableResolver";
            langPromises[langKey].then(onResolve, deferred.reject);
          } else {
            deferred.reject();
          }
          return deferred.promise;
        };
        var getFallbackTranslation = function (
          langKey,
          translationId,
          interpolateParams,
          Interpolator
        ) {
          var deferred = $q.defer();
          var onResolve = function (translationTable) {
            if (
              Object.prototype.hasOwnProperty.call(
                translationTable,
                translationId
              )
            ) {
              Interpolator.setLocale(langKey);
              var translation = translationTable[translationId];
              if (translation.substr(0, 2) === "@:") {
                getFallbackTranslation(
                  langKey,
                  translation.substr(2),
                  interpolateParams,
                  Interpolator
                ).then(deferred.resolve, deferred.reject);
              } else {
                var interpolatedValue = Interpolator.interpolate(
                  translationTable[translationId],
                  interpolateParams,
                  "service"
                );
                interpolatedValue = applyPostProcessing(
                  translationId,
                  translationTable[translationId],
                  interpolatedValue,
                  interpolateParams,
                  langKey
                );
                deferred.resolve(interpolatedValue);
              }
              Interpolator.setLocale($uses);
            } else {
              deferred.reject();
            }
          };
          onResolve.displayName = "fallbackTranslationResolver";
          getTranslationTable(langKey).then(onResolve, deferred.reject);
          return deferred.promise;
        };
        var getFallbackTranslationInstant = function (
          langKey,
          translationId,
          interpolateParams,
          Interpolator,
          sanitizeStrategy
        ) {
          var result,
            translationTable = $translationTable[langKey];
          if (
            translationTable &&
            Object.prototype.hasOwnProperty.call(
              translationTable,
              translationId
            )
          ) {
            Interpolator.setLocale(langKey);
            result = Interpolator.interpolate(
              translationTable[translationId],
              interpolateParams,
              "filter",
              sanitizeStrategy
            );
            result = applyPostProcessing(
              translationId,
              translationTable[translationId],
              result,
              interpolateParams,
              langKey,
              sanitizeStrategy
            );
            if (
              !angular.isString(result) &&
              angular.isFunction(result.$$unwrapTrustedValue)
            ) {
              var result2 = result.$$unwrapTrustedValue();
              if (result2.substr(0, 2) === "@:") {
                return getFallbackTranslationInstant(
                  langKey,
                  result2.substr(2),
                  interpolateParams,
                  Interpolator,
                  sanitizeStrategy
                );
              }
            } else if (result.substr(0, 2) === "@:") {
              return getFallbackTranslationInstant(
                langKey,
                result.substr(2),
                interpolateParams,
                Interpolator,
                sanitizeStrategy
              );
            }
            Interpolator.setLocale($uses);
          }
          return result;
        };
        var translateByHandler = function (
          translationId,
          interpolateParams,
          defaultTranslationText,
          sanitizeStrategy
        ) {
          if ($missingTranslationHandlerFactory) {
            return $injector.get($missingTranslationHandlerFactory)(
              translationId,
              $uses,
              interpolateParams,
              defaultTranslationText,
              sanitizeStrategy
            );
          } else {
            return translationId;
          }
        };
        var resolveForFallbackLanguage = function (
          fallbackLanguageIndex,
          translationId,
          interpolateParams,
          Interpolator,
          defaultTranslationText
        ) {
          var deferred = $q.defer();
          if (fallbackLanguageIndex < $fallbackLanguage.length) {
            var langKey = $fallbackLanguage[fallbackLanguageIndex];
            getFallbackTranslation(
              langKey,
              translationId,
              interpolateParams,
              Interpolator
            ).then(
              function (data) {
                deferred.resolve(data);
              },
              function () {
                return resolveForFallbackLanguage(
                  fallbackLanguageIndex + 1,
                  translationId,
                  interpolateParams,
                  Interpolator,
                  defaultTranslationText
                ).then(deferred.resolve, deferred.reject);
              }
            );
          } else {
            if (defaultTranslationText) {
              deferred.resolve(defaultTranslationText);
            } else {
              var missingTranslationHandlerTranslation = translateByHandler(
                translationId,
                interpolateParams,
                defaultTranslationText
              );
              if (
                $missingTranslationHandlerFactory &&
                missingTranslationHandlerTranslation
              ) {
                deferred.resolve(missingTranslationHandlerTranslation);
              } else {
                deferred.reject(applyNotFoundIndicators(translationId));
              }
            }
          }
          return deferred.promise;
        };
        var resolveForFallbackLanguageInstant = function (
          fallbackLanguageIndex,
          translationId,
          interpolateParams,
          Interpolator,
          sanitizeStrategy
        ) {
          var result;
          if (fallbackLanguageIndex < $fallbackLanguage.length) {
            var langKey = $fallbackLanguage[fallbackLanguageIndex];
            result = getFallbackTranslationInstant(
              langKey,
              translationId,
              interpolateParams,
              Interpolator,
              sanitizeStrategy
            );
            if (!result && result !== "") {
              result = resolveForFallbackLanguageInstant(
                fallbackLanguageIndex + 1,
                translationId,
                interpolateParams,
                Interpolator
              );
            }
          }
          return result;
        };
        var fallbackTranslation = function (
          translationId,
          interpolateParams,
          Interpolator,
          defaultTranslationText
        ) {
          return resolveForFallbackLanguage(
            startFallbackIteration > 0 ? startFallbackIteration : fallbackIndex,
            translationId,
            interpolateParams,
            Interpolator,
            defaultTranslationText
          );
        };
        var fallbackTranslationInstant = function (
          translationId,
          interpolateParams,
          Interpolator,
          sanitizeStrategy
        ) {
          return resolveForFallbackLanguageInstant(
            startFallbackIteration > 0 ? startFallbackIteration : fallbackIndex,
            translationId,
            interpolateParams,
            Interpolator,
            sanitizeStrategy
          );
        };
        var determineTranslation = function (
          translationId,
          interpolateParams,
          interpolationId,
          defaultTranslationText,
          uses
        ) {
          var deferred = $q.defer();
          var table = uses ? $translationTable[uses] : $translationTable,
            Interpolator = interpolationId
              ? interpolatorHashMap[interpolationId]
              : defaultInterpolator;
          if (
            table &&
            Object.prototype.hasOwnProperty.call(table, translationId)
          ) {
            var translation = table[translationId];
            if (translation.substr(0, 2) === "@:") {
              $translate(
                translation.substr(2),
                interpolateParams,
                interpolationId,
                defaultTranslationText,
                uses
              ).then(deferred.resolve, deferred.reject);
            } else {
              var resolvedTranslation = Interpolator.interpolate(
                translation,
                interpolateParams,
                "service"
              );
              resolvedTranslation = applyPostProcessing(
                translationId,
                translation,
                resolvedTranslation,
                interpolateParams,
                uses
              );
              deferred.resolve(resolvedTranslation);
            }
          } else {
            var missingTranslationHandlerTranslation;
            if ($missingTranslationHandlerFactory && !pendingLoader) {
              missingTranslationHandlerTranslation = translateByHandler(
                translationId,
                interpolateParams,
                defaultTranslationText
              );
            }
            if (uses && $fallbackLanguage && $fallbackLanguage.length) {
              fallbackTranslation(
                translationId,
                interpolateParams,
                Interpolator,
                defaultTranslationText
              ).then(
                function (translation) {
                  deferred.resolve(translation);
                },
                function (_translationId) {
                  deferred.reject(applyNotFoundIndicators(_translationId));
                }
              );
            } else if (
              $missingTranslationHandlerFactory &&
              !pendingLoader &&
              missingTranslationHandlerTranslation
            ) {
              if (defaultTranslationText) {
                deferred.resolve(defaultTranslationText);
              } else {
                deferred.resolve(missingTranslationHandlerTranslation);
              }
            } else {
              if (defaultTranslationText) {
                deferred.resolve(defaultTranslationText);
              } else {
                deferred.reject(applyNotFoundIndicators(translationId));
              }
            }
          }
          return deferred.promise;
        };
        var determineTranslationInstant = function (
          translationId,
          interpolateParams,
          interpolationId,
          uses,
          sanitizeStrategy
        ) {
          var result,
            table = uses ? $translationTable[uses] : $translationTable,
            Interpolator = defaultInterpolator;
          if (
            interpolatorHashMap &&
            Object.prototype.hasOwnProperty.call(
              interpolatorHashMap,
              interpolationId
            )
          ) {
            Interpolator = interpolatorHashMap[interpolationId];
          }
          if (
            table &&
            Object.prototype.hasOwnProperty.call(table, translationId)
          ) {
            var translation = table[translationId];
            if (translation.substr(0, 2) === "@:") {
              result = determineTranslationInstant(
                translation.substr(2),
                interpolateParams,
                interpolationId,
                uses,
                sanitizeStrategy
              );
            } else {
              result = Interpolator.interpolate(
                translation,
                interpolateParams,
                "filter",
                sanitizeStrategy
              );
              result = applyPostProcessing(
                translationId,
                translation,
                result,
                interpolateParams,
                uses,
                sanitizeStrategy
              );
            }
          } else {
            var missingTranslationHandlerTranslation;
            if ($missingTranslationHandlerFactory && !pendingLoader) {
              missingTranslationHandlerTranslation = translateByHandler(
                translationId,
                interpolateParams,
                sanitizeStrategy
              );
            }
            if (uses && $fallbackLanguage && $fallbackLanguage.length) {
              fallbackIndex = 0;
              result = fallbackTranslationInstant(
                translationId,
                interpolateParams,
                Interpolator,
                sanitizeStrategy
              );
            } else if (
              $missingTranslationHandlerFactory &&
              !pendingLoader &&
              missingTranslationHandlerTranslation
            ) {
              result = missingTranslationHandlerTranslation;
            } else {
              result = applyNotFoundIndicators(translationId);
            }
          }
          return result;
        };
        var clearNextLangAndPromise = function (key) {
          if ($nextLang === key) {
            $nextLang = undefined;
          }
          langPromises[key] = undefined;
        };
        var applyPostProcessing = function (
          translationId,
          translation,
          resolvedTranslation,
          interpolateParams,
          uses,
          sanitizeStrategy
        ) {
          var fn = postProcessFn;
          if (fn) {
            if (typeof fn === "string") {
              fn = $injector.get(fn);
            }
            if (fn) {
              return fn(
                translationId,
                translation,
                resolvedTranslation,
                interpolateParams,
                uses,
                sanitizeStrategy
              );
            }
          }
          return resolvedTranslation;
        };
        var loadTranslationsIfMissing = function (key) {
          if (!$translationTable[key] && $loaderFactory && !langPromises[key]) {
            langPromises[key] = loadAsync(key).then(function (translation) {
              translations(translation.key, translation.table);
              return translation;
            });
          }
        };
        $translate.preferredLanguage = function (langKey) {
          if (langKey) {
            setupPreferredLanguage(langKey);
          }
          return $preferredLanguage;
        };
        $translate.cloakClassName = function () {
          return $cloakClassName;
        };
        $translate.nestedObjectDelimeter = function () {
          return $nestedObjectDelimeter;
        };
        $translate.fallbackLanguage = function (langKey) {
          if (langKey !== undefined && langKey !== null) {
            fallbackStack(langKey);
            if ($loaderFactory) {
              if ($fallbackLanguage && $fallbackLanguage.length) {
                for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {
                  if (!langPromises[$fallbackLanguage[i]]) {
                    langPromises[$fallbackLanguage[i]] = loadAsync(
                      $fallbackLanguage[i]
                    );
                  }
                }
              }
            }
            $translate.use($translate.use());
          }
          if ($fallbackWasString) {
            return $fallbackLanguage[0];
          } else {
            return $fallbackLanguage;
          }
        };
        $translate.useFallbackLanguage = function (langKey) {
          if (langKey !== undefined && langKey !== null) {
            if (!langKey) {
              startFallbackIteration = 0;
            } else {
              var langKeyPosition = indexOf($fallbackLanguage, langKey);
              if (langKeyPosition > -1) {
                startFallbackIteration = langKeyPosition;
              }
            }
          }
        };
        $translate.proposedLanguage = function () {
          return $nextLang;
        };
        $translate.storage = function () {
          return Storage;
        };
        $translate.negotiateLocale = negotiateLocale;
        $translate.use = function (key) {
          if (!key) {
            return $uses;
          }
          var deferred = $q.defer();
          $rootScope.$emit("$translateChangeStart", { language: key });
          var aliasedKey = negotiateLocale(key);
          if ($availableLanguageKeys.length > 0 && !aliasedKey) {
            return $q.reject(key);
          }
          if (aliasedKey) {
            key = aliasedKey;
          }
          $nextLang = key;
          if (
            ($forceAsyncReloadEnabled || !$translationTable[key]) &&
            $loaderFactory &&
            !langPromises[key]
          ) {
            langPromises[key] = loadAsync(key).then(
              function (translation) {
                translations(translation.key, translation.table);
                deferred.resolve(translation.key);
                if ($nextLang === key) {
                  useLanguage(translation.key);
                }
                return translation;
              },
              function (key) {
                $rootScope.$emit("$translateChangeError", { language: key });
                deferred.reject(key);
                $rootScope.$emit("$translateChangeEnd", { language: key });
                return $q.reject(key);
              }
            );
            langPromises[key]["finally"](function () {
              clearNextLangAndPromise(key);
            });
          } else if (langPromises[key]) {
            langPromises[key].then(
              function (translation) {
                if ($nextLang === translation.key) {
                  useLanguage(translation.key);
                }
                deferred.resolve(translation.key);
                return translation;
              },
              function (key) {
                if (
                  !$uses &&
                  $fallbackLanguage &&
                  $fallbackLanguage.length > 0 &&
                  $fallbackLanguage[0] !== key
                ) {
                  return $translate
                    .use($fallbackLanguage[0])
                    .then(deferred.resolve, deferred.reject);
                } else {
                  return deferred.reject(key);
                }
              }
            );
          } else {
            deferred.resolve(key);
            useLanguage(key);
          }
          return deferred.promise;
        };
        $translate.resolveClientLocale = function () {
          return getLocale();
        };
        $translate.storageKey = function () {
          return storageKey();
        };
        $translate.isPostCompilingEnabled = function () {
          return $postCompilingEnabled;
        };
        $translate.isForceAsyncReloadEnabled = function () {
          return $forceAsyncReloadEnabled;
        };
        $translate.isKeepContent = function () {
          return $keepContent;
        };
        $translate.refresh = function (langKey) {
          if (!$loaderFactory) {
            throw new Error(
              "Couldn't refresh translation table, no loader registered!"
            );
          }
          var deferred = $q.defer();
          function resolve() {
            deferred.resolve();
            $rootScope.$emit("$translateRefreshEnd", { language: langKey });
          }
          function reject() {
            deferred.reject();
            $rootScope.$emit("$translateRefreshEnd", { language: langKey });
          }
          $rootScope.$emit("$translateRefreshStart", { language: langKey });
          if (!langKey) {
            var tables = [],
              loadingKeys = {};
            if ($fallbackLanguage && $fallbackLanguage.length) {
              for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {
                tables.push(loadAsync($fallbackLanguage[i]));
                loadingKeys[$fallbackLanguage[i]] = true;
              }
            }
            if ($uses && !loadingKeys[$uses]) {
              tables.push(loadAsync($uses));
            }
            var allTranslationsLoaded = function (tableData) {
              $translationTable = {};
              angular.forEach(tableData, function (data) {
                translations(data.key, data.table);
              });
              if ($uses) {
                useLanguage($uses);
              }
              resolve();
            };
            allTranslationsLoaded.displayName = "refreshPostProcessor";
            $q.all(tables).then(allTranslationsLoaded, reject);
          } else if ($translationTable[langKey]) {
            var oneTranslationsLoaded = function (data) {
              translations(data.key, data.table);
              if (langKey === $uses) {
                useLanguage($uses);
              }
              resolve();
              return data;
            };
            oneTranslationsLoaded.displayName = "refreshPostProcessor";
            loadAsync(langKey).then(oneTranslationsLoaded, reject);
          } else {
            reject();
          }
          return deferred.promise;
        };
        $translate.instant = function (
          translationId,
          interpolateParams,
          interpolationId,
          forceLanguage,
          sanitizeStrategy
        ) {
          var uses =
            forceLanguage && forceLanguage !== $uses
              ? negotiateLocale(forceLanguage) || forceLanguage
              : $uses;
          if (translationId === null || angular.isUndefined(translationId)) {
            return translationId;
          }
          if (forceLanguage) {
            loadTranslationsIfMissing(forceLanguage);
          }
          if (angular.isArray(translationId)) {
            var results = {};
            for (var i = 0, c = translationId.length; i < c; i++) {
              results[translationId[i]] = $translate.instant(
                translationId[i],
                interpolateParams,
                interpolationId,
                forceLanguage,
                sanitizeStrategy
              );
            }
            return results;
          }
          if (angular.isString(translationId) && translationId.length < 1) {
            return translationId;
          }
          if (translationId) {
            translationId = trim.apply(translationId);
          }
          var result,
            possibleLangKeys = [];
          if ($preferredLanguage) {
            possibleLangKeys.push($preferredLanguage);
          }
          if (uses) {
            possibleLangKeys.push(uses);
          }
          if ($fallbackLanguage && $fallbackLanguage.length) {
            possibleLangKeys = possibleLangKeys.concat($fallbackLanguage);
          }
          for (var j = 0, d = possibleLangKeys.length; j < d; j++) {
            var possibleLangKey = possibleLangKeys[j];
            if ($translationTable[possibleLangKey]) {
              if (
                typeof $translationTable[possibleLangKey][translationId] !==
                "undefined"
              ) {
                result = determineTranslationInstant(
                  translationId,
                  interpolateParams,
                  interpolationId,
                  uses,
                  sanitizeStrategy
                );
              }
            }
            if (typeof result !== "undefined") {
              break;
            }
          }
          if (!result && result !== "") {
            if ($notFoundIndicatorLeft || $notFoundIndicatorRight) {
              result = applyNotFoundIndicators(translationId);
            } else {
              result = defaultInterpolator.interpolate(
                translationId,
                interpolateParams,
                "filter",
                sanitizeStrategy
              );
              var missingTranslationHandlerTranslation;
              if ($missingTranslationHandlerFactory && !pendingLoader) {
                missingTranslationHandlerTranslation = translateByHandler(
                  translationId,
                  interpolateParams,
                  sanitizeStrategy
                );
              }
              if (
                $missingTranslationHandlerFactory &&
                !pendingLoader &&
                missingTranslationHandlerTranslation
              ) {
                result = missingTranslationHandlerTranslation;
              }
            }
          }
          return result;
        };
        $translate.versionInfo = function () {
          return version;
        };
        $translate.loaderCache = function () {
          return loaderCache;
        };
        $translate.directivePriority = function () {
          return directivePriority;
        };
        $translate.statefulFilter = function () {
          return statefulFilter;
        };
        $translate.isReady = function () {
          return $isReady;
        };
        var $onReadyDeferred = $q.defer();
        $onReadyDeferred.promise.then(function () {
          $isReady = true;
        });
        $translate.onReady = function (fn) {
          var deferred = $q.defer();
          if (angular.isFunction(fn)) {
            deferred.promise.then(fn);
          }
          if ($isReady) {
            deferred.resolve();
          } else {
            $onReadyDeferred.promise.then(deferred.resolve);
          }
          return deferred.promise;
        };
        $translate.getAvailableLanguageKeys = function () {
          if ($availableLanguageKeys.length > 0) {
            return $availableLanguageKeys;
          }
          return null;
        };
        $translate.getTranslationTable = function (langKey) {
          langKey = langKey || $translate.use();
          if (langKey && $translationTable[langKey]) {
            return angular.copy($translationTable[langKey]);
          }
          return null;
        };
        var globalOnReadyListener = $rootScope.$on(
          "$translateReady",
          function () {
            $onReadyDeferred.resolve();
            globalOnReadyListener();
            globalOnReadyListener = null;
          }
        );
        var globalOnChangeListener = $rootScope.$on(
          "$translateChangeEnd",
          function () {
            $onReadyDeferred.resolve();
            globalOnChangeListener();
            globalOnChangeListener = null;
          }
        );
        if ($loaderFactory) {
          if (angular.equals($translationTable, {})) {
            if ($translate.use()) {
              $translate.use($translate.use());
            }
          }
          if ($fallbackLanguage && $fallbackLanguage.length) {
            var processAsyncResult = function (translation) {
              translations(translation.key, translation.table);
              $rootScope.$emit("$translateChangeEnd", {
                language: translation.key,
              });
              return translation;
            };
            for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {
              var fallbackLanguageId = $fallbackLanguage[i];
              if (
                $forceAsyncReloadEnabled ||
                !$translationTable[fallbackLanguageId]
              ) {
                langPromises[fallbackLanguageId] =
                  loadAsync(fallbackLanguageId).then(processAsyncResult);
              }
            }
          }
        } else {
          $rootScope.$emit("$translateReady", { language: $translate.use() });
        }
        return $translate;
      },
    ];
  }
  $translate.displayName = "displayName";
  angular
    .module("pascalprecht.translate")
    .factory("$translateDefaultInterpolation", $translateDefaultInterpolation);
  function $translateDefaultInterpolation(
    $interpolate,
    $translateSanitization
  ) {
    "use strict";
    var $translateInterpolator = {},
      $locale,
      $identifier = "default";
    $translateInterpolator.setLocale = function (locale) {
      $locale = locale;
    };
    $translateInterpolator.getInterpolationIdentifier = function () {
      return $identifier;
    };
    $translateInterpolator.useSanitizeValueStrategy = function (value) {
      $translateSanitization.useStrategy(value);
      return this;
    };
    $translateInterpolator.interpolate = function (
      value,
      interpolationParams,
      context,
      sanitizeStrategy
    ) {
      interpolationParams = interpolationParams || {};
      interpolationParams = $translateSanitization.sanitize(
        interpolationParams,
        "params",
        sanitizeStrategy,
        context
      );
      var interpolatedText;
      if (angular.isNumber(value)) {
        interpolatedText = "" + value;
      } else if (angular.isString(value)) {
        interpolatedText = $interpolate(value)(interpolationParams);
        interpolatedText = $translateSanitization.sanitize(
          interpolatedText,
          "text",
          sanitizeStrategy,
          context
        );
      } else {
        interpolatedText = "";
      }
      return interpolatedText;
    };
    return $translateInterpolator;
  }
  $translateDefaultInterpolation.displayName = "$translateDefaultInterpolation";
  angular
    .module("pascalprecht.translate")
    .constant("$STORAGE_KEY", "NG_TRANSLATE_LANG_KEY");
  angular
    .module("pascalprecht.translate")
    .directive("translate", translateDirective);
  function translateDirective(
    $translate,
    $interpolate,
    $compile,
    $parse,
    $rootScope
  ) {
    "use strict";
    var trim = function () {
      return this.toString().replace(/^\s+|\s+$/g, "");
    };
    return {
      restrict: "AE",
      scope: true,
      priority: $translate.directivePriority(),
      compile: function (tElement, tAttr) {
        var translateValuesExist = tAttr.translateValues
          ? tAttr.translateValues
          : undefined;
        var translateInterpolation = tAttr.translateInterpolation
          ? tAttr.translateInterpolation
          : undefined;
        var translateValueExist =
          tElement[0].outerHTML.match(/translate-value-+/i);
        var interpolateRegExp =
            "^(.*)(" +
            $interpolate.startSymbol() +
            ".*" +
            $interpolate.endSymbol() +
            ")(.*)",
          watcherRegExp =
            "^(.*)" +
            $interpolate.startSymbol() +
            "(.*)" +
            $interpolate.endSymbol() +
            "(.*)";
        return function linkFn(scope, iElement, iAttr) {
          scope.interpolateParams = {};
          scope.preText = "";
          scope.postText = "";
          scope.translateNamespace = getTranslateNamespace(scope);
          var translationIds = {};
          var initInterpolationParams = function (
            interpolateParams,
            iAttr,
            tAttr
          ) {
            if (iAttr.translateValues) {
              angular.extend(
                interpolateParams,
                $parse(iAttr.translateValues)(scope.$parent)
              );
            }
            if (translateValueExist) {
              for (var attr in tAttr) {
                if (
                  Object.prototype.hasOwnProperty.call(iAttr, attr) &&
                  attr.substr(0, 14) === "translateValue" &&
                  attr !== "translateValues"
                ) {
                  var attributeName =
                    angular.lowercase(attr.substr(14, 1)) + attr.substr(15);
                  interpolateParams[attributeName] = tAttr[attr];
                }
              }
            }
          };
          var observeElementTranslation = function (translationId) {
            if (angular.isFunction(observeElementTranslation._unwatchOld)) {
              observeElementTranslation._unwatchOld();
              observeElementTranslation._unwatchOld = undefined;
            }
            if (
              angular.equals(translationId, "") ||
              !angular.isDefined(translationId)
            ) {
              var iElementText = trim.apply(iElement.text());
              var interpolateMatches = iElementText.match(interpolateRegExp);
              if (angular.isArray(interpolateMatches)) {
                scope.preText = interpolateMatches[1];
                scope.postText = interpolateMatches[3];
                translationIds.translate = $interpolate(interpolateMatches[2])(
                  scope.$parent
                );
                var watcherMatches = iElementText.match(watcherRegExp);
                if (
                  angular.isArray(watcherMatches) &&
                  watcherMatches[2] &&
                  watcherMatches[2].length
                ) {
                  observeElementTranslation._unwatchOld = scope.$watch(
                    watcherMatches[2],
                    function (newValue) {
                      translationIds.translate = newValue;
                      updateTranslations();
                    }
                  );
                }
              } else {
                translationIds.translate = !iElementText
                  ? undefined
                  : iElementText;
              }
            } else {
              translationIds.translate = translationId;
            }
            updateTranslations();
          };
          var observeAttributeTranslation = function (translateAttr) {
            iAttr.$observe(translateAttr, function (translationId) {
              translationIds[translateAttr] = translationId;
              updateTranslations();
            });
          };
          initInterpolationParams(scope.interpolateParams, iAttr, tAttr);
          var firstAttributeChangedEvent = true;
          iAttr.$observe("translate", function (translationId) {
            if (typeof translationId === "undefined") {
              observeElementTranslation("");
            } else {
              if (translationId !== "" || !firstAttributeChangedEvent) {
                translationIds.translate = translationId;
                updateTranslations();
              }
            }
            firstAttributeChangedEvent = false;
          });
          for (var translateAttr in iAttr) {
            if (
              iAttr.hasOwnProperty(translateAttr) &&
              translateAttr.substr(0, 13) === "translateAttr" &&
              translateAttr.length > 13
            ) {
              observeAttributeTranslation(translateAttr);
            }
          }
          iAttr.$observe("translateDefault", function (value) {
            scope.defaultText = value;
            updateTranslations();
          });
          if (translateValuesExist) {
            iAttr.$observe("translateValues", function (interpolateParams) {
              if (interpolateParams) {
                scope.$parent.$watch(function () {
                  angular.extend(
                    scope.interpolateParams,
                    $parse(interpolateParams)(scope.$parent)
                  );
                });
              }
            });
          }
          if (translateValueExist) {
            var observeValueAttribute = function (attrName) {
              iAttr.$observe(attrName, function (value) {
                var attributeName =
                  angular.lowercase(attrName.substr(14, 1)) +
                  attrName.substr(15);
                scope.interpolateParams[attributeName] = value;
              });
            };
            for (var attr in iAttr) {
              if (
                Object.prototype.hasOwnProperty.call(iAttr, attr) &&
                attr.substr(0, 14) === "translateValue" &&
                attr !== "translateValues"
              ) {
                observeValueAttribute(attr);
              }
            }
          }
          var updateTranslations = function () {
            for (var key in translationIds) {
              if (
                translationIds.hasOwnProperty(key) &&
                translationIds[key] !== undefined
              ) {
                updateTranslation(
                  key,
                  translationIds[key],
                  scope,
                  scope.interpolateParams,
                  scope.defaultText,
                  scope.translateNamespace
                );
              }
            }
          };
          var updateTranslation = function (
            translateAttr,
            translationId,
            scope,
            interpolateParams,
            defaultTranslationText,
            translateNamespace
          ) {
            if (translationId) {
              if (translateNamespace && translationId.charAt(0) === ".") {
                translationId = translateNamespace + translationId;
              }
              $translate(
                translationId,
                interpolateParams,
                translateInterpolation,
                defaultTranslationText,
                scope.translateLanguage
              ).then(
                function (translation) {
                  applyTranslation(translation, scope, true, translateAttr);
                },
                function (translationId) {
                  applyTranslation(translationId, scope, false, translateAttr);
                }
              );
            } else {
              applyTranslation(translationId, scope, false, translateAttr);
            }
          };
          var applyTranslation = function (
            value,
            scope,
            successful,
            translateAttr
          ) {
            if (!successful) {
              if (typeof scope.defaultText !== "undefined") {
                value = scope.defaultText;
              }
            }
            if (translateAttr === "translate") {
              if (
                successful ||
                (!successful &&
                  !$translate.isKeepContent() &&
                  typeof iAttr.translateKeepContent === "undefined")
              ) {
                iElement.empty().append(scope.preText + value + scope.postText);
              }
              var globallyEnabled = $translate.isPostCompilingEnabled();
              var locallyDefined =
                typeof tAttr.translateCompile !== "undefined";
              var locallyEnabled =
                locallyDefined && tAttr.translateCompile !== "false";
              if ((globallyEnabled && !locallyDefined) || locallyEnabled) {
                $compile(iElement.contents())(scope);
              }
            } else {
              var attributeName = iAttr.$attr[translateAttr];
              if (attributeName.substr(0, 5) === "data-") {
                attributeName = attributeName.substr(5);
              }
              attributeName = attributeName.substr(15);
              iElement.attr(attributeName, value);
            }
          };
          if (
            translateValuesExist ||
            translateValueExist ||
            iAttr.translateDefault
          ) {
            scope.$watch("interpolateParams", updateTranslations, true);
          }
          scope.$on("translateLanguageChanged", updateTranslations);
          var unbind = $rootScope.$on(
            "$translateChangeSuccess",
            updateTranslations
          );
          if (iElement.text().length) {
            if (iAttr.translate) {
              observeElementTranslation(iAttr.translate);
            } else {
              observeElementTranslation("");
            }
          } else if (iAttr.translate) {
            observeElementTranslation(iAttr.translate);
          }
          updateTranslations();
          scope.$on("$destroy", unbind);
        };
      },
    };
  }
  function getTranslateNamespace(scope) {
    "use strict";
    if (scope.translateNamespace) {
      return scope.translateNamespace;
    }
    if (scope.$parent) {
      return getTranslateNamespace(scope.$parent);
    }
  }
  translateDirective.displayName = "translateDirective";
  angular
    .module("pascalprecht.translate")
    .directive("translateAttr", translateAttrDirective);
  function translateAttrDirective($translate, $rootScope) {
    "use strict";
    return {
      restrict: "A",
      priority: $translate.directivePriority(),
      link: function linkFn(scope, element, attr) {
        var translateAttr,
          translateValues,
          previousAttributes = {};
        var updateTranslations = function () {
          angular.forEach(
            translateAttr,
            function (translationId, attributeName) {
              if (!translationId) {
                return;
              }
              previousAttributes[attributeName] = true;
              if (scope.translateNamespace && translationId.charAt(0) === ".") {
                translationId = scope.translateNamespace + translationId;
              }
              $translate(
                translationId,
                translateValues,
                attr.translateInterpolation,
                undefined,
                scope.translateLanguage
              ).then(
                function (translation) {
                  element.attr(attributeName, translation);
                },
                function (translationId) {
                  element.attr(attributeName, translationId);
                }
              );
            }
          );
          angular.forEach(previousAttributes, function (flag, attributeName) {
            if (!translateAttr[attributeName]) {
              element.removeAttr(attributeName);
              delete previousAttributes[attributeName];
            }
          });
        };
        watchAttribute(
          scope,
          attr.translateAttr,
          function (newValue) {
            translateAttr = newValue;
          },
          updateTranslations
        );
        watchAttribute(
          scope,
          attr.translateValues,
          function (newValue) {
            translateValues = newValue;
          },
          updateTranslations
        );
        if (attr.translateValues) {
          scope.$watch(attr.translateValues, updateTranslations, true);
        }
        scope.$on("translateLanguageChanged", updateTranslations);
        var unbind = $rootScope.$on(
          "$translateChangeSuccess",
          updateTranslations
        );
        updateTranslations();
        scope.$on("$destroy", unbind);
      },
    };
  }
  function watchAttribute(scope, attribute, valueCallback, changeCallback) {
    "use strict";
    if (!attribute) {
      return;
    }
    if (attribute.substr(0, 2) === "::") {
      attribute = attribute.substr(2);
    } else {
      scope.$watch(
        attribute,
        function (newValue) {
          valueCallback(newValue);
          changeCallback();
        },
        true
      );
    }
    valueCallback(scope.$eval(attribute));
  }
  translateAttrDirective.displayName = "translateAttrDirective";
  angular
    .module("pascalprecht.translate")
    .directive("translateCloak", translateCloakDirective);
  function translateCloakDirective($translate, $rootScope) {
    "use strict";
    return {
      compile: function (tElement) {
        var applyCloak = function () {
            tElement.addClass($translate.cloakClassName());
          },
          removeCloak = function () {
            tElement.removeClass($translate.cloakClassName());
          };
        $translate.onReady(function () {
          removeCloak();
        });
        applyCloak();
        return function linkFn(scope, iElement, iAttr) {
          if (iAttr.translateCloak && iAttr.translateCloak.length) {
            iAttr.$observe("translateCloak", function (translationId) {
              $translate(translationId).then(removeCloak, applyCloak);
            });
            $rootScope.$on("$translateChangeSuccess", function () {
              $translate(iAttr.translateCloak).then(removeCloak, applyCloak);
            });
          }
        };
      },
    };
  }
  translateCloakDirective.displayName = "translateCloakDirective";
  angular
    .module("pascalprecht.translate")
    .directive("translateNamespace", translateNamespaceDirective);
  function translateNamespaceDirective() {
    "use strict";
    return {
      restrict: "A",
      scope: true,
      compile: function () {
        return {
          pre: function (scope, iElement, iAttrs) {
            scope.translateNamespace = getTranslateNamespace(scope);
            if (
              scope.translateNamespace &&
              iAttrs.translateNamespace.charAt(0) === "."
            ) {
              scope.translateNamespace += iAttrs.translateNamespace;
            } else {
              scope.translateNamespace = iAttrs.translateNamespace;
            }
          },
        };
      },
    };
  }
  function getTranslateNamespace(scope) {
    "use strict";
    if (scope.translateNamespace) {
      return scope.translateNamespace;
    }
    if (scope.$parent) {
      return getTranslateNamespace(scope.$parent);
    }
  }
  translateNamespaceDirective.displayName = "translateNamespaceDirective";
  angular
    .module("pascalprecht.translate")
    .directive("translateLanguage", translateLanguageDirective);
  function translateLanguageDirective() {
    "use strict";
    return {
      restrict: "A",
      scope: true,
      compile: function () {
        return function linkFn(scope, iElement, iAttrs) {
          iAttrs.$observe("translateLanguage", function (newTranslateLanguage) {
            scope.translateLanguage = newTranslateLanguage;
          });
          scope.$watch("translateLanguage", function () {
            scope.$broadcast("translateLanguageChanged");
          });
        };
      },
    };
  }
  translateLanguageDirective.displayName = "translateLanguageDirective";
  angular
    .module("pascalprecht.translate")
    .filter("translate", translateFilterFactory);
  function translateFilterFactory($parse, $translate) {
    "use strict";
    var translateFilter = function (
      translationId,
      interpolateParams,
      interpolation,
      forceLanguage
    ) {
      if (!angular.isObject(interpolateParams)) {
        interpolateParams = $parse(interpolateParams)(this);
      }
      return $translate.instant(
        translationId,
        interpolateParams,
        interpolation,
        forceLanguage
      );
    };
    if ($translate.statefulFilter()) {
      translateFilter.$stateful = true;
    }
    return translateFilter;
  }
  translateFilterFactory.displayName = "translateFilterFactory";
  angular
    .module("pascalprecht.translate")
    .factory("$translationCache", $translationCache);
  function $translationCache($cacheFactory) {
    "use strict";
    return $cacheFactory("translations");
  }
  $translationCache.displayName = "$translationCache";
  return "pascalprecht.translate";
});
(function (root, factory) {
  if (typeof define === "function" && define.amd) {
    define([], function () {
      return factory();
    });
  } else if (typeof exports === "object") {
    module.exports = factory();
  } else {
    factory();
  }
})(this, function () {
  $translateStaticFilesLoader.$inject = ["$q", "$http"];
  angular
    .module("pascalprecht.translate")
    .factory("$translateStaticFilesLoader", $translateStaticFilesLoader);
  function $translateStaticFilesLoader($q, $http) {
    "use strict";
    return function (options) {
      if (
        !options ||
        (!angular.isArray(options.files) &&
          (!angular.isString(options.prefix) ||
            !angular.isString(options.suffix)))
      ) {
        throw new Error(
          "Couldn't load static files, no files and prefix or suffix specified!"
        );
      }
      if (!options.files) {
        options.files = [{ prefix: options.prefix, suffix: options.suffix }];
      }
      var load = function (file) {
        if (
          !file ||
          !angular.isString(file.prefix) ||
          !angular.isString(file.suffix)
        ) {
          throw new Error(
            "Couldn't load static file, no prefix or suffix specified!"
          );
        }
        var fileUrl = [file.prefix, options.key, file.suffix].join("");
        if (angular.isObject(options.fileMap) && options.fileMap[fileUrl]) {
          fileUrl = options.fileMap[fileUrl];
        }
        return $http(
          angular.extend(
            { url: fileUrl, method: "GET", params: "" },
            options.$http
          )
        ).then(
          function (result) {
            return result.data;
          },
          function () {
            return $q.reject(options.key);
          }
        );
      };
      var promises = [],
        length = options.files.length;
      for (var i = 0; i < length; i++) {
        promises.push(
          load({
            prefix: options.files[i].prefix,
            key: options.key,
            suffix: options.files[i].suffix,
          })
        );
      }
      return $q.all(promises).then(function (data) {
        var length = data.length,
          mergedData = {};
        for (var i = 0; i < length; i++) {
          for (var key in data[i]) {
            mergedData[key] = data[i][key];
          }
        }
        return mergedData;
      });
    };
  }
  $translateStaticFilesLoader.displayName = "$translateStaticFilesLoader";
  return "pascalprecht.translate";
});
(function (window, angular) {
  "use strict";
  var $sanitizeMinErr = angular.$$minErr("$sanitize");
  var bind;
  var extend;
  var forEach;
  var isDefined;
  var lowercase;
  var noop;
  var htmlParser;
  var htmlSanitizeWriter;
  function $SanitizeProvider() {
    var svgEnabled = false;
    this.$get = [
      "$$sanitizeUri",
      function ($$sanitizeUri) {
        if (svgEnabled) {
          extend(validElements, svgElements);
        }
        return function (html) {
          var buf = [];
          htmlParser(
            html,
            htmlSanitizeWriter(buf, function (uri, isImage) {
              return !/^unsafe:/.test($$sanitizeUri(uri, isImage));
            })
          );
          return buf.join("");
        };
      },
    ];
    this.enableSvg = function (enableSvg) {
      if (isDefined(enableSvg)) {
        svgEnabled = enableSvg;
        return this;
      } else {
        return svgEnabled;
      }
    };
    bind = angular.bind;
    extend = angular.extend;
    forEach = angular.forEach;
    isDefined = angular.isDefined;
    lowercase = angular.lowercase;
    noop = angular.noop;
    htmlParser = htmlParserImpl;
    htmlSanitizeWriter = htmlSanitizeWriterImpl;
    var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
      NON_ALPHANUMERIC_REGEXP = /([^#-~ |!])/g;
    var voidElements = toMap("area,br,col,hr,img,wbr");
    var optionalEndTagBlockElements = toMap(
        "colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"
      ),
      optionalEndTagInlineElements = toMap("rp,rt"),
      optionalEndTagElements = extend(
        {},
        optionalEndTagInlineElements,
        optionalEndTagBlockElements
      );
    var blockElements = extend(
      {},
      optionalEndTagBlockElements,
      toMap(
        "address,article," +
          "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," +
          "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul"
      )
    );
    var inlineElements = extend(
      {},
      optionalEndTagInlineElements,
      toMap(
        "a,abbr,acronym,b," +
          "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," +
          "samp,small,span,strike,strong,sub,sup,time,tt,u,var"
      )
    );
    var svgElements = toMap(
      "circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph," +
        "hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline," +
        "radialGradient,rect,stop,svg,switch,text,title,tspan"
    );
    var blockedElements = toMap("script,style");
    var validElements = extend(
      {},
      voidElements,
      blockElements,
      inlineElements,
      optionalEndTagElements
    );
    var uriAttrs = toMap("background,cite,href,longdesc,src,xlink:href");
    var htmlAttrs = toMap(
      "abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear," +
        "color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace," +
        "ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules," +
        "scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type," +
        "valign,value,vspace,width"
    );
    var svgAttrs = toMap(
      "accent-height,accumulate,additive,alphabetic,arabic-form,ascent," +
        "baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content," +
        "cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch," +
        "font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging," +
        "height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang," +
        "marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical," +
        "max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1," +
        "path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur," +
        "requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color," +
        "stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray," +
        "stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity," +
        "stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position," +
        "underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility," +
        "width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title," +
        "xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan",
      true
    );
    var validAttrs = extend({}, uriAttrs, svgAttrs, htmlAttrs);
    function toMap(str, lowercaseKeys) {
      var obj = {},
        items = str.split(","),
        i;
      for (i = 0; i < items.length; i++) {
        obj[lowercaseKeys ? lowercase(items[i]) : items[i]] = true;
      }
      return obj;
    }
    var inertBodyElement;
    (function (window) {
      var doc;
      if (window.document && window.document.implementation) {
        doc = window.document.implementation.createHTMLDocument("inert");
      } else {
        throw $sanitizeMinErr("noinert", "Can't create an inert html document");
      }
      var docElement = doc.documentElement || doc.getDocumentElement();
      var bodyElements = docElement.getElementsByTagName("body");
      if (bodyElements.length === 1) {
        inertBodyElement = bodyElements[0];
      } else {
        var html = doc.createElement("html");
        inertBodyElement = doc.createElement("body");
        html.appendChild(inertBodyElement);
        doc.appendChild(html);
      }
    })(window);
    function htmlParserImpl(html, handler) {
      if (html === null || html === undefined) {
        html = "";
      } else if (typeof html !== "string") {
        html = "" + html;
      }
      inertBodyElement.innerHTML = html;
      var mXSSAttempts = 5;
      do {
        if (mXSSAttempts === 0) {
          throw $sanitizeMinErr(
            "uinput",
            "Failed to sanitize html because the input is unstable"
          );
        }
        mXSSAttempts--;
        if (window.document.documentMode) {
          stripCustomNsAttrs(inertBodyElement);
        }
        html = inertBodyElement.innerHTML;
        inertBodyElement.innerHTML = html;
      } while (html !== inertBodyElement.innerHTML);
      var node = inertBodyElement.firstChild;
      while (node) {
        switch (node.nodeType) {
          case 1:
            handler.start(
              node.nodeName.toLowerCase(),
              attrToMap(node.attributes)
            );
            break;
          case 3:
            handler.chars(node.textContent);
            break;
        }
        var nextNode;
        if (!(nextNode = node.firstChild)) {
          if (node.nodeType === 1) {
            handler.end(node.nodeName.toLowerCase());
          }
          nextNode = node.nextSibling;
          if (!nextNode) {
            while (nextNode == null) {
              node = node.parentNode;
              if (node === inertBodyElement) break;
              nextNode = node.nextSibling;
              if (node.nodeType === 1) {
                handler.end(node.nodeName.toLowerCase());
              }
            }
          }
        }
        node = nextNode;
      }
      while ((node = inertBodyElement.firstChild)) {
        inertBodyElement.removeChild(node);
      }
    }
    function attrToMap(attrs) {
      var map = {};
      for (var i = 0, ii = attrs.length; i < ii; i++) {
        var attr = attrs[i];
        map[attr.name] = attr.value;
      }
      return map;
    }
    function encodeEntities(value) {
      return value
        .replace(/&/g, "&amp;")
        .replace(SURROGATE_PAIR_REGEXP, function (value) {
          var hi = value.charCodeAt(0);
          var low = value.charCodeAt(1);
          return "&#" + ((hi - 55296) * 1024 + (low - 56320) + 65536) + ";";
        })
        .replace(NON_ALPHANUMERIC_REGEXP, function (value) {
          return "&#" + value.charCodeAt(0) + ";";
        })
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }
    function htmlSanitizeWriterImpl(buf, uriValidator) {
      var ignoreCurrentElement = false;
      var out = bind(buf, buf.push);
      return {
        start: function (tag, attrs) {
          tag = lowercase(tag);
          if (!ignoreCurrentElement && blockedElements[tag]) {
            ignoreCurrentElement = tag;
          }
          if (!ignoreCurrentElement && validElements[tag] === true) {
            out("<");
            out(tag);
            forEach(attrs, function (value, key) {
              var lkey = lowercase(key);
              var isImage =
                (tag === "img" && lkey === "src") || lkey === "background";
              if (
                validAttrs[lkey] === true &&
                (uriAttrs[lkey] !== true || uriValidator(value, isImage))
              ) {
                out(" ");
                out(key);
                out('="');
                out(encodeEntities(value));
                out('"');
              }
            });
            out(">");
          }
        },
        end: function (tag) {
          tag = lowercase(tag);
          if (
            !ignoreCurrentElement &&
            validElements[tag] === true &&
            voidElements[tag] !== true
          ) {
            out("</");
            out(tag);
            out(">");
          }
          if (tag == ignoreCurrentElement) {
            ignoreCurrentElement = false;
          }
        },
        chars: function (chars) {
          if (!ignoreCurrentElement) {
            out(encodeEntities(chars));
          }
        },
      };
    }
    function stripCustomNsAttrs(node) {
      while (node) {
        if (node.nodeType === window.Node.ELEMENT_NODE) {
          var attrs = node.attributes;
          for (var i = 0, l = attrs.length; i < l; i++) {
            var attrNode = attrs[i];
            var attrName = attrNode.name.toLowerCase();
            if (
              attrName === "xmlns:ns1" ||
              attrName.lastIndexOf("ns1:", 0) === 0
            ) {
              node.removeAttributeNode(attrNode);
              i--;
              l--;
            }
          }
        }
        var nextNode = node.firstChild;
        if (nextNode) {
          stripCustomNsAttrs(nextNode);
        }
        node = node.nextSibling;
      }
    }
  }
  function sanitizeText(chars) {
    var buf = [];
    var writer = htmlSanitizeWriter(buf, noop);
    writer.chars(chars);
    return buf.join("");
  }
  angular.module("ngSanitize", []).provider("$sanitize", $SanitizeProvider);
  angular.module("ngSanitize").filter("linky", [
    "$sanitize",
    function ($sanitize) {
      var LINKY_URL_REGEXP =
          /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i,
        MAILTO_REGEXP = /^mailto:/i;
      var linkyMinErr = angular.$$minErr("linky");
      var isDefined = angular.isDefined;
      var isFunction = angular.isFunction;
      var isObject = angular.isObject;
      var isString = angular.isString;
      return function (text, target, attributes) {
        if (text == null || text === "") return text;
        if (!isString(text))
          throw linkyMinErr(
            "notstring",
            "Expected string but received: {0}",
            text
          );
        var attributesFn = isFunction(attributes)
          ? attributes
          : isObject(attributes)
          ? function getAttributesObject() {
              return attributes;
            }
          : function getEmptyAttributesObject() {
              return {};
            };
        var match;
        var raw = text;
        var html = [];
        var url;
        var i;
        while ((match = raw.match(LINKY_URL_REGEXP))) {
          url = match[0];
          if (!match[2] && !match[4]) {
            url = (match[3] ? "http://" : "mailto:") + url;
          }
          i = match.index;
          addText(raw.substr(0, i));
          addLink(url, match[0].replace(MAILTO_REGEXP, ""));
          raw = raw.substring(i + match[0].length);
        }
        addText(raw);
        return $sanitize(html.join(""));
        function addText(text) {
          if (!text) {
            return;
          }
          html.push(sanitizeText(text));
        }
        function addLink(url, text) {
          var key,
            linkAttributes = attributesFn(url);
          html.push("<a ");
          for (key in linkAttributes) {
            html.push(key + '="' + linkAttributes[key] + '" ');
          }
          if (isDefined(target) && !("target" in linkAttributes)) {
            html.push('target="', target, '" ');
          }
          html.push('href="', url.replace(/"/g, "&quot;"), '">');
          addText(text);
          html.push("</a>");
        }
      };
    },
  ]);
})(window, window.angular);
angular.module("ui.bootstrap", [
  "ui.bootstrap.tpls",
  "ui.bootstrap.collapse",
  "ui.bootstrap.tabindex",
  "ui.bootstrap.accordion",
  "ui.bootstrap.alert",
  "ui.bootstrap.buttons",
  "ui.bootstrap.carousel",
  "ui.bootstrap.dateparser",
  "ui.bootstrap.isClass",
  "ui.bootstrap.datepicker",
  "ui.bootstrap.position",
  "ui.bootstrap.datepickerPopup",
  "ui.bootstrap.debounce",
  "ui.bootstrap.multiMap",
  "ui.bootstrap.dropdown",
  "ui.bootstrap.stackedMap",
  "ui.bootstrap.modal",
  "ui.bootstrap.paging",
  "ui.bootstrap.pager",
  "ui.bootstrap.pagination",
  "ui.bootstrap.tooltip",
  "ui.bootstrap.popover",
  "ui.bootstrap.progressbar",
  "ui.bootstrap.rating",
  "ui.bootstrap.tabs",
  "ui.bootstrap.timepicker",
  "ui.bootstrap.typeahead",
]);
angular.module("ui.bootstrap.tpls", [
  "uib/template/accordion/accordion-group.html",
  "uib/template/accordion/accordion.html",
  "uib/template/alert/alert.html",
  "uib/template/carousel/carousel.html",
  "uib/template/carousel/slide.html",
  "uib/template/datepicker/datepicker.html",
  "uib/template/datepicker/day.html",
  "uib/template/datepicker/month.html",
  "uib/template/datepicker/year.html",
  "uib/template/datepickerPopup/popup.html",
  "uib/template/modal/window.html",
  "uib/template/pager/pager.html",
  "uib/template/pagination/pagination.html",
  "uib/template/tooltip/tooltip-html-popup.html",
  "uib/template/tooltip/tooltip-popup.html",
  "uib/template/tooltip/tooltip-template-popup.html",
  "uib/template/popover/popover-html.html",
  "uib/template/popover/popover-template.html",
  "uib/template/popover/popover.html",
  "uib/template/progressbar/bar.html",
  "uib/template/progressbar/progress.html",
  "uib/template/progressbar/progressbar.html",
  "uib/template/rating/rating.html",
  "uib/template/tabs/tab.html",
  "uib/template/tabs/tabset.html",
  "uib/template/timepicker/timepicker.html",
  "uib/template/typeahead/typeahead-match.html",
  "uib/template/typeahead/typeahead-popup.html",
]);
angular.module("ui.bootstrap.collapse", []).directive("uibCollapse", [
  "$animate",
  "$q",
  "$parse",
  "$injector",
  function ($animate, $q, $parse, $injector) {
    var $animateCss = $injector.has("$animateCss")
      ? $injector.get("$animateCss")
      : null;
    return {
      link: function (scope, element, attrs) {
        var expandingExpr = $parse(attrs.expanding),
          expandedExpr = $parse(attrs.expanded),
          collapsingExpr = $parse(attrs.collapsing),
          collapsedExpr = $parse(attrs.collapsed),
          horizontal = false,
          css = {},
          cssTo = {};
        init();
        function init() {
          horizontal = !!("horizontal" in attrs);
          if (horizontal) {
            css = { width: "" };
            cssTo = { width: "0" };
          } else {
            css = { height: "" };
            cssTo = { height: "0" };
          }
          if (!scope.$eval(attrs.uibCollapse)) {
            element
              .addClass("in")
              .addClass("collapse")
              .attr("aria-expanded", true)
              .attr("aria-hidden", false)
              .css(css);
          }
        }
        function getScrollFromElement(element) {
          if (horizontal) {
            return { width: element.scrollWidth + "px" };
          }
          return { height: element.scrollHeight + "px" };
        }
        function expand() {
          if (element.hasClass("collapse") && element.hasClass("in")) {
            return;
          }
          $q.resolve(expandingExpr(scope)).then(function () {
            element
              .removeClass("collapse")
              .addClass("collapsing")
              .attr("aria-expanded", true)
              .attr("aria-hidden", false);
            if ($animateCss) {
              $animateCss(element, {
                addClass: "in",
                easing: "ease",
                css: { overflow: "hidden" },
                to: getScrollFromElement(element[0]),
              })
                .start()
                ["finally"](expandDone);
            } else {
              $animate
                .addClass(element, "in", {
                  css: { overflow: "hidden" },
                  to: getScrollFromElement(element[0]),
                })
                .then(expandDone);
            }
          });
        }
        function expandDone() {
          element.removeClass("collapsing").addClass("collapse").css(css);
          expandedExpr(scope);
        }
        function collapse() {
          if (!element.hasClass("collapse") && !element.hasClass("in")) {
            return collapseDone();
          }
          $q.resolve(collapsingExpr(scope)).then(function () {
            element
              .css(getScrollFromElement(element[0]))
              .removeClass("collapse")
              .addClass("collapsing")
              .attr("aria-expanded", false)
              .attr("aria-hidden", true);
            if ($animateCss) {
              $animateCss(element, { removeClass: "in", to: cssTo })
                .start()
                ["finally"](collapseDone);
            } else {
              $animate
                .removeClass(element, "in", { to: cssTo })
                .then(collapseDone);
            }
          });
        }
        function collapseDone() {
          element.css(cssTo);
          element.removeClass("collapsing").addClass("collapse");
          collapsedExpr(scope);
        }
        scope.$watch(attrs.uibCollapse, function (shouldCollapse) {
          if (shouldCollapse) {
            collapse();
          } else {
            expand();
          }
        });
      },
    };
  },
]);
angular
  .module("ui.bootstrap.tabindex", [])
  .directive("uibTabindexToggle", function () {
    return {
      restrict: "A",
      link: function (scope, elem, attrs) {
        attrs.$observe("disabled", function (disabled) {
          attrs.$set("tabindex", disabled ? -1 : null);
        });
      },
    };
  });
angular
  .module("ui.bootstrap.accordion", [
    "ui.bootstrap.collapse",
    "ui.bootstrap.tabindex",
  ])
  .constant("uibAccordionConfig", { closeOthers: true })
  .controller("UibAccordionController", [
    "$scope",
    "$attrs",
    "uibAccordionConfig",
    function ($scope, $attrs, accordionConfig) {
      this.groups = [];
      this.closeOthers = function (openGroup) {
        var closeOthers = angular.isDefined($attrs.closeOthers)
          ? $scope.$eval($attrs.closeOthers)
          : accordionConfig.closeOthers;
        if (closeOthers) {
          angular.forEach(this.groups, function (group) {
            if (group !== openGroup) {
              group.isOpen = false;
            }
          });
        }
      };
      this.addGroup = function (groupScope) {
        var that = this;
        this.groups.push(groupScope);
        groupScope.$on("$destroy", function (event) {
          that.removeGroup(groupScope);
        });
      };
      this.removeGroup = function (group) {
        var index = this.groups.indexOf(group);
        if (index !== -1) {
          this.groups.splice(index, 1);
        }
      };
    },
  ])
  .directive("uibAccordion", function () {
    return {
      controller: "UibAccordionController",
      controllerAs: "accordion",
      transclude: true,
      templateUrl: function (element, attrs) {
        return attrs.templateUrl || "uib/template/accordion/accordion.html";
      },
    };
  })
  .directive("uibAccordionGroup", function () {
    return {
      require: "^uibAccordion",
      transclude: true,
      restrict: "A",
      templateUrl: function (element, attrs) {
        return (
          attrs.templateUrl || "uib/template/accordion/accordion-group.html"
        );
      },
      scope: { heading: "@", panelClass: "@?", isOpen: "=?", isDisabled: "=?" },
      controller: function () {
        this.setHeading = function (element) {
          this.heading = element;
        };
      },
      link: function (scope, element, attrs, accordionCtrl) {
        element.addClass("panel");
        accordionCtrl.addGroup(scope);
        scope.openClass = attrs.openClass || "panel-open";
        scope.panelClass = attrs.panelClass || "panel-default";
        scope.$watch("isOpen", function (value) {
          element.toggleClass(scope.openClass, !!value);
          if (value) {
            accordionCtrl.closeOthers(scope);
          }
        });
        scope.toggleOpen = function ($event) {
          if (!scope.isDisabled) {
            if (!$event || $event.which === 32) {
              scope.isOpen = !scope.isOpen;
            }
          }
        };
        var id =
          "accordiongroup-" + scope.$id + "-" + Math.floor(Math.random() * 1e4);
        scope.headingId = id + "-tab";
        scope.panelId = id + "-panel";
      },
    };
  })
  .directive("uibAccordionHeading", function () {
    return {
      transclude: true,
      template: "",
      replace: true,
      require: "^uibAccordionGroup",
      link: function (scope, element, attrs, accordionGroupCtrl, transclude) {
        accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
      },
    };
  })
  .directive("uibAccordionTransclude", function () {
    return {
      require: "^uibAccordionGroup",
      link: function (scope, element, attrs, controller) {
        scope.$watch(
          function () {
            return controller[attrs.uibAccordionTransclude];
          },
          function (heading) {
            if (heading) {
              var elem = angular.element(
                element[0].querySelector(getHeaderSelectors())
              );
              elem.html("");
              elem.append(heading);
            }
          }
        );
      },
    };
    function getHeaderSelectors() {
      return (
        "uib-accordion-header," +
        "data-uib-accordion-header," +
        "x-uib-accordion-header," +
        "uib\\:accordion-header," +
        "[uib-accordion-header]," +
        "[data-uib-accordion-header]," +
        "[x-uib-accordion-header]"
      );
    }
  });
angular
  .module("ui.bootstrap.alert", [])
  .controller("UibAlertController", [
    "$scope",
    "$element",
    "$attrs",
    "$interpolate",
    "$timeout",
    function ($scope, $element, $attrs, $interpolate, $timeout) {
      $scope.closeable = !!$attrs.close;
      $element.addClass("alert");
      $attrs.$set("role", "alert");
      if ($scope.closeable) {
        $element.addClass("alert-dismissible");
      }
      var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout)
        ? $interpolate($attrs.dismissOnTimeout)($scope.$parent)
        : null;
      if (dismissOnTimeout) {
        $timeout(function () {
          $scope.close();
        }, parseInt(dismissOnTimeout, 10));
      }
    },
  ])
  .directive("uibAlert", function () {
    return {
      controller: "UibAlertController",
      controllerAs: "alert",
      restrict: "A",
      templateUrl: function (element, attrs) {
        return attrs.templateUrl || "uib/template/alert/alert.html";
      },
      transclude: true,
      scope: { close: "&" },
    };
  });
angular
  .module("ui.bootstrap.buttons", [])
  .constant("uibButtonConfig", { activeClass: "active", toggleEvent: "click" })
  .controller("UibButtonsController", [
    "uibButtonConfig",
    function (buttonConfig) {
      this.activeClass = buttonConfig.activeClass || "active";
      this.toggleEvent = buttonConfig.toggleEvent || "click";
    },
  ])
  .directive("uibBtnRadio", [
    "$parse",
    function ($parse) {
      return {
        require: ["uibBtnRadio", "ngModel"],
        controller: "UibButtonsController",
        controllerAs: "buttons",
        link: function (scope, element, attrs, ctrls) {
          var buttonsCtrl = ctrls[0],
            ngModelCtrl = ctrls[1];
          var uncheckableExpr = $parse(attrs.uibUncheckable);
          element.find("input").css({ display: "none" });
          ngModelCtrl.$render = function () {
            element.toggleClass(
              buttonsCtrl.activeClass,
              angular.equals(
                ngModelCtrl.$modelValue,
                scope.$eval(attrs.uibBtnRadio)
              )
            );
          };
          element.on(buttonsCtrl.toggleEvent, function () {
            if (attrs.disabled) {
              return;
            }
            var isActive = element.hasClass(buttonsCtrl.activeClass);
            if (!isActive || angular.isDefined(attrs.uncheckable)) {
              scope.$apply(function () {
                ngModelCtrl.$setViewValue(
                  isActive ? null : scope.$eval(attrs.uibBtnRadio)
                );
                ngModelCtrl.$render();
              });
            }
          });
          if (attrs.uibUncheckable) {
            scope.$watch(uncheckableExpr, function (uncheckable) {
              attrs.$set("uncheckable", uncheckable ? "" : undefined);
            });
          }
        },
      };
    },
  ])
  .directive("uibBtnCheckbox", function () {
    return {
      require: ["uibBtnCheckbox", "ngModel"],
      controller: "UibButtonsController",
      controllerAs: "button",
      link: function (scope, element, attrs, ctrls) {
        var buttonsCtrl = ctrls[0],
          ngModelCtrl = ctrls[1];
        element.find("input").css({ display: "none" });
        function getTrueValue() {
          return getCheckboxValue(attrs.btnCheckboxTrue, true);
        }
        function getFalseValue() {
          return getCheckboxValue(attrs.btnCheckboxFalse, false);
        }
        function getCheckboxValue(attribute, defaultValue) {
          return angular.isDefined(attribute)
            ? scope.$eval(attribute)
            : defaultValue;
        }
        ngModelCtrl.$render = function () {
          element.toggleClass(
            buttonsCtrl.activeClass,
            angular.equals(ngModelCtrl.$modelValue, getTrueValue())
          );
        };
        element.on(buttonsCtrl.toggleEvent, function () {
          if (attrs.disabled) {
            return;
          }
          scope.$apply(function () {
            ngModelCtrl.$setViewValue(
              element.hasClass(buttonsCtrl.activeClass)
                ? getFalseValue()
                : getTrueValue()
            );
            ngModelCtrl.$render();
          });
        });
      },
    };
  });
angular
  .module("ui.bootstrap.carousel", [])
  .controller("UibCarouselController", [
    "$scope",
    "$element",
    "$interval",
    "$timeout",
    "$animate",
    function ($scope, $element, $interval, $timeout, $animate) {
      var self = this,
        slides = (self.slides = $scope.slides = []),
        SLIDE_DIRECTION = "uib-slideDirection",
        currentIndex = $scope.active,
        currentInterval,
        isPlaying,
        bufferedTransitions = [];
      var destroyed = false;
      $element.addClass("carousel");
      self.addSlide = function (slide, element) {
        slides.push({ slide: slide, element: element });
        slides.sort(function (a, b) {
          return +a.slide.index - +b.slide.index;
        });
        if (
          slide.index === $scope.active ||
          (slides.length === 1 && !angular.isNumber($scope.active))
        ) {
          if ($scope.$currentTransition) {
            $scope.$currentTransition = null;
          }
          currentIndex = slide.index;
          $scope.active = slide.index;
          setActive(currentIndex);
          self.select(slides[findSlideIndex(slide)]);
          if (slides.length === 1) {
            $scope.play();
          }
        }
      };
      self.getCurrentIndex = function () {
        for (var i = 0; i < slides.length; i++) {
          if (slides[i].slide.index === currentIndex) {
            return i;
          }
        }
      };
      self.next = $scope.next = function () {
        var newIndex = (self.getCurrentIndex() + 1) % slides.length;
        if (newIndex === 0 && $scope.noWrap()) {
          $scope.pause();
          return;
        }
        return self.select(slides[newIndex], "next");
      };
      self.prev = $scope.prev = function () {
        var newIndex =
          self.getCurrentIndex() - 1 < 0
            ? slides.length - 1
            : self.getCurrentIndex() - 1;
        if ($scope.noWrap() && newIndex === slides.length - 1) {
          $scope.pause();
          return;
        }
        return self.select(slides[newIndex], "prev");
      };
      self.removeSlide = function (slide) {
        var index = findSlideIndex(slide);
        var bufferedIndex = bufferedTransitions.indexOf(slides[index]);
        if (bufferedIndex !== -1) {
          bufferedTransitions.splice(bufferedIndex, 1);
        }
        slides.splice(index, 1);
        if (slides.length > 0 && currentIndex === index) {
          if (index >= slides.length) {
            currentIndex = slides.length - 1;
            $scope.active = currentIndex;
            setActive(currentIndex);
            self.select(slides[slides.length - 1]);
          } else {
            currentIndex = index;
            $scope.active = currentIndex;
            setActive(currentIndex);
            self.select(slides[index]);
          }
        } else if (currentIndex > index) {
          currentIndex--;
          $scope.active = currentIndex;
        }
        if (slides.length === 0) {
          currentIndex = null;
          $scope.active = null;
          clearBufferedTransitions();
        }
      };
      self.select = $scope.select = function (nextSlide, direction) {
        var nextIndex = findSlideIndex(nextSlide.slide);
        if (direction === undefined) {
          direction = nextIndex > self.getCurrentIndex() ? "next" : "prev";
        }
        if (
          nextSlide.slide.index !== currentIndex &&
          !$scope.$currentTransition
        ) {
          goNext(nextSlide.slide, nextIndex, direction);
        } else if (
          nextSlide &&
          nextSlide.slide.index !== currentIndex &&
          $scope.$currentTransition
        ) {
          bufferedTransitions.push(slides[nextIndex]);
        }
      };
      $scope.indexOfSlide = function (slide) {
        return +slide.slide.index;
      };
      $scope.isActive = function (slide) {
        return $scope.active === slide.slide.index;
      };
      $scope.isPrevDisabled = function () {
        return $scope.active === 0 && $scope.noWrap();
      };
      $scope.isNextDisabled = function () {
        return $scope.active === slides.length - 1 && $scope.noWrap();
      };
      $scope.pause = function () {
        if (!$scope.noPause) {
          isPlaying = false;
          resetTimer();
        }
      };
      $scope.play = function () {
        if (!isPlaying) {
          isPlaying = true;
          restartTimer();
        }
      };
      $element.on("mouseenter", $scope.pause);
      $element.on("mouseleave", $scope.play);
      $scope.$on("$destroy", function () {
        destroyed = true;
        resetTimer();
      });
      $scope.$watch("noTransition", function (noTransition) {
        $animate.enabled($element, !noTransition);
      });
      $scope.$watch("interval", restartTimer);
      $scope.$watchCollection("slides", resetTransition);
      $scope.$watch("active", function (index) {
        if (angular.isNumber(index) && currentIndex !== index) {
          for (var i = 0; i < slides.length; i++) {
            if (slides[i].slide.index === index) {
              index = i;
              break;
            }
          }
          var slide = slides[index];
          if (slide) {
            setActive(index);
            self.select(slides[index]);
            currentIndex = index;
          }
        }
      });
      function clearBufferedTransitions() {
        while (bufferedTransitions.length) {
          bufferedTransitions.shift();
        }
      }
      function getSlideByIndex(index) {
        for (var i = 0, l = slides.length; i < l; ++i) {
          if (slides[i].index === index) {
            return slides[i];
          }
        }
      }
      function setActive(index) {
        for (var i = 0; i < slides.length; i++) {
          slides[i].slide.active = i === index;
        }
      }
      function goNext(slide, index, direction) {
        if (destroyed) {
          return;
        }
        angular.extend(slide, { direction: direction });
        angular.extend(slides[currentIndex].slide || {}, {
          direction: direction,
        });
        if (
          $animate.enabled($element) &&
          !$scope.$currentTransition &&
          slides[index].element &&
          self.slides.length > 1
        ) {
          slides[index].element.data(SLIDE_DIRECTION, slide.direction);
          var currentIdx = self.getCurrentIndex();
          if (angular.isNumber(currentIdx) && slides[currentIdx].element) {
            slides[currentIdx].element.data(SLIDE_DIRECTION, slide.direction);
          }
          $scope.$currentTransition = true;
          $animate.on(
            "addClass",
            slides[index].element,
            function (element, phase) {
              if (phase === "close") {
                $scope.$currentTransition = null;
                $animate.off("addClass", element);
                if (bufferedTransitions.length) {
                  var nextSlide = bufferedTransitions.pop().slide;
                  var nextIndex = nextSlide.index;
                  var nextDirection =
                    nextIndex > self.getCurrentIndex() ? "next" : "prev";
                  clearBufferedTransitions();
                  goNext(nextSlide, nextIndex, nextDirection);
                }
              }
            }
          );
        }
        $scope.active = slide.index;
        currentIndex = slide.index;
        setActive(index);
        restartTimer();
      }
      function findSlideIndex(slide) {
        for (var i = 0; i < slides.length; i++) {
          if (slides[i].slide === slide) {
            return i;
          }
        }
      }
      function resetTimer() {
        if (currentInterval) {
          $interval.cancel(currentInterval);
          currentInterval = null;
        }
      }
      function resetTransition(slides) {
        if (!slides.length) {
          $scope.$currentTransition = null;
          clearBufferedTransitions();
        }
      }
      function restartTimer() {
        resetTimer();
        var interval = +$scope.interval;
        if (!isNaN(interval) && interval > 0) {
          currentInterval = $interval(timerFn, interval);
        }
      }
      function timerFn() {
        var interval = +$scope.interval;
        if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {
          $scope.next();
        } else {
          $scope.pause();
        }
      }
    },
  ])
  .directive("uibCarousel", function () {
    return {
      transclude: true,
      controller: "UibCarouselController",
      controllerAs: "carousel",
      restrict: "A",
      templateUrl: function (element, attrs) {
        return attrs.templateUrl || "uib/template/carousel/carousel.html";
      },
      scope: {
        active: "=",
        interval: "=",
        noTransition: "=",
        noPause: "=",
        noWrap: "&",
      },
    };
  })
  .directive("uibSlide", [
    "$animate",
    function ($animate) {
      return {
        require: "^uibCarousel",
        restrict: "A",
        transclude: true,
        templateUrl: function (element, attrs) {
          return attrs.templateUrl || "uib/template/carousel/slide.html";
        },
        scope: { actual: "=?", index: "=?" },
        link: function (scope, element, attrs, carouselCtrl) {
          element.addClass("item");
          carouselCtrl.addSlide(scope, element);
          scope.$on("$destroy", function () {
            carouselCtrl.removeSlide(scope);
          });
          scope.$watch("active", function (active) {
            $animate[active ? "addClass" : "removeClass"](element, "active");
          });
        },
      };
    },
  ])
  .animation(".item", [
    "$animateCss",
    function ($animateCss) {
      var SLIDE_DIRECTION = "uib-slideDirection";
      function removeClass(element, className, callback) {
        element.removeClass(className);
        if (callback) {
          callback();
        }
      }
      return {
        beforeAddClass: function (element, className, done) {
          if (className === "active") {
            var stopped = false;
            var direction = element.data(SLIDE_DIRECTION);
            var directionClass = direction === "next" ? "left" : "right";
            var removeClassFn = removeClass.bind(
              this,
              element,
              directionClass + " " + direction,
              done
            );
            element.addClass(direction);
            $animateCss(element, { addClass: directionClass })
              .start()
              .done(removeClassFn);
            return function () {
              stopped = true;
            };
          }
          done();
        },
        beforeRemoveClass: function (element, className, done) {
          if (className === "active") {
            var stopped = false;
            var direction = element.data(SLIDE_DIRECTION);
            var directionClass = direction === "next" ? "left" : "right";
            var removeClassFn = removeClass.bind(
              this,
              element,
              directionClass,
              done
            );
            $animateCss(element, { addClass: directionClass })
              .start()
              .done(removeClassFn);
            return function () {
              stopped = true;
            };
          }
          done();
        },
      };
    },
  ]);
angular.module("ui.bootstrap.dateparser", []).service("uibDateParser", [
  "$log",
  "$locale",
  "dateFilter",
  "orderByFilter",
  "filterFilter",
  function ($log, $locale, dateFilter, orderByFilter, filterFilter) {
    var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
    var localeId;
    var formatCodeToRegex;
    this.init = function () {
      localeId = $locale.id;
      this.parsers = {};
      this.formatters = {};
      formatCodeToRegex = [
        {
          key: "yyyy",
          regex: "\\d{4}",
          apply: function (value) {
            this.year = +value;
          },
          formatter: function (date) {
            var _date = new Date();
            _date.setFullYear(Math.abs(date.getFullYear()));
            return dateFilter(_date, "yyyy");
          },
        },
        {
          key: "yy",
          regex: "\\d{2}",
          apply: function (value) {
            value = +value;
            this.year = value < 69 ? value + 2e3 : value + 1900;
          },
          formatter: function (date) {
            var _date = new Date();
            _date.setFullYear(Math.abs(date.getFullYear()));
            return dateFilter(_date, "yy");
          },
        },
        {
          key: "y",
          regex: "\\d{1,4}",
          apply: function (value) {
            this.year = +value;
          },
          formatter: function (date) {
            var _date = new Date();
            _date.setFullYear(Math.abs(date.getFullYear()));
            return dateFilter(_date, "y");
          },
        },
        {
          key: "M!",
          regex: "0?[1-9]|1[0-2]",
          apply: function (value) {
            this.month = value - 1;
          },
          formatter: function (date) {
            var value = date.getMonth();
            if (/^[0-9]$/.test(value)) {
              return dateFilter(date, "MM");
            }
            return dateFilter(date, "M");
          },
        },
        {
          key: "MMMM",
          regex: $locale.DATETIME_FORMATS.MONTH.join("|"),
          apply: function (value) {
            this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value);
          },
          formatter: function (date) {
            return dateFilter(date, "MMMM");
          },
        },
        {
          key: "MMM",
          regex: $locale.DATETIME_FORMATS.SHORTMONTH.join("|"),
          apply: function (value) {
            this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value);
          },
          formatter: function (date) {
            return dateFilter(date, "MMM");
          },
        },
        {
          key: "MM",
          regex: "0[1-9]|1[0-2]",
          apply: function (value) {
            this.month = value - 1;
          },
          formatter: function (date) {
            return dateFilter(date, "MM");
          },
        },
        {
          key: "M",
          regex: "[1-9]|1[0-2]",
          apply: function (value) {
            this.month = value - 1;
          },
          formatter: function (date) {
            return dateFilter(date, "M");
          },
        },
        {
          key: "d!",
          regex: "[0-2]?[0-9]{1}|3[0-1]{1}",
          apply: function (value) {
            this.date = +value;
          },
          formatter: function (date) {
            var value = date.getDate();
            if (/^[1-9]$/.test(value)) {
              return dateFilter(date, "dd");
            }
            return dateFilter(date, "d");
          },
        },
        {
          key: "dd",
          regex: "[0-2][0-9]{1}|3[0-1]{1}",
          apply: function (value) {
            this.date = +value;
          },
          formatter: function (date) {
            return dateFilter(date, "dd");
          },
        },
        {
          key: "d",
          regex: "[1-2]?[0-9]{1}|3[0-1]{1}",
          apply: function (value) {
            this.date = +value;
          },
          formatter: function (date) {
            return dateFilter(date, "d");
          },
        },
        {
          key: "EEEE",
          regex: $locale.DATETIME_FORMATS.DAY.join("|"),
          formatter: function (date) {
            return dateFilter(date, "EEEE");
          },
        },
        {
          key: "EEE",
          regex: $locale.DATETIME_FORMATS.SHORTDAY.join("|"),
          formatter: function (date) {
            return dateFilter(date, "EEE");
          },
        },
        {
          key: "HH",
          regex: "(?:0|1)[0-9]|2[0-3]",
          apply: function (value) {
            this.hours = +value;
          },
          formatter: function (date) {
            return dateFilter(date, "HH");
          },
        },
        {
          key: "hh",
          regex: "0[0-9]|1[0-2]",
          apply: function (value) {
            this.hours = +value;
          },
          formatter: function (date) {
            return dateFilter(date, "hh");
          },
        },
        {
          key: "H",
          regex: "1?[0-9]|2[0-3]",
          apply: function (value) {
            this.hours = +value;
          },
          formatter: function (date) {
            return dateFilter(date, "H");
          },
        },
        {
          key: "h",
          regex: "[0-9]|1[0-2]",
          apply: function (value) {
            this.hours = +value;
          },
          formatter: function (date) {
            return dateFilter(date, "h");
          },
        },
        {
          key: "mm",
          regex: "[0-5][0-9]",
          apply: function (value) {
            this.minutes = +value;
          },
          formatter: function (date) {
            return dateFilter(date, "mm");
          },
        },
        {
          key: "m",
          regex: "[0-9]|[1-5][0-9]",
          apply: function (value) {
            this.minutes = +value;
          },
          formatter: function (date) {
            return dateFilter(date, "m");
          },
        },
        {
          key: "sss",
          regex: "[0-9][0-9][0-9]",
          apply: function (value) {
            this.milliseconds = +value;
          },
          formatter: function (date) {
            return dateFilter(date, "sss");
          },
        },
        {
          key: "ss",
          regex: "[0-5][0-9]",
          apply: function (value) {
            this.seconds = +value;
          },
          formatter: function (date) {
            return dateFilter(date, "ss");
          },
        },
        {
          key: "s",
          regex: "[0-9]|[1-5][0-9]",
          apply: function (value) {
            this.seconds = +value;
          },
          formatter: function (date) {
            return dateFilter(date, "s");
          },
        },
        {
          key: "a",
          regex: $locale.DATETIME_FORMATS.AMPMS.join("|"),
          apply: function (value) {
            if (this.hours === 12) {
              this.hours = 0;
            }
            if (value === "PM") {
              this.hours += 12;
            }
          },
          formatter: function (date) {
            return dateFilter(date, "a");
          },
        },
        {
          key: "Z",
          regex: "[+-]\\d{4}",
          apply: function (value) {
            var matches = value.match(/([+-])(\d{2})(\d{2})/),
              sign = matches[1],
              hours = matches[2],
              minutes = matches[3];
            this.hours += toInt(sign + hours);
            this.minutes += toInt(sign + minutes);
          },
          formatter: function (date) {
            return dateFilter(date, "Z");
          },
        },
        {
          key: "ww",
          regex: "[0-4][0-9]|5[0-3]",
          formatter: function (date) {
            return dateFilter(date, "ww");
          },
        },
        {
          key: "w",
          regex: "[0-9]|[1-4][0-9]|5[0-3]",
          formatter: function (date) {
            return dateFilter(date, "w");
          },
        },
        {
          key: "GGGG",
          regex: $locale.DATETIME_FORMATS.ERANAMES.join("|").replace(
            /\s/g,
            "\\s"
          ),
          formatter: function (date) {
            return dateFilter(date, "GGGG");
          },
        },
        {
          key: "GGG",
          regex: $locale.DATETIME_FORMATS.ERAS.join("|"),
          formatter: function (date) {
            return dateFilter(date, "GGG");
          },
        },
        {
          key: "GG",
          regex: $locale.DATETIME_FORMATS.ERAS.join("|"),
          formatter: function (date) {
            return dateFilter(date, "GG");
          },
        },
        {
          key: "G",
          regex: $locale.DATETIME_FORMATS.ERAS.join("|"),
          formatter: function (date) {
            return dateFilter(date, "G");
          },
        },
      ];
      if (angular.version.major >= 1 && angular.version.minor > 4) {
        formatCodeToRegex.push({
          key: "LLLL",
          regex: $locale.DATETIME_FORMATS.STANDALONEMONTH.join("|"),
          apply: function (value) {
            this.month =
              $locale.DATETIME_FORMATS.STANDALONEMONTH.indexOf(value);
          },
          formatter: function (date) {
            return dateFilter(date, "LLLL");
          },
        });
      }
    };
    this.init();
    function getFormatCodeToRegex(key) {
      return filterFilter(formatCodeToRegex, { key: key }, true)[0];
    }
    this.getParser = function (key) {
      var f = getFormatCodeToRegex(key);
      return (f && f.apply) || null;
    };
    this.overrideParser = function (key, parser) {
      var f = getFormatCodeToRegex(key);
      if (f && angular.isFunction(parser)) {
        this.parsers = {};
        f.apply = parser;
      }
    }.bind(this);
    function createParser(format) {
      var map = [],
        regex = format.split("");
      var quoteIndex = format.indexOf("'");
      if (quoteIndex > -1) {
        var inLiteral = false;
        format = format.split("");
        for (var i = quoteIndex; i < format.length; i++) {
          if (inLiteral) {
            if (format[i] === "'") {
              if (i + 1 < format.length && format[i + 1] === "'") {
                format[i + 1] = "$";
                regex[i + 1] = "";
              } else {
                regex[i] = "";
                inLiteral = false;
              }
            }
            format[i] = "$";
          } else {
            if (format[i] === "'") {
              format[i] = "$";
              regex[i] = "";
              inLiteral = true;
            }
          }
        }
        format = format.join("");
      }
      angular.forEach(formatCodeToRegex, function (data) {
        var index = format.indexOf(data.key);
        if (index > -1) {
          format = format.split("");
          regex[index] = "(" + data.regex + ")";
          format[index] = "$";
          for (var i = index + 1, n = index + data.key.length; i < n; i++) {
            regex[i] = "";
            format[i] = "$";
          }
          format = format.join("");
          map.push({
            index: index,
            key: data.key,
            apply: data.apply,
            matcher: data.regex,
          });
        }
      });
      return {
        regex: new RegExp("^" + regex.join("") + "$"),
        map: orderByFilter(map, "index"),
      };
    }
    function createFormatter(format) {
      var formatters = [];
      var i = 0;
      var formatter, literalIdx;
      while (i < format.length) {
        if (angular.isNumber(literalIdx)) {
          if (format.charAt(i) === "'") {
            if (i + 1 >= format.length || format.charAt(i + 1) !== "'") {
              formatters.push(constructLiteralFormatter(format, literalIdx, i));
              literalIdx = null;
            }
          } else if (i === format.length) {
            while (literalIdx < format.length) {
              formatter = constructFormatterFromIdx(format, literalIdx);
              formatters.push(formatter);
              literalIdx = formatter.endIdx;
            }
          }
          i++;
          continue;
        }
        if (format.charAt(i) === "'") {
          literalIdx = i;
          i++;
          continue;
        }
        formatter = constructFormatterFromIdx(format, i);
        formatters.push(formatter.parser);
        i = formatter.endIdx;
      }
      return formatters;
    }
    function constructLiteralFormatter(format, literalIdx, endIdx) {
      return function () {
        return format.substr(literalIdx + 1, endIdx - literalIdx - 1);
      };
    }
    function constructFormatterFromIdx(format, i) {
      var currentPosStr = format.substr(i);
      for (var j = 0; j < formatCodeToRegex.length; j++) {
        if (new RegExp("^" + formatCodeToRegex[j].key).test(currentPosStr)) {
          var data = formatCodeToRegex[j];
          return { endIdx: i + data.key.length, parser: data.formatter };
        }
      }
      return {
        endIdx: i + 1,
        parser: function () {
          return currentPosStr.charAt(0);
        },
      };
    }
    this.filter = function (date, format) {
      if (!angular.isDate(date) || isNaN(date) || !format) {
        return "";
      }
      format = $locale.DATETIME_FORMATS[format] || format;
      if ($locale.id !== localeId) {
        this.init();
      }
      if (!this.formatters[format]) {
        this.formatters[format] = createFormatter(format);
      }
      var formatters = this.formatters[format];
      return formatters.reduce(function (str, formatter) {
        return str + formatter(date);
      }, "");
    };
    this.parse = function (input, format, baseDate) {
      if (!angular.isString(input) || !format) {
        return input;
      }
      format = $locale.DATETIME_FORMATS[format] || format;
      format = format.replace(SPECIAL_CHARACTERS_REGEXP, "\\$&");
      if ($locale.id !== localeId) {
        this.init();
      }
      if (!this.parsers[format]) {
        this.parsers[format] = createParser(format, "apply");
      }
      var parser = this.parsers[format],
        regex = parser.regex,
        map = parser.map,
        results = input.match(regex),
        tzOffset = false;
      if (results && results.length) {
        var fields, dt;
        if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
          fields = {
            year: baseDate.getFullYear(),
            month: baseDate.getMonth(),
            date: baseDate.getDate(),
            hours: baseDate.getHours(),
            minutes: baseDate.getMinutes(),
            seconds: baseDate.getSeconds(),
            milliseconds: baseDate.getMilliseconds(),
          };
        } else {
          if (baseDate) {
            $log.warn("dateparser:", "baseDate is not a valid date");
          }
          fields = {
            year: 1900,
            month: 0,
            date: 1,
            hours: 0,
            minutes: 0,
            seconds: 0,
            milliseconds: 0,
          };
        }
        for (var i = 1, n = results.length; i < n; i++) {
          var mapper = map[i - 1];
          if (mapper.matcher === "Z") {
            tzOffset = true;
          }
          if (mapper.apply) {
            mapper.apply.call(fields, results[i]);
          }
        }
        var datesetter = tzOffset
          ? Date.prototype.setUTCFullYear
          : Date.prototype.setFullYear;
        var timesetter = tzOffset
          ? Date.prototype.setUTCHours
          : Date.prototype.setHours;
        if (isValid(fields.year, fields.month, fields.date)) {
          if (
            angular.isDate(baseDate) &&
            !isNaN(baseDate.getTime()) &&
            !tzOffset
          ) {
            dt = new Date(baseDate);
            datesetter.call(dt, fields.year, fields.month, fields.date);
            timesetter.call(
              dt,
              fields.hours,
              fields.minutes,
              fields.seconds,
              fields.milliseconds
            );
          } else {
            dt = new Date(0);
            datesetter.call(dt, fields.year, fields.month, fields.date);
            timesetter.call(
              dt,
              fields.hours || 0,
              fields.minutes || 0,
              fields.seconds || 0,
              fields.milliseconds || 0
            );
          }
        }
        return dt;
      }
    };
    function isValid(year, month, date) {
      if (date < 1) {
        return false;
      }
      if (month === 1 && date > 28) {
        return (
          date === 29 &&
          ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0)
        );
      }
      if (month === 3 || month === 5 || month === 8 || month === 10) {
        return date < 31;
      }
      return true;
    }
    function toInt(str) {
      return parseInt(str, 10);
    }
    this.toTimezone = toTimezone;
    this.fromTimezone = fromTimezone;
    this.timezoneToOffset = timezoneToOffset;
    this.addDateMinutes = addDateMinutes;
    this.convertTimezoneToLocal = convertTimezoneToLocal;
    function toTimezone(date, timezone) {
      return date && timezone ? convertTimezoneToLocal(date, timezone) : date;
    }
    function fromTimezone(date, timezone) {
      return date && timezone
        ? convertTimezoneToLocal(date, timezone, true)
        : date;
    }
    function timezoneToOffset(timezone, fallback) {
      timezone = timezone.replace(/:/g, "");
      var requestedTimezoneOffset =
        Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
      return isNaN(requestedTimezoneOffset)
        ? fallback
        : requestedTimezoneOffset;
    }
    function addDateMinutes(date, minutes) {
      date = new Date(date.getTime());
      date.setMinutes(date.getMinutes() + minutes);
      return date;
    }
    function convertTimezoneToLocal(date, timezone, reverse) {
      reverse = reverse ? -1 : 1;
      var dateTimezoneOffset = date.getTimezoneOffset();
      var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
      return addDateMinutes(
        date,
        reverse * (timezoneOffset - dateTimezoneOffset)
      );
    }
  },
]);
angular.module("ui.bootstrap.isClass", []).directive("uibIsClass", [
  "$animate",
  function ($animate) {
    var ON_REGEXP = /^\s*([\s\S]+?)\s+on\s+([\s\S]+?)\s*$/;
    var IS_REGEXP = /^\s*([\s\S]+?)\s+for\s+([\s\S]+?)\s*$/;
    var dataPerTracked = {};
    return {
      restrict: "A",
      compile: function (tElement, tAttrs) {
        var linkedScopes = [];
        var instances = [];
        var expToData = {};
        var lastActivated = null;
        var onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP);
        var onExp = onExpMatches[2];
        var expsStr = onExpMatches[1];
        var exps = expsStr.split(",");
        return linkFn;
        function linkFn(scope, element, attrs) {
          linkedScopes.push(scope);
          instances.push({ scope: scope, element: element });
          exps.forEach(function (exp, k) {
            addForExp(exp, scope);
          });
          scope.$on("$destroy", removeScope);
        }
        function addForExp(exp, scope) {
          var matches = exp.match(IS_REGEXP);
          var clazz = scope.$eval(matches[1]);
          var compareWithExp = matches[2];
          var data = expToData[exp];
          if (!data) {
            var watchFn = function (compareWithVal) {
              var newActivated = null;
              instances.some(function (instance) {
                var thisVal = instance.scope.$eval(onExp);
                if (thisVal === compareWithVal) {
                  newActivated = instance;
                  return true;
                }
              });
              if (data.lastActivated !== newActivated) {
                if (data.lastActivated) {
                  $animate.removeClass(data.lastActivated.element, clazz);
                }
                if (newActivated) {
                  $animate.addClass(newActivated.element, clazz);
                }
                data.lastActivated = newActivated;
              }
            };
            expToData[exp] = data = {
              lastActivated: null,
              scope: scope,
              watchFn: watchFn,
              compareWithExp: compareWithExp,
              watcher: scope.$watch(compareWithExp, watchFn),
            };
          }
          data.watchFn(scope.$eval(compareWithExp));
        }
        function removeScope(e) {
          var removedScope = e.targetScope;
          var index = linkedScopes.indexOf(removedScope);
          linkedScopes.splice(index, 1);
          instances.splice(index, 1);
          if (linkedScopes.length) {
            var newWatchScope = linkedScopes[0];
            angular.forEach(expToData, function (data) {
              if (data.scope === removedScope) {
                data.watcher = newWatchScope.$watch(
                  data.compareWithExp,
                  data.watchFn
                );
                data.scope = newWatchScope;
              }
            });
          } else {
            expToData = {};
          }
        }
      },
    };
  },
]);
angular
  .module("ui.bootstrap.datepicker", [
    "ui.bootstrap.dateparser",
    "ui.bootstrap.isClass",
  ])
  .value("$datepickerSuppressError", false)
  .value("$datepickerLiteralWarning", true)
  .constant("uibDatepickerConfig", {
    datepickerMode: "day",
    formatDay: "dd",
    formatMonth: "MMMM",
    formatYear: "yyyy",
    formatDayHeader: "EEE",
    formatDayTitle: "MMMM yyyy",
    formatMonthTitle: "yyyy",
    maxDate: null,
    maxMode: "year",
    minDate: null,
    minMode: "day",
    monthColumns: 3,
    ngModelOptions: {},
    shortcutPropagation: false,
    showWeeks: true,
    yearColumns: 5,
    yearRows: 4,
  })
  .controller("UibDatepickerController", [
    "$scope",
    "$element",
    "$attrs",
    "$parse",
    "$interpolate",
    "$locale",
    "$log",
    "dateFilter",
    "uibDatepickerConfig",
    "$datepickerLiteralWarning",
    "$datepickerSuppressError",
    "uibDateParser",
    function (
      $scope,
      $element,
      $attrs,
      $parse,
      $interpolate,
      $locale,
      $log,
      dateFilter,
      datepickerConfig,
      $datepickerLiteralWarning,
      $datepickerSuppressError,
      dateParser
    ) {
      var self = this,
        ngModelCtrl = { $setViewValue: angular.noop },
        ngModelOptions = {},
        watchListeners = [];
      $element.addClass("uib-datepicker");
      $attrs.$set("role", "application");
      if (!$scope.datepickerOptions) {
        $scope.datepickerOptions = {};
      }
      this.modes = ["day", "month", "year"];
      [
        "customClass",
        "dateDisabled",
        "datepickerMode",
        "formatDay",
        "formatDayHeader",
        "formatDayTitle",
        "formatMonth",
        "formatMonthTitle",
        "formatYear",
        "maxDate",
        "maxMode",
        "minDate",
        "minMode",
        "monthColumns",
        "showWeeks",
        "shortcutPropagation",
        "startingDay",
        "yearColumns",
        "yearRows",
      ].forEach(function (key) {
        switch (key) {
          case "customClass":
          case "dateDisabled":
            $scope[key] = $scope.datepickerOptions[key] || angular.noop;
            break;
          case "datepickerMode":
            $scope.datepickerMode = angular.isDefined(
              $scope.datepickerOptions.datepickerMode
            )
              ? $scope.datepickerOptions.datepickerMode
              : datepickerConfig.datepickerMode;
            break;
          case "formatDay":
          case "formatDayHeader":
          case "formatDayTitle":
          case "formatMonth":
          case "formatMonthTitle":
          case "formatYear":
            self[key] = angular.isDefined($scope.datepickerOptions[key])
              ? $interpolate($scope.datepickerOptions[key])($scope.$parent)
              : datepickerConfig[key];
            break;
          case "monthColumns":
          case "showWeeks":
          case "shortcutPropagation":
          case "yearColumns":
          case "yearRows":
            self[key] = angular.isDefined($scope.datepickerOptions[key])
              ? $scope.datepickerOptions[key]
              : datepickerConfig[key];
            break;
          case "startingDay":
            if (angular.isDefined($scope.datepickerOptions.startingDay)) {
              self.startingDay = $scope.datepickerOptions.startingDay;
            } else if (angular.isNumber(datepickerConfig.startingDay)) {
              self.startingDay = datepickerConfig.startingDay;
            } else {
              self.startingDay =
                ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;
            }
            break;
          case "maxDate":
          case "minDate":
            $scope.$watch("datepickerOptions." + key, function (value) {
              if (value) {
                if (angular.isDate(value)) {
                  self[key] = dateParser.fromTimezone(
                    new Date(value),
                    ngModelOptions.timezone
                  );
                } else {
                  if ($datepickerLiteralWarning) {
                    $log.warn(
                      "Literal date support has been deprecated, please switch to date object usage"
                    );
                  }
                  self[key] = new Date(dateFilter(value, "medium"));
                }
              } else {
                self[key] = datepickerConfig[key]
                  ? dateParser.fromTimezone(
                      new Date(datepickerConfig[key]),
                      ngModelOptions.timezone
                    )
                  : null;
              }
              self.refreshView();
            });
            break;
          case "maxMode":
          case "minMode":
            if ($scope.datepickerOptions[key]) {
              $scope.$watch(
                function () {
                  return $scope.datepickerOptions[key];
                },
                function (value) {
                  self[key] = $scope[key] = angular.isDefined(value)
                    ? value
                    : $scope.datepickerOptions[key];
                  if (
                    (key === "minMode" &&
                      self.modes.indexOf(
                        $scope.datepickerOptions.datepickerMode
                      ) < self.modes.indexOf(self[key])) ||
                    (key === "maxMode" &&
                      self.modes.indexOf(
                        $scope.datepickerOptions.datepickerMode
                      ) > self.modes.indexOf(self[key]))
                  ) {
                    $scope.datepickerMode = self[key];
                    $scope.datepickerOptions.datepickerMode = self[key];
                  }
                }
              );
            } else {
              self[key] = $scope[key] = datepickerConfig[key] || null;
            }
            break;
        }
      });
      $scope.uniqueId =
        "datepicker-" + $scope.$id + "-" + Math.floor(Math.random() * 1e4);
      $scope.disabled = angular.isDefined($attrs.disabled) || false;
      if (angular.isDefined($attrs.ngDisabled)) {
        watchListeners.push(
          $scope.$parent.$watch($attrs.ngDisabled, function (disabled) {
            $scope.disabled = disabled;
            self.refreshView();
          })
        );
      }
      $scope.isActive = function (dateObject) {
        if (self.compare(dateObject.date, self.activeDate) === 0) {
          $scope.activeDateId = dateObject.uid;
          return true;
        }
        return false;
      };
      this.init = function (ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_;
        ngModelOptions =
          ngModelCtrl_.$options ||
          $scope.datepickerOptions.ngModelOptions ||
          datepickerConfig.ngModelOptions;
        if ($scope.datepickerOptions.initDate) {
          self.activeDate =
            dateParser.fromTimezone(
              $scope.datepickerOptions.initDate,
              ngModelOptions.timezone
            ) || new Date();
          $scope.$watch("datepickerOptions.initDate", function (initDate) {
            if (
              initDate &&
              (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) ||
                ngModelCtrl.$invalid)
            ) {
              self.activeDate = dateParser.fromTimezone(
                initDate,
                ngModelOptions.timezone
              );
              self.refreshView();
            }
          });
        } else {
          self.activeDate = new Date();
        }
        var date = ngModelCtrl.$modelValue
          ? new Date(ngModelCtrl.$modelValue)
          : new Date();
        this.activeDate = !isNaN(date)
          ? dateParser.fromTimezone(date, ngModelOptions.timezone)
          : dateParser.fromTimezone(new Date(), ngModelOptions.timezone);
        ngModelCtrl.$render = function () {
          self.render();
        };
      };
      this.render = function () {
        if (ngModelCtrl.$viewValue) {
          var date = new Date(ngModelCtrl.$viewValue),
            isValid = !isNaN(date);
          if (isValid) {
            this.activeDate = dateParser.fromTimezone(
              date,
              ngModelOptions.timezone
            );
          } else if (!$datepickerSuppressError) {
            $log.error(
              'Datepicker directive: "ng-model" value must be a Date object'
            );
          }
        }
        this.refreshView();
      };
      this.refreshView = function () {
        if (this.element) {
          $scope.selectedDt = null;
          this._refreshView();
          if ($scope.activeDt) {
            $scope.activeDateId = $scope.activeDt.uid;
          }
          var date = ngModelCtrl.$viewValue
            ? new Date(ngModelCtrl.$viewValue)
            : null;
          date = dateParser.fromTimezone(date, ngModelOptions.timezone);
          ngModelCtrl.$setValidity(
            "dateDisabled",
            !date || (this.element && !this.isDisabled(date))
          );
        }
      };
      this.createDateObject = function (date, format) {
        var model = ngModelCtrl.$viewValue
          ? new Date(ngModelCtrl.$viewValue)
          : null;
        model = dateParser.fromTimezone(model, ngModelOptions.timezone);
        var today = new Date();
        today = dateParser.fromTimezone(today, ngModelOptions.timezone);
        var time = this.compare(date, today);
        var dt = {
          date: date,
          label: dateParser.filter(date, format),
          selected: model && this.compare(date, model) === 0,
          disabled: this.isDisabled(date),
          past: time < 0,
          current: time === 0,
          future: time > 0,
          customClass: this.customClass(date) || null,
        };
        if (model && this.compare(date, model) === 0) {
          $scope.selectedDt = dt;
        }
        if (self.activeDate && this.compare(dt.date, self.activeDate) === 0) {
          $scope.activeDt = dt;
        }
        return dt;
      };
      this.isDisabled = function (date) {
        return (
          $scope.disabled ||
          (this.minDate && this.compare(date, this.minDate) < 0) ||
          (this.maxDate && this.compare(date, this.maxDate) > 0) ||
          ($scope.dateDisabled &&
            $scope.dateDisabled({ date: date, mode: $scope.datepickerMode }))
        );
      };
      this.customClass = function (date) {
        return $scope.customClass({ date: date, mode: $scope.datepickerMode });
      };
      this.split = function (arr, size) {
        var arrays = [];
        while (arr.length > 0) {
          arrays.push(arr.splice(0, size));
        }
        return arrays;
      };
      $scope.select = function (date) {
        if ($scope.datepickerMode === self.minMode) {
          var dt = ngModelCtrl.$viewValue
            ? dateParser.fromTimezone(
                new Date(ngModelCtrl.$viewValue),
                ngModelOptions.timezone
              )
            : new Date(0, 0, 0, 0, 0, 0, 0);
          dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
          dt = dateParser.toTimezone(dt, ngModelOptions.timezone);
          ngModelCtrl.$setViewValue(dt);
          ngModelCtrl.$render();
        } else {
          self.activeDate = date;
          setMode(self.modes[self.modes.indexOf($scope.datepickerMode) - 1]);
          $scope.$emit("uib:datepicker.mode");
        }
        $scope.$broadcast("uib:datepicker.focus");
      };
      $scope.move = function (direction) {
        var year =
            self.activeDate.getFullYear() + direction * (self.step.years || 0),
          month =
            self.activeDate.getMonth() + direction * (self.step.months || 0);
        self.activeDate.setFullYear(year, month, 1);
        self.refreshView();
      };
      $scope.toggleMode = function (direction) {
        direction = direction || 1;
        if (
          ($scope.datepickerMode === self.maxMode && direction === 1) ||
          ($scope.datepickerMode === self.minMode && direction === -1)
        ) {
          return;
        }
        setMode(
          self.modes[self.modes.indexOf($scope.datepickerMode) + direction]
        );
        $scope.$emit("uib:datepicker.mode");
      };
      $scope.keys = {
        13: "enter",
        32: "space",
        33: "pageup",
        34: "pagedown",
        35: "end",
        36: "home",
        37: "left",
        38: "up",
        39: "right",
        40: "down",
      };
      var focusElement = function () {
        self.element[0].focus();
      };
      $scope.$on("uib:datepicker.focus", focusElement);
      $scope.keydown = function (evt) {
        var key = $scope.keys[evt.which];
        if (!key || evt.shiftKey || evt.altKey || $scope.disabled) {
          return;
        }
        evt.preventDefault();
        if (!self.shortcutPropagation) {
          evt.stopPropagation();
        }
        if (key === "enter" || key === "space") {
          if (self.isDisabled(self.activeDate)) {
            return;
          }
          $scope.select(self.activeDate);
        } else if (evt.ctrlKey && (key === "up" || key === "down")) {
          $scope.toggleMode(key === "up" ? 1 : -1);
        } else {
          self.handleKeyDown(key, evt);
          self.refreshView();
        }
      };
      $element.on("keydown", function (evt) {
        $scope.$apply(function () {
          $scope.keydown(evt);
        });
      });
      $scope.$on("$destroy", function () {
        while (watchListeners.length) {
          watchListeners.shift()();
        }
      });
      function setMode(mode) {
        $scope.datepickerMode = mode;
        $scope.datepickerOptions.datepickerMode = mode;
      }
    },
  ])
  .controller("UibDaypickerController", [
    "$scope",
    "$element",
    "dateFilter",
    function (scope, $element, dateFilter) {
      var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      this.step = { months: 1 };
      this.element = $element;
      function getDaysInMonth(year, month) {
        return month === 1 &&
          year % 4 === 0 &&
          (year % 100 !== 0 || year % 400 === 0)
          ? 29
          : DAYS_IN_MONTH[month];
      }
      this.init = function (ctrl) {
        angular.extend(ctrl, this);
        scope.showWeeks = ctrl.showWeeks;
        ctrl.refreshView();
      };
      this.getDates = function (startDate, n) {
        var dates = new Array(n),
          current = new Date(startDate),
          i = 0,
          date;
        while (i < n) {
          date = new Date(current);
          dates[i++] = date;
          current.setDate(current.getDate() + 1);
        }
        return dates;
      };
      this._refreshView = function () {
        var year = this.activeDate.getFullYear(),
          month = this.activeDate.getMonth(),
          firstDayOfMonth = new Date(this.activeDate);
        firstDayOfMonth.setFullYear(year, month, 1);
        var difference = this.startingDay - firstDayOfMonth.getDay(),
          numDisplayedFromPreviousMonth =
            difference > 0 ? 7 - difference : -difference,
          firstDate = new Date(firstDayOfMonth);
        if (numDisplayedFromPreviousMonth > 0) {
          firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
        }
        var days = this.getDates(firstDate, 42);
        for (var i = 0; i < 42; i++) {
          days[i] = angular.extend(
            this.createDateObject(days[i], this.formatDay),
            {
              secondary: days[i].getMonth() !== month,
              uid: scope.uniqueId + "-" + i,
            }
          );
        }
        scope.labels = new Array(7);
        for (var j = 0; j < 7; j++) {
          scope.labels[j] = {
            abbr: dateFilter(days[j].date, this.formatDayHeader),
            full: dateFilter(days[j].date, "EEEE"),
          };
        }
        scope.title = dateFilter(this.activeDate, this.formatDayTitle);
        scope.rows = this.split(days, 7);
        if (scope.showWeeks) {
          scope.weekNumbers = [];
          var thursdayIndex = (4 + 7 - this.startingDay) % 7,
            numWeeks = scope.rows.length;
          for (var curWeek = 0; curWeek < numWeeks; curWeek++) {
            scope.weekNumbers.push(
              getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date)
            );
          }
        }
      };
      this.compare = function (date1, date2) {
        var _date1 = new Date(
          date1.getFullYear(),
          date1.getMonth(),
          date1.getDate()
        );
        var _date2 = new Date(
          date2.getFullYear(),
          date2.getMonth(),
          date2.getDate()
        );
        _date1.setFullYear(date1.getFullYear());
        _date2.setFullYear(date2.getFullYear());
        return _date1 - _date2;
      };
      function getISO8601WeekNumber(date) {
        var checkDate = new Date(date);
        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
        var time = checkDate.getTime();
        checkDate.setMonth(0);
        checkDate.setDate(1);
        return Math.floor(Math.round((time - checkDate) / 864e5) / 7) + 1;
      }
      this.handleKeyDown = function (key, evt) {
        var date = this.activeDate.getDate();
        if (key === "left") {
          date = date - 1;
        } else if (key === "up") {
          date = date - 7;
        } else if (key === "right") {
          date = date + 1;
        } else if (key === "down") {
          date = date + 7;
        } else if (key === "pageup" || key === "pagedown") {
          var month = this.activeDate.getMonth() + (key === "pageup" ? -1 : 1);
          this.activeDate.setMonth(month, 1);
          date = Math.min(
            getDaysInMonth(
              this.activeDate.getFullYear(),
              this.activeDate.getMonth()
            ),
            date
          );
        } else if (key === "home") {
          date = 1;
        } else if (key === "end") {
          date = getDaysInMonth(
            this.activeDate.getFullYear(),
            this.activeDate.getMonth()
          );
        }
        this.activeDate.setDate(date);
      };
    },
  ])
  .controller("UibMonthpickerController", [
    "$scope",
    "$element",
    "dateFilter",
    function (scope, $element, dateFilter) {
      this.step = { years: 1 };
      this.element = $element;
      this.init = function (ctrl) {
        angular.extend(ctrl, this);
        ctrl.refreshView();
      };
      this._refreshView = function () {
        var months = new Array(12),
          year = this.activeDate.getFullYear(),
          date;
        for (var i = 0; i < 12; i++) {
          date = new Date(this.activeDate);
          date.setFullYear(year, i, 1);
          months[i] = angular.extend(
            this.createDateObject(date, this.formatMonth),
            { uid: scope.uniqueId + "-" + i }
          );
        }
        scope.title = dateFilter(this.activeDate, this.formatMonthTitle);
        scope.rows = this.split(months, this.monthColumns);
        scope.yearHeaderColspan =
          this.monthColumns > 3 ? this.monthColumns - 2 : 1;
      };
      this.compare = function (date1, date2) {
        var _date1 = new Date(date1.getFullYear(), date1.getMonth());
        var _date2 = new Date(date2.getFullYear(), date2.getMonth());
        _date1.setFullYear(date1.getFullYear());
        _date2.setFullYear(date2.getFullYear());
        return _date1 - _date2;
      };
      this.handleKeyDown = function (key, evt) {
        var date = this.activeDate.getMonth();
        if (key === "left") {
          date = date - 1;
        } else if (key === "up") {
          date = date - this.monthColumns;
        } else if (key === "right") {
          date = date + 1;
        } else if (key === "down") {
          date = date + this.monthColumns;
        } else if (key === "pageup" || key === "pagedown") {
          var year =
            this.activeDate.getFullYear() + (key === "pageup" ? -1 : 1);
          this.activeDate.setFullYear(year);
        } else if (key === "home") {
          date = 0;
        } else if (key === "end") {
          date = 11;
        }
        this.activeDate.setMonth(date);
      };
    },
  ])
  .controller("UibYearpickerController", [
    "$scope",
    "$element",
    "dateFilter",
    function (scope, $element, dateFilter) {
      var columns, range;
      this.element = $element;
      function getStartingYear(year) {
        return parseInt((year - 1) / range, 10) * range + 1;
      }
      this.yearpickerInit = function () {
        columns = this.yearColumns;
        range = this.yearRows * columns;
        this.step = { years: range };
      };
      this._refreshView = function () {
        var years = new Array(range),
          date;
        for (
          var i = 0, start = getStartingYear(this.activeDate.getFullYear());
          i < range;
          i++
        ) {
          date = new Date(this.activeDate);
          date.setFullYear(start + i, 0, 1);
          years[i] = angular.extend(
            this.createDateObject(date, this.formatYear),
            { uid: scope.uniqueId + "-" + i }
          );
        }
        scope.title = [years[0].label, years[range - 1].label].join(" - ");
        scope.rows = this.split(years, columns);
        scope.columns = columns;
      };
      this.compare = function (date1, date2) {
        return date1.getFullYear() - date2.getFullYear();
      };
      this.handleKeyDown = function (key, evt) {
        var date = this.activeDate.getFullYear();
        if (key === "left") {
          date = date - 1;
        } else if (key === "up") {
          date = date - columns;
        } else if (key === "right") {
          date = date + 1;
        } else if (key === "down") {
          date = date + columns;
        } else if (key === "pageup" || key === "pagedown") {
          date += (key === "pageup" ? -1 : 1) * range;
        } else if (key === "home") {
          date = getStartingYear(this.activeDate.getFullYear());
        } else if (key === "end") {
          date = getStartingYear(this.activeDate.getFullYear()) + range - 1;
        }
        this.activeDate.setFullYear(date);
      };
    },
  ])
  .directive("uibDatepicker", function () {
    return {
      templateUrl: function (element, attrs) {
        return attrs.templateUrl || "uib/template/datepicker/datepicker.html";
      },
      scope: { datepickerOptions: "=?" },
      require: ["uibDatepicker", "^ngModel"],
      restrict: "A",
      controller: "UibDatepickerController",
      controllerAs: "datepicker",
      link: function (scope, element, attrs, ctrls) {
        var datepickerCtrl = ctrls[0],
          ngModelCtrl = ctrls[1];
        datepickerCtrl.init(ngModelCtrl);
      },
    };
  })
  .directive("uibDaypicker", function () {
    return {
      templateUrl: function (element, attrs) {
        return attrs.templateUrl || "uib/template/datepicker/day.html";
      },
      require: ["^uibDatepicker", "uibDaypicker"],
      restrict: "A",
      controller: "UibDaypickerController",
      link: function (scope, element, attrs, ctrls) {
        var datepickerCtrl = ctrls[0],
          daypickerCtrl = ctrls[1];
        daypickerCtrl.init(datepickerCtrl);
      },
    };
  })
  .directive("uibMonthpicker", function () {
    return {
      templateUrl: function (element, attrs) {
        return attrs.templateUrl || "uib/template/datepicker/month.html";
      },
      require: ["^uibDatepicker", "uibMonthpicker"],
      restrict: "A",
      controller: "UibMonthpickerController",
      link: function (scope, element, attrs, ctrls) {
        var datepickerCtrl = ctrls[0],
          monthpickerCtrl = ctrls[1];
        monthpickerCtrl.init(datepickerCtrl);
      },
    };
  })
  .directive("uibYearpicker", function () {
    return {
      templateUrl: function (element, attrs) {
        return attrs.templateUrl || "uib/template/datepicker/year.html";
      },
      require: ["^uibDatepicker", "uibYearpicker"],
      restrict: "A",
      controller: "UibYearpickerController",
      link: function (scope, element, attrs, ctrls) {
        var ctrl = ctrls[0];
        angular.extend(ctrl, ctrls[1]);
        ctrl.yearpickerInit();
        ctrl.refreshView();
      },
    };
  });
angular.module("ui.bootstrap.position", []).factory("$uibPosition", [
  "$document",
  "$window",
  function ($document, $window) {
    var SCROLLBAR_WIDTH;
    var BODY_SCROLLBAR_WIDTH;
    var OVERFLOW_REGEX = {
      normal: /(auto|scroll)/,
      hidden: /(auto|scroll|hidden)/,
    };
    var PLACEMENT_REGEX = {
      auto: /\s?auto?\s?/i,
      primary: /^(top|bottom|left|right)$/,
      secondary: /^(top|bottom|left|right|center)$/,
      vertical: /^(top|bottom)$/,
    };
    var BODY_REGEX = /(HTML|BODY)/;
    return {
      getRawNode: function (elem) {
        return elem.nodeName ? elem : elem[0] || elem;
      },
      parseStyle: function (value) {
        value = parseFloat(value);
        return isFinite(value) ? value : 0;
      },
      offsetParent: function (elem) {
        elem = this.getRawNode(elem);
        var offsetParent = elem.offsetParent || $document[0].documentElement;
        function isStaticPositioned(el) {
          return (
            ($window.getComputedStyle(el).position || "static") === "static"
          );
        }
        while (
          offsetParent &&
          offsetParent !== $document[0].documentElement &&
          isStaticPositioned(offsetParent)
        ) {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || $document[0].documentElement;
      },
      scrollbarWidth: function (isBody) {
        if (isBody) {
          if (angular.isUndefined(BODY_SCROLLBAR_WIDTH)) {
            var bodyElem = $document.find("body");
            bodyElem.addClass("uib-position-body-scrollbar-measure");
            BODY_SCROLLBAR_WIDTH = $window.innerWidth - bodyElem[0].clientWidth;
            BODY_SCROLLBAR_WIDTH = isFinite(BODY_SCROLLBAR_WIDTH)
              ? BODY_SCROLLBAR_WIDTH
              : 0;
            bodyElem.removeClass("uib-position-body-scrollbar-measure");
          }
          return BODY_SCROLLBAR_WIDTH;
        }
        if (angular.isUndefined(SCROLLBAR_WIDTH)) {
          var scrollElem = angular.element(
            '<div class="uib-position-scrollbar-measure"></div>'
          );
          $document.find("body").append(scrollElem);
          SCROLLBAR_WIDTH =
            scrollElem[0].offsetWidth - scrollElem[0].clientWidth;
          SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0;
          scrollElem.remove();
        }
        return SCROLLBAR_WIDTH;
      },
      scrollbarPadding: function (elem) {
        elem = this.getRawNode(elem);
        var elemStyle = $window.getComputedStyle(elem);
        var paddingRight = this.parseStyle(elemStyle.paddingRight);
        var paddingBottom = this.parseStyle(elemStyle.paddingBottom);
        var scrollParent = this.scrollParent(elem, false, true);
        var scrollbarWidth = this.scrollbarWidth(
          BODY_REGEX.test(scrollParent.tagName)
        );
        return {
          scrollbarWidth: scrollbarWidth,
          widthOverflow: scrollParent.scrollWidth > scrollParent.clientWidth,
          right: paddingRight + scrollbarWidth,
          originalRight: paddingRight,
          heightOverflow: scrollParent.scrollHeight > scrollParent.clientHeight,
          bottom: paddingBottom + scrollbarWidth,
          originalBottom: paddingBottom,
        };
      },
      isScrollable: function (elem, includeHidden) {
        elem = this.getRawNode(elem);
        var overflowRegex = includeHidden
          ? OVERFLOW_REGEX.hidden
          : OVERFLOW_REGEX.normal;
        var elemStyle = $window.getComputedStyle(elem);
        return overflowRegex.test(
          elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX
        );
      },
      scrollParent: function (elem, includeHidden, includeSelf) {
        elem = this.getRawNode(elem);
        var overflowRegex = includeHidden
          ? OVERFLOW_REGEX.hidden
          : OVERFLOW_REGEX.normal;
        var documentEl = $document[0].documentElement;
        var elemStyle = $window.getComputedStyle(elem);
        if (
          includeSelf &&
          overflowRegex.test(
            elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX
          )
        ) {
          return elem;
        }
        var excludeStatic = elemStyle.position === "absolute";
        var scrollParent = elem.parentElement || documentEl;
        if (scrollParent === documentEl || elemStyle.position === "fixed") {
          return documentEl;
        }
        while (scrollParent.parentElement && scrollParent !== documentEl) {
          var spStyle = $window.getComputedStyle(scrollParent);
          if (excludeStatic && spStyle.position !== "static") {
            excludeStatic = false;
          }
          if (
            !excludeStatic &&
            overflowRegex.test(
              spStyle.overflow + spStyle.overflowY + spStyle.overflowX
            )
          ) {
            break;
          }
          scrollParent = scrollParent.parentElement;
        }
        return scrollParent;
      },
      position: function (elem, includeMagins) {
        elem = this.getRawNode(elem);
        var elemOffset = this.offset(elem);
        if (includeMagins) {
          var elemStyle = $window.getComputedStyle(elem);
          elemOffset.top -= this.parseStyle(elemStyle.marginTop);
          elemOffset.left -= this.parseStyle(elemStyle.marginLeft);
        }
        var parent = this.offsetParent(elem);
        var parentOffset = { top: 0, left: 0 };
        if (parent !== $document[0].documentElement) {
          parentOffset = this.offset(parent);
          parentOffset.top += parent.clientTop - parent.scrollTop;
          parentOffset.left += parent.clientLeft - parent.scrollLeft;
        }
        return {
          width: Math.round(
            angular.isNumber(elemOffset.width)
              ? elemOffset.width
              : elem.offsetWidth
          ),
          height: Math.round(
            angular.isNumber(elemOffset.height)
              ? elemOffset.height
              : elem.offsetHeight
          ),
          top: Math.round(elemOffset.top - parentOffset.top),
          left: Math.round(elemOffset.left - parentOffset.left),
        };
      },
      offset: function (elem) {
        elem = this.getRawNode(elem);
        var elemBCR = elem.getBoundingClientRect();
        return {
          width: Math.round(
            angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth
          ),
          height: Math.round(
            angular.isNumber(elemBCR.height)
              ? elemBCR.height
              : elem.offsetHeight
          ),
          top: Math.round(
            elemBCR.top +
              ($window.pageYOffset || $document[0].documentElement.scrollTop)
          ),
          left: Math.round(
            elemBCR.left +
              ($window.pageXOffset || $document[0].documentElement.scrollLeft)
          ),
        };
      },
      viewportOffset: function (elem, useDocument, includePadding) {
        elem = this.getRawNode(elem);
        includePadding = includePadding !== false ? true : false;
        var elemBCR = elem.getBoundingClientRect();
        var offsetBCR = { top: 0, left: 0, bottom: 0, right: 0 };
        var offsetParent = useDocument
          ? $document[0].documentElement
          : this.scrollParent(elem);
        var offsetParentBCR = offsetParent.getBoundingClientRect();
        offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop;
        offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft;
        if (offsetParent === $document[0].documentElement) {
          offsetBCR.top += $window.pageYOffset;
          offsetBCR.left += $window.pageXOffset;
        }
        offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight;
        offsetBCR.right = offsetBCR.left + offsetParent.clientWidth;
        if (includePadding) {
          var offsetParentStyle = $window.getComputedStyle(offsetParent);
          offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop);
          offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom);
          offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft);
          offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);
        }
        return {
          top: Math.round(elemBCR.top - offsetBCR.top),
          bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),
          left: Math.round(elemBCR.left - offsetBCR.left),
          right: Math.round(offsetBCR.right - elemBCR.right),
        };
      },
      parsePlacement: function (placement) {
        var autoPlace = PLACEMENT_REGEX.auto.test(placement);
        if (autoPlace) {
          placement = placement.replace(PLACEMENT_REGEX.auto, "");
        }
        placement = placement.split("-");
        placement[0] = placement[0] || "top";
        if (!PLACEMENT_REGEX.primary.test(placement[0])) {
          placement[0] = "top";
        }
        placement[1] = placement[1] || "center";
        if (!PLACEMENT_REGEX.secondary.test(placement[1])) {
          placement[1] = "center";
        }
        if (autoPlace) {
          placement[2] = true;
        } else {
          placement[2] = false;
        }
        return placement;
      },
      positionElements: function (
        hostElem,
        targetElem,
        placement,
        appendToBody
      ) {
        hostElem = this.getRawNode(hostElem);
        targetElem = this.getRawNode(targetElem);
        var targetWidth = angular.isDefined(targetElem.offsetWidth)
          ? targetElem.offsetWidth
          : targetElem.prop("offsetWidth");
        var targetHeight = angular.isDefined(targetElem.offsetHeight)
          ? targetElem.offsetHeight
          : targetElem.prop("offsetHeight");
        placement = this.parsePlacement(placement);
        var hostElemPos = appendToBody
          ? this.offset(hostElem)
          : this.position(hostElem);
        var targetElemPos = { top: 0, left: 0, placement: "" };
        if (placement[2]) {
          var viewportOffset = this.viewportOffset(hostElem, appendToBody);
          var targetElemStyle = $window.getComputedStyle(targetElem);
          var adjustedSize = {
            width:
              targetWidth +
              Math.round(
                Math.abs(
                  this.parseStyle(targetElemStyle.marginLeft) +
                    this.parseStyle(targetElemStyle.marginRight)
                )
              ),
            height:
              targetHeight +
              Math.round(
                Math.abs(
                  this.parseStyle(targetElemStyle.marginTop) +
                    this.parseStyle(targetElemStyle.marginBottom)
                )
              ),
          };
          placement[0] =
            placement[0] === "top" &&
            adjustedSize.height > viewportOffset.top &&
            adjustedSize.height <= viewportOffset.bottom
              ? "bottom"
              : placement[0] === "bottom" &&
                adjustedSize.height > viewportOffset.bottom &&
                adjustedSize.height <= viewportOffset.top
              ? "top"
              : placement[0] === "left" &&
                adjustedSize.width > viewportOffset.left &&
                adjustedSize.width <= viewportOffset.right
              ? "right"
              : placement[0] === "right" &&
                adjustedSize.width > viewportOffset.right &&
                adjustedSize.width <= viewportOffset.left
              ? "left"
              : placement[0];
          placement[1] =
            placement[1] === "top" &&
            adjustedSize.height - hostElemPos.height > viewportOffset.bottom &&
            adjustedSize.height - hostElemPos.height <= viewportOffset.top
              ? "bottom"
              : placement[1] === "bottom" &&
                adjustedSize.height - hostElemPos.height > viewportOffset.top &&
                adjustedSize.height - hostElemPos.height <=
                  viewportOffset.bottom
              ? "top"
              : placement[1] === "left" &&
                adjustedSize.width - hostElemPos.width > viewportOffset.right &&
                adjustedSize.width - hostElemPos.width <= viewportOffset.left
              ? "right"
              : placement[1] === "right" &&
                adjustedSize.width - hostElemPos.width > viewportOffset.left &&
                adjustedSize.width - hostElemPos.width <= viewportOffset.right
              ? "left"
              : placement[1];
          if (placement[1] === "center") {
            if (PLACEMENT_REGEX.vertical.test(placement[0])) {
              var xOverflow = hostElemPos.width / 2 - targetWidth / 2;
              if (
                viewportOffset.left + xOverflow < 0 &&
                adjustedSize.width - hostElemPos.width <= viewportOffset.right
              ) {
                placement[1] = "left";
              } else if (
                viewportOffset.right + xOverflow < 0 &&
                adjustedSize.width - hostElemPos.width <= viewportOffset.left
              ) {
                placement[1] = "right";
              }
            } else {
              var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;
              if (
                viewportOffset.top + yOverflow < 0 &&
                adjustedSize.height - hostElemPos.height <=
                  viewportOffset.bottom
              ) {
                placement[1] = "top";
              } else if (
                viewportOffset.bottom + yOverflow < 0 &&
                adjustedSize.height - hostElemPos.height <= viewportOffset.top
              ) {
                placement[1] = "bottom";
              }
            }
          }
        }
        switch (placement[0]) {
          case "top":
            targetElemPos.top = hostElemPos.top - targetHeight;
            break;
          case "bottom":
            targetElemPos.top = hostElemPos.top + hostElemPos.height;
            break;
          case "left":
            targetElemPos.left = hostElemPos.left - targetWidth;
            break;
          case "right":
            targetElemPos.left = hostElemPos.left + hostElemPos.width;
            break;
        }
        switch (placement[1]) {
          case "top":
            targetElemPos.top = hostElemPos.top;
            break;
          case "bottom":
            targetElemPos.top =
              hostElemPos.top + hostElemPos.height - targetHeight;
            break;
          case "left":
            targetElemPos.left = hostElemPos.left;
            break;
          case "right":
            targetElemPos.left =
              hostElemPos.left + hostElemPos.width - targetWidth;
            break;
          case "center":
            if (PLACEMENT_REGEX.vertical.test(placement[0])) {
              targetElemPos.left =
                hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2;
            } else {
              targetElemPos.top =
                hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;
            }
            break;
        }
        targetElemPos.top = Math.round(targetElemPos.top);
        targetElemPos.left = Math.round(targetElemPos.left);
        targetElemPos.placement =
          placement[1] === "center"
            ? placement[0]
            : placement[0] + "-" + placement[1];
        return targetElemPos;
      },
      adjustTop: function (
        placementClasses,
        containerPosition,
        initialHeight,
        currentHeight
      ) {
        if (
          placementClasses.indexOf("top") !== -1 &&
          initialHeight !== currentHeight
        ) {
          return { top: containerPosition.top - currentHeight + "px" };
        }
      },
      positionArrow: function (elem, placement) {
        elem = this.getRawNode(elem);
        var innerElem = elem.querySelector(".tooltip-inner, .popover-inner");
        if (!innerElem) {
          return;
        }
        var isTooltip = angular.element(innerElem).hasClass("tooltip-inner");
        var arrowElem = isTooltip
          ? elem.querySelector(".tooltip-arrow")
          : elem.querySelector(".arrow");
        if (!arrowElem) {
          return;
        }
        var arrowCss = { top: "", bottom: "", left: "", right: "" };
        placement = this.parsePlacement(placement);
        if (placement[1] === "center") {
          angular.element(arrowElem).css(arrowCss);
          return;
        }
        var borderProp = "border-" + placement[0] + "-width";
        var borderWidth = $window.getComputedStyle(arrowElem)[borderProp];
        var borderRadiusProp = "border-";
        if (PLACEMENT_REGEX.vertical.test(placement[0])) {
          borderRadiusProp += placement[0] + "-" + placement[1];
        } else {
          borderRadiusProp += placement[1] + "-" + placement[0];
        }
        borderRadiusProp += "-radius";
        var borderRadius = $window.getComputedStyle(
          isTooltip ? innerElem : elem
        )[borderRadiusProp];
        switch (placement[0]) {
          case "top":
            arrowCss.bottom = isTooltip ? "0" : "-" + borderWidth;
            break;
          case "bottom":
            arrowCss.top = isTooltip ? "0" : "-" + borderWidth;
            break;
          case "left":
            arrowCss.right = isTooltip ? "0" : "-" + borderWidth;
            break;
          case "right":
            arrowCss.left = isTooltip ? "0" : "-" + borderWidth;
            break;
        }
        arrowCss[placement[1]] = borderRadius;
        angular.element(arrowElem).css(arrowCss);
      },
    };
  },
]);
angular
  .module("ui.bootstrap.datepickerPopup", [
    "ui.bootstrap.datepicker",
    "ui.bootstrap.position",
  ])
  .value("$datepickerPopupLiteralWarning", true)
  .constant("uibDatepickerPopupConfig", {
    altInputFormats: [],
    appendToBody: false,
    clearText: "Clear",
    closeOnDateSelection: true,
    closeText: "Done",
    currentText: "Today",
    datepickerPopup: "yyyy-MM-dd",
    datepickerPopupTemplateUrl: "uib/template/datepickerPopup/popup.html",
    datepickerTemplateUrl: "uib/template/datepicker/datepicker.html",
    html5Types: {
      date: "yyyy-MM-dd",
      "datetime-local": "yyyy-MM-ddTHH:mm:ss.sss",
      month: "yyyy-MM",
    },
    onOpenFocus: true,
    showButtonBar: true,
    placement: "auto bottom-left",
  })
  .controller("UibDatepickerPopupController", [
    "$scope",
    "$element",
    "$attrs",
    "$compile",
    "$log",
    "$parse",
    "$window",
    "$document",
    "$rootScope",
    "$uibPosition",
    "dateFilter",
    "uibDateParser",
    "uibDatepickerPopupConfig",
    "$timeout",
    "uibDatepickerConfig",
    "$datepickerPopupLiteralWarning",
    function (
      $scope,
      $element,
      $attrs,
      $compile,
      $log,
      $parse,
      $window,
      $document,
      $rootScope,
      $position,
      dateFilter,
      dateParser,
      datepickerPopupConfig,
      $timeout,
      datepickerConfig,
      $datepickerPopupLiteralWarning
    ) {
      var cache = {},
        isHtml5DateInput = false;
      var dateFormat,
        closeOnDateSelection,
        appendToBody,
        onOpenFocus,
        datepickerPopupTemplateUrl,
        datepickerTemplateUrl,
        popupEl,
        datepickerEl,
        scrollParentEl,
        ngModel,
        ngModelOptions,
        $popup,
        altInputFormats,
        watchListeners = [];
      this.init = function (_ngModel_) {
        ngModel = _ngModel_;
        ngModelOptions = angular.isObject(_ngModel_.$options)
          ? _ngModel_.$options
          : { timezone: null };
        closeOnDateSelection = angular.isDefined($attrs.closeOnDateSelection)
          ? $scope.$parent.$eval($attrs.closeOnDateSelection)
          : datepickerPopupConfig.closeOnDateSelection;
        appendToBody = angular.isDefined($attrs.datepickerAppendToBody)
          ? $scope.$parent.$eval($attrs.datepickerAppendToBody)
          : datepickerPopupConfig.appendToBody;
        onOpenFocus = angular.isDefined($attrs.onOpenFocus)
          ? $scope.$parent.$eval($attrs.onOpenFocus)
          : datepickerPopupConfig.onOpenFocus;
        datepickerPopupTemplateUrl = angular.isDefined(
          $attrs.datepickerPopupTemplateUrl
        )
          ? $attrs.datepickerPopupTemplateUrl
          : datepickerPopupConfig.datepickerPopupTemplateUrl;
        datepickerTemplateUrl = angular.isDefined($attrs.datepickerTemplateUrl)
          ? $attrs.datepickerTemplateUrl
          : datepickerPopupConfig.datepickerTemplateUrl;
        altInputFormats = angular.isDefined($attrs.altInputFormats)
          ? $scope.$parent.$eval($attrs.altInputFormats)
          : datepickerPopupConfig.altInputFormats;
        $scope.showButtonBar = angular.isDefined($attrs.showButtonBar)
          ? $scope.$parent.$eval($attrs.showButtonBar)
          : datepickerPopupConfig.showButtonBar;
        if (datepickerPopupConfig.html5Types[$attrs.type]) {
          dateFormat = datepickerPopupConfig.html5Types[$attrs.type];
          isHtml5DateInput = true;
        } else {
          dateFormat =
            $attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;
          $attrs.$observe("uibDatepickerPopup", function (value, oldValue) {
            var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
            if (newDateFormat !== dateFormat) {
              dateFormat = newDateFormat;
              ngModel.$modelValue = null;
              if (!dateFormat) {
                throw new Error(
                  "uibDatepickerPopup must have a date format specified."
                );
              }
            }
          });
        }
        if (!dateFormat) {
          throw new Error(
            "uibDatepickerPopup must have a date format specified."
          );
        }
        if (isHtml5DateInput && $attrs.uibDatepickerPopup) {
          throw new Error(
            "HTML5 date input types do not support custom formats."
          );
        }
        popupEl = angular.element(
          "<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>"
        );
        popupEl.attr({
          "ng-model": "date",
          "ng-change": "dateSelection(date)",
          "template-url": datepickerPopupTemplateUrl,
        });
        datepickerEl = angular.element(popupEl.children()[0]);
        datepickerEl.attr("template-url", datepickerTemplateUrl);
        if (!$scope.datepickerOptions) {
          $scope.datepickerOptions = {};
        }
        if (isHtml5DateInput) {
          if ($attrs.type === "month") {
            $scope.datepickerOptions.datepickerMode = "month";
            $scope.datepickerOptions.minMode = "month";
          }
        }
        datepickerEl.attr("datepicker-options", "datepickerOptions");
        if (!isHtml5DateInput) {
          ngModel.$$parserName = "date";
          ngModel.$validators.date = validator;
          ngModel.$parsers.unshift(parseDate);
          ngModel.$formatters.push(function (value) {
            if (ngModel.$isEmpty(value)) {
              $scope.date = value;
              return value;
            }
            if (angular.isNumber(value)) {
              value = new Date(value);
            }
            $scope.date = dateParser.fromTimezone(
              value,
              ngModelOptions.timezone
            );
            return dateParser.filter($scope.date, dateFormat);
          });
        } else {
          ngModel.$formatters.push(function (value) {
            $scope.date = dateParser.fromTimezone(
              value,
              ngModelOptions.timezone
            );
            return value;
          });
        }
        ngModel.$viewChangeListeners.push(function () {
          $scope.date = parseDateString(ngModel.$viewValue);
        });
        $element.on("keydown", inputKeydownBind);
        $popup = $compile(popupEl)($scope);
        popupEl.remove();
        if (appendToBody) {
          $document.find("body").append($popup);
        } else {
          $element.after($popup);
        }
        $scope.$on("$destroy", function () {
          if ($scope.isOpen === true) {
            if (!$rootScope.$$phase) {
              $scope.$apply(function () {
                $scope.isOpen = false;
              });
            }
          }
          $popup.remove();
          $element.off("keydown", inputKeydownBind);
          $document.off("click", documentClickBind);
          if (scrollParentEl) {
            scrollParentEl.off("scroll", positionPopup);
          }
          angular.element($window).off("resize", positionPopup);
          while (watchListeners.length) {
            watchListeners.shift()();
          }
        });
      };
      $scope.getText = function (key) {
        return $scope[key + "Text"] || datepickerPopupConfig[key + "Text"];
      };
      $scope.isDisabled = function (date) {
        if (date === "today") {
          date = dateParser.fromTimezone(new Date(), ngModelOptions.timezone);
        }
        var dates = {};
        angular.forEach(["minDate", "maxDate"], function (key) {
          if (!$scope.datepickerOptions[key]) {
            dates[key] = null;
          } else if (angular.isDate($scope.datepickerOptions[key])) {
            dates[key] = new Date($scope.datepickerOptions[key]);
          } else {
            if ($datepickerPopupLiteralWarning) {
              $log.warn(
                "Literal date support has been deprecated, please switch to date object usage"
              );
            }
            dates[key] = new Date(
              dateFilter($scope.datepickerOptions[key], "medium")
            );
          }
        });
        return (
          ($scope.datepickerOptions &&
            dates.minDate &&
            $scope.compare(date, dates.minDate) < 0) ||
          (dates.maxDate && $scope.compare(date, dates.maxDate) > 0)
        );
      };
      $scope.compare = function (date1, date2) {
        return (
          new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) -
          new Date(date2.getFullYear(), date2.getMonth(), date2.getDate())
        );
      };
      $scope.dateSelection = function (dt) {
        $scope.date = dt;
        var date = $scope.date
          ? dateParser.filter($scope.date, dateFormat)
          : null;
        $element.val(date);
        ngModel.$setViewValue(date);
        if (closeOnDateSelection) {
          $scope.isOpen = false;
          $element[0].focus();
        }
      };
      $scope.keydown = function (evt) {
        if (evt.which === 27) {
          evt.stopPropagation();
          $scope.isOpen = false;
          $element[0].focus();
        }
      };
      $scope.select = function (date, evt) {
        evt.stopPropagation();
        if (date === "today") {
          var today = new Date();
          if (angular.isDate($scope.date)) {
            date = new Date($scope.date);
            date.setFullYear(
              today.getFullYear(),
              today.getMonth(),
              today.getDate()
            );
          } else {
            date = dateParser.fromTimezone(today, ngModelOptions.timezone);
            date.setHours(0, 0, 0, 0);
          }
        }
        $scope.dateSelection(date);
      };
      $scope.close = function (evt) {
        evt.stopPropagation();
        $scope.isOpen = false;
        $element[0].focus();
      };
      $scope.disabled = angular.isDefined($attrs.disabled) || false;
      if ($attrs.ngDisabled) {
        watchListeners.push(
          $scope.$parent.$watch($parse($attrs.ngDisabled), function (disabled) {
            $scope.disabled = disabled;
          })
        );
      }
      $scope.$watch("isOpen", function (value) {
        if (value) {
          if (!$scope.disabled) {
            $timeout(
              function () {
                positionPopup();
                if (onOpenFocus) {
                  $scope.$broadcast("uib:datepicker.focus");
                }
                $document.on("click", documentClickBind);
                var placement = $attrs.popupPlacement
                  ? $attrs.popupPlacement
                  : datepickerPopupConfig.placement;
                if (appendToBody || $position.parsePlacement(placement)[2]) {
                  scrollParentEl =
                    scrollParentEl ||
                    angular.element($position.scrollParent($element));
                  if (scrollParentEl) {
                    scrollParentEl.on("scroll", positionPopup);
                  }
                } else {
                  scrollParentEl = null;
                }
                angular.element($window).on("resize", positionPopup);
              },
              0,
              false
            );
          } else {
            $scope.isOpen = false;
          }
        } else {
          $document.off("click", documentClickBind);
          if (scrollParentEl) {
            scrollParentEl.off("scroll", positionPopup);
          }
          angular.element($window).off("resize", positionPopup);
        }
      });
      function cameltoDash(string) {
        return string.replace(/([A-Z])/g, function ($1) {
          return "-" + $1.toLowerCase();
        });
      }
      function parseDateString(viewValue) {
        var date = dateParser.parse(viewValue, dateFormat, $scope.date);
        if (isNaN(date)) {
          for (var i = 0; i < altInputFormats.length; i++) {
            date = dateParser.parse(viewValue, altInputFormats[i], $scope.date);
            if (!isNaN(date)) {
              return date;
            }
          }
        }
        return date;
      }
      function parseDate(viewValue) {
        if (angular.isNumber(viewValue)) {
          viewValue = new Date(viewValue);
        }
        if (!viewValue) {
          return null;
        }
        if (angular.isDate(viewValue) && !isNaN(viewValue)) {
          return viewValue;
        }
        if (angular.isString(viewValue)) {
          var date = parseDateString(viewValue);
          if (!isNaN(date)) {
            return dateParser.toTimezone(date, ngModelOptions.timezone);
          }
        }
        return ngModel.$options && ngModel.$options.allowInvalid
          ? viewValue
          : undefined;
      }
      function validator(modelValue, viewValue) {
        var value = modelValue || viewValue;
        if (!$attrs.ngRequired && !value) {
          return true;
        }
        if (angular.isNumber(value)) {
          value = new Date(value);
        }
        if (!value) {
          return true;
        }
        if (angular.isDate(value) && !isNaN(value)) {
          return true;
        }
        if (angular.isString(value)) {
          return !isNaN(parseDateString(value));
        }
        return false;
      }
      function documentClickBind(event) {
        if (!$scope.isOpen && $scope.disabled) {
          return;
        }
        var popup = $popup[0];
        var dpContainsTarget = $element[0].contains(event.target);
        var popupContainsTarget =
          popup.contains !== undefined && popup.contains(event.target);
        if ($scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {
          $scope.$apply(function () {
            $scope.isOpen = false;
          });
        }
      }
      function inputKeydownBind(evt) {
        if (evt.which === 27 && $scope.isOpen) {
          evt.preventDefault();
          evt.stopPropagation();
          $scope.$apply(function () {
            $scope.isOpen = false;
          });
          $element[0].focus();
        } else if (evt.which === 40 && !$scope.isOpen) {
          evt.preventDefault();
          evt.stopPropagation();
          $scope.$apply(function () {
            $scope.isOpen = true;
          });
        }
      }
      function positionPopup() {
        if ($scope.isOpen) {
          var dpElement = angular.element(
            $popup[0].querySelector(".uib-datepicker-popup")
          );
          var placement = $attrs.popupPlacement
            ? $attrs.popupPlacement
            : datepickerPopupConfig.placement;
          var position = $position.positionElements(
            $element,
            dpElement,
            placement,
            appendToBody
          );
          dpElement.css({
            top: position.top + "px",
            left: position.left + "px",
          });
          if (dpElement.hasClass("uib-position-measure")) {
            dpElement.removeClass("uib-position-measure");
          }
        }
      }
      $scope.$on("uib:datepicker.mode", function () {
        $timeout(positionPopup, 0, false);
      });
    },
  ])
  .directive("uibDatepickerPopup", function () {
    return {
      require: ["ngModel", "uibDatepickerPopup"],
      controller: "UibDatepickerPopupController",
      scope: {
        datepickerOptions: "=?",
        isOpen: "=?",
        currentText: "@",
        clearText: "@",
        closeText: "@",
      },
      link: function (scope, element, attrs, ctrls) {
        var ngModel = ctrls[0],
          ctrl = ctrls[1];
        ctrl.init(ngModel);
      },
    };
  })
  .directive("uibDatepickerPopupWrap", function () {
    return {
      restrict: "A",
      transclude: true,
      templateUrl: function (element, attrs) {
        return attrs.templateUrl || "uib/template/datepickerPopup/popup.html";
      },
    };
  });
angular.module("ui.bootstrap.debounce", []).factory("$$debounce", [
  "$timeout",
  function ($timeout) {
    return function (callback, debounceTime) {
      var timeoutPromise;
      return function () {
        var self = this;
        var args = Array.prototype.slice.call(arguments);
        if (timeoutPromise) {
          $timeout.cancel(timeoutPromise);
        }
        timeoutPromise = $timeout(function () {
          callback.apply(self, args);
        }, debounceTime);
      };
    };
  },
]);
angular.module("ui.bootstrap.multiMap", []).factory("$$multiMap", function () {
  return {
    createNew: function () {
      var map = {};
      return {
        entries: function () {
          return Object.keys(map).map(function (key) {
            return { key: key, value: map[key] };
          });
        },
        get: function (key) {
          return map[key];
        },
        hasKey: function (key) {
          return !!map[key];
        },
        keys: function () {
          return Object.keys(map);
        },
        put: function (key, value) {
          if (!map[key]) {
            map[key] = [];
          }
          map[key].push(value);
        },
        remove: function (key, value) {
          var values = map[key];
          if (!values) {
            return;
          }
          var idx = values.indexOf(value);
          if (idx !== -1) {
            values.splice(idx, 1);
          }
          if (!values.length) {
            delete map[key];
          }
        },
      };
    },
  };
});
angular
  .module("ui.bootstrap.dropdown", [
    "ui.bootstrap.multiMap",
    "ui.bootstrap.position",
  ])
  .constant("uibDropdownConfig", {
    appendToOpenClass: "uib-dropdown-open",
    openClass: "open",
  })
  .service("uibDropdownService", [
    "$document",
    "$rootScope",
    "$$multiMap",
    function ($document, $rootScope, $$multiMap) {
      var openScope = null;
      var openedContainers = $$multiMap.createNew();
      this.isOnlyOpen = function (dropdownScope, appendTo) {
        var openedDropdowns = openedContainers.get(appendTo);
        if (openedDropdowns) {
          var openDropdown = openedDropdowns.reduce(function (
            toClose,
            dropdown
          ) {
            if (dropdown.scope === dropdownScope) {
              return dropdown;
            }
            return toClose;
          },
          {});
          if (openDropdown) {
            return openedDropdowns.length === 1;
          }
        }
        return false;
      };
      this.open = function (dropdownScope, element, appendTo) {
        if (!openScope) {
          $document.on("click", closeDropdown);
        }
        if (openScope && openScope !== dropdownScope) {
          openScope.isOpen = false;
        }
        openScope = dropdownScope;
        if (!appendTo) {
          return;
        }
        var openedDropdowns = openedContainers.get(appendTo);
        if (openedDropdowns) {
          var openedScopes = openedDropdowns.map(function (dropdown) {
            return dropdown.scope;
          });
          if (openedScopes.indexOf(dropdownScope) === -1) {
            openedContainers.put(appendTo, { scope: dropdownScope });
          }
        } else {
          openedContainers.put(appendTo, { scope: dropdownScope });
        }
      };
      this.close = function (dropdownScope, element, appendTo) {
        if (openScope === dropdownScope) {
          $document.off("click", closeDropdown);
          $document.off("keydown", this.keybindFilter);
          openScope = null;
        }
        if (!appendTo) {
          return;
        }
        var openedDropdowns = openedContainers.get(appendTo);
        if (openedDropdowns) {
          var dropdownToClose = openedDropdowns.reduce(function (
            toClose,
            dropdown
          ) {
            if (dropdown.scope === dropdownScope) {
              return dropdown;
            }
            return toClose;
          },
          {});
          if (dropdownToClose) {
            openedContainers.remove(appendTo, dropdownToClose);
          }
        }
      };
      var closeDropdown = function (evt) {
        if (!openScope) {
          return;
        }
        if (evt && openScope.getAutoClose() === "disabled") {
          return;
        }
        if (evt && evt.which === 3) {
          return;
        }
        var toggleElement = openScope.getToggleElement();
        if (evt && toggleElement && toggleElement[0].contains(evt.target)) {
          return;
        }
        var dropdownElement = openScope.getDropdownElement();
        if (
          evt &&
          openScope.getAutoClose() === "outsideClick" &&
          dropdownElement &&
          dropdownElement[0].contains(evt.target)
        ) {
          return;
        }
        openScope.focusToggleElement();
        openScope.isOpen = false;
        if (!$rootScope.$$phase) {
          openScope.$apply();
        }
      };
      this.keybindFilter = function (evt) {
        if (!openScope) {
          return;
        }
        var dropdownElement = openScope.getDropdownElement();
        var toggleElement = openScope.getToggleElement();
        var dropdownElementTargeted =
          dropdownElement && dropdownElement[0].contains(evt.target);
        var toggleElementTargeted =
          toggleElement && toggleElement[0].contains(evt.target);
        if (evt.which === 27) {
          evt.stopPropagation();
          openScope.focusToggleElement();
          closeDropdown();
        } else if (
          openScope.isKeynavEnabled() &&
          [38, 40].indexOf(evt.which) !== -1 &&
          openScope.isOpen &&
          (dropdownElementTargeted || toggleElementTargeted)
        ) {
          evt.preventDefault();
          evt.stopPropagation();
          openScope.focusDropdownEntry(evt.which);
        }
      };
    },
  ])
  .controller("UibDropdownController", [
    "$scope",
    "$element",
    "$attrs",
    "$parse",
    "uibDropdownConfig",
    "uibDropdownService",
    "$animate",
    "$uibPosition",
    "$document",
    "$compile",
    "$templateRequest",
    function (
      $scope,
      $element,
      $attrs,
      $parse,
      dropdownConfig,
      uibDropdownService,
      $animate,
      $position,
      $document,
      $compile,
      $templateRequest
    ) {
      var self = this,
        scope = $scope.$new(),
        templateScope,
        appendToOpenClass = dropdownConfig.appendToOpenClass,
        openClass = dropdownConfig.openClass,
        getIsOpen,
        setIsOpen = angular.noop,
        toggleInvoker = $attrs.onToggle
          ? $parse($attrs.onToggle)
          : angular.noop,
        appendToBody = false,
        appendTo = null,
        keynavEnabled = false,
        selectedOption = null,
        body = $document.find("body");
      $element.addClass("dropdown");
      this.init = function () {
        if ($attrs.isOpen) {
          getIsOpen = $parse($attrs.isOpen);
          setIsOpen = getIsOpen.assign;
          $scope.$watch(getIsOpen, function (value) {
            scope.isOpen = !!value;
          });
        }
        if (angular.isDefined($attrs.dropdownAppendTo)) {
          var appendToEl = $parse($attrs.dropdownAppendTo)(scope);
          if (appendToEl) {
            appendTo = angular.element(appendToEl);
          }
        }
        appendToBody = angular.isDefined($attrs.dropdownAppendToBody);
        keynavEnabled = angular.isDefined($attrs.keyboardNav);
        if (appendToBody && !appendTo) {
          appendTo = body;
        }
        if (appendTo && self.dropdownMenu) {
          appendTo.append(self.dropdownMenu);
          $element.on("$destroy", function handleDestroyEvent() {
            self.dropdownMenu.remove();
          });
        }
      };
      this.toggle = function (open) {
        scope.isOpen = arguments.length ? !!open : !scope.isOpen;
        if (angular.isFunction(setIsOpen)) {
          setIsOpen(scope, scope.isOpen);
        }
        return scope.isOpen;
      };
      this.isOpen = function () {
        return scope.isOpen;
      };
      scope.getToggleElement = function () {
        return self.toggleElement;
      };
      scope.getAutoClose = function () {
        return $attrs.autoClose || "always";
      };
      scope.getElement = function () {
        return $element;
      };
      scope.isKeynavEnabled = function () {
        return keynavEnabled;
      };
      scope.focusDropdownEntry = function (keyCode) {
        var elems = self.dropdownMenu
          ? angular.element(self.dropdownMenu).find("a")
          : $element.find("ul").eq(0).find("a");
        switch (keyCode) {
          case 40: {
            if (!angular.isNumber(self.selectedOption)) {
              self.selectedOption = 0;
            } else {
              self.selectedOption =
                self.selectedOption === elems.length - 1
                  ? self.selectedOption
                  : self.selectedOption + 1;
            }
            break;
          }
          case 38: {
            if (!angular.isNumber(self.selectedOption)) {
              self.selectedOption = elems.length - 1;
            } else {
              self.selectedOption =
                self.selectedOption === 0 ? 0 : self.selectedOption - 1;
            }
            break;
          }
        }
        elems[self.selectedOption].focus();
      };
      scope.getDropdownElement = function () {
        return self.dropdownMenu;
      };
      scope.focusToggleElement = function () {
        if (self.toggleElement) {
          self.toggleElement[0].focus();
        }
      };
      scope.$watch("isOpen", function (isOpen, wasOpen) {
        if (appendTo && self.dropdownMenu) {
          var pos = $position.positionElements(
              $element,
              self.dropdownMenu,
              "bottom-left",
              true
            ),
            css,
            rightalign,
            scrollbarPadding,
            scrollbarWidth = 0;
          css = { top: pos.top + "px", display: isOpen ? "block" : "none" };
          rightalign = self.dropdownMenu.hasClass("dropdown-menu-right");
          if (!rightalign) {
            css.left = pos.left + "px";
            css.right = "auto";
          } else {
            css.left = "auto";
            scrollbarPadding = $position.scrollbarPadding(appendTo);
            if (
              scrollbarPadding.heightOverflow &&
              scrollbarPadding.scrollbarWidth
            ) {
              scrollbarWidth = scrollbarPadding.scrollbarWidth;
            }
            css.right =
              window.innerWidth -
              scrollbarWidth -
              (pos.left + $element.prop("offsetWidth")) +
              "px";
          }
          if (!appendToBody) {
            var appendOffset = $position.offset(appendTo);
            css.top = pos.top - appendOffset.top + "px";
            if (!rightalign) {
              css.left = pos.left - appendOffset.left + "px";
            } else {
              css.right =
                window.innerWidth -
                (pos.left - appendOffset.left + $element.prop("offsetWidth")) +
                "px";
            }
          }
          self.dropdownMenu.css(css);
        }
        var openContainer = appendTo ? appendTo : $element;
        var dropdownOpenClass = appendTo ? appendToOpenClass : openClass;
        var hasOpenClass = openContainer.hasClass(dropdownOpenClass);
        var isOnlyOpen = uibDropdownService.isOnlyOpen($scope, appendTo);
        if (hasOpenClass === !isOpen) {
          var toggleClass;
          if (appendTo) {
            toggleClass = !isOnlyOpen ? "addClass" : "removeClass";
          } else {
            toggleClass = isOpen ? "addClass" : "removeClass";
          }
          $animate[toggleClass](openContainer, dropdownOpenClass).then(
            function () {
              if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
                toggleInvoker($scope, { open: !!isOpen });
              }
            }
          );
        }
        if (isOpen) {
          if (self.dropdownMenuTemplateUrl) {
            $templateRequest(self.dropdownMenuTemplateUrl).then(function (
              tplContent
            ) {
              templateScope = scope.$new();
              $compile(tplContent.trim())(
                templateScope,
                function (dropdownElement) {
                  var newEl = dropdownElement;
                  self.dropdownMenu.replaceWith(newEl);
                  self.dropdownMenu = newEl;
                  $document.on("keydown", uibDropdownService.keybindFilter);
                }
              );
            });
          } else {
            $document.on("keydown", uibDropdownService.keybindFilter);
          }
          scope.focusToggleElement();
          uibDropdownService.open(scope, $element, appendTo);
        } else {
          uibDropdownService.close(scope, $element, appendTo);
          if (self.dropdownMenuTemplateUrl) {
            if (templateScope) {
              templateScope.$destroy();
            }
            var newEl = angular.element('<ul class="dropdown-menu"></ul>');
            self.dropdownMenu.replaceWith(newEl);
            self.dropdownMenu = newEl;
          }
          self.selectedOption = null;
        }
        if (angular.isFunction(setIsOpen)) {
          setIsOpen($scope, isOpen);
        }
      });
    },
  ])
  .directive("uibDropdown", function () {
    return {
      controller: "UibDropdownController",
      link: function (scope, element, attrs, dropdownCtrl) {
        dropdownCtrl.init();
      },
    };
  })
  .directive("uibDropdownMenu", function () {
    return {
      restrict: "A",
      require: "?^uibDropdown",
      link: function (scope, element, attrs, dropdownCtrl) {
        if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {
          return;
        }
        element.addClass("dropdown-menu");
        var tplUrl = attrs.templateUrl;
        if (tplUrl) {
          dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
        }
        if (!dropdownCtrl.dropdownMenu) {
          dropdownCtrl.dropdownMenu = element;
        }
      },
    };
  })
  .directive("uibDropdownToggle", function () {
    return {
      require: "?^uibDropdown",
      link: function (scope, element, attrs, dropdownCtrl) {
        if (!dropdownCtrl) {
          return;
        }
        element.addClass("dropdown-toggle");
        dropdownCtrl.toggleElement = element;
        var toggleDropdown = function (event) {
          event.preventDefault();
          if (!element.hasClass("disabled") && !attrs.disabled) {
            scope.$apply(function () {
              dropdownCtrl.toggle();
            });
          }
        };
        element.on("click", toggleDropdown);
        element.attr({ "aria-haspopup": true, "aria-expanded": false });
        scope.$watch(dropdownCtrl.isOpen, function (isOpen) {
          element.attr("aria-expanded", !!isOpen);
        });
        scope.$on("$destroy", function () {
          element.off("click", toggleDropdown);
        });
      },
    };
  });
angular
  .module("ui.bootstrap.stackedMap", [])
  .factory("$$stackedMap", function () {
    return {
      createNew: function () {
        var stack = [];
        return {
          add: function (key, value) {
            stack.push({ key: key, value: value });
          },
          get: function (key) {
            for (var i = 0; i < stack.length; i++) {
              if (key === stack[i].key) {
                return stack[i];
              }
            }
          },
          keys: function () {
            var keys = [];
            for (var i = 0; i < stack.length; i++) {
              keys.push(stack[i].key);
            }
            return keys;
          },
          top: function () {
            return stack[stack.length - 1];
          },
          remove: function (key) {
            var idx = -1;
            for (var i = 0; i < stack.length; i++) {
              if (key === stack[i].key) {
                idx = i;
                break;
              }
            }
            return stack.splice(idx, 1)[0];
          },
          removeTop: function () {
            return stack.pop();
          },
          length: function () {
            return stack.length;
          },
        };
      },
    };
  });
angular
  .module("ui.bootstrap.modal", [
    "ui.bootstrap.multiMap",
    "ui.bootstrap.stackedMap",
    "ui.bootstrap.position",
  ])
  .provider("$uibResolve", function () {
    var resolve = this;
    this.resolver = null;
    this.setResolver = function (resolver) {
      this.resolver = resolver;
    };
    this.$get = [
      "$injector",
      "$q",
      function ($injector, $q) {
        var resolver = resolve.resolver
          ? $injector.get(resolve.resolver)
          : null;
        return {
          resolve: function (invocables, locals, parent, self) {
            if (resolver) {
              return resolver.resolve(invocables, locals, parent, self);
            }
            var promises = [];
            angular.forEach(invocables, function (value) {
              if (angular.isFunction(value) || angular.isArray(value)) {
                promises.push($q.resolve($injector.invoke(value)));
              } else if (angular.isString(value)) {
                promises.push($q.resolve($injector.get(value)));
              } else {
                promises.push($q.resolve(value));
              }
            });
            return $q.all(promises).then(function (resolves) {
              var resolveObj = {};
              var resolveIter = 0;
              angular.forEach(invocables, function (value, key) {
                resolveObj[key] = resolves[resolveIter++];
              });
              return resolveObj;
            });
          },
        };
      },
    ];
  })
  .directive("uibModalBackdrop", [
    "$animate",
    "$injector",
    "$uibModalStack",
    function ($animate, $injector, $modalStack) {
      return {
        restrict: "A",
        compile: function (tElement, tAttrs) {
          tElement.addClass(tAttrs.backdropClass);
          return linkFn;
        },
      };
      function linkFn(scope, element, attrs) {
        if (attrs.modalInClass) {
          $animate.addClass(element, attrs.modalInClass);
          scope.$on($modalStack.NOW_CLOSING_EVENT, function (e, setIsAsync) {
            var done = setIsAsync();
            if (scope.modalOptions.animation) {
              $animate.removeClass(element, attrs.modalInClass).then(done);
            } else {
              done();
            }
          });
        }
      }
    },
  ])
  .directive("uibModalWindow", [
    "$uibModalStack",
    "$q",
    "$animateCss",
    "$document",
    function ($modalStack, $q, $animateCss, $document) {
      return {
        scope: { index: "@" },
        restrict: "A",
        transclude: true,
        templateUrl: function (tElement, tAttrs) {
          return tAttrs.templateUrl || "uib/template/modal/window.html";
        },
        link: function (scope, element, attrs) {
          element.addClass(attrs.windowTopClass || "");
          scope.size = attrs.size;
          scope.close = function (evt) {
            var modal = $modalStack.getTop();
            if (
              modal &&
              modal.value.backdrop &&
              modal.value.backdrop !== "static" &&
              evt.target === evt.currentTarget
            ) {
              evt.preventDefault();
              evt.stopPropagation();
              $modalStack.dismiss(modal.key, "backdrop click");
            }
          };
          element.on("click", scope.close);
          scope.$isRendered = true;
          var modalRenderDeferObj = $q.defer();
          scope.$$postDigest(function () {
            modalRenderDeferObj.resolve();
          });
          modalRenderDeferObj.promise.then(function () {
            var animationPromise = null;
            if (attrs.modalInClass) {
              animationPromise = $animateCss(element, {
                addClass: attrs.modalInClass,
              }).start();
              scope.$on(
                $modalStack.NOW_CLOSING_EVENT,
                function (e, setIsAsync) {
                  var done = setIsAsync();
                  $animateCss(element, { removeClass: attrs.modalInClass })
                    .start()
                    .then(done);
                }
              );
            }
            $q.when(animationPromise).then(function () {
              var modal = $modalStack.getTop();
              if (modal) {
                $modalStack.modalRendered(modal.key);
              }
              if (
                !(
                  $document[0].activeElement &&
                  element[0].contains($document[0].activeElement)
                )
              ) {
                var inputWithAutofocus =
                  element[0].querySelector("[autofocus]");
                if (inputWithAutofocus) {
                  inputWithAutofocus.focus();
                } else {
                  element[0].focus();
                }
              }
            });
          });
        },
      };
    },
  ])
  .directive("uibModalAnimationClass", function () {
    return {
      compile: function (tElement, tAttrs) {
        if (tAttrs.modalAnimation) {
          tElement.addClass(tAttrs.uibModalAnimationClass);
        }
      },
    };
  })
  .directive("uibModalTransclude", [
    "$animate",
    function ($animate) {
      return {
        link: function (scope, element, attrs, controller, transclude) {
          transclude(scope.$parent, function (clone) {
            element.empty();
            $animate.enter(clone, element);
          });
        },
      };
    },
  ])
  .factory("$uibModalStack", [
    "$animate",
    "$animateCss",
    "$document",
    "$compile",
    "$rootScope",
    "$q",
    "$$multiMap",
    "$$stackedMap",
    "$uibPosition",
    function (
      $animate,
      $animateCss,
      $document,
      $compile,
      $rootScope,
      $q,
      $$multiMap,
      $$stackedMap,
      $uibPosition
    ) {
      var OPENED_MODAL_CLASS = "modal-open";
      var backdropDomEl, backdropScope;
      var openedWindows = $$stackedMap.createNew();
      var openedClasses = $$multiMap.createNew();
      var $modalStack = { NOW_CLOSING_EVENT: "modal.stack.now-closing" };
      var topModalIndex = 0;
      var previousTopOpenedModal = null;
      var ARIA_HIDDEN_ATTRIBUTE_NAME = "data-bootstrap-modal-aria-hidden-count";
      var tabbableSelector =
        "a[href], area[href], input:not([disabled]):not([tabindex='-1']), " +
        "button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']), textarea:not([disabled]):not([tabindex='-1']), " +
        "iframe, object, embed, *[tabindex]:not([tabindex='-1']), *[contenteditable=true]";
      var scrollbarPadding;
      var SNAKE_CASE_REGEXP = /[A-Z]/g;
      function snake_case(name) {
        var separator = "-";
        return name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {
          return (pos ? separator : "") + letter.toLowerCase();
        });
      }
      function isVisible(element) {
        return !!(
          element.offsetWidth ||
          element.offsetHeight ||
          element.getClientRects().length
        );
      }
      function backdropIndex() {
        var topBackdropIndex = -1;
        var opened = openedWindows.keys();
        for (var i = 0; i < opened.length; i++) {
          if (openedWindows.get(opened[i]).value.backdrop) {
            topBackdropIndex = i;
          }
        }
        if (topBackdropIndex > -1 && topBackdropIndex < topModalIndex) {
          topBackdropIndex = topModalIndex;
        }
        return topBackdropIndex;
      }
      $rootScope.$watch(backdropIndex, function (newBackdropIndex) {
        if (backdropScope) {
          backdropScope.index = newBackdropIndex;
        }
      });
      function removeModalWindow(modalInstance, elementToReceiveFocus) {
        var modalWindow = openedWindows.get(modalInstance).value;
        var appendToElement = modalWindow.appendTo;
        openedWindows.remove(modalInstance);
        previousTopOpenedModal = openedWindows.top();
        if (previousTopOpenedModal) {
          topModalIndex = parseInt(
            previousTopOpenedModal.value.modalDomEl.attr("index"),
            10
          );
        }
        removeAfterAnimate(
          modalWindow.modalDomEl,
          modalWindow.modalScope,
          function () {
            var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
            openedClasses.remove(modalBodyClass, modalInstance);
            var areAnyOpen = openedClasses.hasKey(modalBodyClass);
            appendToElement.toggleClass(modalBodyClass, areAnyOpen);
            if (
              !areAnyOpen &&
              scrollbarPadding &&
              scrollbarPadding.heightOverflow &&
              scrollbarPadding.scrollbarWidth
            ) {
              if (scrollbarPadding.originalRight) {
                appendToElement.css({
                  paddingRight: scrollbarPadding.originalRight + "px",
                });
              } else {
                appendToElement.css({ paddingRight: "" });
              }
              scrollbarPadding = null;
            }
            toggleTopWindowClass(true);
          },
          modalWindow.closedDeferred
        );
        checkRemoveBackdrop();
        if (elementToReceiveFocus && elementToReceiveFocus.focus) {
          elementToReceiveFocus.focus();
        } else if (appendToElement.focus) {
          appendToElement.focus();
        }
      }
      function toggleTopWindowClass(toggleSwitch) {
        var modalWindow;
        if (openedWindows.length() > 0) {
          modalWindow = openedWindows.top().value;
          modalWindow.modalDomEl.toggleClass(
            modalWindow.windowTopClass || "",
            toggleSwitch
          );
        }
      }
      function checkRemoveBackdrop() {
        if (backdropDomEl && backdropIndex() === -1) {
          var backdropScopeRef = backdropScope;
          removeAfterAnimate(backdropDomEl, backdropScope, function () {
            backdropScopeRef = null;
          });
          backdropDomEl = undefined;
          backdropScope = undefined;
        }
      }
      function removeAfterAnimate(domEl, scope, done, closedDeferred) {
        var asyncDeferred;
        var asyncPromise = null;
        var setIsAsync = function () {
          if (!asyncDeferred) {
            asyncDeferred = $q.defer();
            asyncPromise = asyncDeferred.promise;
          }
          return function asyncDone() {
            asyncDeferred.resolve();
          };
        };
        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);
        return $q.when(asyncPromise).then(afterAnimating);
        function afterAnimating() {
          if (afterAnimating.done) {
            return;
          }
          afterAnimating.done = true;
          $animate.leave(domEl).then(function () {
            if (done) {
              done();
            }
            domEl.remove();
            if (closedDeferred) {
              closedDeferred.resolve();
            }
          });
          scope.$destroy();
        }
      }
      $document.on("keydown", keydownListener);
      $rootScope.$on("$destroy", function () {
        $document.off("keydown", keydownListener);
      });
      function keydownListener(evt) {
        if (evt.isDefaultPrevented()) {
          return evt;
        }
        var modal = openedWindows.top();
        if (modal) {
          switch (evt.which) {
            case 27: {
              if (modal.value.keyboard) {
                evt.preventDefault();
                $rootScope.$apply(function () {
                  $modalStack.dismiss(modal.key, "escape key press");
                });
              }
              break;
            }
            case 9: {
              var list = $modalStack.loadFocusElementList(modal);
              var focusChanged = false;
              if (evt.shiftKey) {
                if (
                  $modalStack.isFocusInFirstItem(evt, list) ||
                  $modalStack.isModalFocused(evt, modal)
                ) {
                  focusChanged = $modalStack.focusLastFocusableElement(list);
                }
              } else {
                if ($modalStack.isFocusInLastItem(evt, list)) {
                  focusChanged = $modalStack.focusFirstFocusableElement(list);
                }
              }
              if (focusChanged) {
                evt.preventDefault();
                evt.stopPropagation();
              }
              break;
            }
          }
        }
      }
      $modalStack.open = function (modalInstance, modal) {
        var modalOpener = $document[0].activeElement,
          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;
        toggleTopWindowClass(false);
        previousTopOpenedModal = openedWindows.top();
        openedWindows.add(modalInstance, {
          deferred: modal.deferred,
          renderDeferred: modal.renderDeferred,
          closedDeferred: modal.closedDeferred,
          modalScope: modal.scope,
          backdrop: modal.backdrop,
          keyboard: modal.keyboard,
          openedClass: modal.openedClass,
          windowTopClass: modal.windowTopClass,
          animation: modal.animation,
          appendTo: modal.appendTo,
        });
        openedClasses.put(modalBodyClass, modalInstance);
        var appendToElement = modal.appendTo,
          currBackdropIndex = backdropIndex();
        if (!appendToElement.length) {
          throw new Error(
            "appendTo element not found. Make sure that the element passed is in DOM."
          );
        }
        if (currBackdropIndex >= 0 && !backdropDomEl) {
          backdropScope = $rootScope.$new(true);
          backdropScope.modalOptions = modal;
          backdropScope.index = currBackdropIndex;
          backdropDomEl = angular.element(
            '<div uib-modal-backdrop="modal-backdrop"></div>'
          );
          backdropDomEl.attr({
            class: "modal-backdrop",
            "ng-style": "{'z-index': 1040 + (index && 1 || 0) + index*10}",
            "uib-modal-animation-class": "fade",
            "modal-in-class": "in",
          });
          if (modal.backdropClass) {
            backdropDomEl.addClass(modal.backdropClass);
          }
          if (modal.animation) {
            backdropDomEl.attr("modal-animation", "true");
          }
          $compile(backdropDomEl)(backdropScope);
          $animate.enter(backdropDomEl, appendToElement);
          if ($uibPosition.isScrollable(appendToElement)) {
            scrollbarPadding = $uibPosition.scrollbarPadding(appendToElement);
            if (
              scrollbarPadding.heightOverflow &&
              scrollbarPadding.scrollbarWidth
            ) {
              appendToElement.css({
                paddingRight: scrollbarPadding.right + "px",
              });
            }
          }
        }
        var content;
        if (modal.component) {
          content = document.createElement(snake_case(modal.component.name));
          content = angular.element(content);
          content.attr({
            resolve: "$resolve",
            "modal-instance": "$uibModalInstance",
            close: "$close($value)",
            dismiss: "$dismiss($value)",
          });
        } else {
          content = modal.content;
        }
        topModalIndex = previousTopOpenedModal
          ? parseInt(
              previousTopOpenedModal.value.modalDomEl.attr("index"),
              10
            ) + 1
          : 0;
        var angularDomEl = angular.element(
          '<div uib-modal-window="modal-window"></div>'
        );
        angularDomEl
          .attr({
            class: "modal",
            "template-url": modal.windowTemplateUrl,
            "window-top-class": modal.windowTopClass,
            role: "dialog",
            "aria-labelledby": modal.ariaLabelledBy,
            "aria-describedby": modal.ariaDescribedBy,
            size: modal.size,
            index: topModalIndex,
            animate: "animate",
            "ng-style":
              "{'z-index': 1050 + $$topModalIndex*10, display: 'block'}",
            tabindex: -1,
            "uib-modal-animation-class": "fade",
            "modal-in-class": "in",
          })
          .append(content);
        if (modal.windowClass) {
          angularDomEl.addClass(modal.windowClass);
        }
        if (modal.animation) {
          angularDomEl.attr("modal-animation", "true");
        }
        appendToElement.addClass(modalBodyClass);
        if (modal.scope) {
          modal.scope.$$topModalIndex = topModalIndex;
        }
        $animate.enter($compile(angularDomEl)(modal.scope), appendToElement);
        openedWindows.top().value.modalDomEl = angularDomEl;
        openedWindows.top().value.modalOpener = modalOpener;
        applyAriaHidden(angularDomEl);
        function applyAriaHidden(el) {
          if (!el || el[0].tagName === "BODY") {
            return;
          }
          getSiblings(el).forEach(function (sibling) {
            var elemIsAlreadyHidden =
                sibling.getAttribute("aria-hidden") === "true",
              ariaHiddenCount = parseInt(
                sibling.getAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME),
                10
              );
            if (!ariaHiddenCount) {
              ariaHiddenCount = elemIsAlreadyHidden ? 1 : 0;
            }
            sibling.setAttribute(
              ARIA_HIDDEN_ATTRIBUTE_NAME,
              ariaHiddenCount + 1
            );
            sibling.setAttribute("aria-hidden", "true");
          });
          return applyAriaHidden(el.parent());
          function getSiblings(el) {
            var children = el.parent() ? el.parent().children() : [];
            return Array.prototype.filter.call(children, function (child) {
              return child !== el[0];
            });
          }
        }
      };
      function broadcastClosing(modalWindow, resultOrReason, closing) {
        return !modalWindow.value.modalScope.$broadcast(
          "modal.closing",
          resultOrReason,
          closing
        ).defaultPrevented;
      }
      function unhideBackgroundElements() {
        Array.prototype.forEach.call(
          document.querySelectorAll("[" + ARIA_HIDDEN_ATTRIBUTE_NAME + "]"),
          function (hiddenEl) {
            var ariaHiddenCount = parseInt(
                hiddenEl.getAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME),
                10
              ),
              newHiddenCount = ariaHiddenCount - 1;
            hiddenEl.setAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME, newHiddenCount);
            if (!newHiddenCount) {
              hiddenEl.removeAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME);
              hiddenEl.removeAttribute("aria-hidden");
            }
          }
        );
      }
      $modalStack.close = function (modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance);
        unhideBackgroundElements();
        if (modalWindow && broadcastClosing(modalWindow, result, true)) {
          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
          modalWindow.value.deferred.resolve(result);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }
        return !modalWindow;
      };
      $modalStack.dismiss = function (modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance);
        unhideBackgroundElements();
        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {
          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
          modalWindow.value.deferred.reject(reason);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }
        return !modalWindow;
      };
      $modalStack.dismissAll = function (reason) {
        var topModal = this.getTop();
        while (topModal && this.dismiss(topModal.key, reason)) {
          topModal = this.getTop();
        }
      };
      $modalStack.getTop = function () {
        return openedWindows.top();
      };
      $modalStack.modalRendered = function (modalInstance) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow) {
          modalWindow.value.renderDeferred.resolve();
        }
      };
      $modalStack.focusFirstFocusableElement = function (list) {
        if (list.length > 0) {
          list[0].focus();
          return true;
        }
        return false;
      };
      $modalStack.focusLastFocusableElement = function (list) {
        if (list.length > 0) {
          list[list.length - 1].focus();
          return true;
        }
        return false;
      };
      $modalStack.isModalFocused = function (evt, modalWindow) {
        if (evt && modalWindow) {
          var modalDomEl = modalWindow.value.modalDomEl;
          if (modalDomEl && modalDomEl.length) {
            return (evt.target || evt.srcElement) === modalDomEl[0];
          }
        }
        return false;
      };
      $modalStack.isFocusInFirstItem = function (evt, list) {
        if (list.length > 0) {
          return (evt.target || evt.srcElement) === list[0];
        }
        return false;
      };
      $modalStack.isFocusInLastItem = function (evt, list) {
        if (list.length > 0) {
          return (evt.target || evt.srcElement) === list[list.length - 1];
        }
        return false;
      };
      $modalStack.loadFocusElementList = function (modalWindow) {
        if (modalWindow) {
          var modalDomE1 = modalWindow.value.modalDomEl;
          if (modalDomE1 && modalDomE1.length) {
            var elements = modalDomE1[0].querySelectorAll(tabbableSelector);
            return elements
              ? Array.prototype.filter.call(elements, function (element) {
                  return isVisible(element);
                })
              : elements;
          }
        }
      };
      return $modalStack;
    },
  ])
  .provider("$uibModal", function () {
    var $modalProvider = {
      options: { animation: true, backdrop: true, keyboard: true },
      $get: [
        "$rootScope",
        "$q",
        "$document",
        "$templateRequest",
        "$controller",
        "$uibResolve",
        "$uibModalStack",
        function (
          $rootScope,
          $q,
          $document,
          $templateRequest,
          $controller,
          $uibResolve,
          $modalStack
        ) {
          var $modal = {};
          function getTemplatePromise(options) {
            return options.template
              ? $q.when(options.template)
              : $templateRequest(
                  angular.isFunction(options.templateUrl)
                    ? options.templateUrl()
                    : options.templateUrl
                );
          }
          var promiseChain = null;
          $modal.getPromiseChain = function () {
            return promiseChain;
          };
          $modal.open = function (modalOptions) {
            var modalResultDeferred = $q.defer();
            var modalOpenedDeferred = $q.defer();
            var modalClosedDeferred = $q.defer();
            var modalRenderDeferred = $q.defer();
            var modalInstance = {
              result: modalResultDeferred.promise,
              opened: modalOpenedDeferred.promise,
              closed: modalClosedDeferred.promise,
              rendered: modalRenderDeferred.promise,
              close: function (result) {
                return $modalStack.close(modalInstance, result);
              },
              dismiss: function (reason) {
                return $modalStack.dismiss(modalInstance, reason);
              },
            };
            modalOptions = angular.extend(
              {},
              $modalProvider.options,
              modalOptions
            );
            modalOptions.resolve = modalOptions.resolve || {};
            modalOptions.appendTo =
              modalOptions.appendTo || $document.find("body").eq(0);
            if (
              !modalOptions.component &&
              !modalOptions.template &&
              !modalOptions.templateUrl
            ) {
              throw new Error(
                "One of component or template or templateUrl options is required."
              );
            }
            var templateAndResolvePromise;
            if (modalOptions.component) {
              templateAndResolvePromise = $q.when(
                $uibResolve.resolve(modalOptions.resolve, {}, null, null)
              );
            } else {
              templateAndResolvePromise = $q.all([
                getTemplatePromise(modalOptions),
                $uibResolve.resolve(modalOptions.resolve, {}, null, null),
              ]);
            }
            function resolveWithTemplate() {
              return templateAndResolvePromise;
            }
            var samePromise;
            samePromise = promiseChain = $q
              .all([promiseChain])
              .then(resolveWithTemplate, resolveWithTemplate)
              .then(
                function resolveSuccess(tplAndVars) {
                  var providedScope = modalOptions.scope || $rootScope;
                  var modalScope = providedScope.$new();
                  modalScope.$close = modalInstance.close;
                  modalScope.$dismiss = modalInstance.dismiss;
                  modalScope.$on("$destroy", function () {
                    if (!modalScope.$$uibDestructionScheduled) {
                      modalScope.$dismiss("$uibUnscheduledDestruction");
                    }
                  });
                  var modal = {
                    scope: modalScope,
                    deferred: modalResultDeferred,
                    renderDeferred: modalRenderDeferred,
                    closedDeferred: modalClosedDeferred,
                    animation: modalOptions.animation,
                    backdrop: modalOptions.backdrop,
                    keyboard: modalOptions.keyboard,
                    backdropClass: modalOptions.backdropClass,
                    windowTopClass: modalOptions.windowTopClass,
                    windowClass: modalOptions.windowClass,
                    windowTemplateUrl: modalOptions.windowTemplateUrl,
                    ariaLabelledBy: modalOptions.ariaLabelledBy,
                    ariaDescribedBy: modalOptions.ariaDescribedBy,
                    size: modalOptions.size,
                    openedClass: modalOptions.openedClass,
                    appendTo: modalOptions.appendTo,
                  };
                  var component = {};
                  var ctrlInstance,
                    ctrlInstantiate,
                    ctrlLocals = {};
                  if (modalOptions.component) {
                    constructLocals(component, false, true, false);
                    component.name = modalOptions.component;
                    modal.component = component;
                  } else if (modalOptions.controller) {
                    constructLocals(ctrlLocals, true, false, true);
                    ctrlInstantiate = $controller(
                      modalOptions.controller,
                      ctrlLocals,
                      true,
                      modalOptions.controllerAs
                    );
                    if (
                      modalOptions.controllerAs &&
                      modalOptions.bindToController
                    ) {
                      ctrlInstance = ctrlInstantiate.instance;
                      ctrlInstance.$close = modalScope.$close;
                      ctrlInstance.$dismiss = modalScope.$dismiss;
                      angular.extend(
                        ctrlInstance,
                        { $resolve: ctrlLocals.$scope.$resolve },
                        providedScope
                      );
                    }
                    ctrlInstance = ctrlInstantiate();
                    if (angular.isFunction(ctrlInstance.$onInit)) {
                      ctrlInstance.$onInit();
                    }
                  }
                  if (!modalOptions.component) {
                    modal.content = tplAndVars[0];
                  }
                  $modalStack.open(modalInstance, modal);
                  modalOpenedDeferred.resolve(true);
                  function constructLocals(
                    obj,
                    template,
                    instanceOnScope,
                    injectable
                  ) {
                    obj.$scope = modalScope;
                    obj.$scope.$resolve = {};
                    if (instanceOnScope) {
                      obj.$scope.$uibModalInstance = modalInstance;
                    } else {
                      obj.$uibModalInstance = modalInstance;
                    }
                    var resolves = template ? tplAndVars[1] : tplAndVars;
                    angular.forEach(resolves, function (value, key) {
                      if (injectable) {
                        obj[key] = value;
                      }
                      obj.$scope.$resolve[key] = value;
                    });
                  }
                },
                function resolveError(reason) {
                  modalOpenedDeferred.reject(reason);
                  modalResultDeferred.reject(reason);
                }
              )
              ["finally"](function () {
                if (promiseChain === samePromise) {
                  promiseChain = null;
                }
              });
            return modalInstance;
          };
          return $modal;
        },
      ],
    };
    return $modalProvider;
  });
angular.module("ui.bootstrap.paging", []).factory("uibPaging", [
  "$parse",
  function ($parse) {
    return {
      create: function (ctrl, $scope, $attrs) {
        ctrl.setNumPages = $attrs.numPages
          ? $parse($attrs.numPages).assign
          : angular.noop;
        ctrl.ngModelCtrl = { $setViewValue: angular.noop };
        ctrl._watchers = [];
        ctrl.init = function (ngModelCtrl, config) {
          ctrl.ngModelCtrl = ngModelCtrl;
          ctrl.config = config;
          ngModelCtrl.$render = function () {
            ctrl.render();
          };
          if ($attrs.itemsPerPage) {
            ctrl._watchers.push(
              $scope.$parent.$watch($attrs.itemsPerPage, function (value) {
                ctrl.itemsPerPage = parseInt(value, 10);
                $scope.totalPages = ctrl.calculateTotalPages();
                ctrl.updatePage();
              })
            );
          } else {
            ctrl.itemsPerPage = config.itemsPerPage;
          }
          $scope.$watch("totalItems", function (newTotal, oldTotal) {
            if (angular.isDefined(newTotal) || newTotal !== oldTotal) {
              $scope.totalPages = ctrl.calculateTotalPages();
              ctrl.updatePage();
            }
          });
        };
        ctrl.calculateTotalPages = function () {
          var totalPages =
            ctrl.itemsPerPage < 1
              ? 1
              : Math.ceil($scope.totalItems / ctrl.itemsPerPage);
          return Math.max(totalPages || 0, 1);
        };
        ctrl.render = function () {
          $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;
        };
        $scope.selectPage = function (page, evt) {
          if (evt) {
            evt.preventDefault();
          }
          var clickAllowed = !$scope.ngDisabled || !evt;
          if (
            clickAllowed &&
            $scope.page !== page &&
            page > 0 &&
            page <= $scope.totalPages
          ) {
            if (evt && evt.target) {
              evt.target.blur();
            }
            ctrl.ngModelCtrl.$setViewValue(page);
            ctrl.ngModelCtrl.$render();
          }
        };
        $scope.getText = function (key) {
          return $scope[key + "Text"] || ctrl.config[key + "Text"];
        };
        $scope.noPrevious = function () {
          return $scope.page === 1;
        };
        $scope.noNext = function () {
          return $scope.page === $scope.totalPages;
        };
        ctrl.updatePage = function () {
          ctrl.setNumPages($scope.$parent, $scope.totalPages);
          if ($scope.page > $scope.totalPages) {
            $scope.selectPage($scope.totalPages);
          } else {
            ctrl.ngModelCtrl.$render();
          }
        };
        $scope.$on("$destroy", function () {
          while (ctrl._watchers.length) {
            ctrl._watchers.shift()();
          }
        });
      },
    };
  },
]);
angular
  .module("ui.bootstrap.pager", [
    "ui.bootstrap.paging",
    "ui.bootstrap.tabindex",
  ])
  .controller("UibPagerController", [
    "$scope",
    "$attrs",
    "uibPaging",
    "uibPagerConfig",
    function ($scope, $attrs, uibPaging, uibPagerConfig) {
      $scope.align = angular.isDefined($attrs.align)
        ? $scope.$parent.$eval($attrs.align)
        : uibPagerConfig.align;
      uibPaging.create(this, $scope, $attrs);
    },
  ])
  .constant("uibPagerConfig", {
    itemsPerPage: 10,
    previousText: " Previous",
    nextText: "Next ",
    align: true,
  })
  .directive("uibPager", [
    "uibPagerConfig",
    function (uibPagerConfig) {
      return {
        scope: {
          totalItems: "=",
          previousText: "@",
          nextText: "@",
          ngDisabled: "=",
        },
        require: ["uibPager", "?ngModel"],
        restrict: "A",
        controller: "UibPagerController",
        controllerAs: "pager",
        templateUrl: function (element, attrs) {
          return attrs.templateUrl || "uib/template/pager/pager.html";
        },
        link: function (scope, element, attrs, ctrls) {
          element.addClass("pager");
          var paginationCtrl = ctrls[0],
            ngModelCtrl = ctrls[1];
          if (!ngModelCtrl) {
            return;
          }
          paginationCtrl.init(ngModelCtrl, uibPagerConfig);
        },
      };
    },
  ]);
angular
  .module("ui.bootstrap.pagination", [
    "ui.bootstrap.paging",
    "ui.bootstrap.tabindex",
  ])
  .controller("UibPaginationController", [
    "$scope",
    "$attrs",
    "$parse",
    "uibPaging",
    "uibPaginationConfig",
    function ($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {
      var ctrl = this;
      var maxSize = angular.isDefined($attrs.maxSize)
          ? $scope.$parent.$eval($attrs.maxSize)
          : uibPaginationConfig.maxSize,
        rotate = angular.isDefined($attrs.rotate)
          ? $scope.$parent.$eval($attrs.rotate)
          : uibPaginationConfig.rotate,
        forceEllipses = angular.isDefined($attrs.forceEllipses)
          ? $scope.$parent.$eval($attrs.forceEllipses)
          : uibPaginationConfig.forceEllipses,
        boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers)
          ? $scope.$parent.$eval($attrs.boundaryLinkNumbers)
          : uibPaginationConfig.boundaryLinkNumbers,
        pageLabel = angular.isDefined($attrs.pageLabel)
          ? function (idx) {
              return $scope.$parent.$eval($attrs.pageLabel, { $page: idx });
            }
          : angular.identity;
      $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks)
        ? $scope.$parent.$eval($attrs.boundaryLinks)
        : uibPaginationConfig.boundaryLinks;
      $scope.directionLinks = angular.isDefined($attrs.directionLinks)
        ? $scope.$parent.$eval($attrs.directionLinks)
        : uibPaginationConfig.directionLinks;
      uibPaging.create(this, $scope, $attrs);
      if ($attrs.maxSize) {
        ctrl._watchers.push(
          $scope.$parent.$watch($parse($attrs.maxSize), function (value) {
            maxSize = parseInt(value, 10);
            ctrl.render();
          })
        );
      }
      function makePage(number, text, isActive) {
        return { number: number, text: text, active: isActive };
      }
      function getPages(currentPage, totalPages) {
        var pages = [];
        var startPage = 1,
          endPage = totalPages;
        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;
        if (isMaxSized) {
          if (rotate) {
            startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);
            endPage = startPage + maxSize - 1;
            if (endPage > totalPages) {
              endPage = totalPages;
              startPage = endPage - maxSize + 1;
            }
          } else {
            startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;
            endPage = Math.min(startPage + maxSize - 1, totalPages);
          }
        }
        for (var number = startPage; number <= endPage; number++) {
          var page = makePage(
            number,
            pageLabel(number),
            number === currentPage
          );
          pages.push(page);
        }
        if (
          isMaxSized &&
          maxSize > 0 &&
          (!rotate || forceEllipses || boundaryLinkNumbers)
        ) {
          if (startPage > 1) {
            if (!boundaryLinkNumbers || startPage > 3) {
              var previousPageSet = makePage(startPage - 1, "...", false);
              pages.unshift(previousPageSet);
            }
            if (boundaryLinkNumbers) {
              if (startPage === 3) {
                var secondPageLink = makePage(2, "2", false);
                pages.unshift(secondPageLink);
              }
              var firstPageLink = makePage(1, "1", false);
              pages.unshift(firstPageLink);
            }
          }
          if (endPage < totalPages) {
            if (!boundaryLinkNumbers || endPage < totalPages - 2) {
              var nextPageSet = makePage(endPage + 1, "...", false);
              pages.push(nextPageSet);
            }
            if (boundaryLinkNumbers) {
              if (endPage === totalPages - 2) {
                var secondToLastPageLink = makePage(
                  totalPages - 1,
                  totalPages - 1,
                  false
                );
                pages.push(secondToLastPageLink);
              }
              var lastPageLink = makePage(totalPages, totalPages, false);
              pages.push(lastPageLink);
            }
          }
        }
        return pages;
      }
      var originalRender = this.render;
      this.render = function () {
        originalRender();
        if ($scope.page > 0 && $scope.page <= $scope.totalPages) {
          $scope.pages = getPages($scope.page, $scope.totalPages);
        }
      };
    },
  ])
  .constant("uibPaginationConfig", {
    itemsPerPage: 10,
    boundaryLinks: false,
    boundaryLinkNumbers: false,
    directionLinks: true,
    firstText: "First",
    previousText: "Previous",
    nextText: "Next",
    lastText: "Last",
    rotate: true,
    forceEllipses: false,
  })
  .directive("uibPagination", [
    "$parse",
    "uibPaginationConfig",
    function ($parse, uibPaginationConfig) {
      return {
        scope: {
          totalItems: "=",
          firstText: "@",
          previousText: "@",
          nextText: "@",
          lastText: "@",
          ngDisabled: "=",
        },
        require: ["uibPagination", "?ngModel"],
        restrict: "A",
        controller: "UibPaginationController",
        controllerAs: "pagination",
        templateUrl: function (element, attrs) {
          return attrs.templateUrl || "uib/template/pagination/pagination.html";
        },
        link: function (scope, element, attrs, ctrls) {
          element.addClass("pagination");
          var paginationCtrl = ctrls[0],
            ngModelCtrl = ctrls[1];
          if (!ngModelCtrl) {
            return;
          }
          paginationCtrl.init(ngModelCtrl, uibPaginationConfig);
        },
      };
    },
  ]);
angular
  .module("ui.bootstrap.tooltip", [
    "ui.bootstrap.position",
    "ui.bootstrap.stackedMap",
  ])
  .provider("$uibTooltip", function () {
    var defaultOptions = {
      placement: "top",
      placementClassPrefix: "",
      animation: true,
      popupDelay: 0,
      popupCloseDelay: 0,
      useContentExp: false,
    };
    var triggerMap = {
      mouseenter: "mouseleave",
      click: "click",
      outsideClick: "outsideClick",
      focus: "blur",
      none: "",
    };
    var globalOptions = {};
    this.options = function (value) {
      angular.extend(globalOptions, value);
    };
    this.setTriggers = function setTriggers(triggers) {
      angular.extend(triggerMap, triggers);
    };
    function snake_case(name) {
      var regexp = /[A-Z]/g;
      var separator = "-";
      return name.replace(regexp, function (letter, pos) {
        return (pos ? separator : "") + letter.toLowerCase();
      });
    }
    this.$get = [
      "$window",
      "$compile",
      "$timeout",
      "$document",
      "$uibPosition",
      "$interpolate",
      "$rootScope",
      "$parse",
      "$$stackedMap",
      function (
        $window,
        $compile,
        $timeout,
        $document,
        $position,
        $interpolate,
        $rootScope,
        $parse,
        $$stackedMap
      ) {
        var openedTooltips = $$stackedMap.createNew();
        $document.on("keyup", keypressListener);
        $rootScope.$on("$destroy", function () {
          $document.off("keyup", keypressListener);
        });
        function keypressListener(e) {
          if (e.which === 27) {
            var last = openedTooltips.top();
            if (last) {
              last.value.close();
              last = null;
            }
          }
        }
        return function $tooltip(ttType, prefix, defaultTriggerShow, options) {
          options = angular.extend({}, defaultOptions, globalOptions, options);
          function getTriggers(trigger) {
            var show = (trigger || options.trigger || defaultTriggerShow).split(
              " "
            );
            var hide = show.map(function (trigger) {
              return triggerMap[trigger] || trigger;
            });
            return { show: show, hide: hide };
          }
          var directiveName = snake_case(ttType);
          var startSym = $interpolate.startSymbol();
          var endSym = $interpolate.endSymbol();
          var template =
            "<div " +
            directiveName +
            "-popup " +
            'uib-title="' +
            startSym +
            "title" +
            endSym +
            '" ' +
            (options.useContentExp
              ? 'content-exp="contentExp()" '
              : 'content="' + startSym + "content" + endSym + '" ') +
            'origin-scope="origScope" ' +
            'class="uib-position-measure ' +
            prefix +
            '" ' +
            'tooltip-animation-class="fade"' +
            "uib-tooltip-classes " +
            'ng-class="{ in: isOpen }" ' +
            ">" +
            "</div>";
          return {
            compile: function (tElem, tAttrs) {
              var tooltipLinker = $compile(template);
              return function link(scope, element, attrs, tooltipCtrl) {
                var tooltip;
                var tooltipLinkedScope;
                var transitionTimeout;
                var showTimeout;
                var hideTimeout;
                var positionTimeout;
                var adjustmentTimeout;
                var appendToBody = angular.isDefined(options.appendToBody)
                  ? options.appendToBody
                  : false;
                var triggers = getTriggers(undefined);
                var hasEnableExp = angular.isDefined(attrs[prefix + "Enable"]);
                var ttScope = scope.$new(true);
                var repositionScheduled = false;
                var isOpenParse = angular.isDefined(attrs[prefix + "IsOpen"])
                  ? $parse(attrs[prefix + "IsOpen"])
                  : false;
                var contentParse = options.useContentExp
                  ? $parse(attrs[ttType])
                  : false;
                var observers = [];
                var lastPlacement;
                var positionTooltip = function () {
                  if (!tooltip || !tooltip.html()) {
                    return;
                  }
                  if (!positionTimeout) {
                    positionTimeout = $timeout(
                      function () {
                        var ttPosition = $position.positionElements(
                          element,
                          tooltip,
                          ttScope.placement,
                          appendToBody
                        );
                        var initialHeight = angular.isDefined(
                          tooltip.offsetHeight
                        )
                          ? tooltip.offsetHeight
                          : tooltip.prop("offsetHeight");
                        var elementPos = appendToBody
                          ? $position.offset(element)
                          : $position.position(element);
                        tooltip.css({
                          top: ttPosition.top + "px",
                          left: ttPosition.left + "px",
                        });
                        var placementClasses = ttPosition.placement.split("-");
                        if (!tooltip.hasClass(placementClasses[0])) {
                          tooltip.removeClass(lastPlacement.split("-")[0]);
                          tooltip.addClass(placementClasses[0]);
                        }
                        if (
                          !tooltip.hasClass(
                            options.placementClassPrefix + ttPosition.placement
                          )
                        ) {
                          tooltip.removeClass(
                            options.placementClassPrefix + lastPlacement
                          );
                          tooltip.addClass(
                            options.placementClassPrefix + ttPosition.placement
                          );
                        }
                        adjustmentTimeout = $timeout(
                          function () {
                            var currentHeight = angular.isDefined(
                              tooltip.offsetHeight
                            )
                              ? tooltip.offsetHeight
                              : tooltip.prop("offsetHeight");
                            var adjustment = $position.adjustTop(
                              placementClasses,
                              elementPos,
                              initialHeight,
                              currentHeight
                            );
                            if (adjustment) {
                              tooltip.css(adjustment);
                            }
                            adjustmentTimeout = null;
                          },
                          0,
                          false
                        );
                        if (tooltip.hasClass("uib-position-measure")) {
                          $position.positionArrow(
                            tooltip,
                            ttPosition.placement
                          );
                          tooltip.removeClass("uib-position-measure");
                        } else if (lastPlacement !== ttPosition.placement) {
                          $position.positionArrow(
                            tooltip,
                            ttPosition.placement
                          );
                        }
                        lastPlacement = ttPosition.placement;
                        positionTimeout = null;
                      },
                      0,
                      false
                    );
                  }
                };
                ttScope.origScope = scope;
                ttScope.isOpen = false;
                function toggleTooltipBind() {
                  if (!ttScope.isOpen) {
                    showTooltipBind();
                  } else {
                    hideTooltipBind();
                  }
                }
                function showTooltipBind() {
                  if (hasEnableExp && !scope.$eval(attrs[prefix + "Enable"])) {
                    return;
                  }
                  cancelHide();
                  prepareTooltip();
                  if (ttScope.popupDelay) {
                    if (!showTimeout) {
                      showTimeout = $timeout(show, ttScope.popupDelay, false);
                    }
                  } else {
                    show();
                  }
                }
                function hideTooltipBind() {
                  cancelShow();
                  if (ttScope.popupCloseDelay) {
                    if (!hideTimeout) {
                      hideTimeout = $timeout(
                        hide,
                        ttScope.popupCloseDelay,
                        false
                      );
                    }
                  } else {
                    hide();
                  }
                }
                function show() {
                  cancelShow();
                  cancelHide();
                  if (!ttScope.content) {
                    return angular.noop;
                  }
                  createTooltip();
                  ttScope.$evalAsync(function () {
                    ttScope.isOpen = true;
                    assignIsOpen(true);
                    positionTooltip();
                  });
                }
                function cancelShow() {
                  if (showTimeout) {
                    $timeout.cancel(showTimeout);
                    showTimeout = null;
                  }
                  if (positionTimeout) {
                    $timeout.cancel(positionTimeout);
                    positionTimeout = null;
                  }
                }
                function hide() {
                  if (!ttScope) {
                    return;
                  }
                  ttScope.$evalAsync(function () {
                    if (ttScope) {
                      ttScope.isOpen = false;
                      assignIsOpen(false);
                      if (ttScope.animation) {
                        if (!transitionTimeout) {
                          transitionTimeout = $timeout(
                            removeTooltip,
                            150,
                            false
                          );
                        }
                      } else {
                        removeTooltip();
                      }
                    }
                  });
                }
                function cancelHide() {
                  if (hideTimeout) {
                    $timeout.cancel(hideTimeout);
                    hideTimeout = null;
                  }
                  if (transitionTimeout) {
                    $timeout.cancel(transitionTimeout);
                    transitionTimeout = null;
                  }
                }
                function createTooltip() {
                  if (tooltip) {
                    return;
                  }
                  tooltipLinkedScope = ttScope.$new();
                  tooltip = tooltipLinker(
                    tooltipLinkedScope,
                    function (tooltip) {
                      if (appendToBody) {
                        $document.find("body").append(tooltip);
                      } else {
                        element.after(tooltip);
                      }
                    }
                  );
                  openedTooltips.add(ttScope, { close: hide });
                  prepObservers();
                }
                function removeTooltip() {
                  cancelShow();
                  cancelHide();
                  unregisterObservers();
                  if (tooltip) {
                    tooltip.remove();
                    tooltip = null;
                    if (adjustmentTimeout) {
                      $timeout.cancel(adjustmentTimeout);
                    }
                  }
                  openedTooltips.remove(ttScope);
                  if (tooltipLinkedScope) {
                    tooltipLinkedScope.$destroy();
                    tooltipLinkedScope = null;
                  }
                }
                function prepareTooltip() {
                  ttScope.title = attrs[prefix + "Title"];
                  if (contentParse) {
                    ttScope.content = contentParse(scope);
                  } else {
                    ttScope.content = attrs[ttType];
                  }
                  ttScope.popupClass = attrs[prefix + "Class"];
                  ttScope.placement = angular.isDefined(
                    attrs[prefix + "Placement"]
                  )
                    ? attrs[prefix + "Placement"]
                    : options.placement;
                  var placement = $position.parsePlacement(ttScope.placement);
                  lastPlacement = placement[1]
                    ? placement[0] + "-" + placement[1]
                    : placement[0];
                  var delay = parseInt(attrs[prefix + "PopupDelay"], 10);
                  var closeDelay = parseInt(
                    attrs[prefix + "PopupCloseDelay"],
                    10
                  );
                  ttScope.popupDelay = !isNaN(delay)
                    ? delay
                    : options.popupDelay;
                  ttScope.popupCloseDelay = !isNaN(closeDelay)
                    ? closeDelay
                    : options.popupCloseDelay;
                }
                function assignIsOpen(isOpen) {
                  if (isOpenParse && angular.isFunction(isOpenParse.assign)) {
                    isOpenParse.assign(scope, isOpen);
                  }
                }
                ttScope.contentExp = function () {
                  return ttScope.content;
                };
                attrs.$observe("disabled", function (val) {
                  if (val) {
                    cancelShow();
                  }
                  if (val && ttScope.isOpen) {
                    hide();
                  }
                });
                if (isOpenParse) {
                  scope.$watch(isOpenParse, function (val) {
                    if (ttScope && !val === ttScope.isOpen) {
                      toggleTooltipBind();
                    }
                  });
                }
                function prepObservers() {
                  observers.length = 0;
                  if (contentParse) {
                    observers.push(
                      scope.$watch(contentParse, function (val) {
                        ttScope.content = val;
                        if (!val && ttScope.isOpen) {
                          hide();
                        }
                      })
                    );
                    observers.push(
                      tooltipLinkedScope.$watch(function () {
                        if (!repositionScheduled) {
                          repositionScheduled = true;
                          tooltipLinkedScope.$$postDigest(function () {
                            repositionScheduled = false;
                            if (ttScope && ttScope.isOpen) {
                              positionTooltip();
                            }
                          });
                        }
                      })
                    );
                  } else {
                    observers.push(
                      attrs.$observe(ttType, function (val) {
                        ttScope.content = val;
                        if (!val && ttScope.isOpen) {
                          hide();
                        } else {
                          positionTooltip();
                        }
                      })
                    );
                  }
                  observers.push(
                    attrs.$observe(prefix + "Title", function (val) {
                      ttScope.title = val;
                      if (ttScope.isOpen) {
                        positionTooltip();
                      }
                    })
                  );
                  observers.push(
                    attrs.$observe(prefix + "Placement", function (val) {
                      ttScope.placement = val ? val : options.placement;
                      if (ttScope.isOpen) {
                        positionTooltip();
                      }
                    })
                  );
                }
                function unregisterObservers() {
                  if (observers.length) {
                    angular.forEach(observers, function (observer) {
                      observer();
                    });
                    observers.length = 0;
                  }
                }
                function bodyHideTooltipBind(e) {
                  if (!ttScope || !ttScope.isOpen || !tooltip) {
                    return;
                  }
                  if (
                    !element[0].contains(e.target) &&
                    !tooltip[0].contains(e.target)
                  ) {
                    hideTooltipBind();
                  }
                }
                var unregisterTriggers = function () {
                  triggers.show.forEach(function (trigger) {
                    if (trigger === "outsideClick") {
                      element.off("click", toggleTooltipBind);
                    } else {
                      element.off(trigger, showTooltipBind);
                      element.off(trigger, toggleTooltipBind);
                    }
                  });
                  triggers.hide.forEach(function (trigger) {
                    if (trigger === "outsideClick") {
                      $document.off("click", bodyHideTooltipBind);
                    } else {
                      element.off(trigger, hideTooltipBind);
                    }
                  });
                };
                function prepTriggers() {
                  var showTriggers = [],
                    hideTriggers = [];
                  var val = scope.$eval(attrs[prefix + "Trigger"]);
                  unregisterTriggers();
                  if (angular.isObject(val)) {
                    Object.keys(val).forEach(function (key) {
                      showTriggers.push(key);
                      hideTriggers.push(val[key]);
                    });
                    triggers = { show: showTriggers, hide: hideTriggers };
                  } else {
                    triggers = getTriggers(val);
                  }
                  if (triggers.show !== "none") {
                    triggers.show.forEach(function (trigger, idx) {
                      if (trigger === "outsideClick") {
                        element.on("click", toggleTooltipBind);
                        $document.on("click", bodyHideTooltipBind);
                      } else if (trigger === triggers.hide[idx]) {
                        element.on(trigger, toggleTooltipBind);
                      } else if (trigger) {
                        element.on(trigger, showTooltipBind);
                        element.on(triggers.hide[idx], hideTooltipBind);
                      }
                      element.on("keypress", function (e) {
                        if (e.which === 27) {
                          hideTooltipBind();
                        }
                      });
                    });
                  }
                }
                prepTriggers();
                var animation = scope.$eval(attrs[prefix + "Animation"]);
                ttScope.animation = angular.isDefined(animation)
                  ? !!animation
                  : options.animation;
                var appendToBodyVal;
                var appendKey = prefix + "AppendToBody";
                if (appendKey in attrs && attrs[appendKey] === undefined) {
                  appendToBodyVal = true;
                } else {
                  appendToBodyVal = scope.$eval(attrs[appendKey]);
                }
                appendToBody = angular.isDefined(appendToBodyVal)
                  ? appendToBodyVal
                  : appendToBody;
                scope.$on("$destroy", function onDestroyTooltip() {
                  unregisterTriggers();
                  removeTooltip();
                  ttScope = null;
                });
              };
            },
          };
        };
      },
    ];
  })
  .directive("uibTooltipTemplateTransclude", [
    "$animate",
    "$sce",
    "$compile",
    "$templateRequest",
    function ($animate, $sce, $compile, $templateRequest) {
      return {
        link: function (scope, elem, attrs) {
          var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);
          var changeCounter = 0,
            currentScope,
            previousElement,
            currentElement;
          var cleanupLastIncludeContent = function () {
            if (previousElement) {
              previousElement.remove();
              previousElement = null;
            }
            if (currentScope) {
              currentScope.$destroy();
              currentScope = null;
            }
            if (currentElement) {
              $animate.leave(currentElement).then(function () {
                previousElement = null;
              });
              previousElement = currentElement;
              currentElement = null;
            }
          };
          scope.$watch(
            $sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude),
            function (src) {
              var thisChangeId = ++changeCounter;
              if (src) {
                $templateRequest(src, true).then(
                  function (response) {
                    if (thisChangeId !== changeCounter) {
                      return;
                    }
                    var newScope = origScope.$new();
                    var template = response;
                    var clone = $compile(template)(newScope, function (clone) {
                      cleanupLastIncludeContent();
                      $animate.enter(clone, elem);
                    });
                    currentScope = newScope;
                    currentElement = clone;
                    currentScope.$emit("$includeContentLoaded", src);
                  },
                  function () {
                    if (thisChangeId === changeCounter) {
                      cleanupLastIncludeContent();
                      scope.$emit("$includeContentError", src);
                    }
                  }
                );
                scope.$emit("$includeContentRequested", src);
              } else {
                cleanupLastIncludeContent();
              }
            }
          );
          scope.$on("$destroy", cleanupLastIncludeContent);
        },
      };
    },
  ])
  .directive("uibTooltipClasses", [
    "$uibPosition",
    function ($uibPosition) {
      return {
        restrict: "A",
        link: function (scope, element, attrs) {
          if (scope.placement) {
            var position = $uibPosition.parsePlacement(scope.placement);
            element.addClass(position[0]);
          }
          if (scope.popupClass) {
            element.addClass(scope.popupClass);
          }
          if (scope.animation) {
            element.addClass(attrs.tooltipAnimationClass);
          }
        },
      };
    },
  ])
  .directive("uibTooltipPopup", function () {
    return {
      restrict: "A",
      scope: { content: "@" },
      templateUrl: "uib/template/tooltip/tooltip-popup.html",
    };
  })
  .directive("uibTooltip", [
    "$uibTooltip",
    function ($uibTooltip) {
      return $uibTooltip("uibTooltip", "tooltip", "mouseenter");
    },
  ])
  .directive("uibTooltipTemplatePopup", function () {
    return {
      restrict: "A",
      scope: { contentExp: "&", originScope: "&" },
      templateUrl: "uib/template/tooltip/tooltip-template-popup.html",
    };
  })
  .directive("uibTooltipTemplate", [
    "$uibTooltip",
    function ($uibTooltip) {
      return $uibTooltip("uibTooltipTemplate", "tooltip", "mouseenter", {
        useContentExp: true,
      });
    },
  ])
  .directive("uibTooltipHtmlPopup", function () {
    return {
      restrict: "A",
      scope: { contentExp: "&" },
      templateUrl: "uib/template/tooltip/tooltip-html-popup.html",
    };
  })
  .directive("uibTooltipHtml", [
    "$uibTooltip",
    function ($uibTooltip) {
      return $uibTooltip("uibTooltipHtml", "tooltip", "mouseenter", {
        useContentExp: true,
      });
    },
  ]);
angular
  .module("ui.bootstrap.popover", ["ui.bootstrap.tooltip"])
  .directive("uibPopoverTemplatePopup", function () {
    return {
      restrict: "A",
      scope: { uibTitle: "@", contentExp: "&", originScope: "&" },
      templateUrl: "uib/template/popover/popover-template.html",
    };
  })
  .directive("uibPopoverTemplate", [
    "$uibTooltip",
    function ($uibTooltip) {
      return $uibTooltip("uibPopoverTemplate", "popover", "click", {
        useContentExp: true,
      });
    },
  ])
  .directive("uibPopoverHtmlPopup", function () {
    return {
      restrict: "A",
      scope: { contentExp: "&", uibTitle: "@" },
      templateUrl: "uib/template/popover/popover-html.html",
    };
  })
  .directive("uibPopoverHtml", [
    "$uibTooltip",
    function ($uibTooltip) {
      return $uibTooltip("uibPopoverHtml", "popover", "click", {
        useContentExp: true,
      });
    },
  ])
  .directive("uibPopoverPopup", function () {
    return {
      restrict: "A",
      scope: { uibTitle: "@", content: "@" },
      templateUrl: "uib/template/popover/popover.html",
    };
  })
  .directive("uibPopover", [
    "$uibTooltip",
    function ($uibTooltip) {
      return $uibTooltip("uibPopover", "popover", "click");
    },
  ]);
angular
  .module("ui.bootstrap.progressbar", [])
  .constant("uibProgressConfig", { animate: true, max: 100 })
  .controller("UibProgressController", [
    "$scope",
    "$attrs",
    "uibProgressConfig",
    function ($scope, $attrs, progressConfig) {
      var self = this,
        animate = angular.isDefined($attrs.animate)
          ? $scope.$parent.$eval($attrs.animate)
          : progressConfig.animate;
      this.bars = [];
      $scope.max = getMaxOrDefault();
      this.addBar = function (bar, element, attrs) {
        if (!animate) {
          element.css({ transition: "none" });
        }
        this.bars.push(bar);
        bar.max = getMaxOrDefault();
        bar.title =
          attrs && angular.isDefined(attrs.title) ? attrs.title : "progressbar";
        bar.$watch("value", function (value) {
          bar.recalculatePercentage();
        });
        bar.recalculatePercentage = function () {
          var totalPercentage = self.bars.reduce(function (total, bar) {
            bar.percent = +((100 * bar.value) / bar.max).toFixed(2);
            return total + bar.percent;
          }, 0);
          if (totalPercentage > 100) {
            bar.percent -= totalPercentage - 100;
          }
        };
        bar.$on("$destroy", function () {
          element = null;
          self.removeBar(bar);
        });
      };
      this.removeBar = function (bar) {
        this.bars.splice(this.bars.indexOf(bar), 1);
        this.bars.forEach(function (bar) {
          bar.recalculatePercentage();
        });
      };
      $scope.$watch("maxParam", function (maxParam) {
        self.bars.forEach(function (bar) {
          bar.max = getMaxOrDefault();
          bar.recalculatePercentage();
        });
      });
      function getMaxOrDefault() {
        return angular.isDefined($scope.maxParam)
          ? $scope.maxParam
          : progressConfig.max;
      }
    },
  ])
  .directive("uibProgress", function () {
    return {
      replace: true,
      transclude: true,
      controller: "UibProgressController",
      require: "uibProgress",
      scope: { maxParam: "=?max" },
      templateUrl: "uib/template/progressbar/progress.html",
    };
  })
  .directive("uibBar", function () {
    return {
      replace: true,
      transclude: true,
      require: "^uibProgress",
      scope: { value: "=", type: "@" },
      templateUrl: "uib/template/progressbar/bar.html",
      link: function (scope, element, attrs, progressCtrl) {
        progressCtrl.addBar(scope, element, attrs);
      },
    };
  })
  .directive("uibProgressbar", function () {
    return {
      replace: true,
      transclude: true,
      controller: "UibProgressController",
      scope: { value: "=", maxParam: "=?max", type: "@" },
      templateUrl: "uib/template/progressbar/progressbar.html",
      link: function (scope, element, attrs, progressCtrl) {
        progressCtrl.addBar(scope, angular.element(element.children()[0]), {
          title: attrs.title,
        });
      },
    };
  });
angular
  .module("ui.bootstrap.rating", [])
  .constant("uibRatingConfig", {
    max: 5,
    stateOn: null,
    stateOff: null,
    enableReset: true,
    titles: ["one", "two", "three", "four", "five"],
  })
  .controller("UibRatingController", [
    "$scope",
    "$attrs",
    "uibRatingConfig",
    function ($scope, $attrs, ratingConfig) {
      var ngModelCtrl = { $setViewValue: angular.noop },
        self = this;
      this.init = function (ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_;
        ngModelCtrl.$render = this.render;
        ngModelCtrl.$formatters.push(function (value) {
          if (angular.isNumber(value) && value << 0 !== value) {
            value = Math.round(value);
          }
          return value;
        });
        this.stateOn = angular.isDefined($attrs.stateOn)
          ? $scope.$parent.$eval($attrs.stateOn)
          : ratingConfig.stateOn;
        this.stateOff = angular.isDefined($attrs.stateOff)
          ? $scope.$parent.$eval($attrs.stateOff)
          : ratingConfig.stateOff;
        this.enableReset = angular.isDefined($attrs.enableReset)
          ? $scope.$parent.$eval($attrs.enableReset)
          : ratingConfig.enableReset;
        var tmpTitles = angular.isDefined($attrs.titles)
          ? $scope.$parent.$eval($attrs.titles)
          : ratingConfig.titles;
        this.titles =
          angular.isArray(tmpTitles) && tmpTitles.length > 0
            ? tmpTitles
            : ratingConfig.titles;
        var ratingStates = angular.isDefined($attrs.ratingStates)
          ? $scope.$parent.$eval($attrs.ratingStates)
          : new Array(
              angular.isDefined($attrs.max)
                ? $scope.$parent.$eval($attrs.max)
                : ratingConfig.max
            );
        $scope.range = this.buildTemplateObjects(ratingStates);
      };
      this.buildTemplateObjects = function (states) {
        for (var i = 0, n = states.length; i < n; i++) {
          states[i] = angular.extend(
            { index: i },
            {
              stateOn: this.stateOn,
              stateOff: this.stateOff,
              title: this.getTitle(i),
            },
            states[i]
          );
        }
        return states;
      };
      this.getTitle = function (index) {
        if (index >= this.titles.length) {
          return index + 1;
        }
        return this.titles[index];
      };
      $scope.rate = function (value) {
        if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
          var newViewValue =
            self.enableReset && ngModelCtrl.$viewValue === value ? 0 : value;
          ngModelCtrl.$setViewValue(newViewValue);
          ngModelCtrl.$render();
        }
      };
      $scope.enter = function (value) {
        if (!$scope.readonly) {
          $scope.value = value;
        }
        $scope.onHover({ value: value });
      };
      $scope.reset = function () {
        $scope.value = ngModelCtrl.$viewValue;
        $scope.onLeave();
      };
      $scope.onKeydown = function (evt) {
        if (/(37|38|39|40)/.test(evt.which)) {
          evt.preventDefault();
          evt.stopPropagation();
          $scope.rate(
            $scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1)
          );
        }
      };
      this.render = function () {
        $scope.value = ngModelCtrl.$viewValue;
        $scope.title = self.getTitle($scope.value - 1);
      };
    },
  ])
  .directive("uibRating", function () {
    return {
      require: ["uibRating", "ngModel"],
      restrict: "A",
      scope: { readonly: "=?readOnly", onHover: "&", onLeave: "&" },
      controller: "UibRatingController",
      templateUrl: "uib/template/rating/rating.html",
      link: function (scope, element, attrs, ctrls) {
        var ratingCtrl = ctrls[0],
          ngModelCtrl = ctrls[1];
        ratingCtrl.init(ngModelCtrl);
      },
    };
  });
angular
  .module("ui.bootstrap.tabs", [])
  .controller("UibTabsetController", [
    "$scope",
    function ($scope) {
      var ctrl = this,
        oldIndex;
      ctrl.tabs = [];
      ctrl.select = function (index, evt) {
        if (!destroyed) {
          var previousIndex = findTabIndex(oldIndex);
          var previousSelected = ctrl.tabs[previousIndex];
          if (previousSelected) {
            previousSelected.tab.onDeselect({
              $event: evt,
              $selectedIndex: index,
            });
            if (evt && evt.isDefaultPrevented()) {
              return;
            }
            previousSelected.tab.active = false;
          }
          var selected = ctrl.tabs[index];
          if (selected) {
            selected.tab.onSelect({ $event: evt });
            selected.tab.active = true;
            ctrl.active = selected.index;
            oldIndex = selected.index;
          } else if (!selected && angular.isDefined(oldIndex)) {
            ctrl.active = null;
            oldIndex = null;
          }
        }
      };
      ctrl.addTab = function addTab(tab) {
        ctrl.tabs.push({ tab: tab, index: tab.index });
        ctrl.tabs.sort(function (t1, t2) {
          if (t1.index > t2.index) {
            return 1;
          }
          if (t1.index < t2.index) {
            return -1;
          }
          return 0;
        });
        if (
          tab.index === ctrl.active ||
          (!angular.isDefined(ctrl.active) && ctrl.tabs.length === 1)
        ) {
          var newActiveIndex = findTabIndex(tab.index);
          ctrl.select(newActiveIndex);
        }
      };
      ctrl.removeTab = function removeTab(tab) {
        var index;
        for (var i = 0; i < ctrl.tabs.length; i++) {
          if (ctrl.tabs[i].tab === tab) {
            index = i;
            break;
          }
        }
        if (ctrl.tabs[index].index === ctrl.active) {
          var newActiveTabIndex =
            index === ctrl.tabs.length - 1
              ? index - 1
              : index + (1 % ctrl.tabs.length);
          ctrl.select(newActiveTabIndex);
        }
        ctrl.tabs.splice(index, 1);
      };
      $scope.$watch("tabset.active", function (val) {
        if (angular.isDefined(val) && val !== oldIndex) {
          ctrl.select(findTabIndex(val));
        }
      });
      var destroyed;
      $scope.$on("$destroy", function () {
        destroyed = true;
      });
      function findTabIndex(index) {
        for (var i = 0; i < ctrl.tabs.length; i++) {
          if (ctrl.tabs[i].index === index) {
            return i;
          }
        }
      }
    },
  ])
  .directive("uibTabset", function () {
    return {
      transclude: true,
      replace: true,
      scope: {},
      bindToController: { active: "=?", type: "@" },
      controller: "UibTabsetController",
      controllerAs: "tabset",
      templateUrl: function (element, attrs) {
        return attrs.templateUrl || "uib/template/tabs/tabset.html";
      },
      link: function (scope, element, attrs) {
        scope.vertical = angular.isDefined(attrs.vertical)
          ? scope.$parent.$eval(attrs.vertical)
          : false;
        scope.justified = angular.isDefined(attrs.justified)
          ? scope.$parent.$eval(attrs.justified)
          : false;
      },
    };
  })
  .directive("uibTab", [
    "$parse",
    function ($parse) {
      return {
        require: "^uibTabset",
        replace: true,
        templateUrl: function (element, attrs) {
          return attrs.templateUrl || "uib/template/tabs/tab.html";
        },
        transclude: true,
        scope: {
          heading: "@",
          index: "=?",
          classes: "@?",
          onSelect: "&select",
          onDeselect: "&deselect",
        },
        controller: function () {},
        controllerAs: "tab",
        link: function (scope, elm, attrs, tabsetCtrl, transclude) {
          scope.disabled = false;
          if (attrs.disable) {
            scope.$parent.$watch($parse(attrs.disable), function (value) {
              scope.disabled = !!value;
            });
          }
          if (angular.isUndefined(attrs.index)) {
            if (tabsetCtrl.tabs && tabsetCtrl.tabs.length) {
              scope.index =
                Math.max.apply(
                  null,
                  tabsetCtrl.tabs.map(function (t) {
                    return t.index;
                  })
                ) + 1;
            } else {
              scope.index = 0;
            }
          }
          if (angular.isUndefined(attrs.classes)) {
            scope.classes = "";
          }
          scope.select = function (evt) {
            if (!scope.disabled) {
              var index;
              for (var i = 0; i < tabsetCtrl.tabs.length; i++) {
                if (tabsetCtrl.tabs[i].tab === scope) {
                  index = i;
                  break;
                }
              }
              tabsetCtrl.select(index, evt);
            }
          };
          tabsetCtrl.addTab(scope);
          scope.$on("$destroy", function () {
            tabsetCtrl.removeTab(scope);
          });
          scope.$transcludeFn = transclude;
        },
      };
    },
  ])
  .directive("uibTabHeadingTransclude", function () {
    return {
      restrict: "A",
      require: "^uibTab",
      link: function (scope, elm) {
        scope.$watch("headingElement", function updateHeadingElement(heading) {
          if (heading) {
            elm.html("");
            elm.append(heading);
          }
        });
      },
    };
  })
  .directive("uibTabContentTransclude", function () {
    return {
      restrict: "A",
      require: "^uibTabset",
      link: function (scope, elm, attrs) {
        var tab = scope.$eval(attrs.uibTabContentTransclude).tab;
        tab.$transcludeFn(tab.$parent, function (contents) {
          angular.forEach(contents, function (node) {
            if (isTabHeading(node)) {
              tab.headingElement = node;
            } else {
              elm.append(node);
            }
          });
        });
      },
    };
    function isTabHeading(node) {
      return (
        node.tagName &&
        (node.hasAttribute("uib-tab-heading") ||
          node.hasAttribute("data-uib-tab-heading") ||
          node.hasAttribute("x-uib-tab-heading") ||
          node.tagName.toLowerCase() === "uib-tab-heading" ||
          node.tagName.toLowerCase() === "data-uib-tab-heading" ||
          node.tagName.toLowerCase() === "x-uib-tab-heading" ||
          node.tagName.toLowerCase() === "uib:tab-heading")
      );
    }
  });
angular
  .module("ui.bootstrap.timepicker", [])
  .constant("uibTimepickerConfig", {
    hourStep: 1,
    minuteStep: 1,
    secondStep: 1,
    showMeridian: true,
    showSeconds: false,
    meridians: null,
    readonlyInput: false,
    mousewheel: true,
    arrowkeys: true,
    showSpinners: true,
    templateUrl: "uib/template/timepicker/timepicker.html",
  })
  .controller("UibTimepickerController", [
    "$scope",
    "$element",
    "$attrs",
    "$parse",
    "$log",
    "$locale",
    "uibTimepickerConfig",
    function (
      $scope,
      $element,
      $attrs,
      $parse,
      $log,
      $locale,
      timepickerConfig
    ) {
      var hoursModelCtrl, minutesModelCtrl, secondsModelCtrl;
      var selected = new Date(),
        watchers = [],
        ngModelCtrl = { $setViewValue: angular.noop },
        meridians = angular.isDefined($attrs.meridians)
          ? $scope.$parent.$eval($attrs.meridians)
          : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS,
        padHours = angular.isDefined($attrs.padHours)
          ? $scope.$parent.$eval($attrs.padHours)
          : true;
      $scope.tabindex = angular.isDefined($attrs.tabindex)
        ? $attrs.tabindex
        : 0;
      $element.removeAttr("tabindex");
      this.init = function (ngModelCtrl_, inputs) {
        ngModelCtrl = ngModelCtrl_;
        ngModelCtrl.$render = this.render;
        ngModelCtrl.$formatters.unshift(function (modelValue) {
          return modelValue ? new Date(modelValue) : null;
        });
        var hoursInputEl = inputs.eq(0),
          minutesInputEl = inputs.eq(1),
          secondsInputEl = inputs.eq(2);
        hoursModelCtrl = hoursInputEl.controller("ngModel");
        minutesModelCtrl = minutesInputEl.controller("ngModel");
        secondsModelCtrl = secondsInputEl.controller("ngModel");
        var mousewheel = angular.isDefined($attrs.mousewheel)
          ? $scope.$parent.$eval($attrs.mousewheel)
          : timepickerConfig.mousewheel;
        if (mousewheel) {
          this.setupMousewheelEvents(
            hoursInputEl,
            minutesInputEl,
            secondsInputEl
          );
        }
        var arrowkeys = angular.isDefined($attrs.arrowkeys)
          ? $scope.$parent.$eval($attrs.arrowkeys)
          : timepickerConfig.arrowkeys;
        if (arrowkeys) {
          this.setupArrowkeyEvents(
            hoursInputEl,
            minutesInputEl,
            secondsInputEl
          );
        }
        $scope.readonlyInput = angular.isDefined($attrs.readonlyInput)
          ? $scope.$parent.$eval($attrs.readonlyInput)
          : timepickerConfig.readonlyInput;
        this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);
      };
      var hourStep = timepickerConfig.hourStep;
      if ($attrs.hourStep) {
        watchers.push(
          $scope.$parent.$watch($parse($attrs.hourStep), function (value) {
            hourStep = +value;
          })
        );
      }
      var minuteStep = timepickerConfig.minuteStep;
      if ($attrs.minuteStep) {
        watchers.push(
          $scope.$parent.$watch($parse($attrs.minuteStep), function (value) {
            minuteStep = +value;
          })
        );
      }
      var min;
      watchers.push(
        $scope.$parent.$watch($parse($attrs.min), function (value) {
          var dt = new Date(value);
          min = isNaN(dt) ? undefined : dt;
        })
      );
      var max;
      watchers.push(
        $scope.$parent.$watch($parse($attrs.max), function (value) {
          var dt = new Date(value);
          max = isNaN(dt) ? undefined : dt;
        })
      );
      var disabled = false;
      if ($attrs.ngDisabled) {
        watchers.push(
          $scope.$parent.$watch($parse($attrs.ngDisabled), function (value) {
            disabled = value;
          })
        );
      }
      $scope.noIncrementHours = function () {
        var incrementedSelected = addMinutes(selected, hourStep * 60);
        return (
          disabled ||
          incrementedSelected > max ||
          (incrementedSelected < selected && incrementedSelected < min)
        );
      };
      $scope.noDecrementHours = function () {
        var decrementedSelected = addMinutes(selected, -hourStep * 60);
        return (
          disabled ||
          decrementedSelected < min ||
          (decrementedSelected > selected && decrementedSelected > max)
        );
      };
      $scope.noIncrementMinutes = function () {
        var incrementedSelected = addMinutes(selected, minuteStep);
        return (
          disabled ||
          incrementedSelected > max ||
          (incrementedSelected < selected && incrementedSelected < min)
        );
      };
      $scope.noDecrementMinutes = function () {
        var decrementedSelected = addMinutes(selected, -minuteStep);
        return (
          disabled ||
          decrementedSelected < min ||
          (decrementedSelected > selected && decrementedSelected > max)
        );
      };
      $scope.noIncrementSeconds = function () {
        var incrementedSelected = addSeconds(selected, secondStep);
        return (
          disabled ||
          incrementedSelected > max ||
          (incrementedSelected < selected && incrementedSelected < min)
        );
      };
      $scope.noDecrementSeconds = function () {
        var decrementedSelected = addSeconds(selected, -secondStep);
        return (
          disabled ||
          decrementedSelected < min ||
          (decrementedSelected > selected && decrementedSelected > max)
        );
      };
      $scope.noToggleMeridian = function () {
        if (selected.getHours() < 12) {
          return disabled || addMinutes(selected, 12 * 60) > max;
        }
        return disabled || addMinutes(selected, -12 * 60) < min;
      };
      var secondStep = timepickerConfig.secondStep;
      if ($attrs.secondStep) {
        watchers.push(
          $scope.$parent.$watch($parse($attrs.secondStep), function (value) {
            secondStep = +value;
          })
        );
      }
      $scope.showSeconds = timepickerConfig.showSeconds;
      if ($attrs.showSeconds) {
        watchers.push(
          $scope.$parent.$watch($parse($attrs.showSeconds), function (value) {
            $scope.showSeconds = !!value;
          })
        );
      }
      $scope.showMeridian = timepickerConfig.showMeridian;
      if ($attrs.showMeridian) {
        watchers.push(
          $scope.$parent.$watch($parse($attrs.showMeridian), function (value) {
            $scope.showMeridian = !!value;
            if (ngModelCtrl.$error.time) {
              var hours = getHoursFromTemplate(),
                minutes = getMinutesFromTemplate();
              if (angular.isDefined(hours) && angular.isDefined(minutes)) {
                selected.setHours(hours);
                refresh();
              }
            } else {
              updateTemplate();
            }
          })
        );
      }
      function getHoursFromTemplate() {
        var hours = +$scope.hours;
        var valid = $scope.showMeridian
          ? hours > 0 && hours < 13
          : hours >= 0 && hours < 24;
        if (!valid || $scope.hours === "") {
          return undefined;
        }
        if ($scope.showMeridian) {
          if (hours === 12) {
            hours = 0;
          }
          if ($scope.meridian === meridians[1]) {
            hours = hours + 12;
          }
        }
        return hours;
      }
      function getMinutesFromTemplate() {
        var minutes = +$scope.minutes;
        var valid = minutes >= 0 && minutes < 60;
        if (!valid || $scope.minutes === "") {
          return undefined;
        }
        return minutes;
      }
      function getSecondsFromTemplate() {
        var seconds = +$scope.seconds;
        return seconds >= 0 && seconds < 60 ? seconds : undefined;
      }
      function pad(value, noPad) {
        if (value === null) {
          return "";
        }
        return angular.isDefined(value) && value.toString().length < 2 && !noPad
          ? "0" + value
          : value.toString();
      }
      this.setupMousewheelEvents = function (
        hoursInputEl,
        minutesInputEl,
        secondsInputEl
      ) {
        var isScrollingUp = function (e) {
          if (e.originalEvent) {
            e = e.originalEvent;
          }
          var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
          return e.detail || delta > 0;
        };
        hoursInputEl.on("mousewheel wheel", function (e) {
          if (!disabled) {
            $scope.$apply(
              isScrollingUp(e)
                ? $scope.incrementHours()
                : $scope.decrementHours()
            );
          }
          e.preventDefault();
        });
        minutesInputEl.on("mousewheel wheel", function (e) {
          if (!disabled) {
            $scope.$apply(
              isScrollingUp(e)
                ? $scope.incrementMinutes()
                : $scope.decrementMinutes()
            );
          }
          e.preventDefault();
        });
        secondsInputEl.on("mousewheel wheel", function (e) {
          if (!disabled) {
            $scope.$apply(
              isScrollingUp(e)
                ? $scope.incrementSeconds()
                : $scope.decrementSeconds()
            );
          }
          e.preventDefault();
        });
      };
      this.setupArrowkeyEvents = function (
        hoursInputEl,
        minutesInputEl,
        secondsInputEl
      ) {
        hoursInputEl.on("keydown", function (e) {
          if (!disabled) {
            if (e.which === 38) {
              e.preventDefault();
              $scope.incrementHours();
              $scope.$apply();
            } else if (e.which === 40) {
              e.preventDefault();
              $scope.decrementHours();
              $scope.$apply();
            }
          }
        });
        minutesInputEl.on("keydown", function (e) {
          if (!disabled) {
            if (e.which === 38) {
              e.preventDefault();
              $scope.incrementMinutes();
              $scope.$apply();
            } else if (e.which === 40) {
              e.preventDefault();
              $scope.decrementMinutes();
              $scope.$apply();
            }
          }
        });
        secondsInputEl.on("keydown", function (e) {
          if (!disabled) {
            if (e.which === 38) {
              e.preventDefault();
              $scope.incrementSeconds();
              $scope.$apply();
            } else if (e.which === 40) {
              e.preventDefault();
              $scope.decrementSeconds();
              $scope.$apply();
            }
          }
        });
      };
      this.setupInputEvents = function (
        hoursInputEl,
        minutesInputEl,
        secondsInputEl
      ) {
        if ($scope.readonlyInput) {
          $scope.updateHours = angular.noop;
          $scope.updateMinutes = angular.noop;
          $scope.updateSeconds = angular.noop;
          return;
        }
        var invalidate = function (
          invalidHours,
          invalidMinutes,
          invalidSeconds
        ) {
          ngModelCtrl.$setViewValue(null);
          ngModelCtrl.$setValidity("time", false);
          if (angular.isDefined(invalidHours)) {
            $scope.invalidHours = invalidHours;
            if (hoursModelCtrl) {
              hoursModelCtrl.$setValidity("hours", false);
            }
          }
          if (angular.isDefined(invalidMinutes)) {
            $scope.invalidMinutes = invalidMinutes;
            if (minutesModelCtrl) {
              minutesModelCtrl.$setValidity("minutes", false);
            }
          }
          if (angular.isDefined(invalidSeconds)) {
            $scope.invalidSeconds = invalidSeconds;
            if (secondsModelCtrl) {
              secondsModelCtrl.$setValidity("seconds", false);
            }
          }
        };
        $scope.updateHours = function () {
          var hours = getHoursFromTemplate(),
            minutes = getMinutesFromTemplate();
          ngModelCtrl.$setDirty();
          if (angular.isDefined(hours) && angular.isDefined(minutes)) {
            selected.setHours(hours);
            selected.setMinutes(minutes);
            if (selected < min || selected > max) {
              invalidate(true);
            } else {
              refresh("h");
            }
          } else {
            invalidate(true);
          }
        };
        hoursInputEl.on("blur", function (e) {
          ngModelCtrl.$setTouched();
          if (modelIsEmpty()) {
            makeValid();
          } else if ($scope.hours === null || $scope.hours === "") {
            invalidate(true);
          } else if (!$scope.invalidHours && $scope.hours < 10) {
            $scope.$apply(function () {
              $scope.hours = pad($scope.hours, !padHours);
            });
          }
        });
        $scope.updateMinutes = function () {
          var minutes = getMinutesFromTemplate(),
            hours = getHoursFromTemplate();
          ngModelCtrl.$setDirty();
          if (angular.isDefined(minutes) && angular.isDefined(hours)) {
            selected.setHours(hours);
            selected.setMinutes(minutes);
            if (selected < min || selected > max) {
              invalidate(undefined, true);
            } else {
              refresh("m");
            }
          } else {
            invalidate(undefined, true);
          }
        };
        minutesInputEl.on("blur", function (e) {
          ngModelCtrl.$setTouched();
          if (modelIsEmpty()) {
            makeValid();
          } else if ($scope.minutes === null) {
            invalidate(undefined, true);
          } else if (!$scope.invalidMinutes && $scope.minutes < 10) {
            $scope.$apply(function () {
              $scope.minutes = pad($scope.minutes);
            });
          }
        });
        $scope.updateSeconds = function () {
          var seconds = getSecondsFromTemplate();
          ngModelCtrl.$setDirty();
          if (angular.isDefined(seconds)) {
            selected.setSeconds(seconds);
            refresh("s");
          } else {
            invalidate(undefined, undefined, true);
          }
        };
        secondsInputEl.on("blur", function (e) {
          if (modelIsEmpty()) {
            makeValid();
          } else if (!$scope.invalidSeconds && $scope.seconds < 10) {
            $scope.$apply(function () {
              $scope.seconds = pad($scope.seconds);
            });
          }
        });
      };
      this.render = function () {
        var date = ngModelCtrl.$viewValue;
        if (isNaN(date)) {
          ngModelCtrl.$setValidity("time", false);
          $log.error(
            'Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.'
          );
        } else {
          if (date) {
            selected = date;
          }
          if (selected < min || selected > max) {
            ngModelCtrl.$setValidity("time", false);
            $scope.invalidHours = true;
            $scope.invalidMinutes = true;
          } else {
            makeValid();
          }
          updateTemplate();
        }
      };
      function refresh(keyboardChange) {
        makeValid();
        ngModelCtrl.$setViewValue(new Date(selected));
        updateTemplate(keyboardChange);
      }
      function makeValid() {
        if (hoursModelCtrl) {
          hoursModelCtrl.$setValidity("hours", true);
        }
        if (minutesModelCtrl) {
          minutesModelCtrl.$setValidity("minutes", true);
        }
        if (secondsModelCtrl) {
          secondsModelCtrl.$setValidity("seconds", true);
        }
        ngModelCtrl.$setValidity("time", true);
        $scope.invalidHours = false;
        $scope.invalidMinutes = false;
        $scope.invalidSeconds = false;
      }
      function updateTemplate(keyboardChange) {
        if (!ngModelCtrl.$modelValue) {
          $scope.hours = null;
          $scope.minutes = null;
          $scope.seconds = null;
          $scope.meridian = meridians[0];
        } else {
          var hours = selected.getHours(),
            minutes = selected.getMinutes(),
            seconds = selected.getSeconds();
          if ($scope.showMeridian) {
            hours = hours === 0 || hours === 12 ? 12 : hours % 12;
          }
          $scope.hours = keyboardChange === "h" ? hours : pad(hours, !padHours);
          if (keyboardChange !== "m") {
            $scope.minutes = pad(minutes);
          }
          $scope.meridian =
            selected.getHours() < 12 ? meridians[0] : meridians[1];
          if (keyboardChange !== "s") {
            $scope.seconds = pad(seconds);
          }
          $scope.meridian =
            selected.getHours() < 12 ? meridians[0] : meridians[1];
        }
      }
      function addSecondsToSelected(seconds) {
        selected = addSeconds(selected, seconds);
        refresh();
      }
      function addMinutes(selected, minutes) {
        return addSeconds(selected, minutes * 60);
      }
      function addSeconds(date, seconds) {
        var dt = new Date(date.getTime() + seconds * 1e3);
        var newDate = new Date(date);
        newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds());
        return newDate;
      }
      function modelIsEmpty() {
        return (
          ($scope.hours === null || $scope.hours === "") &&
          ($scope.minutes === null || $scope.minutes === "") &&
          (!$scope.showSeconds ||
            ($scope.showSeconds &&
              ($scope.seconds === null || $scope.seconds === "")))
        );
      }
      $scope.showSpinners = angular.isDefined($attrs.showSpinners)
        ? $scope.$parent.$eval($attrs.showSpinners)
        : timepickerConfig.showSpinners;
      $scope.incrementHours = function () {
        if (!$scope.noIncrementHours()) {
          addSecondsToSelected(hourStep * 60 * 60);
        }
      };
      $scope.decrementHours = function () {
        if (!$scope.noDecrementHours()) {
          addSecondsToSelected(-hourStep * 60 * 60);
        }
      };
      $scope.incrementMinutes = function () {
        if (!$scope.noIncrementMinutes()) {
          addSecondsToSelected(minuteStep * 60);
        }
      };
      $scope.decrementMinutes = function () {
        if (!$scope.noDecrementMinutes()) {
          addSecondsToSelected(-minuteStep * 60);
        }
      };
      $scope.incrementSeconds = function () {
        if (!$scope.noIncrementSeconds()) {
          addSecondsToSelected(secondStep);
        }
      };
      $scope.decrementSeconds = function () {
        if (!$scope.noDecrementSeconds()) {
          addSecondsToSelected(-secondStep);
        }
      };
      $scope.toggleMeridian = function () {
        var minutes = getMinutesFromTemplate(),
          hours = getHoursFromTemplate();
        if (!$scope.noToggleMeridian()) {
          if (angular.isDefined(minutes) && angular.isDefined(hours)) {
            addSecondsToSelected(
              12 * 60 * (selected.getHours() < 12 ? 60 : -60)
            );
          } else {
            $scope.meridian =
              $scope.meridian === meridians[0] ? meridians[1] : meridians[0];
          }
        }
      };
      $scope.blur = function () {
        ngModelCtrl.$setTouched();
      };
      $scope.$on("$destroy", function () {
        while (watchers.length) {
          watchers.shift()();
        }
      });
    },
  ])
  .directive("uibTimepicker", [
    "uibTimepickerConfig",
    function (uibTimepickerConfig) {
      return {
        require: ["uibTimepicker", "?^ngModel"],
        restrict: "A",
        controller: "UibTimepickerController",
        controllerAs: "timepicker",
        scope: {},
        templateUrl: function (element, attrs) {
          return attrs.templateUrl || uibTimepickerConfig.templateUrl;
        },
        link: function (scope, element, attrs, ctrls) {
          var timepickerCtrl = ctrls[0],
            ngModelCtrl = ctrls[1];
          if (ngModelCtrl) {
            timepickerCtrl.init(ngModelCtrl, element.find("input"));
          }
        },
      };
    },
  ]);
angular
  .module("ui.bootstrap.typeahead", [
    "ui.bootstrap.debounce",
    "ui.bootstrap.position",
  ])
  .factory("uibTypeaheadParser", [
    "$parse",
    function ($parse) {
      var TYPEAHEAD_REGEXP =
        /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
      return {
        parse: function (input) {
          var match = input.match(TYPEAHEAD_REGEXP);
          if (!match) {
            throw new Error(
              'Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' +
                ' but got "' +
                input +
                '".'
            );
          }
          return {
            itemName: match[3],
            source: $parse(match[4]),
            viewMapper: $parse(match[2] || match[1]),
            modelMapper: $parse(match[1]),
          };
        },
      };
    },
  ])
  .controller("UibTypeaheadController", [
    "$scope",
    "$element",
    "$attrs",
    "$compile",
    "$parse",
    "$q",
    "$timeout",
    "$document",
    "$window",
    "$rootScope",
    "$$debounce",
    "$uibPosition",
    "uibTypeaheadParser",
    function (
      originalScope,
      element,
      attrs,
      $compile,
      $parse,
      $q,
      $timeout,
      $document,
      $window,
      $rootScope,
      $$debounce,
      $position,
      typeaheadParser
    ) {
      var HOT_KEYS = [9, 13, 27, 38, 40];
      var eventDebounceTime = 200;
      var modelCtrl, ngModelOptions;
      var minLength = originalScope.$eval(attrs.typeaheadMinLength);
      if (!minLength && minLength !== 0) {
        minLength = 1;
      }
      originalScope.$watch(attrs.typeaheadMinLength, function (newVal) {
        minLength = !newVal && newVal !== 0 ? 1 : newVal;
      });
      var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;
      var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
      originalScope.$watch(attrs.typeaheadEditable, function (newVal) {
        isEditable = newVal !== false;
      });
      var isLoadingSetter =
        $parse(attrs.typeaheadLoading).assign || angular.noop;
      var isSelectEvent = attrs.typeaheadShouldSelect
        ? $parse(attrs.typeaheadShouldSelect)
        : function (scope, vals) {
            var evt = vals.$event;
            return evt.which === 13 || evt.which === 9;
          };
      var onSelectCallback = $parse(attrs.typeaheadOnSelect);
      var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur)
        ? originalScope.$eval(attrs.typeaheadSelectOnBlur)
        : false;
      var isNoResultsSetter =
        $parse(attrs.typeaheadNoResults).assign || angular.noop;
      var inputFormatter = attrs.typeaheadInputFormatter
        ? $parse(attrs.typeaheadInputFormatter)
        : undefined;
      var appendToBody = attrs.typeaheadAppendToBody
        ? originalScope.$eval(attrs.typeaheadAppendToBody)
        : false;
      var appendTo = attrs.typeaheadAppendTo
        ? originalScope.$eval(attrs.typeaheadAppendTo)
        : null;
      var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;
      var selectOnExact = attrs.typeaheadSelectOnExact
        ? originalScope.$eval(attrs.typeaheadSelectOnExact)
        : false;
      var isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop;
      var showHint = originalScope.$eval(attrs.typeaheadShowHint) || false;
      var parsedModel = $parse(attrs.ngModel);
      var invokeModelSetter = $parse(attrs.ngModel + "($$$p)");
      var $setModelValue = function (scope, newValue) {
        if (
          angular.isFunction(parsedModel(originalScope)) &&
          ngModelOptions &&
          ngModelOptions.$options &&
          ngModelOptions.$options.getterSetter
        ) {
          return invokeModelSetter(scope, { $$$p: newValue });
        }
        return parsedModel.assign(scope, newValue);
      };
      var parserResult = typeaheadParser.parse(attrs.uibTypeahead);
      var hasFocus;
      var selected;
      var scope = originalScope.$new();
      var offDestroy = originalScope.$on("$destroy", function () {
        scope.$destroy();
      });
      scope.$on("$destroy", offDestroy);
      var popupId =
        "typeahead-" + scope.$id + "-" + Math.floor(Math.random() * 1e4);
      element.attr({
        "aria-autocomplete": "list",
        "aria-expanded": false,
        "aria-owns": popupId,
      });
      var inputsContainer, hintInputElem;
      if (showHint) {
        inputsContainer = angular.element("<div></div>");
        inputsContainer.css("position", "relative");
        element.after(inputsContainer);
        hintInputElem = element.clone();
        hintInputElem.attr("placeholder", "");
        hintInputElem.attr("tabindex", "-1");
        hintInputElem.val("");
        hintInputElem.css({
          position: "absolute",
          top: "0px",
          left: "0px",
          "border-color": "transparent",
          "box-shadow": "none",
          opacity: 1,
          background:
            "none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)",
          color: "#999",
        });
        element.css({
          position: "relative",
          "vertical-align": "top",
          "background-color": "transparent",
        });
        if (hintInputElem.attr("id")) {
          hintInputElem.removeAttr("id");
        }
        inputsContainer.append(hintInputElem);
        hintInputElem.after(element);
      }
      var popUpEl = angular.element("<div uib-typeahead-popup></div>");
      popUpEl.attr({
        id: popupId,
        matches: "matches",
        active: "activeIdx",
        select: "select(activeIdx, evt)",
        "move-in-progress": "moveInProgress",
        query: "query",
        position: "position",
        "assign-is-open": "assignIsOpen(isOpen)",
        debounce: "debounceUpdate",
      });
      if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
        popUpEl.attr("template-url", attrs.typeaheadTemplateUrl);
      }
      if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
        popUpEl.attr("popup-template-url", attrs.typeaheadPopupTemplateUrl);
      }
      var resetHint = function () {
        if (showHint) {
          hintInputElem.val("");
        }
      };
      var resetMatches = function () {
        scope.matches = [];
        scope.activeIdx = -1;
        element.attr("aria-expanded", false);
        resetHint();
      };
      var getMatchId = function (index) {
        return popupId + "-option-" + index;
      };
      scope.$watch("activeIdx", function (index) {
        if (index < 0) {
          element.removeAttr("aria-activedescendant");
        } else {
          element.attr("aria-activedescendant", getMatchId(index));
        }
      });
      var inputIsExactMatch = function (inputValue, index) {
        if (scope.matches.length > index && inputValue) {
          return (
            inputValue.toUpperCase() ===
            scope.matches[index].label.toUpperCase()
          );
        }
        return false;
      };
      var getMatchesAsync = function (inputValue, evt) {
        var locals = { $viewValue: inputValue };
        isLoadingSetter(originalScope, true);
        isNoResultsSetter(originalScope, false);
        $q.when(parserResult.source(originalScope, locals)).then(
          function (matches) {
            var onCurrentRequest = inputValue === modelCtrl.$viewValue;
            if (onCurrentRequest && hasFocus) {
              if (matches && matches.length > 0) {
                scope.activeIdx = focusFirst ? 0 : -1;
                isNoResultsSetter(originalScope, false);
                scope.matches.length = 0;
                for (var i = 0; i < matches.length; i++) {
                  locals[parserResult.itemName] = matches[i];
                  scope.matches.push({
                    id: getMatchId(i),
                    label: parserResult.viewMapper(scope, locals),
                    model: matches[i],
                  });
                }
                scope.query = inputValue;
                recalculatePosition();
                element.attr("aria-expanded", true);
                if (
                  selectOnExact &&
                  scope.matches.length === 1 &&
                  inputIsExactMatch(inputValue, 0)
                ) {
                  if (
                    angular.isNumber(scope.debounceUpdate) ||
                    angular.isObject(scope.debounceUpdate)
                  ) {
                    $$debounce(
                      function () {
                        scope.select(0, evt);
                      },
                      angular.isNumber(scope.debounceUpdate)
                        ? scope.debounceUpdate
                        : scope.debounceUpdate["default"]
                    );
                  } else {
                    scope.select(0, evt);
                  }
                }
                if (showHint) {
                  var firstLabel = scope.matches[0].label;
                  if (
                    angular.isString(inputValue) &&
                    inputValue.length > 0 &&
                    firstLabel.slice(0, inputValue.length).toUpperCase() ===
                      inputValue.toUpperCase()
                  ) {
                    hintInputElem.val(
                      inputValue + firstLabel.slice(inputValue.length)
                    );
                  } else {
                    hintInputElem.val("");
                  }
                }
              } else {
                resetMatches();
                isNoResultsSetter(originalScope, true);
              }
            }
            if (onCurrentRequest) {
              isLoadingSetter(originalScope, false);
            }
          },
          function () {
            resetMatches();
            isLoadingSetter(originalScope, false);
            isNoResultsSetter(originalScope, true);
          }
        );
      };
      if (appendToBody) {
        angular.element($window).on("resize", fireRecalculating);
        $document.find("body").on("scroll", fireRecalculating);
      }
      var debouncedRecalculate = $$debounce(function () {
        if (scope.matches.length) {
          recalculatePosition();
        }
        scope.moveInProgress = false;
      }, eventDebounceTime);
      scope.moveInProgress = false;
      function fireRecalculating() {
        if (!scope.moveInProgress) {
          scope.moveInProgress = true;
          scope.$digest();
        }
        debouncedRecalculate();
      }
      function recalculatePosition() {
        scope.position = appendToBody
          ? $position.offset(element)
          : $position.position(element);
        scope.position.top += element.prop("offsetHeight");
      }
      scope.query = undefined;
      var timeoutPromise;
      var scheduleSearchWithTimeout = function (inputValue) {
        timeoutPromise = $timeout(function () {
          getMatchesAsync(inputValue);
        }, waitTime);
      };
      var cancelPreviousTimeout = function () {
        if (timeoutPromise) {
          $timeout.cancel(timeoutPromise);
        }
      };
      resetMatches();
      scope.assignIsOpen = function (isOpen) {
        isOpenSetter(originalScope, isOpen);
      };
      scope.select = function (activeIdx, evt) {
        var locals = {};
        var model, item;
        selected = true;
        locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
        model = parserResult.modelMapper(originalScope, locals);
        $setModelValue(originalScope, model);
        modelCtrl.$setValidity("editable", true);
        modelCtrl.$setValidity("parse", true);
        onSelectCallback(originalScope, {
          $item: item,
          $model: model,
          $label: parserResult.viewMapper(originalScope, locals),
          $event: evt,
        });
        resetMatches();
        if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
          $timeout(
            function () {
              element[0].focus();
            },
            0,
            false
          );
        }
      };
      element.on("keydown", function (evt) {
        if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
          return;
        }
        var shouldSelect = isSelectEvent(originalScope, { $event: evt });
        if (
          (scope.activeIdx === -1 && shouldSelect) ||
          (evt.which === 9 && !!evt.shiftKey)
        ) {
          resetMatches();
          scope.$digest();
          return;
        }
        evt.preventDefault();
        var target;
        switch (evt.which) {
          case 27:
            evt.stopPropagation();
            resetMatches();
            originalScope.$digest();
            break;
          case 38:
            scope.activeIdx =
              (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) -
              1;
            scope.$digest();
            target = popUpEl[0].querySelectorAll(".uib-typeahead-match")[
              scope.activeIdx
            ];
            target.parentNode.scrollTop = target.offsetTop;
            break;
          case 40:
            scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
            scope.$digest();
            target = popUpEl[0].querySelectorAll(".uib-typeahead-match")[
              scope.activeIdx
            ];
            target.parentNode.scrollTop = target.offsetTop;
            break;
          default:
            if (shouldSelect) {
              scope.$apply(function () {
                if (
                  angular.isNumber(scope.debounceUpdate) ||
                  angular.isObject(scope.debounceUpdate)
                ) {
                  $$debounce(
                    function () {
                      scope.select(scope.activeIdx, evt);
                    },
                    angular.isNumber(scope.debounceUpdate)
                      ? scope.debounceUpdate
                      : scope.debounceUpdate["default"]
                  );
                } else {
                  scope.select(scope.activeIdx, evt);
                }
              });
            }
        }
      });
      element.on("focus", function (evt) {
        hasFocus = true;
        if (minLength === 0 && !modelCtrl.$viewValue) {
          $timeout(function () {
            getMatchesAsync(modelCtrl.$viewValue, evt);
          }, 0);
        }
      });
      element.on("blur", function (evt) {
        if (
          isSelectOnBlur &&
          scope.matches.length &&
          scope.activeIdx !== -1 &&
          !selected
        ) {
          selected = true;
          scope.$apply(function () {
            if (
              angular.isObject(scope.debounceUpdate) &&
              angular.isNumber(scope.debounceUpdate.blur)
            ) {
              $$debounce(function () {
                scope.select(scope.activeIdx, evt);
              }, scope.debounceUpdate.blur);
            } else {
              scope.select(scope.activeIdx, evt);
            }
          });
        }
        if (!isEditable && modelCtrl.$error.editable) {
          modelCtrl.$setViewValue();
          scope.$apply(function () {
            modelCtrl.$setValidity("editable", true);
            modelCtrl.$setValidity("parse", true);
          });
          element.val("");
        }
        hasFocus = false;
        selected = false;
      });
      var dismissClickHandler = function (evt) {
        if (
          element[0] !== evt.target &&
          evt.which !== 3 &&
          scope.matches.length !== 0
        ) {
          resetMatches();
          if (!$rootScope.$$phase) {
            originalScope.$digest();
          }
        }
      };
      $document.on("click", dismissClickHandler);
      originalScope.$on("$destroy", function () {
        $document.off("click", dismissClickHandler);
        if (appendToBody || appendTo) {
          $popup.remove();
        }
        if (appendToBody) {
          angular.element($window).off("resize", fireRecalculating);
          $document.find("body").off("scroll", fireRecalculating);
        }
        popUpEl.remove();
        if (showHint) {
          inputsContainer.remove();
        }
      });
      var $popup = $compile(popUpEl)(scope);
      if (appendToBody) {
        $document.find("body").append($popup);
      } else if (appendTo) {
        angular.element(appendTo).eq(0).append($popup);
      } else {
        element.after($popup);
      }
      this.init = function (_modelCtrl, _ngModelOptions) {
        modelCtrl = _modelCtrl;
        ngModelOptions = _ngModelOptions;
        scope.debounceUpdate =
          modelCtrl.$options &&
          $parse(modelCtrl.$options.debounce)(originalScope);
        modelCtrl.$parsers.unshift(function (inputValue) {
          hasFocus = true;
          if (
            minLength === 0 ||
            (inputValue && inputValue.length >= minLength)
          ) {
            if (waitTime > 0) {
              cancelPreviousTimeout();
              scheduleSearchWithTimeout(inputValue);
            } else {
              getMatchesAsync(inputValue);
            }
          } else {
            isLoadingSetter(originalScope, false);
            cancelPreviousTimeout();
            resetMatches();
          }
          if (isEditable) {
            return inputValue;
          }
          if (!inputValue) {
            modelCtrl.$setValidity("editable", true);
            return null;
          }
          modelCtrl.$setValidity("editable", false);
          return undefined;
        });
        modelCtrl.$formatters.push(function (modelValue) {
          var candidateViewValue, emptyViewValue;
          var locals = {};
          if (!isEditable) {
            modelCtrl.$setValidity("editable", true);
          }
          if (inputFormatter) {
            locals.$model = modelValue;
            return inputFormatter(originalScope, locals);
          }
          locals[parserResult.itemName] = modelValue;
          candidateViewValue = parserResult.viewMapper(originalScope, locals);
          locals[parserResult.itemName] = undefined;
          emptyViewValue = parserResult.viewMapper(originalScope, locals);
          return candidateViewValue !== emptyViewValue
            ? candidateViewValue
            : modelValue;
        });
      };
    },
  ])
  .directive("uibTypeahead", function () {
    return {
      controller: "UibTypeaheadController",
      require: ["ngModel", "^?ngModelOptions", "uibTypeahead"],
      link: function (originalScope, element, attrs, ctrls) {
        ctrls[2].init(ctrls[0], ctrls[1]);
      },
    };
  })
  .directive("uibTypeaheadPopup", [
    "$$debounce",
    function ($$debounce) {
      return {
        scope: {
          matches: "=",
          query: "=",
          active: "=",
          position: "&",
          moveInProgress: "=",
          select: "&",
          assignIsOpen: "&",
          debounce: "&",
        },
        replace: true,
        templateUrl: function (element, attrs) {
          return (
            attrs.popupTemplateUrl ||
            "uib/template/typeahead/typeahead-popup.html"
          );
        },
        link: function (scope, element, attrs) {
          scope.templateUrl = attrs.templateUrl;
          scope.isOpen = function () {
            var isDropdownOpen = scope.matches.length > 0;
            scope.assignIsOpen({ isOpen: isDropdownOpen });
            return isDropdownOpen;
          };
          scope.isActive = function (matchIdx) {
            return scope.active === matchIdx;
          };
          scope.selectActive = function (matchIdx) {
            scope.active = matchIdx;
          };
          scope.selectMatch = function (activeIdx, evt) {
            var debounce = scope.debounce();
            if (angular.isNumber(debounce) || angular.isObject(debounce)) {
              $$debounce(
                function () {
                  scope.select({ activeIdx: activeIdx, evt: evt });
                },
                angular.isNumber(debounce) ? debounce : debounce["default"]
              );
            } else {
              scope.select({ activeIdx: activeIdx, evt: evt });
            }
          };
        },
      };
    },
  ])
  .directive("uibTypeaheadMatch", [
    "$templateRequest",
    "$compile",
    "$parse",
    function ($templateRequest, $compile, $parse) {
      return {
        scope: { index: "=", match: "=", query: "=" },
        link: function (scope, element, attrs) {
          var tplUrl =
            $parse(attrs.templateUrl)(scope.$parent) ||
            "uib/template/typeahead/typeahead-match.html";
          $templateRequest(tplUrl).then(function (tplContent) {
            var tplEl = angular.element(tplContent.trim());
            element.replaceWith(tplEl);
            $compile(tplEl)(scope);
          });
        },
      };
    },
  ])
  .filter("uibTypeaheadHighlight", [
    "$sce",
    "$injector",
    "$log",
    function ($sce, $injector, $log) {
      var isSanitizePresent;
      isSanitizePresent = $injector.has("$sanitize");
      function escapeRegexp(queryToEscape) {
        return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
      }
      function containsHtml(matchItem) {
        return /<.*>/g.test(matchItem);
      }
      return function (matchItem, query) {
        if (!isSanitizePresent && containsHtml(matchItem)) {
          $log.warn("Unsafe use of typeahead please use ngSanitize");
        }
        matchItem = query
          ? ("" + matchItem).replace(
              new RegExp(escapeRegexp(query), "gi"),
              "<strong>$&</strong>"
            )
          : matchItem;
        if (!isSanitizePresent) {
          matchItem = $sce.trustAsHtml(matchItem);
        }
        return matchItem;
      };
    },
  ]);
angular.module("uib/template/accordion/accordion-group.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "uib/template/accordion/accordion-group.html",
      '<div role="tab" id="{{::headingId}}" aria-selected="{{isOpen}}" class="panel-heading" ng-keypress="toggleOpen($event)">\n' +
        '  <h4 class="panel-title">\n' +
        '    <a role="button" data-toggle="collapse" href aria-expanded="{{isOpen}}" aria-controls="{{::panelId}}" tabindex="0" class="accordion-toggle" ng-click="toggleOpen()" uib-accordion-transclude="heading" ng-disabled="isDisabled" uib-tabindex-toggle><span uib-accordion-header ng-class="{\'text-muted\': isDisabled}">{{heading}}</span></a>\n' +
        "  </h4>\n" +
        "</div>\n" +
        '<div id="{{::panelId}}" aria-labelledby="{{::headingId}}" aria-hidden="{{!isOpen}}" role="tabpanel" class="panel-collapse collapse" uib-collapse="!isOpen">\n' +
        '  <div class="panel-body" ng-transclude></div>\n' +
        "</div>\n" +
        ""
    );
  },
]);
angular.module("uib/template/accordion/accordion.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "uib/template/accordion/accordion.html",
      '<div role="tablist" class="panel-group" ng-transclude></div>'
    );
  },
]);
angular.module("uib/template/alert/alert.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "uib/template/alert/alert.html",
      '<button ng-show="closeable" type="button" class="close" ng-click="close({$event: $event})">\n' +
        '  <span aria-hidden="true">&times;</span>\n' +
        '  <span class="sr-only">Close</span>\n' +
        "</button>\n" +
        "<div ng-transclude></div>\n" +
        ""
    );
  },
]);
angular.module("uib/template/carousel/carousel.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "uib/template/carousel/carousel.html",
      '<div class="carousel-inner" ng-transclude></div>\n' +
        '<a role="button" href class="left carousel-control" ng-click="prev()" ng-class="{ disabled: isPrevDisabled() }" ng-show="slides.length > 1">\n' +
        '  <span aria-hidden="true" class="glyphicon glyphicon-chevron-left"></span>\n' +
        '  <span class="sr-only">previous</span>\n' +
        "</a>\n" +
        '<a role="button" href class="right carousel-control" ng-click="next()" ng-class="{ disabled: isNextDisabled() }" ng-show="slides.length > 1">\n' +
        '  <span aria-hidden="true" class="glyphicon glyphicon-chevron-right"></span>\n' +
        '  <span class="sr-only">next</span>\n' +
        "</a>\n" +
        '<ol class="carousel-indicators" ng-show="slides.length > 1">\n' +
        '  <li ng-repeat="slide in slides | orderBy:indexOfSlide track by $index" ng-class="{ active: isActive(slide) }" ng-click="select(slide)">\n' +
        '    <span class="sr-only">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if="isActive(slide)">, currently active</span></span>\n' +
        "  </li>\n" +
        "</ol>\n" +
        ""
    );
  },
]);
angular.module("uib/template/carousel/slide.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "uib/template/carousel/slide.html",
      '<div class="text-center" ng-transclude></div>\n' + ""
    );
  },
]);
angular.module("uib/template/datepicker/datepicker.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "uib/template/datepicker/datepicker.html",
      '<div ng-switch="datepickerMode">\n' +
        '  <div uib-daypicker ng-switch-when="day" tabindex="0" class="uib-daypicker"></div>\n' +
        '  <div uib-monthpicker ng-switch-when="month" tabindex="0" class="uib-monthpicker"></div>\n' +
        '  <div uib-yearpicker ng-switch-when="year" tabindex="0" class="uib-yearpicker"></div>\n' +
        "</div>\n" +
        ""
    );
  },
]);
angular.module("uib/template/datepicker/day.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "uib/template/datepicker/day.html",
      '<table role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n' +
        "  <thead>\n" +
        "    <tr>\n" +
        '      <th><button type="button" class="btn btn-default btn-sm pull-left uib-left" ng-click="move(-1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-left"></i><span class="sr-only">previous</span></button></th>\n' +
        '      <th colspan="{{::5 + showWeeks}}"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm uib-title" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1"><strong>{{title}}</strong></button></th>\n' +
        '      <th><button type="button" class="btn btn-default btn-sm pull-right uib-right" ng-click="move(1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-right"></i><span class="sr-only">next</span></button></th>\n' +
        "    </tr>\n" +
        "    <tr>\n" +
        '      <th ng-if="showWeeks" class="text-center"></th>\n' +
        '      <th ng-repeat="label in ::labels track by $index" class="text-center"><small aria-label="{{::label.full}}">{{::label.abbr}}</small></th>\n' +
        "    </tr>\n" +
        "  </thead>\n" +
        "  <tbody>\n" +
        '    <tr class="uib-weeks" ng-repeat="row in rows track by $index" role="row">\n' +
        '      <td ng-if="showWeeks" class="text-center h6"><em>{{ weekNumbers[$index] }}</em></td>\n' +
        '      <td ng-repeat="dt in row" class="uib-day text-center" role="gridcell"\n' +
        '        id="{{::dt.uid}}"\n' +
        '        ng-class="::dt.customClass">\n' +
        '        <button type="button" class="btn btn-default btn-sm"\n' +
        '          uib-is-class="\n' +
        "            'btn-info' for selectedDt,\n" +
        "            'active' for activeDt\n" +
        '            on dt"\n' +
        '          ng-click="select(dt.date)"\n' +
        '          ng-disabled="::dt.disabled"\n' +
        "          tabindex=\"-1\"><span ng-class=\"::{'text-muted': dt.secondary, 'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
        "      </td>\n" +
        "    </tr>\n" +
        "  </tbody>\n" +
        "</table>\n" +
        ""
    );
  },
]);
angular.module("uib/template/datepicker/month.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "uib/template/datepicker/month.html",
      '<table role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n' +
        "  <thead>\n" +
        "    <tr>\n" +
        '      <th><button type="button" class="btn btn-default btn-sm pull-left uib-left" ng-click="move(-1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-left"></i><span class="sr-only">previous</span></button></th>\n' +
        '      <th colspan="{{::yearHeaderColspan}}"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm uib-title" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1"><strong>{{title}}</strong></button></th>\n' +
        '      <th><button type="button" class="btn btn-default btn-sm pull-right uib-right" ng-click="move(1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-right"></i><span class="sr-only">next</span></i></button></th>\n' +
        "    </tr>\n" +
        "  </thead>\n" +
        "  <tbody>\n" +
        '    <tr class="uib-months" ng-repeat="row in rows track by $index" role="row">\n' +
        '      <td ng-repeat="dt in row" class="uib-month text-center" role="gridcell"\n' +
        '        id="{{::dt.uid}}"\n' +
        '        ng-class="::dt.customClass">\n' +
        '        <button type="button" class="btn btn-default"\n' +
        '          uib-is-class="\n' +
        "            'btn-info' for selectedDt,\n" +
        "            'active' for activeDt\n" +
        '            on dt"\n' +
        '          ng-click="select(dt.date)"\n' +
        '          ng-disabled="::dt.disabled"\n' +
        '          tabindex="-1"><span ng-class="::{\'text-info\': dt.current}">{{::dt.label}}</span></button>\n' +
        "      </td>\n" +
        "    </tr>\n" +
        "  </tbody>\n" +
        "</table>\n" +
        ""
    );
  },
]);
angular.module("uib/template/datepicker/year.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "uib/template/datepicker/year.html",
      '<table role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n' +
        "  <thead>\n" +
        "    <tr>\n" +
        '      <th><button type="button" class="btn btn-default btn-sm pull-left uib-left" ng-click="move(-1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-left"></i><span class="sr-only">previous</span></button></th>\n' +
        '      <th colspan="{{::columns - 2}}"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm uib-title" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1"><strong>{{title}}</strong></button></th>\n' +
        '      <th><button type="button" class="btn btn-default btn-sm pull-right uib-right" ng-click="move(1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-right"></i><span class="sr-only">next</span></button></th>\n' +
        "    </tr>\n" +
        "  </thead>\n" +
        "  <tbody>\n" +
        '    <tr class="uib-years" ng-repeat="row in rows track by $index" role="row">\n' +
        '      <td ng-repeat="dt in row" class="uib-year text-center" role="gridcell"\n' +
        '        id="{{::dt.uid}}"\n' +
        '        ng-class="::dt.customClass">\n' +
        '        <button type="button" class="btn btn-default"\n' +
        '          uib-is-class="\n' +
        "            'btn-info' for selectedDt,\n" +
        "            'active' for activeDt\n" +
        '            on dt"\n' +
        '          ng-click="select(dt.date)"\n' +
        '          ng-disabled="::dt.disabled"\n' +
        '          tabindex="-1"><span ng-class="::{\'text-info\': dt.current}">{{::dt.label}}</span></button>\n' +
        "      </td>\n" +
        "    </tr>\n" +
        "  </tbody>\n" +
        "</table>\n" +
        ""
    );
  },
]);
angular.module("uib/template/datepickerPopup/popup.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "uib/template/datepickerPopup/popup.html",
      '<ul role="presentation" class="uib-datepicker-popup dropdown-menu uib-position-measure" dropdown-nested ng-if="isOpen" ng-keydown="keydown($event)" ng-click="$event.stopPropagation()">\n' +
        "  <li ng-transclude></li>\n" +
        '  <li ng-if="showButtonBar" class="uib-button-bar">\n' +
        '    <span class="btn-group pull-left">\n' +
        '      <button type="button" class="btn btn-sm btn-info uib-datepicker-current" ng-click="select(\'today\', $event)" ng-disabled="isDisabled(\'today\')">{{ getText(\'current\') }}</button>\n' +
        '      <button type="button" class="btn btn-sm btn-danger uib-clear" ng-click="select(null, $event)">{{ getText(\'clear\') }}</button>\n' +
        "    </span>\n" +
        '    <button type="button" class="btn btn-sm btn-success pull-right uib-close" ng-click="close($event)">{{ getText(\'close\') }}</button>\n' +
        "  </li>\n" +
        "</ul>\n" +
        ""
    );
  },
]);
angular.module("uib/template/modal/window.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "uib/template/modal/window.html",
      "<div class=\"modal-dialog {{size ? 'modal-' + size : ''}}\"><div class=\"modal-content\" uib-modal-transclude></div></div>\n" +
        ""
    );
  },
]);
angular.module("uib/template/pager/pager.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "uib/template/pager/pager.html",
      '<li ng-class="{disabled: noPrevious()||ngDisabled, previous: align}"><a href ng-click="selectPage(page - 1, $event)" ng-disabled="noPrevious()||ngDisabled" uib-tabindex-toggle>{{::getText(\'previous\')}}</a></li>\n' +
        '<li ng-class="{disabled: noNext()||ngDisabled, next: align}"><a href ng-click="selectPage(page + 1, $event)" ng-disabled="noNext()||ngDisabled" uib-tabindex-toggle>{{::getText(\'next\')}}</a></li>\n' +
        ""
    );
  },
]);
angular.module("uib/template/pagination/pagination.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "uib/template/pagination/pagination.html",
      '<li ng-if="::boundaryLinks" ng-class="{disabled: noPrevious()||ngDisabled}" class="pagination-first"><a href ng-click="selectPage(1, $event)" ng-disabled="noPrevious()||ngDisabled" uib-tabindex-toggle>{{::getText(\'first\')}}</a></li>\n' +
        '<li ng-if="::directionLinks" ng-class="{disabled: noPrevious()||ngDisabled}" class="pagination-prev"><a href ng-click="selectPage(page - 1, $event)" ng-disabled="noPrevious()||ngDisabled" uib-tabindex-toggle>{{::getText(\'previous\')}}</a></li>\n' +
        '<li ng-repeat="page in pages track by $index" ng-class="{active: page.active,disabled: ngDisabled&&!page.active}" class="pagination-page"><a href ng-click="selectPage(page.number, $event)" ng-disabled="ngDisabled&&!page.active" uib-tabindex-toggle>{{page.text}}</a></li>\n' +
        '<li ng-if="::directionLinks" ng-class="{disabled: noNext()||ngDisabled}" class="pagination-next"><a href ng-click="selectPage(page + 1, $event)" ng-disabled="noNext()||ngDisabled" uib-tabindex-toggle>{{::getText(\'next\')}}</a></li>\n' +
        '<li ng-if="::boundaryLinks" ng-class="{disabled: noNext()||ngDisabled}" class="pagination-last"><a href ng-click="selectPage(totalPages, $event)" ng-disabled="noNext()||ngDisabled" uib-tabindex-toggle>{{::getText(\'last\')}}</a></li>\n' +
        ""
    );
  },
]);
angular.module("uib/template/tooltip/tooltip-html-popup.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "uib/template/tooltip/tooltip-html-popup.html",
      '<div class="tooltip-arrow"></div>\n' +
        '<div class="tooltip-inner" ng-bind-html="contentExp()"></div>\n' +
        ""
    );
  },
]);
angular.module("uib/template/tooltip/tooltip-popup.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "uib/template/tooltip/tooltip-popup.html",
      '<div class="tooltip-arrow"></div>\n' +
        '<div class="tooltip-inner" ng-bind="content"></div>\n' +
        ""
    );
  },
]);
angular.module("uib/template/tooltip/tooltip-template-popup.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "uib/template/tooltip/tooltip-template-popup.html",
      '<div class="tooltip-arrow"></div>\n' +
        '<div class="tooltip-inner"\n' +
        '  uib-tooltip-template-transclude="contentExp()"\n' +
        '  tooltip-template-transclude-scope="originScope()"></div>\n' +
        ""
    );
  },
]);
angular.module("uib/template/popover/popover-html.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "uib/template/popover/popover-html.html",
      '<div class="arrow"></div>\n' +
        "\n" +
        '<div class="popover-inner">\n' +
        '    <h3 class="popover-title" ng-bind="uibTitle" ng-if="uibTitle"></h3>\n' +
        '    <div class="popover-content" ng-bind-html="contentExp()"></div>\n' +
        "</div>\n" +
        ""
    );
  },
]);
angular.module("uib/template/popover/popover-template.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "uib/template/popover/popover-template.html",
      '<div class="arrow"></div>\n' +
        "\n" +
        '<div class="popover-inner">\n' +
        '    <h3 class="popover-title" ng-bind="uibTitle" ng-if="uibTitle"></h3>\n' +
        '    <div class="popover-content"\n' +
        '      uib-tooltip-template-transclude="contentExp()"\n' +
        '      tooltip-template-transclude-scope="originScope()"></div>\n' +
        "</div>\n" +
        ""
    );
  },
]);
angular.module("uib/template/popover/popover.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "uib/template/popover/popover.html",
      '<div class="arrow"></div>\n' +
        "\n" +
        '<div class="popover-inner">\n' +
        '    <h3 class="popover-title" ng-bind="uibTitle" ng-if="uibTitle"></h3>\n' +
        '    <div class="popover-content" ng-bind="content"></div>\n' +
        "</div>\n" +
        ""
    );
  },
]);
angular.module("uib/template/progressbar/bar.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "uib/template/progressbar/bar.html",
      '<div class="progress-bar" ng-class="type && \'progress-bar-\' + type" role="progressbar" aria-valuenow="{{value}}" aria-valuemin="0" aria-valuemax="{{max}}" ng-style="{width: (percent < 100 ? percent : 100) + \'%\'}" aria-valuetext="{{percent | number:0}}%" aria-labelledby="{{::title}}" ng-transclude></div>\n' +
        ""
    );
  },
]);
angular.module("uib/template/progressbar/progress.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "uib/template/progressbar/progress.html",
      '<div class="progress" ng-transclude aria-labelledby="{{::title}}"></div>'
    );
  },
]);
angular.module("uib/template/progressbar/progressbar.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "uib/template/progressbar/progressbar.html",
      '<div class="progress">\n' +
        '  <div class="progress-bar" ng-class="type && \'progress-bar-\' + type" role="progressbar" aria-valuenow="{{value}}" aria-valuemin="0" aria-valuemax="{{max}}" ng-style="{width: (percent < 100 ? percent : 100) + \'%\'}" aria-valuetext="{{percent | number:0}}%" aria-labelledby="{{::title}}" ng-transclude></div>\n' +
        "</div>\n" +
        ""
    );
  },
]);
angular.module("uib/template/rating/rating.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "uib/template/rating/rating.html",
      '<span ng-mouseleave="reset()" ng-keydown="onKeydown($event)" tabindex="0" role="slider" aria-valuemin="0" aria-valuemax="{{range.length}}" aria-valuenow="{{value}}" aria-valuetext="{{title}}">\n' +
        "    <span ng-repeat-start=\"r in range track by $index\" class=\"sr-only\">({{ $index < value ? '*' : ' ' }})</span>\n" +
        '    <i ng-repeat-end ng-mouseenter="enter($index + 1)" ng-click="rate($index + 1)" class="glyphicon" ng-class="$index < value && (r.stateOn || \'glyphicon-star\') || (r.stateOff || \'glyphicon-star-empty\')" ng-attr-title="{{r.title}}"></i>\n' +
        "</span>\n" +
        ""
    );
  },
]);
angular.module("uib/template/tabs/tab.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "uib/template/tabs/tab.html",
      '<li ng-class="[{active: active, disabled: disabled}, classes]" class="uib-tab nav-item">\n' +
        '  <a href ng-click="select($event)" class="nav-link" uib-tab-heading-transclude>{{heading}}</a>\n' +
        "</li>\n" +
        ""
    );
  },
]);
angular.module("uib/template/tabs/tabset.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "uib/template/tabs/tabset.html",
      "<div>\n" +
        "  <ul class=\"nav nav-{{tabset.type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" +
        '  <div class="tab-content">\n' +
        '    <div class="tab-pane"\n' +
        '         ng-repeat="tab in tabset.tabs"\n' +
        '         ng-class="{active: tabset.active === tab.index}"\n' +
        '         uib-tab-content-transclude="tab">\n' +
        "    </div>\n" +
        "  </div>\n" +
        "</div>\n" +
        ""
    );
  },
]);
angular.module("uib/template/timepicker/timepicker.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "uib/template/timepicker/timepicker.html",
      '<table class="uib-timepicker">\n' +
        "  <tbody>\n" +
        '    <tr class="text-center" ng-show="::showSpinners">\n' +
        '      <td class="uib-increment hours"><a ng-click="incrementHours()" ng-class="{disabled: noIncrementHours()}" class="btn btn-link" ng-disabled="noIncrementHours()" tabindex="-1"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n' +
        "      <td>&nbsp;</td>\n" +
        '      <td class="uib-increment minutes"><a ng-click="incrementMinutes()" ng-class="{disabled: noIncrementMinutes()}" class="btn btn-link" ng-disabled="noIncrementMinutes()" tabindex="-1"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n' +
        '      <td ng-show="showSeconds">&nbsp;</td>\n' +
        '      <td ng-show="showSeconds" class="uib-increment seconds"><a ng-click="incrementSeconds()" ng-class="{disabled: noIncrementSeconds()}" class="btn btn-link" ng-disabled="noIncrementSeconds()" tabindex="-1"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n' +
        '      <td ng-show="showMeridian"></td>\n' +
        "    </tr>\n" +
        "    <tr>\n" +
        '      <td class="form-group uib-time hours" ng-class="{\'has-error\': invalidHours}">\n' +
        '        <input type="text" placeholder="HH" ng-model="hours" ng-change="updateHours()" class="form-control text-center" ng-readonly="::readonlyInput" maxlength="2" tabindex="{{::tabindex}}" ng-disabled="noIncrementHours()" ng-blur="blur()">\n' +
        "      </td>\n" +
        '      <td class="uib-separator">:</td>\n' +
        '      <td class="form-group uib-time minutes" ng-class="{\'has-error\': invalidMinutes}">\n' +
        '        <input type="text" placeholder="MM" ng-model="minutes" ng-change="updateMinutes()" class="form-control text-center" ng-readonly="::readonlyInput" maxlength="2" tabindex="{{::tabindex}}" ng-disabled="noIncrementMinutes()" ng-blur="blur()">\n' +
        "      </td>\n" +
        '      <td ng-show="showSeconds" class="uib-separator">:</td>\n' +
        '      <td class="form-group uib-time seconds" ng-class="{\'has-error\': invalidSeconds}" ng-show="showSeconds">\n' +
        '        <input type="text" placeholder="SS" ng-model="seconds" ng-change="updateSeconds()" class="form-control text-center" ng-readonly="readonlyInput" maxlength="2" tabindex="{{::tabindex}}" ng-disabled="noIncrementSeconds()" ng-blur="blur()">\n' +
        "      </td>\n" +
        '      <td ng-show="showMeridian" class="uib-time am-pm"><button type="button" ng-class="{disabled: noToggleMeridian()}" class="btn btn-default text-center" ng-click="toggleMeridian()" ng-disabled="noToggleMeridian()" tabindex="{{::tabindex}}">{{meridian}}</button></td>\n' +
        "    </tr>\n" +
        '    <tr class="text-center" ng-show="::showSpinners">\n' +
        '      <td class="uib-decrement hours"><a ng-click="decrementHours()" ng-class="{disabled: noDecrementHours()}" class="btn btn-link" ng-disabled="noDecrementHours()" tabindex="-1"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n' +
        "      <td>&nbsp;</td>\n" +
        '      <td class="uib-decrement minutes"><a ng-click="decrementMinutes()" ng-class="{disabled: noDecrementMinutes()}" class="btn btn-link" ng-disabled="noDecrementMinutes()" tabindex="-1"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n' +
        '      <td ng-show="showSeconds">&nbsp;</td>\n' +
        '      <td ng-show="showSeconds" class="uib-decrement seconds"><a ng-click="decrementSeconds()" ng-class="{disabled: noDecrementSeconds()}" class="btn btn-link" ng-disabled="noDecrementSeconds()" tabindex="-1"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n' +
        '      <td ng-show="showMeridian"></td>\n' +
        "    </tr>\n" +
        "  </tbody>\n" +
        "</table>\n" +
        ""
    );
  },
]);
angular.module("uib/template/typeahead/typeahead-match.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "uib/template/typeahead/typeahead-match.html",
      "<a href\n" +
        '   tabindex="-1"\n' +
        '   ng-bind-html="match.label | uibTypeaheadHighlight:query"\n' +
        '   ng-attr-title="{{match.label}}"></a>\n' +
        ""
    );
  },
]);
angular.module("uib/template/typeahead/typeahead-popup.html", []).run([
  "$templateCache",
  function ($templateCache) {
    $templateCache.put(
      "uib/template/typeahead/typeahead-popup.html",
      '<ul class="dropdown-menu" ng-show="isOpen() && !moveInProgress" ng-style="{top: position().top+\'px\', left: position().left+\'px\'}" role="listbox" aria-hidden="{{!isOpen()}}">\n' +
        '    <li class="uib-typeahead-match" ng-repeat="match in matches track by $index" ng-class="{active: isActive($index) }" ng-mouseenter="selectActive($index)" ng-click="selectMatch($index, $event)" role="option" id="{{::match.id}}">\n' +
        '        <div uib-typeahead-match index="$index" match="match" query="query" template-url="templateUrl"></div>\n' +
        "    </li>\n" +
        "</ul>\n" +
        ""
    );
  },
]);
angular.module("ui.bootstrap.carousel").run(function () {
  !angular.$$csp().noInlineStyle &&
    !angular.$$uibCarouselCss &&
    angular
      .element(document)
      .find("head")
      .prepend(
        '<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>'
      );
  angular.$$uibCarouselCss = true;
});
angular.module("ui.bootstrap.datepicker").run(function () {
  !angular.$$csp().noInlineStyle &&
    !angular.$$uibDatepickerCss &&
    angular
      .element(document)
      .find("head")
      .prepend(
        '<style type="text/css">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-left,.uib-right{width:100%}</style>'
      );
  angular.$$uibDatepickerCss = true;
});
angular.module("ui.bootstrap.position").run(function () {
  !angular.$$csp().noInlineStyle &&
    !angular.$$uibPositionCss &&
    angular
      .element(document)
      .find("head")
      .prepend(
        '<style type="text/css">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}</style>'
      );
  angular.$$uibPositionCss = true;
});
angular.module("ui.bootstrap.datepickerPopup").run(function () {
  !angular.$$csp().noInlineStyle &&
    !angular.$$uibDatepickerpopupCss &&
    angular
      .element(document)
      .find("head")
      .prepend(
        '<style type="text/css">.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}</style>'
      );
  angular.$$uibDatepickerpopupCss = true;
});
angular.module("ui.bootstrap.tooltip").run(function () {
  !angular.$$csp().noInlineStyle &&
    !angular.$$uibTooltipCss &&
    angular
      .element(document)
      .find("head")
      .prepend(
        '<style type="text/css">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow,[uib-popover-html-popup].popover.top-left > .arrow,[uib-popover-html-popup].popover.top-right > .arrow,[uib-popover-html-popup].popover.bottom-left > .arrow,[uib-popover-html-popup].popover.bottom-right > .arrow,[uib-popover-html-popup].popover.left-top > .arrow,[uib-popover-html-popup].popover.left-bottom > .arrow,[uib-popover-html-popup].popover.right-top > .arrow,[uib-popover-html-popup].popover.right-bottom > .arrow,[uib-popover-template-popup].popover.top-left > .arrow,[uib-popover-template-popup].popover.top-right > .arrow,[uib-popover-template-popup].popover.bottom-left > .arrow,[uib-popover-template-popup].popover.bottom-right > .arrow,[uib-popover-template-popup].popover.left-top > .arrow,[uib-popover-template-popup].popover.left-bottom > .arrow,[uib-popover-template-popup].popover.right-top > .arrow,[uib-popover-template-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-html-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>'
      );
  angular.$$uibTooltipCss = true;
});
angular.module("ui.bootstrap.timepicker").run(function () {
  !angular.$$csp().noInlineStyle &&
    !angular.$$uibTimepickerCss &&
    angular
      .element(document)
      .find("head")
      .prepend('<style type="text/css">.uib-time input{width:50px;}</style>');
  angular.$$uibTimepickerCss = true;
});
angular.module("ui.bootstrap.typeahead").run(function () {
  !angular.$$csp().noInlineStyle &&
    !angular.$$uibTypeaheadCss &&
    angular
      .element(document)
      .find("head")
      .prepend(
        '<style type="text/css">[uib-typeahead-popup].dropdown-menu{display:block;}</style>'
      );
  angular.$$uibTypeaheadCss = true;
});
(function (window, document) {
  var version = "3.7.3-pre";
  var options = window.html5 || {};
  var reSkip =
    /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i;
  var saveClones =
    /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i;
  var supportsHtml5Styles;
  var expando = "_html5shiv";
  var expanID = 0;
  var expandoData = {};
  var supportsUnknownElements;
  (function () {
    try {
      var a = document.createElement("a");
      a.innerHTML = "<xyz></xyz>";
      supportsHtml5Styles = "hidden" in a;
      supportsUnknownElements =
        a.childNodes.length == 1 ||
        (function () {
          document.createElement("a");
          var frag = document.createDocumentFragment();
          return (
            typeof frag.cloneNode == "undefined" ||
            typeof frag.createDocumentFragment == "undefined" ||
            typeof frag.createElement == "undefined"
          );
        })();
    } catch (e) {
      supportsHtml5Styles = true;
      supportsUnknownElements = true;
    }
  })();
  function addStyleSheet(ownerDocument, cssText) {
    var p = ownerDocument.createElement("p"),
      parent =
        ownerDocument.getElementsByTagName("head")[0] ||
        ownerDocument.documentElement;
    p.innerHTML = "x<style>" + cssText + "</style>";
    return parent.insertBefore(p.lastChild, parent.firstChild);
  }
  function getElements() {
    var elements = html5.elements;
    return typeof elements == "string" ? elements.split(" ") : elements;
  }
  function addElements(newElements, ownerDocument) {
    var elements = html5.elements;
    if (typeof elements != "string") {
      elements = elements.join(" ");
    }
    if (typeof newElements != "string") {
      newElements = newElements.join(" ");
    }
    html5.elements = elements + " " + newElements;
    shivDocument(ownerDocument);
  }
  function getExpandoData(ownerDocument) {
    var data = expandoData[ownerDocument[expando]];
    if (!data) {
      data = {};
      expanID++;
      ownerDocument[expando] = expanID;
      expandoData[expanID] = data;
    }
    return data;
  }
  function createElement(nodeName, ownerDocument, data) {
    if (!ownerDocument) {
      ownerDocument = document;
    }
    if (supportsUnknownElements) {
      return ownerDocument.createElement(nodeName);
    }
    if (!data) {
      data = getExpandoData(ownerDocument);
    }
    var node;
    if (data.cache[nodeName]) {
      node = data.cache[nodeName].cloneNode();
    } else if (saveClones.test(nodeName)) {
      node = (data.cache[nodeName] = data.createElem(nodeName)).cloneNode();
    } else {
      node = data.createElem(nodeName);
    }
    return node.canHaveChildren && !reSkip.test(nodeName) && !node.tagUrn
      ? data.frag.appendChild(node)
      : node;
  }
  function createDocumentFragment(ownerDocument, data) {
    if (!ownerDocument) {
      ownerDocument = document;
    }
    if (supportsUnknownElements) {
      return ownerDocument.createDocumentFragment();
    }
    data = data || getExpandoData(ownerDocument);
    var clone = data.frag.cloneNode(),
      i = 0,
      elems = getElements(),
      l = elems.length;
    for (; i < l; i++) {
      clone.createElement(elems[i]);
    }
    return clone;
  }
  function shivMethods(ownerDocument, data) {
    if (!data.cache) {
      data.cache = {};
      data.createElem = ownerDocument.createElement;
      data.createFrag = ownerDocument.createDocumentFragment;
      data.frag = data.createFrag();
    }
    ownerDocument.createElement = function (nodeName) {
      if (!html5.shivMethods) {
        return data.createElem(nodeName);
      }
      return createElement(nodeName, ownerDocument, data);
    };
    ownerDocument.createDocumentFragment = Function(
      "h,f",
      "return function(){" +
        "var n=f.cloneNode(),c=n.createElement;" +
        "h.shivMethods&&(" +
        getElements()
          .join()
          .replace(/[\w\-:]+/g, function (nodeName) {
            data.createElem(nodeName);
            data.frag.createElement(nodeName);
            return 'c("' + nodeName + '")';
          }) +
        ");return n}"
    )(html5, data.frag);
  }
  function shivDocument(ownerDocument) {
    if (!ownerDocument) {
      ownerDocument = document;
    }
    var data = getExpandoData(ownerDocument);
    if (html5.shivCSS && !supportsHtml5Styles && !data.hasCSS) {
      data.hasCSS = !!addStyleSheet(
        ownerDocument,
        "article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}" +
          "mark{background:#FF0;color:#000}" +
          "template{display:none}"
      );
    }
    if (!supportsUnknownElements) {
      shivMethods(ownerDocument, data);
    }
    return ownerDocument;
  }
  var html5 = {
    elements:
      options.elements ||
      "abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output picture progress section summary template time video",
    version: version,
    shivCSS: options.shivCSS !== false,
    supportsUnknownElements: supportsUnknownElements,
    shivMethods: options.shivMethods !== false,
    type: "default",
    shivDocument: shivDocument,
    createElement: createElement,
    createDocumentFragment: createDocumentFragment,
    addElements: addElements,
  };
  window.html5 = html5;
  shivDocument(document);
  if (typeof module == "object" && module.exports) {
    module.exports = html5;
  }
})(typeof window !== "undefined" ? window : this, document);
(function (w) {
  "use strict";
  var respond = {};
  w.respond = respond;
  respond.update = function () {};
  var requestQueue = [],
    xmlHttp = (function () {
      var xmlhttpmethod = false;
      try {
        xmlhttpmethod = new w.XMLHttpRequest();
      } catch (e) {
        xmlhttpmethod = new w.ActiveXObject("Microsoft.XMLHTTP");
      }
      return function () {
        return xmlhttpmethod;
      };
    })(),
    ajax = function (url, callback) {
      var req = xmlHttp();
      if (!req) {
        return;
      }
      req.open("GET", url, true);
      req.onreadystatechange = function () {
        if (
          req.readyState !== 4 ||
          (req.status !== 200 && req.status !== 304)
        ) {
          return;
        }
        callback(req.responseText);
      };
      if (req.readyState === 4) {
        return;
      }
      req.send(null);
    },
    isUnsupportedMediaQuery = function (query) {
      return query
        .replace(respond.regex.minmaxwh, "")
        .match(respond.regex.other);
    };
  respond.ajax = ajax;
  respond.queue = requestQueue;
  respond.unsupportedmq = isUnsupportedMediaQuery;
  respond.regex = {
    media: /@media[^\{]+\{([^\{\}]*\{[^\}\{]*\})+/gi,
    keyframes:
      /@(?:\-(?:o|moz|webkit)\-)?keyframes[^\{]+\{(?:[^\{\}]*\{[^\}\{]*\})+[^\}]*\}/gi,
    comments: /\/\*[^*]*\*+([^\/][^*]*\*+)*\//gi,
    urls: /(url\()['"]?([^\/\)'"][^:\)'"]+)['"]?(\))/g,
    findStyles: /@media *([^\{]+)\{([\S\s]+?)$/,
    only: /(only\s+)?([a-zA-Z]+)\s?/,
    minw: /\(\s*min\-width\s*:\s*(\s*[0-9\.]+)(px|em)\s*\)/,
    maxw: /\(\s*max\-width\s*:\s*(\s*[0-9\.]+)(px|em)\s*\)/,
    minmaxwh: /\(\s*m(in|ax)\-(height|width)\s*:\s*(\s*[0-9\.]+)(px|em)\s*\)/gi,
    other: /\([^\)]*\)/g,
  };
  respond.mediaQueriesSupported =
    w.matchMedia &&
    w.matchMedia("only all") !== null &&
    w.matchMedia("only all").matches;
  if (respond.mediaQueriesSupported) {
    return;
  }
  var doc = w.document,
    docElem = doc.documentElement,
    mediastyles = [],
    rules = [],
    appendedEls = [],
    parsedSheets = {},
    resizeThrottle = 30,
    head = doc.getElementsByTagName("head")[0] || docElem,
    base = doc.getElementsByTagName("base")[0],
    links = head.getElementsByTagName("link"),
    lastCall,
    resizeDefer,
    eminpx,
    getEmValue = function () {
      var ret,
        div = doc.createElement("div"),
        body = doc.body,
        originalHTMLFontSize = docElem.style.fontSize,
        originalBodyFontSize = body && body.style.fontSize,
        fakeUsed = false;
      div.style.cssText = "position:absolute;font-size:1em;width:1em";
      if (!body) {
        body = fakeUsed = doc.createElement("body");
        body.style.background = "none";
      }
      docElem.style.fontSize = "100%";
      body.style.fontSize = "100%";
      body.appendChild(div);
      if (fakeUsed) {
        docElem.insertBefore(body, docElem.firstChild);
      }
      ret = div.offsetWidth;
      if (fakeUsed) {
        docElem.removeChild(body);
      } else {
        body.removeChild(div);
      }
      docElem.style.fontSize = originalHTMLFontSize;
      if (originalBodyFontSize) {
        body.style.fontSize = originalBodyFontSize;
      }
      ret = eminpx = parseFloat(ret);
      return ret;
    },
    applyMedia = function (fromResize) {
      var name = "clientWidth",
        docElemProp = docElem[name],
        currWidth =
          (doc.compatMode === "CSS1Compat" && docElemProp) ||
          doc.body[name] ||
          docElemProp,
        styleBlocks = {},
        lastLink = links[links.length - 1],
        now = new Date().getTime();
      if (fromResize && lastCall && now - lastCall < resizeThrottle) {
        w.clearTimeout(resizeDefer);
        resizeDefer = w.setTimeout(applyMedia, resizeThrottle);
        return;
      } else {
        lastCall = now;
      }
      for (var i in mediastyles) {
        if (mediastyles.hasOwnProperty(i)) {
          var thisstyle = mediastyles[i],
            min = thisstyle.minw,
            max = thisstyle.maxw,
            minnull = min === null,
            maxnull = max === null,
            em = "em";
          if (!!min) {
            min =
              parseFloat(min) *
              (min.indexOf(em) > -1 ? eminpx || getEmValue() : 1);
          }
          if (!!max) {
            max =
              parseFloat(max) *
              (max.indexOf(em) > -1 ? eminpx || getEmValue() : 1);
          }
          if (
            !thisstyle.hasquery ||
            ((!minnull || !maxnull) &&
              (minnull || currWidth >= min) &&
              (maxnull || currWidth <= max))
          ) {
            if (!styleBlocks[thisstyle.media]) {
              styleBlocks[thisstyle.media] = [];
            }
            styleBlocks[thisstyle.media].push(rules[thisstyle.rules]);
          }
        }
      }
      for (var j in appendedEls) {
        if (appendedEls.hasOwnProperty(j)) {
          if (appendedEls[j] && appendedEls[j].parentNode === head) {
            head.removeChild(appendedEls[j]);
          }
        }
      }
      appendedEls.length = 0;
      for (var k in styleBlocks) {
        if (styleBlocks.hasOwnProperty(k)) {
          var ss = doc.createElement("style"),
            css = styleBlocks[k].join("\n");
          ss.type = "text/css";
          ss.media = k;
          head.insertBefore(ss, lastLink.nextSibling);
          if (ss.styleSheet) {
            ss.styleSheet.cssText = css;
          } else {
            ss.appendChild(doc.createTextNode(css));
          }
          appendedEls.push(ss);
        }
      }
    },
    translate = function (styles, href, media) {
      var qs = styles
          .replace(respond.regex.comments, "")
          .replace(respond.regex.keyframes, "")
          .match(respond.regex.media),
        ql = (qs && qs.length) || 0;
      href = href.substring(0, href.lastIndexOf("/"));
      var repUrls = function (css) {
          return css.replace(respond.regex.urls, "$1" + href + "$2$3");
        },
        useMedia = !ql && media;
      if (href.length) {
        href += "/";
      }
      if (useMedia) {
        ql = 1;
      }
      for (var i = 0; i < ql; i++) {
        var fullq, thisq, eachq, eql;
        if (useMedia) {
          fullq = media;
          rules.push(repUrls(styles));
        } else {
          fullq = qs[i].match(respond.regex.findStyles) && RegExp.$1;
          rules.push(RegExp.$2 && repUrls(RegExp.$2));
        }
        eachq = fullq.split(",");
        eql = eachq.length;
        for (var j = 0; j < eql; j++) {
          thisq = eachq[j];
          if (isUnsupportedMediaQuery(thisq)) {
            continue;
          }
          mediastyles.push({
            media:
              (thisq.split("(")[0].match(respond.regex.only) && RegExp.$2) ||
              "all",
            rules: rules.length - 1,
            hasquery: thisq.indexOf("(") > -1,
            minw:
              thisq.match(respond.regex.minw) &&
              parseFloat(RegExp.$1) + (RegExp.$2 || ""),
            maxw:
              thisq.match(respond.regex.maxw) &&
              parseFloat(RegExp.$1) + (RegExp.$2 || ""),
          });
        }
      }
      applyMedia();
    },
    makeRequests = function () {
      if (requestQueue.length) {
        var thisRequest = requestQueue.shift();
        ajax(thisRequest.href, function (styles) {
          translate(styles, thisRequest.href, thisRequest.media);
          parsedSheets[thisRequest.href] = true;
          w.setTimeout(function () {
            makeRequests();
          }, 0);
        });
      }
    },
    ripCSS = function () {
      for (var i = 0; i < links.length; i++) {
        var sheet = links[i],
          href = sheet.href,
          media = sheet.media,
          isCSS = sheet.rel && sheet.rel.toLowerCase() === "stylesheet";
        if (!!href && isCSS && !parsedSheets[href]) {
          if (sheet.styleSheet && sheet.styleSheet.rawCssText) {
            translate(sheet.styleSheet.rawCssText, href, media);
            parsedSheets[href] = true;
          } else {
            if (
              (!/^([a-zA-Z:]*\/\/)/.test(href) && !base) ||
              href.replace(RegExp.$1, "").split("/")[0] === w.location.host
            ) {
              if (href.substring(0, 2) === "//") {
                href = w.location.protocol + href;
              }
              requestQueue.push({ href: href, media: media });
            }
          }
        }
      }
      makeRequests();
    };
  ripCSS();
  respond.update = ripCSS;
  respond.getEmValue = getEmValue;
  function callMedia() {
    applyMedia(true);
  }
  if (w.addEventListener) {
    w.addEventListener("resize", callMedia, false);
  } else if (w.attachEvent) {
    w.attachEvent("onresize", callMedia);
  }
})(this);
(function (root, factory) {
  "use strict";
  if (typeof define === "function" && define.amd) {
    define(factory);
  } else if (typeof exports === "object") {
    module.exports = factory();
  } else {
    root.returnExports = factory();
  }
})(this, function () {
  var $Array = Array;
  var ArrayPrototype = $Array.prototype;
  var $Object = Object;
  var ObjectPrototype = $Object.prototype;
  var $Function = Function;
  var FunctionPrototype = $Function.prototype;
  var $String = String;
  var StringPrototype = $String.prototype;
  var $Number = Number;
  var NumberPrototype = $Number.prototype;
  var array_slice = ArrayPrototype.slice;
  var array_splice = ArrayPrototype.splice;
  var array_push = ArrayPrototype.push;
  var array_unshift = ArrayPrototype.unshift;
  var array_concat = ArrayPrototype.concat;
  var array_join = ArrayPrototype.join;
  var call = FunctionPrototype.call;
  var apply = FunctionPrototype.apply;
  var max = Math.max;
  var min = Math.min;
  var to_string = ObjectPrototype.toString;
  var hasToStringTag =
    typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
  var isCallable;
  var fnToStr = Function.prototype.toString,
    constructorRegex = /^\s*class /,
    isES6ClassFn = function isES6ClassFn(value) {
      try {
        var fnStr = fnToStr.call(value);
        var singleStripped = fnStr.replace(/\/\/.*\n/g, "");
        var multiStripped = singleStripped.replace(/\/\*[.\s\S]*\*\//g, "");
        var spaceStripped = multiStripped
          .replace(/\n/gm, " ")
          .replace(/ {2}/g, " ");
        return constructorRegex.test(spaceStripped);
      } catch (e) {
        return false;
      }
    },
    tryFunctionObject = function tryFunctionObject(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e) {
        return false;
      }
    },
    fnClass = "[object Function]",
    genClass = "[object GeneratorFunction]",
    isCallable = function isCallable(value) {
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = to_string.call(value);
      return strClass === fnClass || strClass === genClass;
    };
  var isRegex;
  var regexExec = RegExp.prototype.exec,
    tryRegexExec = function tryRegexExec(value) {
      try {
        regexExec.call(value);
        return true;
      } catch (e) {
        return false;
      }
    },
    regexClass = "[object RegExp]";
  isRegex = function isRegex(value) {
    if (typeof value !== "object") {
      return false;
    }
    return hasToStringTag
      ? tryRegexExec(value)
      : to_string.call(value) === regexClass;
  };
  var isString;
  var strValue = String.prototype.valueOf,
    tryStringObject = function tryStringObject(value) {
      try {
        strValue.call(value);
        return true;
      } catch (e) {
        return false;
      }
    },
    stringClass = "[object String]";
  isString = function isString(value) {
    if (typeof value === "string") {
      return true;
    }
    if (typeof value !== "object") {
      return false;
    }
    return hasToStringTag
      ? tryStringObject(value)
      : to_string.call(value) === stringClass;
  };
  var supportsDescriptors =
    $Object.defineProperty &&
    (function () {
      try {
        var obj = {};
        $Object.defineProperty(obj, "x", { enumerable: false, value: obj });
        for (var _ in obj) {
          return false;
        }
        return obj.x === obj;
      } catch (e) {
        return false;
      }
    })();
  var defineProperties = (function (has) {
    var defineProperty;
    if (supportsDescriptors) {
      defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && name in object) {
          return;
        }
        $Object.defineProperty(object, name, {
          configurable: true,
          enumerable: false,
          writable: true,
          value: method,
        });
      };
    } else {
      defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && name in object) {
          return;
        }
        object[name] = method;
      };
    }
    return function defineProperties(object, map, forceAssign) {
      for (var name in map) {
        if (has.call(map, name)) {
          defineProperty(object, name, map[name], forceAssign);
        }
      }
    };
  })(ObjectPrototype.hasOwnProperty);
  var isPrimitive = function isPrimitive(input) {
    var type = typeof input;
    return input === null || (type !== "object" && type !== "function");
  };
  var isActualNaN =
    $Number.isNaN ||
    function isActualNaN(x) {
      return x !== x;
    };
  var ES = {
    ToInteger: function ToInteger(num) {
      var n = +num;
      if (isActualNaN(n)) {
        n = 0;
      } else if (n !== 0 && n !== 1 / 0 && n !== -(1 / 0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
      }
      return n;
    },
    ToPrimitive: function ToPrimitive(input) {
      var val, valueOf, toStr;
      if (isPrimitive(input)) {
        return input;
      }
      valueOf = input.valueOf;
      if (isCallable(valueOf)) {
        val = valueOf.call(input);
        if (isPrimitive(val)) {
          return val;
        }
      }
      toStr = input.toString;
      if (isCallable(toStr)) {
        val = toStr.call(input);
        if (isPrimitive(val)) {
          return val;
        }
      }
      throw new TypeError();
    },
    ToObject: function (o) {
      if (o == null) {
        throw new TypeError("can't convert " + o + " to object");
      }
      return $Object(o);
    },
    ToUint32: function ToUint32(x) {
      return x >>> 0;
    },
  };
  var Empty = function Empty() {};
  defineProperties(FunctionPrototype, {
    bind: function bind(that) {
      var target = this;
      if (!isCallable(target)) {
        throw new TypeError(
          "Function.prototype.bind called on incompatible " + target
        );
      }
      var args = array_slice.call(arguments, 1);
      var bound;
      var binder = function () {
        if (this instanceof bound) {
          var result = apply.call(
            target,
            this,
            array_concat.call(args, array_slice.call(arguments))
          );
          if ($Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return apply.call(
            target,
            that,
            array_concat.call(args, array_slice.call(arguments))
          );
        }
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        array_push.call(boundArgs, "$" + i);
      }
      bound = $Function(
        "binder",
        "return function (" +
          array_join.call(boundArgs, ",") +
          "){ return binder.apply(this, arguments); }"
      )(binder);
      if (target.prototype) {
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    },
  });
  var owns = call.bind(ObjectPrototype.hasOwnProperty);
  var toStr = call.bind(ObjectPrototype.toString);
  var arraySlice = call.bind(array_slice);
  var arraySliceApply = apply.bind(array_slice);
  var strSlice = call.bind(StringPrototype.slice);
  var strSplit = call.bind(StringPrototype.split);
  var strIndexOf = call.bind(StringPrototype.indexOf);
  var pushCall = call.bind(array_push);
  var isEnum = call.bind(ObjectPrototype.propertyIsEnumerable);
  var arraySort = call.bind(ArrayPrototype.sort);
  var isArray =
    $Array.isArray ||
    function isArray(obj) {
      return toStr(obj) === "[object Array]";
    };
  var hasUnshiftReturnValueBug = [].unshift(0) !== 1;
  defineProperties(
    ArrayPrototype,
    {
      unshift: function () {
        array_unshift.apply(this, arguments);
        return this.length;
      },
    },
    hasUnshiftReturnValueBug
  );
  defineProperties($Array, { isArray: isArray });
  var boxedString = $Object("a");
  var splitString = boxedString[0] !== "a" || !(0 in boxedString);
  var properlyBoxesContext = function properlyBoxed(method) {
    var properlyBoxesNonStrict = true;
    var properlyBoxesStrict = true;
    var threwException = false;
    if (method) {
      try {
        method.call("foo", function (_, __, context) {
          if (typeof context !== "object") {
            properlyBoxesNonStrict = false;
          }
        });
        method.call(
          [1],
          function () {
            "use strict";
            properlyBoxesStrict = typeof this === "string";
          },
          "x"
        );
      } catch (e) {
        threwException = true;
      }
    }
    return (
      !!method &&
      !threwException &&
      properlyBoxesNonStrict &&
      properlyBoxesStrict
    );
  };
  defineProperties(
    ArrayPrototype,
    {
      forEach: function forEach(callbackfn) {
        var object = ES.ToObject(this);
        var self = splitString && isString(this) ? strSplit(this, "") : object;
        var i = -1;
        var length = ES.ToUint32(self.length);
        var T;
        if (arguments.length > 1) {
          T = arguments[1];
        }
        if (!isCallable(callbackfn)) {
          throw new TypeError(
            "Array.prototype.forEach callback must be a function"
          );
        }
        while (++i < length) {
          if (i in self) {
            if (typeof T === "undefined") {
              callbackfn(self[i], i, object);
            } else {
              callbackfn.call(T, self[i], i, object);
            }
          }
        }
      },
    },
    !properlyBoxesContext(ArrayPrototype.forEach)
  );
  defineProperties(
    ArrayPrototype,
    {
      map: function map(callbackfn) {
        var object = ES.ToObject(this);
        var self = splitString && isString(this) ? strSplit(this, "") : object;
        var length = ES.ToUint32(self.length);
        var result = $Array(length);
        var T;
        if (arguments.length > 1) {
          T = arguments[1];
        }
        if (!isCallable(callbackfn)) {
          throw new TypeError(
            "Array.prototype.map callback must be a function"
          );
        }
        for (var i = 0; i < length; i++) {
          if (i in self) {
            if (typeof T === "undefined") {
              result[i] = callbackfn(self[i], i, object);
            } else {
              result[i] = callbackfn.call(T, self[i], i, object);
            }
          }
        }
        return result;
      },
    },
    !properlyBoxesContext(ArrayPrototype.map)
  );
  defineProperties(
    ArrayPrototype,
    {
      filter: function filter(callbackfn) {
        var object = ES.ToObject(this);
        var self = splitString && isString(this) ? strSplit(this, "") : object;
        var length = ES.ToUint32(self.length);
        var result = [];
        var value;
        var T;
        if (arguments.length > 1) {
          T = arguments[1];
        }
        if (!isCallable(callbackfn)) {
          throw new TypeError(
            "Array.prototype.filter callback must be a function"
          );
        }
        for (var i = 0; i < length; i++) {
          if (i in self) {
            value = self[i];
            if (
              typeof T === "undefined"
                ? callbackfn(value, i, object)
                : callbackfn.call(T, value, i, object)
            ) {
              pushCall(result, value);
            }
          }
        }
        return result;
      },
    },
    !properlyBoxesContext(ArrayPrototype.filter)
  );
  defineProperties(
    ArrayPrototype,
    {
      every: function every(callbackfn) {
        var object = ES.ToObject(this);
        var self = splitString && isString(this) ? strSplit(this, "") : object;
        var length = ES.ToUint32(self.length);
        var T;
        if (arguments.length > 1) {
          T = arguments[1];
        }
        if (!isCallable(callbackfn)) {
          throw new TypeError(
            "Array.prototype.every callback must be a function"
          );
        }
        for (var i = 0; i < length; i++) {
          if (
            i in self &&
            !(typeof T === "undefined"
              ? callbackfn(self[i], i, object)
              : callbackfn.call(T, self[i], i, object))
          ) {
            return false;
          }
        }
        return true;
      },
    },
    !properlyBoxesContext(ArrayPrototype.every)
  );
  defineProperties(
    ArrayPrototype,
    {
      some: function some(callbackfn) {
        var object = ES.ToObject(this);
        var self = splitString && isString(this) ? strSplit(this, "") : object;
        var length = ES.ToUint32(self.length);
        var T;
        if (arguments.length > 1) {
          T = arguments[1];
        }
        if (!isCallable(callbackfn)) {
          throw new TypeError(
            "Array.prototype.some callback must be a function"
          );
        }
        for (var i = 0; i < length; i++) {
          if (
            i in self &&
            (typeof T === "undefined"
              ? callbackfn(self[i], i, object)
              : callbackfn.call(T, self[i], i, object))
          ) {
            return true;
          }
        }
        return false;
      },
    },
    !properlyBoxesContext(ArrayPrototype.some)
  );
  var reduceCoercesToObject = false;
  if (ArrayPrototype.reduce) {
    reduceCoercesToObject =
      typeof ArrayPrototype.reduce.call("es5", function (_, __, ___, list) {
        return list;
      }) === "object";
  }
  defineProperties(
    ArrayPrototype,
    {
      reduce: function reduce(callbackfn) {
        var object = ES.ToObject(this);
        var self = splitString && isString(this) ? strSplit(this, "") : object;
        var length = ES.ToUint32(self.length);
        if (!isCallable(callbackfn)) {
          throw new TypeError(
            "Array.prototype.reduce callback must be a function"
          );
        }
        if (length === 0 && arguments.length === 1) {
          throw new TypeError("reduce of empty array with no initial value");
        }
        var i = 0;
        var result;
        if (arguments.length >= 2) {
          result = arguments[1];
        } else {
          do {
            if (i in self) {
              result = self[i++];
              break;
            }
            if (++i >= length) {
              throw new TypeError(
                "reduce of empty array with no initial value"
              );
            }
          } while (true);
        }
        for (; i < length; i++) {
          if (i in self) {
            result = callbackfn(result, self[i], i, object);
          }
        }
        return result;
      },
    },
    !reduceCoercesToObject
  );
  var reduceRightCoercesToObject = false;
  if (ArrayPrototype.reduceRight) {
    reduceRightCoercesToObject =
      typeof ArrayPrototype.reduceRight.call(
        "es5",
        function (_, __, ___, list) {
          return list;
        }
      ) === "object";
  }
  defineProperties(
    ArrayPrototype,
    {
      reduceRight: function reduceRight(callbackfn) {
        var object = ES.ToObject(this);
        var self = splitString && isString(this) ? strSplit(this, "") : object;
        var length = ES.ToUint32(self.length);
        if (!isCallable(callbackfn)) {
          throw new TypeError(
            "Array.prototype.reduceRight callback must be a function"
          );
        }
        if (length === 0 && arguments.length === 1) {
          throw new TypeError(
            "reduceRight of empty array with no initial value"
          );
        }
        var result;
        var i = length - 1;
        if (arguments.length >= 2) {
          result = arguments[1];
        } else {
          do {
            if (i in self) {
              result = self[i--];
              break;
            }
            if (--i < 0) {
              throw new TypeError(
                "reduceRight of empty array with no initial value"
              );
            }
          } while (true);
        }
        if (i < 0) {
          return result;
        }
        do {
          if (i in self) {
            result = callbackfn(result, self[i], i, object);
          }
        } while (i--);
        return result;
      },
    },
    !reduceRightCoercesToObject
  );
  var hasFirefox2IndexOfBug =
    ArrayPrototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
  defineProperties(
    ArrayPrototype,
    {
      indexOf: function indexOf(searchElement) {
        var self =
          splitString && isString(this)
            ? strSplit(this, "")
            : ES.ToObject(this);
        var length = ES.ToUint32(self.length);
        if (length === 0) {
          return -1;
        }
        var i = 0;
        if (arguments.length > 1) {
          i = ES.ToInteger(arguments[1]);
        }
        i = i >= 0 ? i : max(0, length + i);
        for (; i < length; i++) {
          if (i in self && self[i] === searchElement) {
            return i;
          }
        }
        return -1;
      },
    },
    hasFirefox2IndexOfBug
  );
  var hasFirefox2LastIndexOfBug =
    ArrayPrototype.lastIndexOf && [0, 1].lastIndexOf(0, -3) !== -1;
  defineProperties(
    ArrayPrototype,
    {
      lastIndexOf: function lastIndexOf(searchElement) {
        var self =
          splitString && isString(this)
            ? strSplit(this, "")
            : ES.ToObject(this);
        var length = ES.ToUint32(self.length);
        if (length === 0) {
          return -1;
        }
        var i = length - 1;
        if (arguments.length > 1) {
          i = min(i, ES.ToInteger(arguments[1]));
        }
        i = i >= 0 ? i : length - Math.abs(i);
        for (; i >= 0; i--) {
          if (i in self && searchElement === self[i]) {
            return i;
          }
        }
        return -1;
      },
    },
    hasFirefox2LastIndexOfBug
  );
  var spliceNoopReturnsEmptyArray = (function () {
    var a = [1, 2];
    var result = a.splice();
    return a.length === 2 && isArray(result) && result.length === 0;
  })();
  defineProperties(
    ArrayPrototype,
    {
      splice: function splice(start, deleteCount) {
        if (arguments.length === 0) {
          return [];
        } else {
          return array_splice.apply(this, arguments);
        }
      },
    },
    !spliceNoopReturnsEmptyArray
  );
  var spliceWorksWithEmptyObject = (function () {
    var obj = {};
    ArrayPrototype.splice.call(obj, 0, 0, 1);
    return obj.length === 1;
  })();
  defineProperties(
    ArrayPrototype,
    {
      splice: function splice(start, deleteCount) {
        if (arguments.length === 0) {
          return [];
        }
        var args = arguments;
        this.length = max(ES.ToInteger(this.length), 0);
        if (arguments.length > 0 && typeof deleteCount !== "number") {
          args = arraySlice(arguments);
          if (args.length < 2) {
            pushCall(args, this.length - start);
          } else {
            args[1] = ES.ToInteger(deleteCount);
          }
        }
        return array_splice.apply(this, args);
      },
    },
    !spliceWorksWithEmptyObject
  );
  var spliceWorksWithLargeSparseArrays = (function () {
    var arr = new $Array(1e5);
    arr[8] = "x";
    arr.splice(1, 1);
    return arr.indexOf("x") === 7;
  })();
  var spliceWorksWithSmallSparseArrays = (function () {
    var n = 256;
    var arr = [];
    arr[n] = "a";
    arr.splice(n + 1, 0, "b");
    return arr[n] === "a";
  })();
  defineProperties(
    ArrayPrototype,
    {
      splice: function splice(start, deleteCount) {
        var O = ES.ToObject(this);
        var A = [];
        var len = ES.ToUint32(O.length);
        var relativeStart = ES.ToInteger(start);
        var actualStart =
          relativeStart < 0
            ? max(len + relativeStart, 0)
            : min(relativeStart, len);
        var actualDeleteCount = min(
          max(ES.ToInteger(deleteCount), 0),
          len - actualStart
        );
        var k = 0;
        var from;
        while (k < actualDeleteCount) {
          from = $String(actualStart + k);
          if (owns(O, from)) {
            A[k] = O[from];
          }
          k += 1;
        }
        var items = arraySlice(arguments, 2);
        var itemCount = items.length;
        var to;
        if (itemCount < actualDeleteCount) {
          k = actualStart;
          var maxK = len - actualDeleteCount;
          while (k < maxK) {
            from = $String(k + actualDeleteCount);
            to = $String(k + itemCount);
            if (owns(O, from)) {
              O[to] = O[from];
            } else {
              delete O[to];
            }
            k += 1;
          }
          k = len;
          var minK = len - actualDeleteCount + itemCount;
          while (k > minK) {
            delete O[k - 1];
            k -= 1;
          }
        } else if (itemCount > actualDeleteCount) {
          k = len - actualDeleteCount;
          while (k > actualStart) {
            from = $String(k + actualDeleteCount - 1);
            to = $String(k + itemCount - 1);
            if (owns(O, from)) {
              O[to] = O[from];
            } else {
              delete O[to];
            }
            k -= 1;
          }
        }
        k = actualStart;
        for (var i = 0; i < items.length; ++i) {
          O[k] = items[i];
          k += 1;
        }
        O.length = len - actualDeleteCount + itemCount;
        return A;
      },
    },
    !spliceWorksWithLargeSparseArrays || !spliceWorksWithSmallSparseArrays
  );
  var originalJoin = ArrayPrototype.join;
  var hasStringJoinBug;
  try {
    hasStringJoinBug = Array.prototype.join.call("123", ",") !== "1,2,3";
  } catch (e) {
    hasStringJoinBug = true;
  }
  if (hasStringJoinBug) {
    defineProperties(
      ArrayPrototype,
      {
        join: function join(separator) {
          var sep = typeof separator === "undefined" ? "," : separator;
          return originalJoin.call(
            isString(this) ? strSplit(this, "") : this,
            sep
          );
        },
      },
      hasStringJoinBug
    );
  }
  var hasJoinUndefinedBug = [1, 2].join(undefined) !== "1,2";
  if (hasJoinUndefinedBug) {
    defineProperties(
      ArrayPrototype,
      {
        join: function join(separator) {
          var sep = typeof separator === "undefined" ? "," : separator;
          return originalJoin.call(this, sep);
        },
      },
      hasJoinUndefinedBug
    );
  }
  var pushShim = function push(item) {
    var O = ES.ToObject(this);
    var n = ES.ToUint32(O.length);
    var i = 0;
    while (i < arguments.length) {
      O[n + i] = arguments[i];
      i += 1;
    }
    O.length = n + i;
    return n + i;
  };
  var pushIsNotGeneric = (function () {
    var obj = {};
    var result = Array.prototype.push.call(obj, undefined);
    return (
      result !== 1 ||
      obj.length !== 1 ||
      typeof obj[0] !== "undefined" ||
      !owns(obj, 0)
    );
  })();
  defineProperties(
    ArrayPrototype,
    {
      push: function push(item) {
        if (isArray(this)) {
          return array_push.apply(this, arguments);
        }
        return pushShim.apply(this, arguments);
      },
    },
    pushIsNotGeneric
  );
  var pushUndefinedIsWeird = (function () {
    var arr = [];
    var result = arr.push(undefined);
    return (
      result !== 1 ||
      arr.length !== 1 ||
      typeof arr[0] !== "undefined" ||
      !owns(arr, 0)
    );
  })();
  defineProperties(ArrayPrototype, { push: pushShim }, pushUndefinedIsWeird);
  defineProperties(
    ArrayPrototype,
    {
      slice: function (start, end) {
        var arr = isString(this) ? strSplit(this, "") : this;
        return arraySliceApply(arr, arguments);
      },
    },
    splitString
  );
  var sortIgnoresNonFunctions = (function () {
    try {
      [1, 2].sort(null);
      [1, 2].sort({});
      return true;
    } catch (e) {}
    return false;
  })();
  var sortThrowsOnRegex = (function () {
    try {
      [1, 2].sort(/a/);
      return false;
    } catch (e) {}
    return true;
  })();
  var sortIgnoresUndefined = (function () {
    try {
      [1, 2].sort(undefined);
      return true;
    } catch (e) {}
    return false;
  })();
  defineProperties(
    ArrayPrototype,
    {
      sort: function sort(compareFn) {
        if (typeof compareFn === "undefined") {
          return arraySort(this);
        }
        if (!isCallable(compareFn)) {
          throw new TypeError(
            "Array.prototype.sort callback must be a function"
          );
        }
        return arraySort(this, compareFn);
      },
    },
    sortIgnoresNonFunctions || !sortIgnoresUndefined || !sortThrowsOnRegex
  );
  var hasDontEnumBug = !isEnum({ toString: null }, "toString");
  var hasProtoEnumBug = isEnum(function () {}, "prototype");
  var hasStringEnumBug = !owns("x", "0");
  var equalsConstructorPrototype = function (o) {
    var ctor = o.constructor;
    return ctor && ctor.prototype === o;
  };
  var blacklistedKeys = {
    $window: true,
    $console: true,
    $parent: true,
    $self: true,
    $frame: true,
    $frames: true,
    $frameElement: true,
    $webkitIndexedDB: true,
    $webkitStorageInfo: true,
    $external: true,
  };
  var hasAutomationEqualityBug = (function () {
    if (typeof window === "undefined") {
      return false;
    }
    for (var k in window) {
      try {
        if (
          !blacklistedKeys["$" + k] &&
          owns(window, k) &&
          window[k] !== null &&
          typeof window[k] === "object"
        ) {
          equalsConstructorPrototype(window[k]);
        }
      } catch (e) {
        return true;
      }
    }
    return false;
  })();
  var equalsConstructorPrototypeIfNotBuggy = function (object) {
    if (typeof window === "undefined" || !hasAutomationEqualityBug) {
      return equalsConstructorPrototype(object);
    }
    try {
      return equalsConstructorPrototype(object);
    } catch (e) {
      return false;
    }
  };
  var dontEnums = [
    "toString",
    "toLocaleString",
    "valueOf",
    "hasOwnProperty",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "constructor",
  ];
  var dontEnumsLength = dontEnums.length;
  var isStandardArguments = function isArguments(value) {
    return toStr(value) === "[object Arguments]";
  };
  var isLegacyArguments = function isArguments(value) {
    return (
      value !== null &&
      typeof value === "object" &&
      typeof value.length === "number" &&
      value.length >= 0 &&
      !isArray(value) &&
      isCallable(value.callee)
    );
  };
  var isArguments = isStandardArguments(arguments)
    ? isStandardArguments
    : isLegacyArguments;
  defineProperties($Object, {
    keys: function keys(object) {
      var isFn = isCallable(object);
      var isArgs = isArguments(object);
      var isObject = object !== null && typeof object === "object";
      var isStr = isObject && isString(object);
      if (!isObject && !isFn && !isArgs) {
        throw new TypeError("Object.keys called on a non-object");
      }
      var theKeys = [];
      var skipProto = hasProtoEnumBug && isFn;
      if ((isStr && hasStringEnumBug) || isArgs) {
        for (var i = 0; i < object.length; ++i) {
          pushCall(theKeys, $String(i));
        }
      }
      if (!isArgs) {
        for (var name in object) {
          if (!(skipProto && name === "prototype") && owns(object, name)) {
            pushCall(theKeys, $String(name));
          }
        }
      }
      if (hasDontEnumBug) {
        var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
        for (var j = 0; j < dontEnumsLength; j++) {
          var dontEnum = dontEnums[j];
          if (
            !(skipConstructor && dontEnum === "constructor") &&
            owns(object, dontEnum)
          ) {
            pushCall(theKeys, dontEnum);
          }
        }
      }
      return theKeys;
    },
  });
  var keysWorksWithArguments =
    $Object.keys &&
    (function () {
      return $Object.keys(arguments).length === 2;
    })(1, 2);
  var keysHasArgumentsLengthBug =
    $Object.keys &&
    (function () {
      var argKeys = $Object.keys(arguments);
      return arguments.length !== 1 || argKeys.length !== 1 || argKeys[0] !== 1;
    })(1);
  var originalKeys = $Object.keys;
  defineProperties(
    $Object,
    {
      keys: function keys(object) {
        if (isArguments(object)) {
          return originalKeys(arraySlice(object));
        } else {
          return originalKeys(object);
        }
      },
    },
    !keysWorksWithArguments || keysHasArgumentsLengthBug
  );
  var hasNegativeMonthYearBug = new Date(-0xc782b5b342b24).getUTCMonth() !== 0;
  var aNegativeTestDate = new Date(-0x55d318d56a724);
  var aPositiveTestDate = new Date(14496624e5);
  var hasToUTCStringFormatBug =
    aNegativeTestDate.toUTCString() !== "Mon, 01 Jan -45875 11:59:59 GMT";
  var hasToDateStringFormatBug;
  var hasToStringFormatBug;
  var timeZoneOffset = aNegativeTestDate.getTimezoneOffset();
  if (timeZoneOffset < -720) {
    hasToDateStringFormatBug =
      aNegativeTestDate.toDateString() !== "Tue Jan 02 -45875";
    hasToStringFormatBug =
      !/^Thu Dec 10 2015 \d\d:\d\d:\d\d GMT[-\+]\d\d\d\d(?: |$)/.test(
        aPositiveTestDate.toString()
      );
  } else {
    hasToDateStringFormatBug =
      aNegativeTestDate.toDateString() !== "Mon Jan 01 -45875";
    hasToStringFormatBug =
      !/^Wed Dec 09 2015 \d\d:\d\d:\d\d GMT[-\+]\d\d\d\d(?: |$)/.test(
        aPositiveTestDate.toString()
      );
  }
  var originalGetFullYear = call.bind(Date.prototype.getFullYear);
  var originalGetMonth = call.bind(Date.prototype.getMonth);
  var originalGetDate = call.bind(Date.prototype.getDate);
  var originalGetUTCFullYear = call.bind(Date.prototype.getUTCFullYear);
  var originalGetUTCMonth = call.bind(Date.prototype.getUTCMonth);
  var originalGetUTCDate = call.bind(Date.prototype.getUTCDate);
  var originalGetUTCDay = call.bind(Date.prototype.getUTCDay);
  var originalGetUTCHours = call.bind(Date.prototype.getUTCHours);
  var originalGetUTCMinutes = call.bind(Date.prototype.getUTCMinutes);
  var originalGetUTCSeconds = call.bind(Date.prototype.getUTCSeconds);
  var originalGetUTCMilliseconds = call.bind(Date.prototype.getUTCMilliseconds);
  var dayName = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
  var monthName = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec",
  ];
  var daysInMonth = function daysInMonth(month, year) {
    return originalGetDate(new Date(year, month, 0));
  };
  defineProperties(
    Date.prototype,
    {
      getFullYear: function getFullYear() {
        if (!this || !(this instanceof Date)) {
          throw new TypeError("this is not a Date object.");
        }
        var year = originalGetFullYear(this);
        if (year < 0 && originalGetMonth(this) > 11) {
          return year + 1;
        }
        return year;
      },
      getMonth: function getMonth() {
        if (!this || !(this instanceof Date)) {
          throw new TypeError("this is not a Date object.");
        }
        var year = originalGetFullYear(this);
        var month = originalGetMonth(this);
        if (year < 0 && month > 11) {
          return 0;
        }
        return month;
      },
      getDate: function getDate() {
        if (!this || !(this instanceof Date)) {
          throw new TypeError("this is not a Date object.");
        }
        var year = originalGetFullYear(this);
        var month = originalGetMonth(this);
        var date = originalGetDate(this);
        if (year < 0 && month > 11) {
          if (month === 12) {
            return date;
          }
          var days = daysInMonth(0, year + 1);
          return days - date + 1;
        }
        return date;
      },
      getUTCFullYear: function getUTCFullYear() {
        if (!this || !(this instanceof Date)) {
          throw new TypeError("this is not a Date object.");
        }
        var year = originalGetUTCFullYear(this);
        if (year < 0 && originalGetUTCMonth(this) > 11) {
          return year + 1;
        }
        return year;
      },
      getUTCMonth: function getUTCMonth() {
        if (!this || !(this instanceof Date)) {
          throw new TypeError("this is not a Date object.");
        }
        var year = originalGetUTCFullYear(this);
        var month = originalGetUTCMonth(this);
        if (year < 0 && month > 11) {
          return 0;
        }
        return month;
      },
      getUTCDate: function getUTCDate() {
        if (!this || !(this instanceof Date)) {
          throw new TypeError("this is not a Date object.");
        }
        var year = originalGetUTCFullYear(this);
        var month = originalGetUTCMonth(this);
        var date = originalGetUTCDate(this);
        if (year < 0 && month > 11) {
          if (month === 12) {
            return date;
          }
          var days = daysInMonth(0, year + 1);
          return days - date + 1;
        }
        return date;
      },
    },
    hasNegativeMonthYearBug
  );
  defineProperties(
    Date.prototype,
    {
      toUTCString: function toUTCString() {
        if (!this || !(this instanceof Date)) {
          throw new TypeError("this is not a Date object.");
        }
        var day = originalGetUTCDay(this);
        var date = originalGetUTCDate(this);
        var month = originalGetUTCMonth(this);
        var year = originalGetUTCFullYear(this);
        var hour = originalGetUTCHours(this);
        var minute = originalGetUTCMinutes(this);
        var second = originalGetUTCSeconds(this);
        return (
          dayName[day] +
          ", " +
          (date < 10 ? "0" + date : date) +
          " " +
          monthName[month] +
          " " +
          year +
          " " +
          (hour < 10 ? "0" + hour : hour) +
          ":" +
          (minute < 10 ? "0" + minute : minute) +
          ":" +
          (second < 10 ? "0" + second : second) +
          " GMT"
        );
      },
    },
    hasNegativeMonthYearBug || hasToUTCStringFormatBug
  );
  defineProperties(
    Date.prototype,
    {
      toDateString: function toDateString() {
        if (!this || !(this instanceof Date)) {
          throw new TypeError("this is not a Date object.");
        }
        var day = this.getDay();
        var date = this.getDate();
        var month = this.getMonth();
        var year = this.getFullYear();
        return (
          dayName[day] +
          " " +
          monthName[month] +
          " " +
          (date < 10 ? "0" + date : date) +
          " " +
          year
        );
      },
    },
    hasNegativeMonthYearBug || hasToDateStringFormatBug
  );
  if (hasNegativeMonthYearBug || hasToStringFormatBug) {
    Date.prototype.toString = function toString() {
      if (!this || !(this instanceof Date)) {
        throw new TypeError("this is not a Date object.");
      }
      var day = this.getDay();
      var date = this.getDate();
      var month = this.getMonth();
      var year = this.getFullYear();
      var hour = this.getHours();
      var minute = this.getMinutes();
      var second = this.getSeconds();
      var timezoneOffset = this.getTimezoneOffset();
      var hoursOffset = Math.floor(Math.abs(timezoneOffset) / 60);
      var minutesOffset = Math.floor(Math.abs(timezoneOffset) % 60);
      return (
        dayName[day] +
        " " +
        monthName[month] +
        " " +
        (date < 10 ? "0" + date : date) +
        " " +
        year +
        " " +
        (hour < 10 ? "0" + hour : hour) +
        ":" +
        (minute < 10 ? "0" + minute : minute) +
        ":" +
        (second < 10 ? "0" + second : second) +
        " GMT" +
        (timezoneOffset > 0 ? "-" : "+") +
        (hoursOffset < 10 ? "0" + hoursOffset : hoursOffset) +
        (minutesOffset < 10 ? "0" + minutesOffset : minutesOffset)
      );
    };
    if (supportsDescriptors) {
      $Object.defineProperty(Date.prototype, "toString", {
        configurable: true,
        enumerable: false,
        writable: true,
      });
    }
  }
  var negativeDate = -621987552e5;
  var negativeYearString = "-000001";
  var hasNegativeDateBug =
    Date.prototype.toISOString &&
    new Date(negativeDate).toISOString().indexOf(negativeYearString) === -1;
  var hasSafari51DateBug =
    Date.prototype.toISOString &&
    new Date(-1).toISOString() !== "1969-12-31T23:59:59.999Z";
  var getTime = call.bind(Date.prototype.getTime);
  defineProperties(
    Date.prototype,
    {
      toISOString: function toISOString() {
        if (!isFinite(this) || !isFinite(getTime(this))) {
          throw new RangeError(
            "Date.prototype.toISOString called on non-finite value."
          );
        }
        var year = originalGetUTCFullYear(this);
        var month = originalGetUTCMonth(this);
        year += Math.floor(month / 12);
        month = ((month % 12) + 12) % 12;
        var result = [
          month + 1,
          originalGetUTCDate(this),
          originalGetUTCHours(this),
          originalGetUTCMinutes(this),
          originalGetUTCSeconds(this),
        ];
        year =
          (year < 0 ? "-" : year > 9999 ? "+" : "") +
          strSlice(
            "00000" + Math.abs(year),
            0 <= year && year <= 9999 ? -4 : -6
          );
        for (var i = 0; i < result.length; ++i) {
          result[i] = strSlice("00" + result[i], -2);
        }
        return (
          year +
          "-" +
          arraySlice(result, 0, 2).join("-") +
          "T" +
          arraySlice(result, 2).join(":") +
          "." +
          strSlice("000" + originalGetUTCMilliseconds(this), -3) +
          "Z"
        );
      },
    },
    hasNegativeDateBug || hasSafari51DateBug
  );
  var dateToJSONIsSupported = (function () {
    try {
      return (
        Date.prototype.toJSON &&
        new Date(NaN).toJSON() === null &&
        new Date(negativeDate).toJSON().indexOf(negativeYearString) !== -1 &&
        Date.prototype.toJSON.call({
          toISOString: function () {
            return true;
          },
        })
      );
    } catch (e) {
      return false;
    }
  })();
  if (!dateToJSONIsSupported) {
    Date.prototype.toJSON = function toJSON(key) {
      var O = $Object(this);
      var tv = ES.ToPrimitive(O);
      if (typeof tv === "number" && !isFinite(tv)) {
        return null;
      }
      var toISO = O.toISOString;
      if (!isCallable(toISO)) {
        throw new TypeError("toISOString property is not callable");
      }
      return toISO.call(O);
    };
  }
  var supportsExtendedYears =
    Date.parse("+033658-09-27T01:46:40.000Z") === 1e15;
  var acceptsInvalidDates =
    !isNaN(Date.parse("2012-04-04T24:00:00.500Z")) ||
    !isNaN(Date.parse("2012-11-31T23:59:59.000Z")) ||
    !isNaN(Date.parse("2012-12-31T23:59:60.000Z"));
  var doesNotParseY2KNewYear = isNaN(Date.parse("2000-01-01T00:00:00.000Z"));
  if (doesNotParseY2KNewYear || acceptsInvalidDates || !supportsExtendedYears) {
    var maxSafeUnsigned32Bit = Math.pow(2, 31) - 1;
    var hasSafariSignedIntBug = isActualNaN(
      new Date(1970, 0, 1, 0, 0, 0, maxSafeUnsigned32Bit + 1).getTime()
    );
    Date = (function (NativeDate) {
      var DateShim = function Date(Y, M, D, h, m, s, ms) {
        var length = arguments.length;
        var date;
        if (this instanceof NativeDate) {
          var seconds = s;
          var millis = ms;
          if (
            hasSafariSignedIntBug &&
            length >= 7 &&
            ms > maxSafeUnsigned32Bit
          ) {
            var msToShift =
              Math.floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
            var sToShift = Math.floor(msToShift / 1e3);
            seconds += sToShift;
            millis -= sToShift * 1e3;
          }
          date =
            length === 1 && $String(Y) === Y
              ? new NativeDate(DateShim.parse(Y))
              : length >= 7
              ? new NativeDate(Y, M, D, h, m, seconds, millis)
              : length >= 6
              ? new NativeDate(Y, M, D, h, m, seconds)
              : length >= 5
              ? new NativeDate(Y, M, D, h, m)
              : length >= 4
              ? new NativeDate(Y, M, D, h)
              : length >= 3
              ? new NativeDate(Y, M, D)
              : length >= 2
              ? new NativeDate(Y, M)
              : length >= 1
              ? new NativeDate(Y instanceof NativeDate ? +Y : Y)
              : new NativeDate();
        } else {
          date = NativeDate.apply(this, arguments);
        }
        if (!isPrimitive(date)) {
          defineProperties(date, { constructor: DateShim }, true);
        }
        return date;
      };
      var isoDateExpression = new RegExp(
        "^" +
          "(\\d{4}|[+-]\\d{6})" +
          "(?:-(\\d{2})" +
          "(?:-(\\d{2})" +
          "(?:" +
          "T(\\d{2})" +
          ":(\\d{2})" +
          "(?:" +
          ":(\\d{2})" +
          "(?:(\\.\\d{1,}))?" +
          ")?" +
          "(" +
          "Z|" +
          "(?:" +
          "([-+])" +
          "(\\d{2})" +
          ":(\\d{2})" +
          ")" +
          ")?)?)?)?" +
          "$"
      );
      var months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];
      var dayFromMonth = function dayFromMonth(year, month) {
        var t = month > 1 ? 1 : 0;
        return (
          months[month] +
          Math.floor((year - 1969 + t) / 4) -
          Math.floor((year - 1901 + t) / 100) +
          Math.floor((year - 1601 + t) / 400) +
          365 * (year - 1970)
        );
      };
      var toUTC = function toUTC(t) {
        var s = 0;
        var ms = t;
        if (hasSafariSignedIntBug && ms > maxSafeUnsigned32Bit) {
          var msToShift =
            Math.floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
          var sToShift = Math.floor(msToShift / 1e3);
          s += sToShift;
          ms -= sToShift * 1e3;
        }
        return $Number(new NativeDate(1970, 0, 1, 0, 0, s, ms));
      };
      for (var key in NativeDate) {
        if (owns(NativeDate, key)) {
          DateShim[key] = NativeDate[key];
        }
      }
      defineProperties(
        DateShim,
        { now: NativeDate.now, UTC: NativeDate.UTC },
        true
      );
      DateShim.prototype = NativeDate.prototype;
      defineProperties(DateShim.prototype, { constructor: DateShim }, true);
      var parseShim = function parse(string) {
        var match = isoDateExpression.exec(string);
        if (match) {
          var year = $Number(match[1]),
            month = $Number(match[2] || 1) - 1,
            day = $Number(match[3] || 1) - 1,
            hour = $Number(match[4] || 0),
            minute = $Number(match[5] || 0),
            second = $Number(match[6] || 0),
            millisecond = Math.floor($Number(match[7] || 0) * 1e3),
            isLocalTime = Boolean(match[4] && !match[8]),
            signOffset = match[9] === "-" ? 1 : -1,
            hourOffset = $Number(match[10] || 0),
            minuteOffset = $Number(match[11] || 0),
            result;
          var hasMinutesOrSecondsOrMilliseconds =
            minute > 0 || second > 0 || millisecond > 0;
          if (
            hour < (hasMinutesOrSecondsOrMilliseconds ? 24 : 25) &&
            minute < 60 &&
            second < 60 &&
            millisecond < 1e3 &&
            month > -1 &&
            month < 12 &&
            hourOffset < 24 &&
            minuteOffset < 60 &&
            day > -1 &&
            day < dayFromMonth(year, month + 1) - dayFromMonth(year, month)
          ) {
            result =
              ((dayFromMonth(year, month) + day) * 24 +
                hour +
                hourOffset * signOffset) *
              60;
            result =
              ((result + minute + minuteOffset * signOffset) * 60 + second) *
                1e3 +
              millisecond;
            if (isLocalTime) {
              result = toUTC(result);
            }
            if (-864e13 <= result && result <= 864e13) {
              return result;
            }
          }
          return NaN;
        }
        return NativeDate.parse.apply(this, arguments);
      };
      defineProperties(DateShim, { parse: parseShim });
      return DateShim;
    })(Date);
  }
  if (!Date.now) {
    Date.now = function now() {
      return new Date().getTime();
    };
  }
  var hasToFixedBugs =
    NumberPrototype.toFixed &&
    ((8e-5).toFixed(3) !== "0.000" ||
      (0.9).toFixed(0) !== "1" ||
      (1.255).toFixed(2) !== "1.25" ||
      (0xde0b6b3a7640080).toFixed(0) !== "1000000000000000128");
  var toFixedHelpers = {
    base: 1e7,
    size: 6,
    data: [0, 0, 0, 0, 0, 0],
    multiply: function multiply(n, c) {
      var i = -1;
      var c2 = c;
      while (++i < toFixedHelpers.size) {
        c2 += n * toFixedHelpers.data[i];
        toFixedHelpers.data[i] = c2 % toFixedHelpers.base;
        c2 = Math.floor(c2 / toFixedHelpers.base);
      }
    },
    divide: function divide(n) {
      var i = toFixedHelpers.size;
      var c = 0;
      while (--i >= 0) {
        c += toFixedHelpers.data[i];
        toFixedHelpers.data[i] = Math.floor(c / n);
        c = (c % n) * toFixedHelpers.base;
      }
    },
    numToString: function numToString() {
      var i = toFixedHelpers.size;
      var s = "";
      while (--i >= 0) {
        if (s !== "" || i === 0 || toFixedHelpers.data[i] !== 0) {
          var t = $String(toFixedHelpers.data[i]);
          if (s === "") {
            s = t;
          } else {
            s += strSlice("0000000", 0, 7 - t.length) + t;
          }
        }
      }
      return s;
    },
    pow: function pow(x, n, acc) {
      return n === 0
        ? acc
        : n % 2 === 1
        ? pow(x, n - 1, acc * x)
        : pow(x * x, n / 2, acc);
    },
    log: function log(x) {
      var n = 0;
      var x2 = x;
      while (x2 >= 4096) {
        n += 12;
        x2 /= 4096;
      }
      while (x2 >= 2) {
        n += 1;
        x2 /= 2;
      }
      return n;
    },
  };
  var toFixedShim = function toFixed(fractionDigits) {
    var f, x, s, m, e, z, j, k;
    f = $Number(fractionDigits);
    f = isActualNaN(f) ? 0 : Math.floor(f);
    if (f < 0 || f > 20) {
      throw new RangeError(
        "Number.toFixed called with invalid number of decimals"
      );
    }
    x = $Number(this);
    if (isActualNaN(x)) {
      return "NaN";
    }
    if (x <= -1e21 || x >= 1e21) {
      return $String(x);
    }
    s = "";
    if (x < 0) {
      s = "-";
      x = -x;
    }
    m = "0";
    if (x > 1e-21) {
      e = toFixedHelpers.log(x * toFixedHelpers.pow(2, 69, 1)) - 69;
      z =
        e < 0
          ? x * toFixedHelpers.pow(2, -e, 1)
          : x / toFixedHelpers.pow(2, e, 1);
      z *= 4503599627370496;
      e = 52 - e;
      if (e > 0) {
        toFixedHelpers.multiply(0, z);
        j = f;
        while (j >= 7) {
          toFixedHelpers.multiply(1e7, 0);
          j -= 7;
        }
        toFixedHelpers.multiply(toFixedHelpers.pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          toFixedHelpers.divide(1 << 23);
          j -= 23;
        }
        toFixedHelpers.divide(1 << j);
        toFixedHelpers.multiply(1, 1);
        toFixedHelpers.divide(2);
        m = toFixedHelpers.numToString();
      } else {
        toFixedHelpers.multiply(0, z);
        toFixedHelpers.multiply(1 << -e, 0);
        m =
          toFixedHelpers.numToString() +
          strSlice("0.00000000000000000000", 2, 2 + f);
      }
    }
    if (f > 0) {
      k = m.length;
      if (k <= f) {
        m = s + strSlice("0.0000000000000000000", 0, f - k + 2) + m;
      } else {
        m = s + strSlice(m, 0, k - f) + "." + strSlice(m, k - f);
      }
    } else {
      m = s + m;
    }
    return m;
  };
  defineProperties(NumberPrototype, { toFixed: toFixedShim }, hasToFixedBugs);
  var hasToPrecisionUndefinedBug = (function () {
    try {
      return (1).toPrecision(undefined) === "1";
    } catch (e) {
      return true;
    }
  })();
  var originalToPrecision = NumberPrototype.toPrecision;
  defineProperties(
    NumberPrototype,
    {
      toPrecision: function toPrecision(precision) {
        return typeof precision === "undefined"
          ? originalToPrecision.call(this)
          : originalToPrecision.call(this, precision);
      },
    },
    hasToPrecisionUndefinedBug
  );
  if (
    "ab".split(/(?:ab)*/).length !== 2 ||
    ".".split(/(.?)(.?)/).length !== 4 ||
    "tesst".split(/(s)*/)[1] === "t" ||
    "test".split(/(?:)/, -1).length !== 4 ||
    "".split(/.?/).length ||
    ".".split(/()()/).length > 1
  ) {
    (function () {
      var compliantExecNpcg = typeof /()??/.exec("")[1] === "undefined";
      var maxSafe32BitInt = Math.pow(2, 32) - 1;
      StringPrototype.split = function (separator, limit) {
        var string = String(this);
        if (typeof separator === "undefined" && limit === 0) {
          return [];
        }
        if (!isRegex(separator)) {
          return strSplit(this, separator, limit);
        }
        var output = [];
        var flags =
            (separator.ignoreCase ? "i" : "") +
            (separator.multiline ? "m" : "") +
            (separator.unicode ? "u" : "") +
            (separator.sticky ? "y" : ""),
          lastLastIndex = 0,
          separator2,
          match,
          lastIndex,
          lastLength;
        var separatorCopy = new RegExp(separator.source, flags + "g");
        if (!compliantExecNpcg) {
          separator2 = new RegExp(
            "^" + separatorCopy.source + "$(?!\\s)",
            flags
          );
        }
        var splitLimit =
          typeof limit === "undefined" ? maxSafe32BitInt : ES.ToUint32(limit);
        match = separatorCopy.exec(string);
        while (match) {
          lastIndex = match.index + match[0].length;
          if (lastIndex > lastLastIndex) {
            pushCall(output, strSlice(string, lastLastIndex, match.index));
            if (!compliantExecNpcg && match.length > 1) {
              match[0].replace(separator2, function () {
                for (var i = 1; i < arguments.length - 2; i++) {
                  if (typeof arguments[i] === "undefined") {
                    match[i] = void 0;
                  }
                }
              });
            }
            if (match.length > 1 && match.index < string.length) {
              array_push.apply(output, arraySlice(match, 1));
            }
            lastLength = match[0].length;
            lastLastIndex = lastIndex;
            if (output.length >= splitLimit) {
              break;
            }
          }
          if (separatorCopy.lastIndex === match.index) {
            separatorCopy.lastIndex++;
          }
          match = separatorCopy.exec(string);
        }
        if (lastLastIndex === string.length) {
          if (lastLength || !separatorCopy.test("")) {
            pushCall(output, "");
          }
        } else {
          pushCall(output, strSlice(string, lastLastIndex));
        }
        return output.length > splitLimit
          ? arraySlice(output, 0, splitLimit)
          : output;
      };
    })();
  } else if ("0".split(void 0, 0).length) {
    StringPrototype.split = function split(separator, limit) {
      if (typeof separator === "undefined" && limit === 0) {
        return [];
      }
      return strSplit(this, separator, limit);
    };
  }
  var str_replace = StringPrototype.replace;
  var replaceReportsGroupsCorrectly = (function () {
    var groups = [];
    "x".replace(/x(.)?/g, function (match, group) {
      pushCall(groups, group);
    });
    return groups.length === 1 && typeof groups[0] === "undefined";
  })();
  if (!replaceReportsGroupsCorrectly) {
    StringPrototype.replace = function replace(searchValue, replaceValue) {
      var isFn = isCallable(replaceValue);
      var hasCapturingGroups =
        isRegex(searchValue) && /\)[*?]/.test(searchValue.source);
      if (!isFn || !hasCapturingGroups) {
        return str_replace.call(this, searchValue, replaceValue);
      } else {
        var wrappedReplaceValue = function (match) {
          var length = arguments.length;
          var originalLastIndex = searchValue.lastIndex;
          searchValue.lastIndex = 0;
          var args = searchValue.exec(match) || [];
          searchValue.lastIndex = originalLastIndex;
          pushCall(args, arguments[length - 2], arguments[length - 1]);
          return replaceValue.apply(this, args);
        };
        return str_replace.call(this, searchValue, wrappedReplaceValue);
      }
    };
  }
  var string_substr = StringPrototype.substr;
  var hasNegativeSubstrBug = "".substr && "0b".substr(-1) !== "b";
  defineProperties(
    StringPrototype,
    {
      substr: function substr(start, length) {
        var normalizedStart = start;
        if (start < 0) {
          normalizedStart = max(this.length + start, 0);
        }
        return string_substr.call(this, normalizedStart, length);
      },
    },
    hasNegativeSubstrBug
  );
  var ws = "\t\n\v\f\r " + "\u2028" + "\u2029\ufeff";
  var zeroWidth = "";
  var wsRegexChars = "[" + ws + "]";
  var trimBeginRegexp = new RegExp("^" + wsRegexChars + wsRegexChars + "*");
  var trimEndRegexp = new RegExp(wsRegexChars + wsRegexChars + "*$");
  var hasTrimWhitespaceBug =
    StringPrototype.trim && (ws.trim() || !zeroWidth.trim());
  defineProperties(
    StringPrototype,
    {
      trim: function trim() {
        if (typeof this === "undefined" || this === null) {
          throw new TypeError("can't convert " + this + " to object");
        }
        return $String(this)
          .replace(trimBeginRegexp, "")
          .replace(trimEndRegexp, "");
      },
    },
    hasTrimWhitespaceBug
  );
  var trim = call.bind(String.prototype.trim);
  var hasLastIndexBug =
    StringPrototype.lastIndexOf && "abc".lastIndexOf("", 2) !== -1;
  defineProperties(
    StringPrototype,
    {
      lastIndexOf: function lastIndexOf(searchString) {
        if (typeof this === "undefined" || this === null) {
          throw new TypeError("can't convert " + this + " to object");
        }
        var S = $String(this);
        var searchStr = $String(searchString);
        var numPos = arguments.length > 1 ? $Number(arguments[1]) : NaN;
        var pos = isActualNaN(numPos) ? Infinity : ES.ToInteger(numPos);
        var start = min(max(pos, 0), S.length);
        var searchLen = searchStr.length;
        var k = start + searchLen;
        while (k > 0) {
          k = max(0, k - searchLen);
          var index = strIndexOf(strSlice(S, k, start + searchLen), searchStr);
          if (index !== -1) {
            return k + index;
          }
        }
        return -1;
      },
    },
    hasLastIndexBug
  );
  var originalLastIndexOf = StringPrototype.lastIndexOf;
  defineProperties(
    StringPrototype,
    {
      lastIndexOf: function lastIndexOf(searchString) {
        return originalLastIndexOf.apply(this, arguments);
      },
    },
    StringPrototype.lastIndexOf.length !== 1
  );
  if (parseInt(ws + "08") !== 8 || parseInt(ws + "0x16") !== 22) {
    parseInt = (function (origParseInt) {
      var hexRegex = /^[\-+]?0[xX]/;
      return function parseInt(str, radix) {
        var string = trim(String(str));
        var defaultedRadix =
          $Number(radix) || (hexRegex.test(string) ? 16 : 10);
        return origParseInt(string, defaultedRadix);
      };
    })(parseInt);
  }
  if (1 / parseFloat("-0") !== -Infinity) {
    parseFloat = (function (origParseFloat) {
      return function parseFloat(string) {
        var inputString = trim(String(string));
        var result = origParseFloat(inputString);
        return result === 0 && strSlice(inputString, 0, 1) === "-"
          ? -0
          : result;
      };
    })(parseFloat);
  }
  if (String(new RangeError("test")) !== "RangeError: test") {
    var errorToStringShim = function toString() {
      if (typeof this === "undefined" || this === null) {
        throw new TypeError("can't convert " + this + " to object");
      }
      var name = this.name;
      if (typeof name === "undefined") {
        name = "Error";
      } else if (typeof name !== "string") {
        name = $String(name);
      }
      var msg = this.message;
      if (typeof msg === "undefined") {
        msg = "";
      } else if (typeof msg !== "string") {
        msg = $String(msg);
      }
      if (!name) {
        return msg;
      }
      if (!msg) {
        return name;
      }
      return name + ": " + msg;
    };
    Error.prototype.toString = errorToStringShim;
  }
  if (supportsDescriptors) {
    var ensureNonEnumerable = function (obj, prop) {
      if (isEnum(obj, prop)) {
        var desc = Object.getOwnPropertyDescriptor(obj, prop);
        if (desc.configurable) {
          desc.enumerable = false;
          Object.defineProperty(obj, prop, desc);
        }
      }
    };
    ensureNonEnumerable(Error.prototype, "message");
    if (Error.prototype.message !== "") {
      Error.prototype.message = "";
    }
    ensureNonEnumerable(Error.prototype, "name");
  }
  if (String(/a/gim) !== "/a/gim") {
    var regexToString = function toString() {
      var str = "/" + this.source + "/";
      if (this.global) {
        str += "g";
      }
      if (this.ignoreCase) {
        str += "i";
      }
      if (this.multiline) {
        str += "m";
      }
      return str;
    };
    RegExp.prototype.toString = regexToString;
  }
});
if (
  typeof module !== "undefined" &&
  typeof exports !== "undefined" &&
  module.exports === exports
) {
  module.exports = "ui.router";
}
(function (window, angular, undefined) {
  "use strict";
  var isDefined = angular.isDefined,
    isFunction = angular.isFunction,
    isString = angular.isString,
    isObject = angular.isObject,
    isArray = angular.isArray,
    forEach = angular.forEach,
    extend = angular.extend,
    copy = angular.copy,
    toJson = angular.toJson;
  function inherit(parent, extra) {
    return extend(new (extend(function () {}, { prototype: parent }))(), extra);
  }
  function merge(dst) {
    forEach(arguments, function (obj) {
      if (obj !== dst) {
        forEach(obj, function (value, key) {
          if (!dst.hasOwnProperty(key)) dst[key] = value;
        });
      }
    });
    return dst;
  }
  function ancestors(first, second) {
    var path = [];
    for (var n in first.path) {
      if (first.path[n] !== second.path[n]) break;
      path.push(first.path[n]);
    }
    return path;
  }
  function objectKeys(object) {
    if (Object.keys) {
      return Object.keys(object);
    }
    var result = [];
    forEach(object, function (val, key) {
      result.push(key);
    });
    return result;
  }
  function indexOf(array, value) {
    if (Array.prototype.indexOf) {
      return array.indexOf(value, Number(arguments[2]) || 0);
    }
    var len = array.length >>> 0,
      from = Number(arguments[2]) || 0;
    from = from < 0 ? Math.ceil(from) : Math.floor(from);
    if (from < 0) from += len;
    for (; from < len; from++) {
      if (from in array && array[from] === value) return from;
    }
    return -1;
  }
  function inheritParams(currentParams, newParams, $current, $to) {
    var parents = ancestors($current, $to),
      parentParams,
      inherited = {},
      inheritList = [];
    for (var i in parents) {
      if (!parents[i] || !parents[i].params) continue;
      parentParams = objectKeys(parents[i].params);
      if (!parentParams.length) continue;
      for (var j in parentParams) {
        if (indexOf(inheritList, parentParams[j]) >= 0) continue;
        inheritList.push(parentParams[j]);
        inherited[parentParams[j]] = currentParams[parentParams[j]];
      }
    }
    return extend({}, inherited, newParams);
  }
  function equalForKeys(a, b, keys) {
    if (!keys) {
      keys = [];
      for (var n in a) keys.push(n);
    }
    for (var i = 0; i < keys.length; i++) {
      var k = keys[i];
      if (a[k] != b[k]) return false;
    }
    return true;
  }
  function filterByKeys(keys, values) {
    var filtered = {};
    forEach(keys, function (name) {
      filtered[name] = values[name];
    });
    return filtered;
  }
  function indexBy(array, propName) {
    var result = {};
    forEach(array, function (item) {
      result[item[propName]] = item;
    });
    return result;
  }
  function pick(obj) {
    var copy = {};
    var keys = Array.prototype.concat.apply(
      Array.prototype,
      Array.prototype.slice.call(arguments, 1)
    );
    forEach(keys, function (key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  }
  function omit(obj) {
    var copy = {};
    var keys = Array.prototype.concat.apply(
      Array.prototype,
      Array.prototype.slice.call(arguments, 1)
    );
    for (var key in obj) {
      if (indexOf(keys, key) == -1) copy[key] = obj[key];
    }
    return copy;
  }
  function pluck(collection, key) {
    var result = isArray(collection) ? [] : {};
    forEach(collection, function (val, i) {
      result[i] = isFunction(key) ? key(val) : val[key];
    });
    return result;
  }
  function filter(collection, callback) {
    var array = isArray(collection);
    var result = array ? [] : {};
    forEach(collection, function (val, i) {
      if (callback(val, i)) {
        result[array ? result.length : i] = val;
      }
    });
    return result;
  }
  function map(collection, callback) {
    var result = isArray(collection) ? [] : {};
    forEach(collection, function (val, i) {
      result[i] = callback(val, i);
    });
    return result;
  }
  function silenceUncaughtInPromise(promise) {
    return promise.then(undefined, function () {}) && promise;
  }
  angular.module("ui.router.util", ["ng"]);
  angular.module("ui.router.router", ["ui.router.util"]);
  angular.module("ui.router.state", ["ui.router.router", "ui.router.util"]);
  angular.module("ui.router", ["ui.router.state"]);
  angular.module("ui.router.compat", ["ui.router"]);
  $Resolve.$inject = ["$q", "$injector"];
  function $Resolve($q, $injector) {
    var VISIT_IN_PROGRESS = 1,
      VISIT_DONE = 2,
      NOTHING = {},
      NO_DEPENDENCIES = [],
      NO_LOCALS = NOTHING,
      NO_PARENT = extend($q.when(NOTHING), {
        $$promises: NOTHING,
        $$values: NOTHING,
      });
    this.study = function (invocables) {
      if (!isObject(invocables))
        throw new Error("'invocables' must be an object");
      var invocableKeys = objectKeys(invocables || {});
      var plan = [],
        cycle = [],
        visited = {};
      function visit(value, key) {
        if (visited[key] === VISIT_DONE) return;
        cycle.push(key);
        if (visited[key] === VISIT_IN_PROGRESS) {
          cycle.splice(0, indexOf(cycle, key));
          throw new Error("Cyclic dependency: " + cycle.join(" -> "));
        }
        visited[key] = VISIT_IN_PROGRESS;
        if (isString(value)) {
          plan.push(
            key,
            [
              function () {
                return $injector.get(value);
              },
            ],
            NO_DEPENDENCIES
          );
        } else {
          var params = $injector.annotate(value);
          forEach(params, function (param) {
            if (param !== key && invocables.hasOwnProperty(param))
              visit(invocables[param], param);
          });
          plan.push(key, value, params);
        }
        cycle.pop();
        visited[key] = VISIT_DONE;
      }
      forEach(invocables, visit);
      invocables = cycle = visited = null;
      function isResolve(value) {
        return isObject(value) && value.then && value.$$promises;
      }
      return function (locals, parent, self) {
        if (isResolve(locals) && self === undefined) {
          self = parent;
          parent = locals;
          locals = null;
        }
        if (!locals) locals = NO_LOCALS;
        else if (!isObject(locals)) {
          throw new Error("'locals' must be an object");
        }
        if (!parent) parent = NO_PARENT;
        else if (!isResolve(parent)) {
          throw new Error(
            "'parent' must be a promise returned by $resolve.resolve()"
          );
        }
        var resolution = $q.defer(),
          result = silenceUncaughtInPromise(resolution.promise),
          promises = (result.$$promises = {}),
          values = extend({}, locals),
          wait = 1 + plan.length / 3,
          merged = false;
        silenceUncaughtInPromise(result);
        function done() {
          if (!--wait) {
            if (!merged) merge(values, parent.$$values);
            result.$$values = values;
            result.$$promises = result.$$promises || true;
            delete result.$$inheritedValues;
            resolution.resolve(values);
          }
        }
        function fail(reason) {
          result.$$failure = reason;
          resolution.reject(reason);
        }
        if (isDefined(parent.$$failure)) {
          fail(parent.$$failure);
          return result;
        }
        if (parent.$$inheritedValues) {
          merge(values, omit(parent.$$inheritedValues, invocableKeys));
        }
        extend(promises, parent.$$promises);
        if (parent.$$values) {
          merged = merge(values, omit(parent.$$values, invocableKeys));
          result.$$inheritedValues = omit(parent.$$values, invocableKeys);
          done();
        } else {
          if (parent.$$inheritedValues) {
            result.$$inheritedValues = omit(
              parent.$$inheritedValues,
              invocableKeys
            );
          }
          parent.then(done, fail);
        }
        for (var i = 0, ii = plan.length; i < ii; i += 3) {
          if (locals.hasOwnProperty(plan[i])) done();
          else invoke(plan[i], plan[i + 1], plan[i + 2]);
        }
        function invoke(key, invocable, params) {
          var invocation = $q.defer(),
            waitParams = 0;
          function onfailure(reason) {
            invocation.reject(reason);
            fail(reason);
          }
          forEach(params, function (dep) {
            if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
              waitParams++;
              promises[dep].then(function (result) {
                values[dep] = result;
                if (!--waitParams) proceed();
              }, onfailure);
            }
          });
          if (!waitParams) proceed();
          function proceed() {
            if (isDefined(result.$$failure)) return;
            try {
              invocation.resolve($injector.invoke(invocable, self, values));
              invocation.promise.then(function (result) {
                values[key] = result;
                done();
              }, onfailure);
            } catch (e) {
              onfailure(e);
            }
          }
          promises[key] = silenceUncaughtInPromise(invocation.promise);
        }
        return result;
      };
    };
    this.resolve = function (invocables, locals, parent, self) {
      return this.study(invocables)(locals, parent, self);
    };
  }
  angular.module("ui.router.util").service("$resolve", $Resolve);
  function TemplateFactoryProvider() {
    var shouldUnsafelyUseHttp = angular.version.minor < 3;
    this.shouldUnsafelyUseHttp = function (value) {
      shouldUnsafelyUseHttp = !!value;
    };
    this.$get = [
      "$http",
      "$templateCache",
      "$injector",
      function ($http, $templateCache, $injector) {
        return new TemplateFactory(
          $http,
          $templateCache,
          $injector,
          shouldUnsafelyUseHttp
        );
      },
    ];
  }
  function TemplateFactory(
    $http,
    $templateCache,
    $injector,
    shouldUnsafelyUseHttp
  ) {
    this.fromConfig = function (config, params, locals) {
      return isDefined(config.template)
        ? this.fromString(config.template, params)
        : isDefined(config.templateUrl)
        ? this.fromUrl(config.templateUrl, params)
        : isDefined(config.templateProvider)
        ? this.fromProvider(config.templateProvider, params, locals)
        : null;
    };
    this.fromString = function (template, params) {
      return isFunction(template) ? template(params) : template;
    };
    this.fromUrl = function (url, params) {
      if (isFunction(url)) url = url(params);
      if (url == null) return null;
      else {
        if (!shouldUnsafelyUseHttp) {
          return $injector.get("$templateRequest")(url);
        } else {
          return $http
            .get(url, {
              cache: $templateCache,
              headers: { Accept: "text/html" },
            })
            .then(function (response) {
              return response.data;
            });
        }
      }
    };
    this.fromProvider = function (provider, params, locals) {
      return $injector.invoke(provider, null, locals || { params: params });
    };
  }
  angular
    .module("ui.router.util")
    .provider("$templateFactory", TemplateFactoryProvider);
  var $$UMFP;
  function UrlMatcher(pattern, config, parentMatcher) {
    config = extend({ params: {} }, isObject(config) ? config : {});
    var placeholder =
        /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
      searchPlaceholder =
        /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
      compiled = "^",
      last = 0,
      m,
      segments = (this.segments = []),
      parentParams = parentMatcher ? parentMatcher.params : {},
      params = (this.params = parentMatcher
        ? parentMatcher.params.$$new()
        : new $$UMFP.ParamSet()),
      paramNames = [];
    function addParameter(id, type, config, location) {
      paramNames.push(id);
      if (parentParams[id]) return parentParams[id];
      if (!/^\w+([-.]+\w+)*(?:\[\])?$/.test(id))
        throw new Error(
          "Invalid parameter name '" + id + "' in pattern '" + pattern + "'"
        );
      if (params[id])
        throw new Error(
          "Duplicate parameter name '" + id + "' in pattern '" + pattern + "'"
        );
      params[id] = new $$UMFP.Param(id, type, config, location);
      return params[id];
    }
    function quoteRegExp(string, pattern, squash, optional) {
      var surroundPattern = ["", ""],
        result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
      if (!pattern) return result;
      switch (squash) {
        case false:
          surroundPattern = ["(", ")" + (optional ? "?" : "")];
          break;
        case true:
          result = result.replace(/\/$/, "");
          surroundPattern = ["(?:/(", ")|/)?"];
          break;
        default:
          surroundPattern = ["(" + squash + "|", ")?"];
          break;
      }
      return result + surroundPattern[0] + pattern + surroundPattern[1];
    }
    this.source = pattern;
    function matchDetails(m, isSearch) {
      var id, regexp, segment, type, cfg, arrayMode;
      id = m[2] || m[3];
      cfg = config.params[id];
      segment = pattern.substring(last, m.index);
      regexp = isSearch ? m[4] : m[4] || (m[1] == "*" ? ".*" : null);
      if (regexp) {
        type =
          $$UMFP.type(regexp) ||
          inherit($$UMFP.type("string"), {
            pattern: new RegExp(
              regexp,
              config.caseInsensitive ? "i" : undefined
            ),
          });
      }
      return { id: id, regexp: regexp, segment: segment, type: type, cfg: cfg };
    }
    var p, param, segment;
    while ((m = placeholder.exec(pattern))) {
      p = matchDetails(m, false);
      if (p.segment.indexOf("?") >= 0) break;
      param = addParameter(p.id, p.type, p.cfg, "path");
      compiled += quoteRegExp(
        p.segment,
        param.type.pattern.source,
        param.squash,
        param.isOptional
      );
      segments.push(p.segment);
      last = placeholder.lastIndex;
    }
    segment = pattern.substring(last);
    var i = segment.indexOf("?");
    if (i >= 0) {
      var search = (this.sourceSearch = segment.substring(i));
      segment = segment.substring(0, i);
      this.sourcePath = pattern.substring(0, last + i);
      if (search.length > 0) {
        last = 0;
        while ((m = searchPlaceholder.exec(search))) {
          p = matchDetails(m, true);
          param = addParameter(p.id, p.type, p.cfg, "search");
          last = placeholder.lastIndex;
        }
      }
    } else {
      this.sourcePath = pattern;
      this.sourceSearch = "";
    }
    compiled +=
      quoteRegExp(segment) + (config.strict === false ? "/?" : "") + "$";
    segments.push(segment);
    this.regexp = new RegExp(
      compiled,
      config.caseInsensitive ? "i" : undefined
    );
    this.prefix = segments[0];
    this.$$paramNames = paramNames;
  }
  UrlMatcher.prototype.concat = function (pattern, config) {
    var defaultConfig = {
      caseInsensitive: $$UMFP.caseInsensitive(),
      strict: $$UMFP.strictMode(),
      squash: $$UMFP.defaultSquashPolicy(),
    };
    return new UrlMatcher(
      this.sourcePath + pattern + this.sourceSearch,
      extend(defaultConfig, config),
      this
    );
  };
  UrlMatcher.prototype.toString = function () {
    return this.source;
  };
  UrlMatcher.prototype.exec = function (path, searchParams) {
    var m = this.regexp.exec(path);
    if (!m) return null;
    searchParams = searchParams || {};
    var paramNames = this.parameters(),
      nTotal = paramNames.length,
      nPath = this.segments.length - 1,
      values = {},
      i,
      j,
      cfg,
      paramName;
    if (nPath !== m.length - 1)
      throw new Error(
        "Unbalanced capture group in route '" + this.source + "'"
      );
    function decodePathArray(string) {
      function reverseString(str) {
        return str.split("").reverse().join("");
      }
      function unquoteDashes(str) {
        return str.replace(/\\-/g, "-");
      }
      var split = reverseString(string).split(/-(?!\\)/);
      var allReversed = map(split, reverseString);
      return map(allReversed, unquoteDashes).reverse();
    }
    var param, paramVal;
    for (i = 0; i < nPath; i++) {
      paramName = paramNames[i];
      param = this.params[paramName];
      paramVal = m[i + 1];
      for (j = 0; j < param.replace.length; j++) {
        if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;
      }
      if (paramVal && param.array === true)
        paramVal = decodePathArray(paramVal);
      if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);
      values[paramName] = param.value(paramVal);
    }
    for (; i < nTotal; i++) {
      paramName = paramNames[i];
      values[paramName] = this.params[paramName].value(searchParams[paramName]);
      param = this.params[paramName];
      paramVal = searchParams[paramName];
      for (j = 0; j < param.replace.length; j++) {
        if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;
      }
      if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);
      values[paramName] = param.value(paramVal);
    }
    return values;
  };
  UrlMatcher.prototype.parameters = function (param) {
    if (!isDefined(param)) return this.$$paramNames;
    return this.params[param] || null;
  };
  UrlMatcher.prototype.validates = function (params) {
    return this.params.$$validates(params);
  };
  UrlMatcher.prototype.format = function (values) {
    values = values || {};
    var segments = this.segments,
      params = this.parameters(),
      paramset = this.params;
    if (!this.validates(values)) return null;
    var i,
      search = false,
      nPath = segments.length - 1,
      nTotal = params.length,
      result = segments[0];
    function encodeDashes(str) {
      return encodeURIComponent(str).replace(/-/g, function (c) {
        return "%5C%" + c.charCodeAt(0).toString(16).toUpperCase();
      });
    }
    for (i = 0; i < nTotal; i++) {
      var isPathParam = i < nPath;
      var name = params[i],
        param = paramset[name],
        value = param.value(values[name]);
      var isDefaultValue =
        param.isOptional && param.type.equals(param.value(), value);
      var squash = isDefaultValue ? param.squash : false;
      var encoded = param.type.encode(value);
      if (isPathParam) {
        var nextSegment = segments[i + 1];
        var isFinalPathParam = i + 1 === nPath;
        if (squash === false) {
          if (encoded != null) {
            if (isArray(encoded)) {
              result += map(encoded, encodeDashes).join("-");
            } else {
              result += encodeURIComponent(encoded);
            }
          }
          result += nextSegment;
        } else if (squash === true) {
          var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
          result += nextSegment.match(capture)[1];
        } else if (isString(squash)) {
          result += squash + nextSegment;
        }
        if (
          isFinalPathParam &&
          param.squash === true &&
          result.slice(-1) === "/"
        )
          result = result.slice(0, -1);
      } else {
        if (encoded == null || (isDefaultValue && squash !== false)) continue;
        if (!isArray(encoded)) encoded = [encoded];
        if (encoded.length === 0) continue;
        encoded = map(encoded, encodeURIComponent).join("&" + name + "=");
        result += (search ? "&" : "?") + (name + "=" + encoded);
        search = true;
      }
    }
    return result;
  };
  function Type(config) {
    extend(this, config);
  }
  Type.prototype.is = function (val, key) {
    return true;
  };
  Type.prototype.encode = function (val, key) {
    return val;
  };
  Type.prototype.decode = function (val, key) {
    return val;
  };
  Type.prototype.equals = function (a, b) {
    return a == b;
  };
  Type.prototype.$subPattern = function () {
    var sub = this.pattern.toString();
    return sub.substr(1, sub.length - 2);
  };
  Type.prototype.pattern = /.*/;
  Type.prototype.toString = function () {
    return "{Type:" + this.name + "}";
  };
  Type.prototype.$normalize = function (val) {
    return this.is(val) ? val : this.decode(val);
  };
  Type.prototype.$asArray = function (mode, isSearch) {
    if (!mode) return this;
    if (mode === "auto" && !isSearch)
      throw new Error("'auto' array mode is for query parameters only");
    function ArrayType(type, mode) {
      function bindTo(type, callbackName) {
        return function () {
          return type[callbackName].apply(type, arguments);
        };
      }
      function arrayWrap(val) {
        return isArray(val) ? val : isDefined(val) ? [val] : [];
      }
      function arrayUnwrap(val) {
        switch (val.length) {
          case 0:
            return undefined;
          case 1:
            return mode === "auto" ? val[0] : val;
          default:
            return val;
        }
      }
      function falsey(val) {
        return !val;
      }
      function arrayHandler(callback, allTruthyMode) {
        return function handleArray(val) {
          if (isArray(val) && val.length === 0) return val;
          val = arrayWrap(val);
          var result = map(val, callback);
          if (allTruthyMode === true)
            return filter(result, falsey).length === 0;
          return arrayUnwrap(result);
        };
      }
      function arrayEqualsHandler(callback) {
        return function handleArray(val1, val2) {
          var left = arrayWrap(val1),
            right = arrayWrap(val2);
          if (left.length !== right.length) return false;
          for (var i = 0; i < left.length; i++) {
            if (!callback(left[i], right[i])) return false;
          }
          return true;
        };
      }
      this.encode = arrayHandler(bindTo(type, "encode"));
      this.decode = arrayHandler(bindTo(type, "decode"));
      this.is = arrayHandler(bindTo(type, "is"), true);
      this.equals = arrayEqualsHandler(bindTo(type, "equals"));
      this.pattern = type.pattern;
      this.$normalize = arrayHandler(bindTo(type, "$normalize"));
      this.name = type.name;
      this.$arrayMode = mode;
    }
    return new ArrayType(this, mode);
  };
  function $UrlMatcherFactory() {
    $$UMFP = this;
    var isCaseInsensitive = false,
      isStrictMode = true,
      defaultSquashPolicy = false;
    function valToString(val) {
      return val != null
        ? val.toString().replace(/(~|\/)/g, function (m) {
            return { "~": "~~", "/": "~2F" }[m];
          })
        : val;
    }
    function valFromString(val) {
      return val != null
        ? val.toString().replace(/(~~|~2F)/g, function (m) {
            return { "~~": "~", "~2F": "/" }[m];
          })
        : val;
    }
    var $types = {},
      enqueue = true,
      typeQueue = [],
      injector,
      defaultTypes = {
        string: {
          encode: valToString,
          decode: valFromString,
          is: function (val) {
            return val == null || !isDefined(val) || typeof val === "string";
          },
          pattern: /[^\/]*/,
        },
        int: {
          encode: valToString,
          decode: function (val) {
            return parseInt(val, 10);
          },
          is: function (val) {
            return (
              val !== undefined &&
              val !== null &&
              this.decode(val.toString()) === val
            );
          },
          pattern: /\d+/,
        },
        bool: {
          encode: function (val) {
            return val ? 1 : 0;
          },
          decode: function (val) {
            return parseInt(val, 10) !== 0;
          },
          is: function (val) {
            return val === true || val === false;
          },
          pattern: /0|1/,
        },
        date: {
          encode: function (val) {
            if (!this.is(val)) return undefined;
            return [
              val.getFullYear(),
              ("0" + (val.getMonth() + 1)).slice(-2),
              ("0" + val.getDate()).slice(-2),
            ].join("-");
          },
          decode: function (val) {
            if (this.is(val)) return val;
            var match = this.capture.exec(val);
            return match
              ? new Date(match[1], match[2] - 1, match[3])
              : undefined;
          },
          is: function (val) {
            return val instanceof Date && !isNaN(val.valueOf());
          },
          equals: function (a, b) {
            return (
              this.is(a) && this.is(b) && a.toISOString() === b.toISOString()
            );
          },
          pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
          capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/,
        },
        json: {
          encode: angular.toJson,
          decode: angular.fromJson,
          is: angular.isObject,
          equals: angular.equals,
          pattern: /[^\/]*/,
        },
        any: {
          encode: angular.identity,
          decode: angular.identity,
          equals: angular.equals,
          pattern: /.*/,
        },
      };
    function getDefaultConfig() {
      return { strict: isStrictMode, caseInsensitive: isCaseInsensitive };
    }
    function isInjectable(value) {
      return (
        isFunction(value) ||
        (isArray(value) && isFunction(value[value.length - 1]))
      );
    }
    $UrlMatcherFactory.$$getDefaultValue = function (config) {
      if (!isInjectable(config.value)) return config.value;
      if (!injector)
        throw new Error(
          "Injectable functions cannot be called at configuration time"
        );
      return injector.invoke(config.value);
    };
    this.caseInsensitive = function (value) {
      if (isDefined(value)) isCaseInsensitive = value;
      return isCaseInsensitive;
    };
    this.strictMode = function (value) {
      if (isDefined(value)) isStrictMode = value;
      return isStrictMode;
    };
    this.defaultSquashPolicy = function (value) {
      if (!isDefined(value)) return defaultSquashPolicy;
      if (value !== true && value !== false && !isString(value))
        throw new Error(
          "Invalid squash policy: " +
            value +
            ". Valid policies: false, true, arbitrary-string"
        );
      defaultSquashPolicy = value;
      return value;
    };
    this.compile = function (pattern, config) {
      return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
    };
    this.isMatcher = function (o) {
      if (!isObject(o)) return false;
      var result = true;
      forEach(UrlMatcher.prototype, function (val, name) {
        if (isFunction(val)) {
          result = result && isDefined(o[name]) && isFunction(o[name]);
        }
      });
      return result;
    };
    this.type = function (name, definition, definitionFn) {
      if (!isDefined(definition)) return $types[name];
      if ($types.hasOwnProperty(name))
        throw new Error(
          "A type named '" + name + "' has already been defined."
        );
      $types[name] = new Type(extend({ name: name }, definition));
      if (definitionFn) {
        typeQueue.push({ name: name, def: definitionFn });
        if (!enqueue) flushTypeQueue();
      }
      return this;
    };
    function flushTypeQueue() {
      while (typeQueue.length) {
        var type = typeQueue.shift();
        if (type.pattern)
          throw new Error("You cannot override a type's .pattern at runtime.");
        angular.extend($types[type.name], injector.invoke(type.def));
      }
    }
    forEach(defaultTypes, function (type, name) {
      $types[name] = new Type(extend({ name: name }, type));
    });
    $types = inherit($types, {});
    this.$get = [
      "$injector",
      function ($injector) {
        injector = $injector;
        enqueue = false;
        flushTypeQueue();
        forEach(defaultTypes, function (type, name) {
          if (!$types[name]) $types[name] = new Type(type);
        });
        return this;
      },
    ];
    this.Param = function Param(id, type, config, location) {
      var self = this;
      config = unwrapShorthand(config);
      type = getType(config, type, location);
      var arrayMode = getArrayMode();
      type = arrayMode ? type.$asArray(arrayMode, location === "search") : type;
      if (
        type.name === "string" &&
        !arrayMode &&
        location === "path" &&
        config.value === undefined
      )
        config.value = "";
      var isOptional = config.value !== undefined;
      var squash = getSquashPolicy(config, isOptional);
      var replace = getReplace(config, arrayMode, isOptional, squash);
      function unwrapShorthand(config) {
        var keys = isObject(config) ? objectKeys(config) : [];
        var isShorthand =
          indexOf(keys, "value") === -1 &&
          indexOf(keys, "type") === -1 &&
          indexOf(keys, "squash") === -1 &&
          indexOf(keys, "array") === -1;
        if (isShorthand) config = { value: config };
        config.$$fn = isInjectable(config.value)
          ? config.value
          : function () {
              return config.value;
            };
        return config;
      }
      function getType(config, urlType, location) {
        if (config.type && urlType)
          throw new Error("Param '" + id + "' has two type configurations.");
        if (urlType) return urlType;
        if (!config.type)
          return location === "config" ? $types.any : $types.string;
        if (angular.isString(config.type)) return $types[config.type];
        if (config.type instanceof Type) return config.type;
        return new Type(config.type);
      }
      function getArrayMode() {
        var arrayDefaults = { array: location === "search" ? "auto" : false };
        var arrayParamNomenclature = id.match(/\[\]$/) ? { array: true } : {};
        return extend(arrayDefaults, arrayParamNomenclature, config).array;
      }
      function getSquashPolicy(config, isOptional) {
        var squash = config.squash;
        if (!isOptional || squash === false) return false;
        if (!isDefined(squash) || squash == null) return defaultSquashPolicy;
        if (squash === true || isString(squash)) return squash;
        throw new Error(
          "Invalid squash policy: '" +
            squash +
            "'. Valid policies: false, true, or arbitrary string"
        );
      }
      function getReplace(config, arrayMode, isOptional, squash) {
        var replace,
          configuredKeys,
          defaultPolicy = [
            { from: "", to: isOptional || arrayMode ? undefined : "" },
            { from: null, to: isOptional || arrayMode ? undefined : "" },
          ];
        replace = isArray(config.replace) ? config.replace : [];
        if (isString(squash)) replace.push({ from: squash, to: undefined });
        configuredKeys = map(replace, function (item) {
          return item.from;
        });
        return filter(defaultPolicy, function (item) {
          return indexOf(configuredKeys, item.from) === -1;
        }).concat(replace);
      }
      function $$getDefaultValue() {
        if (!injector)
          throw new Error(
            "Injectable functions cannot be called at configuration time"
          );
        var defaultValue = injector.invoke(config.$$fn);
        if (
          defaultValue !== null &&
          defaultValue !== undefined &&
          !self.type.is(defaultValue)
        )
          throw new Error(
            "Default value (" +
              defaultValue +
              ") for parameter '" +
              self.id +
              "' is not an instance of Type (" +
              self.type.name +
              ")"
          );
        return defaultValue;
      }
      function $value(value) {
        function hasReplaceVal(val) {
          return function (obj) {
            return obj.from === val;
          };
        }
        function $replace(value) {
          var replacement = map(
            filter(self.replace, hasReplaceVal(value)),
            function (obj) {
              return obj.to;
            }
          );
          return replacement.length ? replacement[0] : value;
        }
        value = $replace(value);
        return !isDefined(value)
          ? $$getDefaultValue()
          : self.type.$normalize(value);
      }
      function toString() {
        return (
          "{Param:" +
          id +
          " " +
          type +
          " squash: '" +
          squash +
          "' optional: " +
          isOptional +
          "}"
        );
      }
      extend(this, {
        id: id,
        type: type,
        location: location,
        array: arrayMode,
        squash: squash,
        replace: replace,
        isOptional: isOptional,
        value: $value,
        dynamic: undefined,
        config: config,
        toString: toString,
      });
    };
    function ParamSet(params) {
      extend(this, params || {});
    }
    ParamSet.prototype = {
      $$new: function () {
        return inherit(this, extend(new ParamSet(), { $$parent: this }));
      },
      $$keys: function () {
        var keys = [],
          chain = [],
          parent = this,
          ignore = objectKeys(ParamSet.prototype);
        while (parent) {
          chain.push(parent);
          parent = parent.$$parent;
        }
        chain.reverse();
        forEach(chain, function (paramset) {
          forEach(objectKeys(paramset), function (key) {
            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1)
              keys.push(key);
          });
        });
        return keys;
      },
      $$values: function (paramValues) {
        var values = {},
          self = this;
        forEach(self.$$keys(), function (key) {
          values[key] = self[key].value(paramValues && paramValues[key]);
        });
        return values;
      },
      $$equals: function (paramValues1, paramValues2) {
        var equal = true,
          self = this;
        forEach(self.$$keys(), function (key) {
          var left = paramValues1 && paramValues1[key],
            right = paramValues2 && paramValues2[key];
          if (!self[key].type.equals(left, right)) equal = false;
        });
        return equal;
      },
      $$validates: function $$validate(paramValues) {
        var keys = this.$$keys(),
          i,
          param,
          rawVal,
          normalized,
          encoded;
        for (i = 0; i < keys.length; i++) {
          param = this[keys[i]];
          rawVal = paramValues[keys[i]];
          if ((rawVal === undefined || rawVal === null) && param.isOptional)
            break;
          normalized = param.type.$normalize(rawVal);
          if (!param.type.is(normalized)) return false;
          encoded = param.type.encode(normalized);
          if (angular.isString(encoded) && !param.type.pattern.exec(encoded))
            return false;
        }
        return true;
      },
      $$parent: undefined,
    };
    this.ParamSet = ParamSet;
  }
  angular
    .module("ui.router.util")
    .provider("$urlMatcherFactory", $UrlMatcherFactory);
  angular
    .module("ui.router.util")
    .run(["$urlMatcherFactory", function ($urlMatcherFactory) {}]);
  $UrlRouterProvider.$inject = [
    "$locationProvider",
    "$urlMatcherFactoryProvider",
  ];
  function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
    var rules = [],
      otherwise = null,
      interceptDeferred = false,
      listener;
    function regExpPrefix(re) {
      var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(
        re.source
      );
      return prefix != null ? prefix[1].replace(/\\(.)/g, "$1") : "";
    }
    function interpolate(pattern, match) {
      return pattern.replace(/\$(\$|\d{1,2})/, function (m, what) {
        return match[what === "$" ? 0 : Number(what)];
      });
    }
    this.rule = function (rule) {
      if (!isFunction(rule)) throw new Error("'rule' must be a function");
      rules.push(rule);
      return this;
    };
    this.otherwise = function (rule) {
      if (isString(rule)) {
        var redirect = rule;
        rule = function () {
          return redirect;
        };
      } else if (!isFunction(rule))
        throw new Error("'rule' must be a function");
      otherwise = rule;
      return this;
    };
    function handleIfMatch($injector, handler, match) {
      if (!match) return false;
      var result = $injector.invoke(handler, handler, { $match: match });
      return isDefined(result) ? result : true;
    }
    this.when = function (what, handler) {
      var redirect,
        handlerIsString = isString(handler);
      if (isString(what)) what = $urlMatcherFactory.compile(what);
      if (!handlerIsString && !isFunction(handler) && !isArray(handler))
        throw new Error("invalid 'handler' in when()");
      var strategies = {
        matcher: function (what, handler) {
          if (handlerIsString) {
            redirect = $urlMatcherFactory.compile(handler);
            handler = [
              "$match",
              function ($match) {
                return redirect.format($match);
              },
            ];
          }
          return extend(
            function ($injector, $location) {
              return handleIfMatch(
                $injector,
                handler,
                what.exec($location.path(), $location.search())
              );
            },
            { prefix: isString(what.prefix) ? what.prefix : "" }
          );
        },
        regex: function (what, handler) {
          if (what.global || what.sticky)
            throw new Error("when() RegExp must not be global or sticky");
          if (handlerIsString) {
            redirect = handler;
            handler = [
              "$match",
              function ($match) {
                return interpolate(redirect, $match);
              },
            ];
          }
          return extend(
            function ($injector, $location) {
              return handleIfMatch(
                $injector,
                handler,
                what.exec($location.path())
              );
            },
            { prefix: regExpPrefix(what) }
          );
        },
      };
      var check = {
        matcher: $urlMatcherFactory.isMatcher(what),
        regex: what instanceof RegExp,
      };
      for (var n in check) {
        if (check[n]) return this.rule(strategies[n](what, handler));
      }
      throw new Error("invalid 'what' in when()");
    };
    this.deferIntercept = function (defer) {
      if (defer === undefined) defer = true;
      interceptDeferred = defer;
    };
    this.$get = $get;
    $get.$inject = [
      "$location",
      "$rootScope",
      "$injector",
      "$browser",
      "$sniffer",
    ];
    function $get($location, $rootScope, $injector, $browser, $sniffer) {
      var baseHref = $browser.baseHref(),
        location = $location.url(),
        lastPushedUrl;
      function appendBasePath(url, isHtml5, absolute) {
        if (baseHref === "/") return url;
        if (isHtml5) return baseHref.slice(0, -1) + url;
        if (absolute) return baseHref.slice(1) + url;
        return url;
      }
      function update(evt) {
        if (evt && evt.defaultPrevented) return;
        var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
        lastPushedUrl = undefined;
        function check(rule) {
          var handled = rule($injector, $location);
          if (!handled) return false;
          if (isString(handled)) $location.replace().url(handled);
          return true;
        }
        var n = rules.length,
          i;
        for (i = 0; i < n; i++) {
          if (check(rules[i])) return;
        }
        if (otherwise) check(otherwise);
      }
      function listen() {
        listener = listener || $rootScope.$on("$locationChangeSuccess", update);
        return listener;
      }
      if (!interceptDeferred) listen();
      return {
        sync: function () {
          update();
        },
        listen: function () {
          return listen();
        },
        update: function (read) {
          if (read) {
            location = $location.url();
            return;
          }
          if ($location.url() === location) return;
          $location.url(location);
          $location.replace();
        },
        push: function (urlMatcher, params, options) {
          var url = urlMatcher.format(params || {});
          if (url !== null && params && params["#"]) {
            url += "#" + params["#"];
          }
          $location.url(url);
          lastPushedUrl =
            options && options.$$avoidResync ? $location.url() : undefined;
          if (options && options.replace) $location.replace();
        },
        href: function (urlMatcher, params, options) {
          if (!urlMatcher.validates(params)) return null;
          var isHtml5 = $locationProvider.html5Mode();
          if (angular.isObject(isHtml5)) {
            isHtml5 = isHtml5.enabled;
          }
          isHtml5 = isHtml5 && $sniffer.history;
          var url = urlMatcher.format(params);
          options = options || {};
          if (!isHtml5 && url !== null) {
            url = "#" + $locationProvider.hashPrefix() + url;
          }
          if (url !== null && params && params["#"]) {
            url += "#" + params["#"];
          }
          url = appendBasePath(url, isHtml5, options.absolute);
          if (!options.absolute || !url) {
            return url;
          }
          var slash = !isHtml5 && url ? "/" : "",
            port = $location.port();
          port = port === 80 || port === 443 ? "" : ":" + port;
          return [
            $location.protocol(),
            "://",
            $location.host(),
            port,
            slash,
            url,
          ].join("");
        },
      };
    }
  }
  angular.module("ui.router.router").provider("$urlRouter", $UrlRouterProvider);
  $StateProvider.$inject = ["$urlRouterProvider", "$urlMatcherFactoryProvider"];
  function $StateProvider($urlRouterProvider, $urlMatcherFactory) {
    var root,
      states = {},
      $state,
      queue = {},
      abstractKey = "abstract";
    var stateBuilder = {
      parent: function (state) {
        if (isDefined(state.parent) && state.parent)
          return findState(state.parent);
        var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
        return compositeName ? findState(compositeName[1]) : root;
      },
      data: function (state) {
        if (state.parent && state.parent.data) {
          state.data = state.self.data = inherit(state.parent.data, state.data);
        }
        return state.data;
      },
      url: function (state) {
        var url = state.url,
          config = { params: state.params || {} };
        if (isString(url)) {
          if (url.charAt(0) == "^")
            return $urlMatcherFactory.compile(url.substring(1), config);
          return (state.parent.navigable || root).url.concat(url, config);
        }
        if (!url || $urlMatcherFactory.isMatcher(url)) return url;
        throw new Error("Invalid url '" + url + "' in state '" + state + "'");
      },
      navigable: function (state) {
        return state.url ? state : state.parent ? state.parent.navigable : null;
      },
      ownParams: function (state) {
        var params = (state.url && state.url.params) || new $$UMFP.ParamSet();
        forEach(state.params || {}, function (config, id) {
          if (!params[id])
            params[id] = new $$UMFP.Param(id, null, config, "config");
        });
        return params;
      },
      params: function (state) {
        var ownParams = pick(state.ownParams, state.ownParams.$$keys());
        return state.parent && state.parent.params
          ? extend(state.parent.params.$$new(), ownParams)
          : new $$UMFP.ParamSet();
      },
      views: function (state) {
        var views = {};
        forEach(
          isDefined(state.views) ? state.views : { "": state },
          function (view, name) {
            if (name.indexOf("@") < 0) name += "@" + state.parent.name;
            view.resolveAs = view.resolveAs || state.resolveAs || "$resolve";
            views[name] = view;
          }
        );
        return views;
      },
      path: function (state) {
        return state.parent ? state.parent.path.concat(state) : [];
      },
      includes: function (state) {
        var includes = state.parent ? extend({}, state.parent.includes) : {};
        includes[state.name] = true;
        return includes;
      },
      $delegates: {},
    };
    function isRelative(stateName) {
      return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
    }
    function findState(stateOrName, base) {
      if (!stateOrName) return undefined;
      var isStr = isString(stateOrName),
        name = isStr ? stateOrName : stateOrName.name,
        path = isRelative(name);
      if (path) {
        if (!base)
          throw new Error("No reference point given for path '" + name + "'");
        base = findState(base);
        var rel = name.split("."),
          i = 0,
          pathLength = rel.length,
          current = base;
        for (; i < pathLength; i++) {
          if (rel[i] === "" && i === 0) {
            current = base;
            continue;
          }
          if (rel[i] === "^") {
            if (!current.parent)
              throw new Error(
                "Path '" + name + "' not valid for state '" + base.name + "'"
              );
            current = current.parent;
            continue;
          }
          break;
        }
        rel = rel.slice(i).join(".");
        name = current.name + (current.name && rel ? "." : "") + rel;
      }
      var state = states[name];
      if (
        state &&
        (isStr ||
          (!isStr && (state === stateOrName || state.self === stateOrName)))
      ) {
        return state;
      }
      return undefined;
    }
    function queueState(parentName, state) {
      if (!queue[parentName]) {
        queue[parentName] = [];
      }
      queue[parentName].push(state);
    }
    function flushQueuedChildren(parentName) {
      var queued = queue[parentName] || [];
      while (queued.length) {
        registerState(queued.shift());
      }
    }
    function registerState(state) {
      state = inherit(state, {
        self: state,
        resolve: state.resolve || {},
        toString: function () {
          return this.name;
        },
      });
      var name = state.name;
      if (!isString(name) || name.indexOf("@") >= 0)
        throw new Error("State must have a valid name");
      if (states.hasOwnProperty(name))
        throw new Error("State '" + name + "' is already defined");
      var parentName =
        name.indexOf(".") !== -1
          ? name.substring(0, name.lastIndexOf("."))
          : isString(state.parent)
          ? state.parent
          : isObject(state.parent) && isString(state.parent.name)
          ? state.parent.name
          : "";
      if (parentName && !states[parentName]) {
        return queueState(parentName, state.self);
      }
      for (var key in stateBuilder) {
        if (isFunction(stateBuilder[key]))
          state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
      }
      states[name] = state;
      if (!state[abstractKey] && state.url) {
        $urlRouterProvider.when(state.url, [
          "$match",
          "$stateParams",
          function ($match, $stateParams) {
            if (
              $state.$current.navigable != state ||
              !equalForKeys($match, $stateParams)
            ) {
              $state.transitionTo(state, $match, {
                inherit: true,
                location: false,
              });
            }
          },
        ]);
      }
      flushQueuedChildren(name);
      return state;
    }
    function isGlob(text) {
      return text.indexOf("*") > -1;
    }
    function doesStateMatchGlob(glob) {
      var globSegments = glob.split("."),
        segments = $state.$current.name.split(".");
      for (var i = 0, l = globSegments.length; i < l; i++) {
        if (globSegments[i] === "*") {
          segments[i] = "*";
        }
      }
      if (globSegments[0] === "**") {
        segments = segments.slice(indexOf(segments, globSegments[1]));
        segments.unshift("**");
      }
      if (globSegments[globSegments.length - 1] === "**") {
        segments.splice(
          indexOf(segments, globSegments[globSegments.length - 2]) + 1,
          Number.MAX_VALUE
        );
        segments.push("**");
      }
      if (globSegments.length != segments.length) {
        return false;
      }
      return segments.join("") === globSegments.join("");
    }
    root = registerState({ name: "", url: "^", views: null, abstract: true });
    root.navigable = null;
    this.decorator = decorator;
    function decorator(name, func) {
      if (isString(name) && !isDefined(func)) {
        return stateBuilder[name];
      }
      if (!isFunction(func) || !isString(name)) {
        return this;
      }
      if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
        stateBuilder.$delegates[name] = stateBuilder[name];
      }
      stateBuilder[name] = func;
      return this;
    }
    this.state = state;
    function state(name, definition) {
      if (isObject(name)) definition = name;
      else definition.name = name;
      registerState(definition);
      return this;
    }
    this.$get = $get;
    $get.$inject = [
      "$rootScope",
      "$q",
      "$view",
      "$injector",
      "$resolve",
      "$stateParams",
      "$urlRouter",
      "$location",
      "$urlMatcherFactory",
    ];
    function $get(
      $rootScope,
      $q,
      $view,
      $injector,
      $resolve,
      $stateParams,
      $urlRouter,
      $location,
      $urlMatcherFactory
    ) {
      var TransitionSupersededError = new Error("transition superseded");
      var TransitionSuperseded = silenceUncaughtInPromise(
        $q.reject(TransitionSupersededError)
      );
      var TransitionPrevented = silenceUncaughtInPromise(
        $q.reject(new Error("transition prevented"))
      );
      var TransitionAborted = silenceUncaughtInPromise(
        $q.reject(new Error("transition aborted"))
      );
      var TransitionFailed = silenceUncaughtInPromise(
        $q.reject(new Error("transition failed"))
      );
      function handleRedirect(redirect, state, params, options) {
        var evt = $rootScope.$broadcast(
          "$stateNotFound",
          redirect,
          state,
          params
        );
        if (evt.defaultPrevented) {
          $urlRouter.update();
          return TransitionAborted;
        }
        if (!evt.retry) {
          return null;
        }
        if (options.$retry) {
          $urlRouter.update();
          return TransitionFailed;
        }
        var retryTransition = ($state.transition = $q.when(evt.retry));
        retryTransition.then(
          function () {
            if (retryTransition !== $state.transition) {
              $rootScope.$broadcast(
                "$stateChangeCancel",
                redirect.to,
                redirect.toParams,
                state,
                params
              );
              return TransitionSuperseded;
            }
            redirect.options.$retry = true;
            return $state.transitionTo(
              redirect.to,
              redirect.toParams,
              redirect.options
            );
          },
          function () {
            return TransitionAborted;
          }
        );
        $urlRouter.update();
        return retryTransition;
      }
      root.locals = { resolve: null, globals: { $stateParams: {} } };
      $state = {
        params: {},
        current: root.self,
        $current: root,
        transition: null,
      };
      $state.reload = function reload(state) {
        return $state.transitionTo($state.current, $stateParams, {
          reload: state || true,
          inherit: false,
          notify: true,
        });
      };
      $state.go = function go(to, params, options) {
        return $state.transitionTo(
          to,
          params,
          extend({ inherit: true, relative: $state.$current }, options)
        );
      };
      $state.transitionTo = function transitionTo(to, toParams, options) {
        toParams = toParams || {};
        options = extend(
          {
            location: true,
            inherit: false,
            relative: null,
            notify: true,
            reload: false,
            $retry: false,
          },
          options || {}
        );
        var from = $state.$current,
          fromParams = $state.params,
          fromPath = from.path;
        var evt,
          toState = findState(to, options.relative);
        var hash = toParams["#"];
        if (!isDefined(toState)) {
          var redirect = { to: to, toParams: toParams, options: options };
          var redirectResult = handleRedirect(
            redirect,
            from.self,
            fromParams,
            options
          );
          if (redirectResult) {
            return redirectResult;
          }
          to = redirect.to;
          toParams = redirect.toParams;
          options = redirect.options;
          toState = findState(to, options.relative);
          if (!isDefined(toState)) {
            if (!options.relative)
              throw new Error("No such state '" + to + "'");
            throw new Error(
              "Could not resolve '" +
                to +
                "' from state '" +
                options.relative +
                "'"
            );
          }
        }
        if (toState[abstractKey])
          throw new Error("Cannot transition to abstract state '" + to + "'");
        if (options.inherit)
          toParams = inheritParams(
            $stateParams,
            toParams || {},
            $state.$current,
            toState
          );
        if (!toState.params.$$validates(toParams)) return TransitionFailed;
        toParams = toState.params.$$values(toParams);
        to = toState;
        var toPath = to.path;
        var keep = 0,
          state = toPath[keep],
          locals = root.locals,
          toLocals = [];
        if (!options.reload) {
          while (
            state &&
            state === fromPath[keep] &&
            state.ownParams.$$equals(toParams, fromParams)
          ) {
            locals = toLocals[keep] = state.locals;
            keep++;
            state = toPath[keep];
          }
        } else if (isString(options.reload) || isObject(options.reload)) {
          if (isObject(options.reload) && !options.reload.name) {
            throw new Error("Invalid reload state object");
          }
          var reloadState =
            options.reload === true ? fromPath[0] : findState(options.reload);
          if (options.reload && !reloadState) {
            throw new Error(
              "No such reload state '" +
                (isString(options.reload)
                  ? options.reload
                  : options.reload.name) +
                "'"
            );
          }
          while (state && state === fromPath[keep] && state !== reloadState) {
            locals = toLocals[keep] = state.locals;
            keep++;
            state = toPath[keep];
          }
        }
        if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {
          if (hash) toParams["#"] = hash;
          $state.params = toParams;
          copy($state.params, $stateParams);
          copy(
            filterByKeys(to.params.$$keys(), $stateParams),
            to.locals.globals.$stateParams
          );
          if (options.location && to.navigable && to.navigable.url) {
            $urlRouter.push(to.navigable.url, toParams, {
              $$avoidResync: true,
              replace: options.location === "replace",
            });
            $urlRouter.update(true);
          }
          $state.transition = null;
          return $q.when($state.current);
        }
        toParams = filterByKeys(to.params.$$keys(), toParams || {});
        if (hash) toParams["#"] = hash;
        if (options.notify) {
          if (
            $rootScope.$broadcast(
              "$stateChangeStart",
              to.self,
              toParams,
              from.self,
              fromParams,
              options
            ).defaultPrevented
          ) {
            $rootScope.$broadcast(
              "$stateChangeCancel",
              to.self,
              toParams,
              from.self,
              fromParams
            );
            if ($state.transition == null) $urlRouter.update();
            return TransitionPrevented;
          }
        }
        var resolved = $q.when(locals);
        for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
          locals = toLocals[l] = inherit(locals);
          resolved = resolveState(
            state,
            toParams,
            state === to,
            resolved,
            locals,
            options
          );
        }
        var transition = ($state.transition = resolved
          .then(function () {
            var l, entering, exiting;
            if ($state.transition !== transition) {
              $rootScope.$broadcast(
                "$stateChangeCancel",
                to.self,
                toParams,
                from.self,
                fromParams
              );
              return TransitionSuperseded;
            }
            for (l = fromPath.length - 1; l >= keep; l--) {
              exiting = fromPath[l];
              if (exiting.self.onExit) {
                $injector.invoke(
                  exiting.self.onExit,
                  exiting.self,
                  exiting.locals.globals
                );
              }
              exiting.locals = null;
            }
            for (l = keep; l < toPath.length; l++) {
              entering = toPath[l];
              entering.locals = toLocals[l];
              if (entering.self.onEnter) {
                $injector.invoke(
                  entering.self.onEnter,
                  entering.self,
                  entering.locals.globals
                );
              }
            }
            if ($state.transition !== transition) {
              $rootScope.$broadcast(
                "$stateChangeCancel",
                to.self,
                toParams,
                from.self,
                fromParams
              );
              return TransitionSuperseded;
            }
            $state.$current = to;
            $state.current = to.self;
            $state.params = toParams;
            copy($state.params, $stateParams);
            $state.transition = null;
            if (options.location && to.navigable) {
              $urlRouter.push(
                to.navigable.url,
                to.navigable.locals.globals.$stateParams,
                { $$avoidResync: true, replace: options.location === "replace" }
              );
            }
            if (options.notify) {
              $rootScope.$broadcast(
                "$stateChangeSuccess",
                to.self,
                toParams,
                from.self,
                fromParams
              );
            }
            $urlRouter.update(true);
            return $state.current;
          })
          .then(null, function (error) {
            if (error === TransitionSupersededError)
              return TransitionSuperseded;
            if ($state.transition !== transition) {
              $rootScope.$broadcast(
                "$stateChangeCancel",
                to.self,
                toParams,
                from.self,
                fromParams
              );
              return TransitionSuperseded;
            }
            $state.transition = null;
            evt = $rootScope.$broadcast(
              "$stateChangeError",
              to.self,
              toParams,
              from.self,
              fromParams,
              error
            );
            if (!evt.defaultPrevented) {
              $urlRouter.update();
            }
            return $q.reject(error);
          }));
        silenceUncaughtInPromise(transition);
        return transition;
      };
      $state.is = function is(stateOrName, params, options) {
        options = extend({ relative: $state.$current }, options || {});
        var state = findState(stateOrName, options.relative);
        if (!isDefined(state)) {
          return undefined;
        }
        if ($state.$current !== state) {
          return false;
        }
        return (
          !params ||
          objectKeys(params).reduce(function (acc, key) {
            var paramDef = state.params[key];
            return (
              (acc && !paramDef) ||
              paramDef.type.equals($stateParams[key], params[key])
            );
          }, true)
        );
      };
      $state.includes = function includes(stateOrName, params, options) {
        options = extend({ relative: $state.$current }, options || {});
        if (isString(stateOrName) && isGlob(stateOrName)) {
          if (!doesStateMatchGlob(stateOrName)) {
            return false;
          }
          stateOrName = $state.$current.name;
        }
        var state = findState(stateOrName, options.relative);
        if (!isDefined(state)) {
          return undefined;
        }
        if (!isDefined($state.$current.includes[state.name])) {
          return false;
        }
        if (!params) {
          return true;
        }
        var keys = objectKeys(params);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i],
            paramDef = state.params[key];
          if (
            paramDef &&
            !paramDef.type.equals($stateParams[key], params[key])
          ) {
            return false;
          }
        }
        return objectKeys(params).reduce(function (acc, key) {
          var paramDef = state.params[key];
          return (
            (acc && !paramDef) ||
            paramDef.type.equals($stateParams[key], params[key])
          );
        }, true);
      };
      $state.href = function href(stateOrName, params, options) {
        options = extend(
          {
            lossy: true,
            inherit: true,
            absolute: false,
            relative: $state.$current,
          },
          options || {}
        );
        var state = findState(stateOrName, options.relative);
        if (!isDefined(state)) return null;
        if (options.inherit)
          params = inheritParams(
            $stateParams,
            params || {},
            $state.$current,
            state
          );
        var nav = state && options.lossy ? state.navigable : state;
        if (!nav || nav.url === undefined || nav.url === null) {
          return null;
        }
        return $urlRouter.href(
          nav.url,
          filterByKeys(state.params.$$keys().concat("#"), params || {}),
          { absolute: options.absolute }
        );
      };
      $state.get = function (stateOrName, context) {
        if (arguments.length === 0)
          return map(objectKeys(states), function (name) {
            return states[name].self;
          });
        var state = findState(stateOrName, context || $state.$current);
        return state && state.self ? state.self : null;
      };
      function resolveState(
        state,
        params,
        paramsAreFiltered,
        inherited,
        dst,
        options
      ) {
        var $stateParams = paramsAreFiltered
          ? params
          : filterByKeys(state.params.$$keys(), params);
        var locals = { $stateParams: $stateParams };
        dst.resolve = $resolve.resolve(
          state.resolve,
          locals,
          dst.resolve,
          state
        );
        var promises = [
          dst.resolve.then(function (globals) {
            dst.globals = globals;
          }),
        ];
        if (inherited) promises.push(inherited);
        function resolveViews() {
          var viewsPromises = [];
          forEach(state.views, function (view, name) {
            var injectables =
              view.resolve && view.resolve !== state.resolve
                ? view.resolve
                : {};
            injectables.$template = [
              function () {
                return (
                  $view.load(name, {
                    view: view,
                    locals: dst.globals,
                    params: $stateParams,
                    notify: options.notify,
                  }) || ""
                );
              },
            ];
            viewsPromises.push(
              $resolve
                .resolve(injectables, dst.globals, dst.resolve, state)
                .then(function (result) {
                  if (
                    isFunction(view.controllerProvider) ||
                    isArray(view.controllerProvider)
                  ) {
                    var injectLocals = angular.extend(
                      {},
                      injectables,
                      dst.globals
                    );
                    result.$$controller = $injector.invoke(
                      view.controllerProvider,
                      null,
                      injectLocals
                    );
                  } else {
                    result.$$controller = view.controller;
                  }
                  result.$$state = state;
                  result.$$controllerAs = view.controllerAs;
                  result.$$resolveAs = view.resolveAs;
                  dst[name] = result;
                })
            );
          });
          return $q.all(viewsPromises).then(function () {
            return dst.globals;
          });
        }
        return $q
          .all(promises)
          .then(resolveViews)
          .then(function (values) {
            return dst;
          });
      }
      return $state;
    }
    function shouldSkipReload(to, toParams, from, fromParams, locals, options) {
      function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {
        function notSearchParam(key) {
          return fromAndToState.params[key].location != "search";
        }
        var nonQueryParamKeys = fromAndToState.params
          .$$keys()
          .filter(notSearchParam);
        var nonQueryParams = pick.apply(
          {},
          [fromAndToState.params].concat(nonQueryParamKeys)
        );
        var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);
        return nonQueryParamSet.$$equals(fromParams, toParams);
      }
      if (
        !options.reload &&
        to === from &&
        (locals === from.locals ||
          (to.self.reloadOnSearch === false &&
            nonSearchParamsEqual(from, fromParams, toParams)))
      ) {
        return true;
      }
    }
  }
  angular
    .module("ui.router.state")
    .factory("$stateParams", function () {
      return {};
    })
    .constant("$state.runtime", { autoinject: true })
    .provider("$state", $StateProvider)
    .run([
      "$injector",
      function ($injector) {
        if ($injector.get("$state.runtime").autoinject) {
          $injector.get("$state");
        }
      },
    ]);
  $ViewProvider.$inject = [];
  function $ViewProvider() {
    this.$get = $get;
    $get.$inject = ["$rootScope", "$templateFactory"];
    function $get($rootScope, $templateFactory) {
      return {
        load: function load(name, options) {
          var result,
            defaults = {
              template: null,
              controller: null,
              view: null,
              locals: null,
              notify: true,
              async: true,
              params: {},
            };
          options = extend(defaults, options);
          if (options.view) {
            result = $templateFactory.fromConfig(
              options.view,
              options.params,
              options.locals
            );
          }
          return result;
        },
      };
    }
  }
  angular.module("ui.router.state").provider("$view", $ViewProvider);
  function $ViewScrollProvider() {
    var useAnchorScroll = false;
    this.useAnchorScroll = function () {
      useAnchorScroll = true;
    };
    this.$get = [
      "$anchorScroll",
      "$timeout",
      function ($anchorScroll, $timeout) {
        if (useAnchorScroll) {
          return $anchorScroll;
        }
        return function ($element) {
          return $timeout(
            function () {
              $element[0].scrollIntoView();
            },
            0,
            false
          );
        };
      },
    ];
  }
  angular
    .module("ui.router.state")
    .provider("$uiViewScroll", $ViewScrollProvider);
  $ViewDirective.$inject = [
    "$state",
    "$injector",
    "$uiViewScroll",
    "$interpolate",
    "$q",
  ];
  function $ViewDirective($state, $injector, $uiViewScroll, $interpolate, $q) {
    function getService() {
      return $injector.has
        ? function (service) {
            return $injector.has(service) ? $injector.get(service) : null;
          }
        : function (service) {
            try {
              return $injector.get(service);
            } catch (e) {
              return null;
            }
          };
    }
    var service = getService(),
      $animator = service("$animator"),
      $animate = service("$animate");
    function getRenderer(attrs, scope) {
      var statics = function () {
        return {
          enter: function (element, target, cb) {
            target.after(element);
            cb();
          },
          leave: function (element, cb) {
            element.remove();
            cb();
          },
        };
      };
      if ($animate) {
        return {
          enter: function (element, target, cb) {
            if (angular.version.minor > 2) {
              $animate.enter(element, null, target).then(cb);
            } else {
              $animate.enter(element, null, target, cb);
            }
          },
          leave: function (element, cb) {
            if (angular.version.minor > 2) {
              $animate.leave(element).then(cb);
            } else {
              $animate.leave(element, cb);
            }
          },
        };
      }
      if ($animator) {
        var animate = $animator && $animator(scope, attrs);
        return {
          enter: function (element, target, cb) {
            animate.enter(element, null, target);
            cb();
          },
          leave: function (element, cb) {
            animate.leave(element);
            cb();
          },
        };
      }
      return statics();
    }
    var directive = {
      restrict: "ECA",
      terminal: true,
      priority: 400,
      transclude: "element",
      compile: function (tElement, tAttrs, $transclude) {
        return function (scope, $element, attrs) {
          var previousEl,
            currentEl,
            currentScope,
            latestLocals,
            onloadExp = attrs.onload || "",
            autoScrollExp = attrs.autoscroll,
            renderer = getRenderer(attrs, scope),
            inherited = $element.inheritedData("$uiView");
          scope.$on("$stateChangeSuccess", function () {
            updateView(false);
          });
          updateView(true);
          function cleanupLastView() {
            if (previousEl) {
              previousEl.remove();
              previousEl = null;
            }
            if (currentScope) {
              currentScope.$destroy();
              currentScope = null;
            }
            if (currentEl) {
              var $uiViewData = currentEl.data("$uiViewAnim");
              renderer.leave(currentEl, function () {
                $uiViewData.$$animLeave.resolve();
                previousEl = null;
              });
              previousEl = currentEl;
              currentEl = null;
            }
          }
          function updateView(firstTime) {
            var newScope,
              name = getUiViewName(scope, attrs, $element, $interpolate),
              previousLocals =
                name && $state.$current && $state.$current.locals[name];
            if (!firstTime && previousLocals === latestLocals) return;
            newScope = scope.$new();
            latestLocals = $state.$current.locals[name];
            newScope.$emit("$viewContentLoading", name);
            var clone = $transclude(newScope, function (clone) {
              var animEnter = $q.defer(),
                animLeave = $q.defer();
              var viewAnimData = {
                $animEnter: animEnter.promise,
                $animLeave: animLeave.promise,
                $$animLeave: animLeave,
              };
              clone.data("$uiViewAnim", viewAnimData);
              renderer.enter(clone, $element, function onUiViewEnter() {
                animEnter.resolve();
                if (currentScope) {
                  currentScope.$emit("$viewContentAnimationEnded");
                }
                if (
                  (angular.isDefined(autoScrollExp) && !autoScrollExp) ||
                  scope.$eval(autoScrollExp)
                ) {
                  $uiViewScroll(clone);
                }
              });
              cleanupLastView();
            });
            currentEl = clone;
            currentScope = newScope;
            currentScope.$emit("$viewContentLoaded", name);
            currentScope.$eval(onloadExp);
          }
        };
      },
    };
    return directive;
  }
  $ViewDirectiveFill.$inject = [
    "$compile",
    "$controller",
    "$state",
    "$interpolate",
  ];
  function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
    return {
      restrict: "ECA",
      priority: -400,
      compile: function (tElement) {
        var initial = tElement.html();
        if (tElement.empty) {
          tElement.empty();
        } else {
          tElement[0].innerHTML = null;
        }
        return function (scope, $element, attrs) {
          var current = $state.$current,
            name = getUiViewName(scope, attrs, $element, $interpolate),
            locals = current && current.locals[name];
          if (!locals) {
            $element.html(initial);
            $compile($element.contents())(scope);
            return;
          }
          $element.data("$uiView", { name: name, state: locals.$$state });
          $element.html(locals.$template ? locals.$template : initial);
          var resolveData = angular.extend({}, locals);
          scope[locals.$$resolveAs] = resolveData;
          var link = $compile($element.contents());
          if (locals.$$controller) {
            locals.$scope = scope;
            locals.$element = $element;
            var controller = $controller(locals.$$controller, locals);
            if (locals.$$controllerAs) {
              scope[locals.$$controllerAs] = controller;
              scope[locals.$$controllerAs][locals.$$resolveAs] = resolveData;
            }
            if (isFunction(controller.$onInit)) controller.$onInit();
            $element.data("$ngControllerController", controller);
            $element.children().data("$ngControllerController", controller);
          }
          link(scope);
        };
      },
    };
  }
  function getUiViewName(scope, attrs, element, $interpolate) {
    var name = $interpolate(attrs.uiView || attrs.name || "")(scope);
    var uiViewCreatedBy = element.inheritedData("$uiView");
    return name.indexOf("@") >= 0
      ? name
      : name + "@" + (uiViewCreatedBy ? uiViewCreatedBy.state.name : "");
  }
  angular.module("ui.router.state").directive("uiView", $ViewDirective);
  angular.module("ui.router.state").directive("uiView", $ViewDirectiveFill);
  function parseStateRef(ref, current) {
    var preparsed = ref.match(/^\s*({[^}]*})\s*$/),
      parsed;
    if (preparsed) ref = current + "(" + preparsed[1] + ")";
    parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
    if (!parsed || parsed.length !== 4)
      throw new Error("Invalid state ref '" + ref + "'");
    return { state: parsed[1], paramExpr: parsed[3] || null };
  }
  function stateContext(el) {
    var stateData = el.parent().inheritedData("$uiView");
    if (stateData && stateData.state && stateData.state.name) {
      return stateData.state;
    }
  }
  function getTypeInfo(el) {
    var isSvg =
      Object.prototype.toString.call(el.prop("href")) ===
      "[object SVGAnimatedString]";
    var isForm = el[0].nodeName === "FORM";
    return {
      attr: isForm ? "action" : isSvg ? "xlink:href" : "href",
      isAnchor: el.prop("tagName").toUpperCase() === "A",
      clickable: !isForm,
    };
  }
  function clickHook(el, $state, $timeout, type, current) {
    return function (e) {
      var button = e.which || e.button,
        target = current();
      if (
        !(
          button > 1 ||
          e.ctrlKey ||
          e.metaKey ||
          e.shiftKey ||
          el.attr("target")
        )
      ) {
        var transition = $timeout(function () {
          $state.go(target.state, target.params, target.options);
        });
        e.preventDefault();
        var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0;
        e.preventDefault = function () {
          if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);
        };
      }
    };
  }
  function defaultOpts(el, $state) {
    return { relative: stateContext(el) || $state.$current, inherit: true };
  }
  $StateRefDirective.$inject = ["$state", "$timeout"];
  function $StateRefDirective($state, $timeout) {
    return {
      restrict: "A",
      require: ["?^uiSrefActive", "?^uiSrefActiveEq"],
      link: function (scope, element, attrs, uiSrefActive) {
        var ref = parseStateRef(attrs.uiSref, $state.current.name);
        var def = { state: ref.state, href: null, params: null };
        var type = getTypeInfo(element);
        var active = uiSrefActive[1] || uiSrefActive[0];
        var unlinkInfoFn = null;
        var hookFn;
        def.options = extend(
          defaultOpts(element, $state),
          attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {}
        );
        var update = function (val) {
          if (val) def.params = angular.copy(val);
          def.href = $state.href(ref.state, def.params, def.options);
          if (unlinkInfoFn) unlinkInfoFn();
          if (active)
            unlinkInfoFn = active.$$addStateInfo(ref.state, def.params);
          if (def.href !== null) attrs.$set(type.attr, def.href);
        };
        if (ref.paramExpr) {
          scope.$watch(
            ref.paramExpr,
            function (val) {
              if (val !== def.params) update(val);
            },
            true
          );
          def.params = angular.copy(scope.$eval(ref.paramExpr));
        }
        update();
        if (!type.clickable) return;
        hookFn = clickHook(element, $state, $timeout, type, function () {
          return def;
        });
        element[element.on ? "on" : "bind"]("click", hookFn);
        scope.$on("$destroy", function () {
          element[element.off ? "off" : "unbind"]("click", hookFn);
        });
      },
    };
  }
  $StateRefDynamicDirective.$inject = ["$state", "$timeout"];
  function $StateRefDynamicDirective($state, $timeout) {
    return {
      restrict: "A",
      require: ["?^uiSrefActive", "?^uiSrefActiveEq"],
      link: function (scope, element, attrs, uiSrefActive) {
        var type = getTypeInfo(element);
        var active = uiSrefActive[1] || uiSrefActive[0];
        var group = [
          attrs.uiState,
          attrs.uiStateParams || null,
          attrs.uiStateOpts || null,
        ];
        var watch =
          "[" +
          group
            .map(function (val) {
              return val || "null";
            })
            .join(", ") +
          "]";
        var def = { state: null, params: null, options: null, href: null };
        var unlinkInfoFn = null;
        var hookFn;
        function runStateRefLink(group) {
          def.state = group[0];
          def.params = group[1];
          def.options = group[2];
          def.href = $state.href(def.state, def.params, def.options);
          if (unlinkInfoFn) unlinkInfoFn();
          if (active)
            unlinkInfoFn = active.$$addStateInfo(def.state, def.params);
          if (def.href) attrs.$set(type.attr, def.href);
        }
        scope.$watch(watch, runStateRefLink, true);
        runStateRefLink(scope.$eval(watch));
        if (!type.clickable) return;
        hookFn = clickHook(element, $state, $timeout, type, function () {
          return def;
        });
        element[element.on ? "on" : "bind"]("click", hookFn);
        scope.$on("$destroy", function () {
          element[element.off ? "off" : "unbind"]("click", hookFn);
        });
      },
    };
  }
  $StateRefActiveDirective.$inject = ["$state", "$stateParams", "$interpolate"];
  function $StateRefActiveDirective($state, $stateParams, $interpolate) {
    return {
      restrict: "A",
      controller: [
        "$scope",
        "$element",
        "$attrs",
        "$timeout",
        function ($scope, $element, $attrs, $timeout) {
          var states = [],
            activeClasses = {},
            activeEqClass,
            uiSrefActive;
          activeEqClass = $interpolate(
            $attrs.uiSrefActiveEq || "",
            false
          )($scope);
          try {
            uiSrefActive = $scope.$eval($attrs.uiSrefActive);
          } catch (e) {}
          uiSrefActive =
            uiSrefActive ||
            $interpolate($attrs.uiSrefActive || "", false)($scope);
          if (isObject(uiSrefActive)) {
            forEach(uiSrefActive, function (stateOrName, activeClass) {
              if (isString(stateOrName)) {
                var ref = parseStateRef(stateOrName, $state.current.name);
                addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);
              }
            });
          }
          this.$$addStateInfo = function (newState, newParams) {
            if (isObject(uiSrefActive) && states.length > 0) {
              return;
            }
            var deregister = addState(newState, newParams, uiSrefActive);
            update();
            return deregister;
          };
          $scope.$on("$stateChangeSuccess", update);
          function addState(stateName, stateParams, activeClass) {
            var state = $state.get(stateName, stateContext($element));
            var stateHash = createStateHash(stateName, stateParams);
            var stateInfo = {
              state: state || { name: stateName },
              params: stateParams,
              hash: stateHash,
            };
            states.push(stateInfo);
            activeClasses[stateHash] = activeClass;
            return function removeState() {
              var idx = states.indexOf(stateInfo);
              if (idx !== -1) states.splice(idx, 1);
            };
          }
          function createStateHash(state, params) {
            if (!isString(state)) {
              throw new Error("state should be a string");
            }
            if (isObject(params)) {
              return state + toJson(params);
            }
            params = $scope.$eval(params);
            if (isObject(params)) {
              return state + toJson(params);
            }
            return state;
          }
          function update() {
            for (var i = 0; i < states.length; i++) {
              if (anyMatch(states[i].state, states[i].params)) {
                addClass($element, activeClasses[states[i].hash]);
              } else {
                removeClass($element, activeClasses[states[i].hash]);
              }
              if (exactMatch(states[i].state, states[i].params)) {
                addClass($element, activeEqClass);
              } else {
                removeClass($element, activeEqClass);
              }
            }
          }
          function addClass(el, className) {
            $timeout(function () {
              el.addClass(className);
            });
          }
          function removeClass(el, className) {
            el.removeClass(className);
          }
          function anyMatch(state, params) {
            return $state.includes(state.name, params);
          }
          function exactMatch(state, params) {
            return $state.is(state.name, params);
          }
          update();
        },
      ],
    };
  }
  angular
    .module("ui.router.state")
    .directive("uiSref", $StateRefDirective)
    .directive("uiSrefActive", $StateRefActiveDirective)
    .directive("uiSrefActiveEq", $StateRefActiveDirective)
    .directive("uiState", $StateRefDynamicDirective);
  $IsStateFilter.$inject = ["$state"];
  function $IsStateFilter($state) {
    var isFilter = function (state, params) {
      return $state.is(state, params);
    };
    isFilter.$stateful = true;
    return isFilter;
  }
  $IncludedByStateFilter.$inject = ["$state"];
  function $IncludedByStateFilter($state) {
    var includesFilter = function (state, params, options) {
      return $state.includes(state, params, options);
    };
    includesFilter.$stateful = true;
    return includesFilter;
  }
  angular
    .module("ui.router.state")
    .filter("isState", $IsStateFilter)
    .filter("includedByState", $IncludedByStateFilter);
})(window, window.angular);
(function (root, factory) {
  "use strict";
  if (typeof define === "function" && define.amd) {
    define(["angular"], factory);
  } else if (root.hasOwnProperty("angular")) {
    factory(root.angular);
  } else if (typeof exports === "object") {
    module.exports = factory(require("angular"));
  }
})(this, function (angular) {
  "use strict";
  angular = angular && angular.module ? angular : window.angular;
  function isStorageSupported($window, storageType) {
    var supported;
    try {
      supported = $window[storageType];
    } catch (err) {
      supported = false;
    }
    if (supported) {
      var key = "__" + Math.round(Math.random() * 1e7);
      try {
        $window[storageType].setItem(key, key);
        $window[storageType].removeItem(key, key);
      } catch (err) {
        supported = false;
      }
    }
    return supported;
  }
  return angular
    .module("ngStorage", [])
    .provider("$localStorage", _storageProvider("localStorage"))
    .provider("$sessionStorage", _storageProvider("sessionStorage"));
  function _storageProvider(storageType) {
    var providerWebStorage = isStorageSupported(window, storageType);
    return function () {
      var storageKeyPrefix = "ngStorage-";
      this.setKeyPrefix = function (prefix) {
        if (typeof prefix !== "string") {
          throw new TypeError(
            "[ngStorage] - " +
              storageType +
              "Provider.setKeyPrefix() expects a String."
          );
        }
        storageKeyPrefix = prefix;
      };
      var serializer = angular.toJson;
      var deserializer = angular.fromJson;
      this.setSerializer = function (s) {
        if (typeof s !== "function") {
          throw new TypeError(
            "[ngStorage] - " +
              storageType +
              "Provider.setSerializer expects a function."
          );
        }
        serializer = s;
      };
      this.setDeserializer = function (d) {
        if (typeof d !== "function") {
          throw new TypeError(
            "[ngStorage] - " +
              storageType +
              "Provider.setDeserializer expects a function."
          );
        }
        deserializer = d;
      };
      this.supported = function () {
        return !!providerWebStorage;
      };
      this.get = function (key) {
        return (
          providerWebStorage &&
          deserializer(providerWebStorage.getItem(storageKeyPrefix + key))
        );
      };
      this.set = function (key, value) {
        return (
          providerWebStorage &&
          providerWebStorage.setItem(storageKeyPrefix + key, serializer(value))
        );
      };
      this.remove = function (key) {
        providerWebStorage &&
          providerWebStorage.removeItem(storageKeyPrefix + key);
      };
      this.$get = [
        "$rootScope",
        "$window",
        "$log",
        "$timeout",
        "$document",
        function ($rootScope, $window, $log, $timeout, $document) {
          var prefixLength = storageKeyPrefix.length;
          var isSupported = isStorageSupported($window, storageType),
            webStorage =
              isSupported ||
              ($log.warn("This browser does not support Web Storage!"),
              {
                setItem: angular.noop,
                getItem: angular.noop,
                removeItem: angular.noop,
              }),
            $storage = {
              $default: function (items) {
                for (var k in items) {
                  angular.isDefined($storage[k]) ||
                    ($storage[k] = angular.copy(items[k]));
                }
                $storage.$sync();
                return $storage;
              },
              $reset: function (items) {
                for (var k in $storage) {
                  "$" === k[0] ||
                    (delete $storage[k] &&
                      webStorage.removeItem(storageKeyPrefix + k));
                }
                return $storage.$default(items);
              },
              $sync: function () {
                for (var i = 0, l = webStorage.length, k; i < l; i++) {
                  (k = webStorage.key(i)) &&
                    storageKeyPrefix === k.slice(0, prefixLength) &&
                    ($storage[k.slice(prefixLength)] = deserializer(
                      webStorage.getItem(k)
                    ));
                }
              },
              $apply: function () {
                var temp$storage;
                _debounce = null;
                if (!angular.equals($storage, _last$storage)) {
                  temp$storage = angular.copy(_last$storage);
                  angular.forEach($storage, function (v, k) {
                    if (angular.isDefined(v) && "$" !== k[0]) {
                      webStorage.setItem(storageKeyPrefix + k, serializer(v));
                      delete temp$storage[k];
                    }
                  });
                  for (var k in temp$storage) {
                    webStorage.removeItem(storageKeyPrefix + k);
                  }
                  _last$storage = angular.copy($storage);
                }
              },
              $supported: function () {
                return !!isSupported;
              },
            },
            _last$storage,
            _debounce;
          $storage.$sync();
          _last$storage = angular.copy($storage);
          $rootScope.$watch(function () {
            _debounce || (_debounce = $timeout($storage.$apply, 100, false));
          });
          $window.addEventListener &&
            $window.addEventListener("storage", function (event) {
              if (!event.key) {
                return;
              }
              var doc = $document[0];
              if (
                (!doc.hasFocus || !doc.hasFocus()) &&
                storageKeyPrefix === event.key.slice(0, prefixLength)
              ) {
                event.newValue
                  ? ($storage[event.key.slice(prefixLength)] = deserializer(
                      event.newValue
                    ))
                  : delete $storage[event.key.slice(prefixLength)];
                _last$storage = angular.copy($storage);
                $rootScope.$apply();
              }
            });
          $window.addEventListener &&
            $window.addEventListener("beforeunload", function () {
              $storage.$apply();
            });
          return $storage;
        },
      ];
    };
  }
});
(function () {
  "use strict";
  angular.module("focus-if", []).directive("focusIf", focusIf);
  focusIf.$inject = ["$timeout"];
  function focusIf($timeout) {
    function link($scope, $element, $attrs) {
      var dom = $element[0];
      if ($attrs.focusIf) {
        $scope.$watch($attrs.focusIf, focus);
      } else {
        focus(true);
      }
      function focus(condition) {
        if (condition) {
          $timeout(function () {
            dom.focus();
          }, $scope.$eval($attrs.focusDelay) || 0);
        }
      }
    }
    return { restrict: "A", link: link };
  }
})();
(function (window, angular) {
  "use strict";
  var ngTouch = angular.module("ngTouch", []);
  ngTouch.provider("$touch", $TouchProvider);
  function nodeName_(element) {
    return angular.lowercase(
      element.nodeName || (element[0] && element[0].nodeName)
    );
  }
  $TouchProvider.$inject = ["$provide", "$compileProvider"];
  function $TouchProvider($provide, $compileProvider) {
    var ngClickOverrideEnabled = false;
    var ngClickDirectiveAdded = false;
    this.ngClickOverrideEnabled = function (enabled) {
      if (angular.isDefined(enabled)) {
        if (enabled && !ngClickDirectiveAdded) {
          ngClickDirectiveAdded = true;
          ngTouchClickDirectiveFactory.$$moduleName = "ngTouch";
          $compileProvider.directive("ngClick", ngTouchClickDirectiveFactory);
          $provide.decorator("ngClickDirective", [
            "$delegate",
            function ($delegate) {
              if (ngClickOverrideEnabled) {
                $delegate.shift();
              } else {
                var i = $delegate.length - 1;
                while (i >= 0) {
                  if ($delegate[i].$$moduleName === "ngTouch") {
                    $delegate.splice(i, 1);
                    break;
                  }
                  i--;
                }
              }
              return $delegate;
            },
          ]);
        }
        ngClickOverrideEnabled = enabled;
        return this;
      }
      return ngClickOverrideEnabled;
    };
    this.$get = function () {
      return {
        ngClickOverrideEnabled: function () {
          return ngClickOverrideEnabled;
        },
      };
    };
  }
  ngTouch.factory("$swipe", [
    function () {
      var MOVE_BUFFER_RADIUS = 10;
      var POINTER_EVENTS = {
        mouse: { start: "mousedown", move: "mousemove", end: "mouseup" },
        touch: {
          start: "touchstart",
          move: "touchmove",
          end: "touchend",
          cancel: "touchcancel",
        },
        pointer: {
          start: "pointerdown",
          move: "pointermove",
          end: "pointerup",
          cancel: "pointercancel",
        },
      };
      function getCoordinates(event) {
        var originalEvent = event.originalEvent || event;
        var touches =
          originalEvent.touches && originalEvent.touches.length
            ? originalEvent.touches
            : [originalEvent];
        var e =
          (originalEvent.changedTouches && originalEvent.changedTouches[0]) ||
          touches[0];
        return { x: e.clientX, y: e.clientY };
      }
      function getEvents(pointerTypes, eventType) {
        var res = [];
        angular.forEach(pointerTypes, function (pointerType) {
          var eventName = POINTER_EVENTS[pointerType][eventType];
          if (eventName) {
            res.push(eventName);
          }
        });
        return res.join(" ");
      }
      return {
        bind: function (element, eventHandlers, pointerTypes) {
          var totalX, totalY;
          var startCoords;
          var lastPos;
          var active = false;
          pointerTypes = pointerTypes || ["mouse", "touch", "pointer"];
          element.on(getEvents(pointerTypes, "start"), function (event) {
            startCoords = getCoordinates(event);
            active = true;
            totalX = 0;
            totalY = 0;
            lastPos = startCoords;
            if (eventHandlers["start"]) {
              eventHandlers["start"](startCoords, event);
            }
          });
          var events = getEvents(pointerTypes, "cancel");
          if (events) {
            element.on(events, function (event) {
              active = false;
              if (eventHandlers["cancel"]) {
                eventHandlers["cancel"](event);
              }
            });
          }
          element.on(getEvents(pointerTypes, "move"), function (event) {
            if (!active) return;
            if (!startCoords) return;
            var coords = getCoordinates(event);
            totalX += Math.abs(coords.x - lastPos.x);
            totalY += Math.abs(coords.y - lastPos.y);
            lastPos = coords;
            if (totalX < MOVE_BUFFER_RADIUS && totalY < MOVE_BUFFER_RADIUS) {
              return;
            }
            if (totalY > totalX) {
              active = false;
              if (eventHandlers["cancel"]) {
                eventHandlers["cancel"](event);
              }
              return;
            } else {
              event.preventDefault();
              if (eventHandlers["move"]) {
                eventHandlers["move"](coords, event);
              }
            }
          });
          element.on(getEvents(pointerTypes, "end"), function (event) {
            if (!active) return;
            active = false;
            if (eventHandlers["end"]) {
              eventHandlers["end"](getCoordinates(event), event);
            }
          });
        },
      };
    },
  ]);
  var ngTouchClickDirectiveFactory = [
    "$parse",
    "$timeout",
    "$rootElement",
    function ($parse, $timeout, $rootElement) {
      var TAP_DURATION = 750;
      var MOVE_TOLERANCE = 12;
      var PREVENT_DURATION = 2500;
      var CLICKBUSTER_THRESHOLD = 25;
      var ACTIVE_CLASS_NAME = "ng-click-active";
      var lastPreventedTime;
      var touchCoordinates;
      var lastLabelClickCoordinates;
      function hit(x1, y1, x2, y2) {
        return (
          Math.abs(x1 - x2) < CLICKBUSTER_THRESHOLD &&
          Math.abs(y1 - y2) < CLICKBUSTER_THRESHOLD
        );
      }
      function checkAllowableRegions(touchCoordinates, x, y) {
        for (var i = 0; i < touchCoordinates.length; i += 2) {
          if (hit(touchCoordinates[i], touchCoordinates[i + 1], x, y)) {
            touchCoordinates.splice(i, i + 2);
            return true;
          }
        }
        return false;
      }
      function onClick(event) {
        if (Date.now() - lastPreventedTime > PREVENT_DURATION) {
          return;
        }
        var touches =
          event.touches && event.touches.length ? event.touches : [event];
        var x = touches[0].clientX;
        var y = touches[0].clientY;
        if (x < 1 && y < 1) {
          return;
        }
        if (
          lastLabelClickCoordinates &&
          lastLabelClickCoordinates[0] === x &&
          lastLabelClickCoordinates[1] === y
        ) {
          return;
        }
        if (lastLabelClickCoordinates) {
          lastLabelClickCoordinates = null;
        }
        if (nodeName_(event.target) === "label") {
          lastLabelClickCoordinates = [x, y];
        }
        if (checkAllowableRegions(touchCoordinates, x, y)) {
          return;
        }
        event.stopPropagation();
        event.preventDefault();
        if (event.target && event.target.blur) {
          event.target.blur();
        }
      }
      function onTouchStart(event) {
        var touches =
          event.touches && event.touches.length ? event.touches : [event];
        var x = touches[0].clientX;
        var y = touches[0].clientY;
        touchCoordinates.push(x, y);
        $timeout(
          function () {
            for (var i = 0; i < touchCoordinates.length; i += 2) {
              if (touchCoordinates[i] === x && touchCoordinates[i + 1] === y) {
                touchCoordinates.splice(i, i + 2);
                return;
              }
            }
          },
          PREVENT_DURATION,
          false
        );
      }
      function preventGhostClick(x, y) {
        if (!touchCoordinates) {
          $rootElement[0].addEventListener("click", onClick, true);
          $rootElement[0].addEventListener("touchstart", onTouchStart, true);
          touchCoordinates = [];
        }
        lastPreventedTime = Date.now();
        checkAllowableRegions(touchCoordinates, x, y);
      }
      return function (scope, element, attr) {
        var clickHandler = $parse(attr.ngClick),
          tapping = false,
          tapElement,
          startTime,
          touchStartX,
          touchStartY;
        function resetState() {
          tapping = false;
          element.removeClass(ACTIVE_CLASS_NAME);
        }
        element.on("touchstart", function (event) {
          tapping = true;
          tapElement = event.target ? event.target : event.srcElement;
          if (tapElement.nodeType === 3) {
            tapElement = tapElement.parentNode;
          }
          element.addClass(ACTIVE_CLASS_NAME);
          startTime = Date.now();
          var originalEvent = event.originalEvent || event;
          var touches =
            originalEvent.touches && originalEvent.touches.length
              ? originalEvent.touches
              : [originalEvent];
          var e = touches[0];
          touchStartX = e.clientX;
          touchStartY = e.clientY;
        });
        element.on("touchcancel", function (event) {
          resetState();
        });
        element.on("touchend", function (event) {
          var diff = Date.now() - startTime;
          var originalEvent = event.originalEvent || event;
          var touches =
            originalEvent.changedTouches && originalEvent.changedTouches.length
              ? originalEvent.changedTouches
              : originalEvent.touches && originalEvent.touches.length
              ? originalEvent.touches
              : [originalEvent];
          var e = touches[0];
          var x = e.clientX;
          var y = e.clientY;
          var dist = Math.sqrt(
            Math.pow(x - touchStartX, 2) + Math.pow(y - touchStartY, 2)
          );
          if (tapping && diff < TAP_DURATION && dist < MOVE_TOLERANCE) {
            preventGhostClick(x, y);
            if (tapElement) {
              tapElement.blur();
            }
            if (!angular.isDefined(attr.disabled) || attr.disabled === false) {
              element.triggerHandler("click", [event]);
            }
          }
          resetState();
        });
        element.onclick = function (event) {};
        element.on("click", function (event, touchend) {
          scope.$apply(function () {
            clickHandler(scope, { $event: touchend || event });
          });
        });
        element.on("mousedown", function (event) {
          element.addClass(ACTIVE_CLASS_NAME);
        });
        element.on("mousemove mouseup", function (event) {
          element.removeClass(ACTIVE_CLASS_NAME);
        });
      };
    },
  ];
  function makeSwipeDirective(directiveName, direction, eventName) {
    ngTouch.directive(directiveName, [
      "$parse",
      "$swipe",
      function ($parse, $swipe) {
        var MAX_VERTICAL_DISTANCE = 75;
        var MAX_VERTICAL_RATIO = 0.3;
        var MIN_HORIZONTAL_DISTANCE = 30;
        return function (scope, element, attr) {
          var swipeHandler = $parse(attr[directiveName]);
          var startCoords, valid;
          function validSwipe(coords) {
            if (!startCoords) return false;
            var deltaY = Math.abs(coords.y - startCoords.y);
            var deltaX = (coords.x - startCoords.x) * direction;
            return (
              valid &&
              deltaY < MAX_VERTICAL_DISTANCE &&
              deltaX > 0 &&
              deltaX > MIN_HORIZONTAL_DISTANCE &&
              deltaY / deltaX < MAX_VERTICAL_RATIO
            );
          }
          var pointerTypes = ["touch"];
          if (!angular.isDefined(attr["ngSwipeDisableMouse"])) {
            pointerTypes.push("mouse");
          }
          $swipe.bind(
            element,
            {
              start: function (coords, event) {
                startCoords = coords;
                valid = true;
              },
              cancel: function (event) {
                valid = false;
              },
              end: function (coords, event) {
                if (validSwipe(coords)) {
                  scope.$apply(function () {
                    element.triggerHandler(eventName);
                    swipeHandler(scope, { $event: event });
                  });
                }
              },
            },
            pointerTypes
          );
        };
      },
    ]);
  }
  makeSwipeDirective("ngSwipeLeft", -1, "swipeleft");
  makeSwipeDirective("ngSwipeRight", 1, "swiperight");
})(window, window.angular);
!(function () {
  "use strict";
  angular
    .module("cfp.hotkeys", [])
    .provider("hotkeys", [
      "$injector",
      function (a) {
        (this.includeCheatSheet = !0),
          (this.useNgRoute = a.has("ngViewDirective")),
          (this.templateTitle = "Keyboard Shortcuts:"),
          (this.templateHeader = null),
          (this.templateFooter = null),
          (this.template =
            '<div class="cfp-hotkeys-container fade" ng-class="{in: helpVisible}" style="display: none;"><div class="cfp-hotkeys"><h4 class="cfp-hotkeys-title" ng-if="!header">{{ title }}</h4><div ng-bind-html="header" ng-if="header"></div><table><tbody><tr ng-repeat="hotkey in hotkeys | filter:{ description: \'!$$undefined$$\' }"><td class="cfp-hotkeys-keys"><span ng-repeat="key in hotkey.format() track by $index" class="cfp-hotkeys-key">{{ key }}</span></td><td class="cfp-hotkeys-text">{{ hotkey.description }}</td></tr></tbody></table><div ng-bind-html="footer" ng-if="footer"></div><div class="cfp-hotkeys-close" ng-click="toggleCheatSheet()">&#215;</div></div></div>'),
          (this.cheatSheetHotkey = "?"),
          (this.cheatSheetDescription = "Show / hide this help menu"),
          (this.$get = [
            "$rootElement",
            "$rootScope",
            "$compile",
            "$window",
            "$document",
            function (a, b, c, d, e) {
              function f() {
                q = !1;
              }
              function g() {
                q = !0;
              }
              function h(a) {
                var b = {
                  command: "",
                  shift: "",
                  left: "",
                  right: "",
                  up: "",
                  down: "",
                  return: "",
                  backspace: "",
                };
                a = a.split("+");
                for (var c = 0; c < a.length; c++)
                  "mod" === a[c] &&
                    (d.navigator && d.navigator.platform.indexOf("Mac") >= 0
                      ? (a[c] = "command")
                      : (a[c] = "ctrl")),
                    (a[c] = b[a[c]] || a[c]);
                return a.join(" + ");
              }
              function i(a, b, c, d, e, f) {
                (this.combo = a instanceof Array ? a : [a]),
                  (this.description = b),
                  (this.callback = c),
                  (this.action = d),
                  (this.allowIn = e),
                  (this.persistent = f),
                  (this._formated = null);
              }
              function j() {
                for (var a = r.hotkeys.length; a--; ) {
                  var b = r.hotkeys[a];
                  b && !b.persistent && m(b);
                }
              }
              function k() {
                (r.helpVisible = !r.helpVisible),
                  r.helpVisible
                    ? ((w = n("esc")),
                      m("esc"),
                      l("esc", w.description, k, null, [
                        "INPUT",
                        "SELECT",
                        "TEXTAREA",
                      ]))
                    : (m("esc"), w !== !1 && l(w));
              }
              function l(a, b, c, d, e, f) {
                var g,
                  h = ["INPUT", "SELECT", "TEXTAREA"],
                  j = Object.prototype.toString.call(a);
                if (
                  ("[object Object]" === j &&
                    ((b = a.description),
                    (c = a.callback),
                    (d = a.action),
                    (f = a.persistent),
                    (e = a.allowIn),
                    (a = a.combo)),
                  m(a),
                  b instanceof Function
                    ? ((d = c), (c = b), (b = "$$undefined$$"))
                    : angular.isUndefined(b) && (b = "$$undefined$$"),
                  void 0 === f && (f = !0),
                  "function" == typeof c)
                ) {
                  (g = c), e instanceof Array || (e = []);
                  for (var k, l = 0; l < e.length; l++)
                    (e[l] = e[l].toUpperCase()),
                      (k = h.indexOf(e[l])),
                      -1 !== k && h.splice(k, 1);
                  c = function (a) {
                    var b = !0;
                    if (a) {
                      var c = a.target || a.srcElement,
                        d = c.nodeName.toUpperCase();
                      if ((" " + c.className + " ").indexOf(" mousetrap ") > -1)
                        b = !0;
                      else
                        for (var e = 0; e < h.length; e++)
                          if (h[e] === d) {
                            b = !1;
                            break;
                          }
                    }
                    b && p(g.apply(this, arguments));
                  };
                }
                "string" == typeof d
                  ? Mousetrap.bind(a, p(c), d)
                  : Mousetrap.bind(a, p(c));
                var n = new i(a, b, c, d, e, f);
                return r.hotkeys.push(n), n;
              }
              function m(a) {
                var b = a instanceof i ? a.combo : a;
                if ((Mousetrap.unbind(b), angular.isArray(b))) {
                  for (var c = !0, d = b.length; d--; ) c = m(b[d]) && c;
                  return c;
                }
                var e = r.hotkeys.indexOf(n(b));
                return e > -1
                  ? (r.hotkeys[e].combo.length > 1
                      ? r.hotkeys[e].combo.splice(
                          r.hotkeys[e].combo.indexOf(b),
                          1
                        )
                      : (angular.forEach(s, function (a) {
                          var b = a.indexOf(r.hotkeys[e]);
                          -1 !== b && a.splice(b, 1);
                        }),
                        r.hotkeys.splice(e, 1)),
                    !0)
                  : !1;
              }
              function n(a) {
                if (!a) return r.hotkeys;
                for (var b, c = 0; c < r.hotkeys.length; c++)
                  if (((b = r.hotkeys[c]), b.combo.indexOf(a) > -1)) return b;
                return !1;
              }
              function o(a) {
                return (
                  a.$id in s ||
                    ((s[a.$id] = []),
                    a.$on("$destroy", function () {
                      for (var b = s[a.$id].length; b--; ) m(s[a.$id].pop());
                    })),
                  {
                    add: function (b) {
                      var c;
                      return (
                        (c =
                          arguments.length > 1
                            ? l.apply(this, arguments)
                            : l(b)),
                        s[a.$id].push(c),
                        this
                      );
                    },
                  }
                );
              }
              function p(a) {
                return function (c, d) {
                  if (a instanceof Array) {
                    var e = a[0],
                      f = a[1];
                    a = function (a) {
                      f.scope.$eval(e);
                    };
                  }
                  b.$apply(function () {
                    a(c, n(d));
                  });
                };
              }
              var q = !0;
              (Mousetrap.prototype.stopCallback = function (a, b) {
                return q
                  ? (" " + b.className + " ").indexOf(" mousetrap ") > -1
                    ? !1
                    : b.contentEditable && "true" == b.contentEditable
                  : !0;
              }),
                (i.prototype.format = function () {
                  if (null === this._formated) {
                    for (
                      var a = this.combo[0], b = a.split(/[\s]/), c = 0;
                      c < b.length;
                      c++
                    )
                      b[c] = h(b[c]);
                    this._formated = b;
                  }
                  return this._formated;
                });
              var r = b.$new();
              (r.hotkeys = []),
                (r.helpVisible = !1),
                (r.title = this.templateTitle),
                (r.header = this.templateHeader),
                (r.footer = this.templateFooter),
                (r.toggleCheatSheet = k);
              var s = {};
              if (
                (this.useNgRoute &&
                  b.$on("$routeChangeSuccess", function (a, b) {
                    j(),
                      b &&
                        b.hotkeys &&
                        angular.forEach(b.hotkeys, function (a) {
                          var c = a[2];
                          ("string" == typeof c || c instanceof String) &&
                            (a[2] = [c, b]),
                            (a[5] = !1),
                            l.apply(this, a);
                        });
                  }),
                this.includeCheatSheet)
              ) {
                var t = e[0],
                  u = a[0],
                  v = angular.element(this.template);
                l(this.cheatSheetHotkey, this.cheatSheetDescription, k),
                  (u === t || u === t.documentElement) && (u = t.body),
                  angular.element(u).append(c(v)(r));
              }
              var w = !1,
                x = {
                  add: l,
                  del: m,
                  get: n,
                  bindTo: o,
                  template: this.template,
                  toggleCheatSheet: k,
                  includeCheatSheet: this.includeCheatSheet,
                  cheatSheetHotkey: this.cheatSheetHotkey,
                  cheatSheetDescription: this.cheatSheetDescription,
                  useNgRoute: this.useNgRoute,
                  purgeHotkeys: j,
                  templateTitle: this.templateTitle,
                  pause: f,
                  unpause: g,
                };
              return x;
            },
          ]);
      },
    ])
    .directive("hotkey", [
      "hotkeys",
      function (a) {
        return {
          restrict: "A",
          link: function (b, c, d) {
            var e,
              f = [];
            angular.forEach(b.$eval(d.hotkey), function (b, c) {
              (e =
                "string" == typeof d.hotkeyAllowIn
                  ? d.hotkeyAllowIn.split(/[\s,]+/)
                  : []),
                f.push(c),
                a.add({
                  combo: c,
                  description: d.hotkeyDescription,
                  callback: b,
                  action: d.hotkeyAction,
                  allowIn: e,
                });
            }),
              c.bind("$destroy", function () {
                angular.forEach(f, a.del);
              });
          },
        };
      },
    ])
    .run(["hotkeys", function (a) {}]);
})(),
  (function (a, b, c) {
    function d(a, b, c) {
      return a.addEventListener
        ? void a.addEventListener(b, c, !1)
        : void a.attachEvent("on" + b, c);
    }
    function e(a) {
      if ("keypress" == a.type) {
        var b = String.fromCharCode(a.which);
        return a.shiftKey || (b = b.toLowerCase()), b;
      }
      return r[a.which]
        ? r[a.which]
        : s[a.which]
        ? s[a.which]
        : String.fromCharCode(a.which).toLowerCase();
    }
    function f(a, b) {
      return a.sort().join(",") === b.sort().join(",");
    }
    function g(a) {
      var b = [];
      return (
        a.shiftKey && b.push("shift"),
        a.altKey && b.push("alt"),
        a.ctrlKey && b.push("ctrl"),
        a.metaKey && b.push("meta"),
        b
      );
    }
    function h(a) {
      return a.preventDefault
        ? void a.preventDefault()
        : void (a.returnValue = !1);
    }
    function i(a) {
      return a.stopPropagation
        ? void a.stopPropagation()
        : void (a.cancelBubble = !0);
    }
    function j(a) {
      return "shift" == a || "ctrl" == a || "alt" == a || "meta" == a;
    }
    function k() {
      if (!q) {
        q = {};
        for (var a in r)
          (a > 95 && 112 > a) || (r.hasOwnProperty(a) && (q[r[a]] = a));
      }
      return q;
    }
    function l(a, b, c) {
      return (
        c || (c = k()[a] ? "keydown" : "keypress"),
        "keypress" == c && b.length && (c = "keydown"),
        c
      );
    }
    function m(a) {
      return "+" === a
        ? ["+"]
        : ((a = a.replace(/\+{2}/g, "+plus")), a.split("+"));
    }
    function n(a, b) {
      var c,
        d,
        e,
        f = [];
      for (c = m(a), e = 0; e < c.length; ++e)
        (d = c[e]),
          u[d] && (d = u[d]),
          b && "keypress" != b && t[d] && ((d = t[d]), f.push("shift")),
          j(d) && f.push(d);
      return (b = l(d, f, b)), { key: d, modifiers: f, action: b };
    }
    function o(a, c) {
      return a === b ? !1 : a === c ? !0 : o(a.parentNode, c);
    }
    function p(a) {
      function c(a) {
        a = a || {};
        var b,
          c = !1;
        for (b in u) a[b] ? (c = !0) : (u[b] = 0);
        c || (x = !1);
      }
      function k(a, b, c, d, e, g) {
        var h,
          i,
          k = [],
          l = c.type;
        if (!s._callbacks[a]) return [];
        for (
          "keyup" == l && j(a) && (b = [a]), h = 0;
          h < s._callbacks[a].length;
          ++h
        )
          if (
            ((i = s._callbacks[a][h]),
            (d || !i.seq || u[i.seq] == i.level) &&
              l == i.action &&
              (("keypress" == l && !c.metaKey && !c.ctrlKey) ||
                f(b, i.modifiers)))
          ) {
            var m = !d && i.combo == e,
              n = d && i.seq == d && i.level == g;
            (m || n) && s._callbacks[a].splice(h, 1), k.push(i);
          }
        return k;
      }
      function l(a, b, c, d) {
        s.stopCallback(b, b.target || b.srcElement, c, d) ||
          (a(b, c) === !1 && (h(b), i(b)));
      }
      function m(a) {
        "number" != typeof a.which && (a.which = a.keyCode);
        var b = e(a);
        if (b)
          return "keyup" == a.type && v === b
            ? void (v = !1)
            : void s.handleKey(b, g(a), a);
      }
      function o() {
        clearTimeout(t), (t = setTimeout(c, 1e3));
      }
      function q(a, b, d, f) {
        function g(b) {
          return function () {
            (x = b), ++u[a], o();
          };
        }
        function h(b) {
          l(d, b, a), "keyup" !== f && (v = e(b)), setTimeout(c, 10);
        }
        u[a] = 0;
        for (var i = 0; i < b.length; ++i) {
          var j = i + 1 === b.length,
            k = j ? h : g(f || n(b[i + 1]).action);
          r(b[i], k, f, a, i);
        }
      }
      function r(a, b, c, d, e) {
        (s._directMap[a + ":" + c] = b), (a = a.replace(/\s+/g, " "));
        var f,
          g = a.split(" ");
        return g.length > 1
          ? void q(a, g, b, c)
          : ((f = n(a, c)),
            (s._callbacks[f.key] = s._callbacks[f.key] || []),
            k(f.key, f.modifiers, { type: f.action }, d, a, e),
            void s._callbacks[f.key][d ? "unshift" : "push"]({
              callback: b,
              modifiers: f.modifiers,
              action: f.action,
              seq: d,
              level: e,
              combo: a,
            }));
      }
      var s = this;
      if (((a = a || b), !(s instanceof p))) return new p(a);
      (s.target = a), (s._callbacks = {}), (s._directMap = {});
      var t,
        u = {},
        v = !1,
        w = !1,
        x = !1;
      (s._handleKey = function (a, b, d) {
        var e,
          f = k(a, b, d),
          g = {},
          h = 0,
          i = !1;
        for (e = 0; e < f.length; ++e)
          f[e].seq && (h = Math.max(h, f[e].level));
        for (e = 0; e < f.length; ++e)
          if (f[e].seq) {
            if (f[e].level != h) continue;
            (i = !0),
              (g[f[e].seq] = 1),
              l(f[e].callback, d, f[e].combo, f[e].seq);
          } else i || l(f[e].callback, d, f[e].combo);
        var m = "keypress" == d.type && w;
        d.type != x || j(a) || m || c(g), (w = i && "keydown" == d.type);
      }),
        (s._bindMultiple = function (a, b, c) {
          for (var d = 0; d < a.length; ++d) r(a[d], b, c);
        }),
        d(a, "keypress", m),
        d(a, "keydown", m),
        d(a, "keyup", m);
    }
    for (
      var q,
        r = {
          8: "backspace",
          9: "tab",
          13: "enter",
          16: "shift",
          17: "ctrl",
          18: "alt",
          20: "capslock",
          27: "esc",
          32: "space",
          33: "pageup",
          34: "pagedown",
          35: "end",
          36: "home",
          37: "left",
          38: "up",
          39: "right",
          40: "down",
          45: "ins",
          46: "del",
          91: "meta",
          93: "meta",
          224: "meta",
        },
        s = {
          106: "*",
          107: "+",
          109: "-",
          110: ".",
          111: "/",
          186: ";",
          187: "=",
          188: ",",
          189: "-",
          190: ".",
          191: "/",
          192: "`",
          219: "[",
          220: "\\",
          221: "]",
          222: "'",
        },
        t = {
          "~": "`",
          "!": "1",
          "@": "2",
          "#": "3",
          $: "4",
          "%": "5",
          "^": "6",
          "&": "7",
          "*": "8",
          "(": "9",
          ")": "0",
          _: "-",
          "+": "=",
          ":": ";",
          '"': "'",
          "<": ",",
          ">": ".",
          "?": "/",
          "|": "\\",
        },
        u = {
          option: "alt",
          command: "meta",
          return: "enter",
          escape: "esc",
          plus: "+",
          mod: /Mac|iPod|iPhone|iPad/.test(navigator.platform)
            ? "meta"
            : "ctrl",
        },
        v = 1;
      20 > v;
      ++v
    )
      r[111 + v] = "f" + v;
    for (v = 0; 9 >= v; ++v) r[v + 96] = v;
    (p.prototype.bind = function (a, b, c) {
      var d = this;
      return (
        (a = a instanceof Array ? a : [a]), d._bindMultiple.call(d, a, b, c), d
      );
    }),
      (p.prototype.unbind = function (a, b) {
        var c = this;
        return c.bind.call(c, a, function () {}, b);
      }),
      (p.prototype.trigger = function (a, b) {
        var c = this;
        return c._directMap[a + ":" + b] && c._directMap[a + ":" + b]({}, a), c;
      }),
      (p.prototype.reset = function () {
        var a = this;
        return (a._callbacks = {}), (a._directMap = {}), a;
      }),
      (p.prototype.stopCallback = function (a, b) {
        var c = this;
        return (" " + b.className + " ").indexOf(" mousetrap ") > -1
          ? !1
          : o(b, c.target)
          ? !1
          : "INPUT" == b.tagName ||
            "SELECT" == b.tagName ||
            "TEXTAREA" == b.tagName ||
            b.isContentEditable;
      }),
      (p.prototype.handleKey = function () {
        var a = this;
        return a._handleKey.apply(a, arguments);
      }),
      (p.init = function () {
        var a = p(b);
        for (var c in a)
          "_" !== c.charAt(0) &&
            (p[c] = (function (b) {
              return function () {
                return a[b].apply(a, arguments);
              };
            })(c));
      }),
      p.init(),
      (a.Mousetrap = p),
      "undefined" != typeof module && module.exports && (module.exports = p),
      "function" == typeof define &&
        define.amd &&
        define(function () {
          return p;
        });
  })(window, document);
angular
  .module("ngProgress.provider", ["ngProgress.directive"])
  .service("ngProgress", function () {
    "use strict";
    return [
      "$document",
      "$window",
      "$compile",
      "$rootScope",
      "$timeout",
      function ($document, $window, $compile, $rootScope, $timeout) {
        this.autoStyle = true;
        this.count = 0;
        this.height = "2px";
        this.$scope = $rootScope.$new();
        this.color = "firebrick";
        this.parent = $document.find("body")[0];
        this.count = 0;
        this.progressbarEl = $compile("<ng-progress></ng-progress>")(
          this.$scope
        );
        this.parent.appendChild(this.progressbarEl[0]);
        this.$scope.count = this.count;
        if (this.height !== undefined) {
          this.progressbarEl.eq(0).children().css("height", this.height);
        }
        if (this.color !== undefined) {
          this.progressbarEl
            .eq(0)
            .children()
            .css("background-color", this.color);
          this.progressbarEl.eq(0).children().css("color", this.color);
        }
        this.intervalCounterId = 0;
        this.start = function () {
          this.show();
          var self = this;
          clearInterval(this.intervalCounterId);
          this.intervalCounterId = setInterval(function () {
            if (isNaN(self.count)) {
              clearInterval(self.intervalCounterId);
              self.count = 0;
              self.hide();
            } else {
              self.remaining = 100 - self.count;
              self.count =
                self.count + 0.15 * Math.pow(1 - Math.sqrt(self.remaining), 2);
              self.updateCount(self.count);
            }
          }, 200);
        };
        this.updateCount = function (new_count) {
          this.$scope.count = new_count;
          if (!this.$scope.$$phase) {
            this.$scope.$apply();
          }
        };
        this.setHeight = function (new_height) {
          if (new_height !== undefined) {
            this.height = new_height;
            this.$scope.height = this.height;
            if (!this.$scope.$$phase) {
              this.$scope.$apply();
            }
          }
          return this.height;
        };
        this.setColor = function (new_color) {
          if (new_color !== undefined) {
            this.color = new_color;
            this.$scope.color = this.color;
            if (!this.$scope.$$phase) {
              this.$scope.$apply();
            }
          }
          return this.color;
        };
        this.hide = function () {
          this.progressbarEl.children().css("opacity", "0");
          var self = this;
          self.animate(function () {
            self.progressbarEl.children().css("width", "0%");
            self.animate(function () {
              self.show();
            }, 500);
          }, 500);
        };
        this.show = function () {
          var self = this;
          self.animate(function () {
            self.progressbarEl.children().css("opacity", "1");
          }, 100);
        };
        this.animate = function (fn, time) {
          if (this.animation !== undefined) {
            $timeout.cancel(this.animation);
          }
          this.animation = $timeout(fn, time);
        };
        this.status = function () {
          return this.count;
        };
        this.stop = function () {
          clearInterval(this.intervalCounterId);
        };
        this.set = function (new_count) {
          this.show();
          this.updateCount(new_count);
          this.count = new_count;
          clearInterval(this.intervalCounterId);
          return this.count;
        };
        this.css = function (args) {
          return this.progressbarEl.children().css(args);
        };
        this.reset = function () {
          clearInterval(this.intervalCounterId);
          this.count = 0;
          this.updateCount(this.count);
          return 0;
        };
        this.complete = function () {
          this.count = 100;
          this.updateCount(this.count);
          var self = this;
          clearInterval(this.intervalCounterId);
          $timeout(function () {
            self.hide();
            $timeout(function () {
              self.count = 0;
              self.updateCount(self.count);
            }, 500);
          }, 1e3);
          return this.count;
        };
        this.setParent = function (newParent) {
          if (newParent === null || newParent === undefined) {
            throw new Error("Provide a valid parent of type HTMLElement");
          }
          if (this.parent !== null && this.parent !== undefined) {
            this.parent.removeChild(this.progressbarEl[0]);
          }
          this.parent = newParent;
          this.parent.appendChild(this.progressbarEl[0]);
        };
        this.getDomElement = function () {
          return this.progressbarEl;
        };
        this.setAbsolute = function () {
          this.progressbarEl.css("position", "absolute");
        };
      },
    ];
  })
  .factory("ngProgressFactory", function ($injector, ngProgress) {
    var service = {
      createInstance: function () {
        return $injector.instantiate(ngProgress);
      },
    };
    return service;
  });
angular.module("ngProgress.directive", []).directive("ngProgress", [
  "$window",
  "$rootScope",
  function ($window, $rootScope) {
    var directiveObj = {
      replace: true,
      restrict: "E",
      link: function ($scope, $element, $attrs, $controller) {
        $scope.$watch("count", function (newVal) {
          if (newVal !== undefined || newVal !== null) {
            $scope.counter = newVal;
            $element
              .eq(0)
              .children()
              .css("width", newVal + "%");
          }
        });
        $scope.$watch("color", function (newVal) {
          if (newVal !== undefined || newVal !== null) {
            $scope.color = newVal;
            $element.eq(0).children().css("background-color", newVal);
            $element.eq(0).children().css("color", newVal);
          }
        });
        $scope.$watch("height", function (newVal) {
          if (newVal !== undefined || newVal !== null) {
            $scope.height = newVal;
            $element.eq(0).children().css("height", newVal);
          }
        });
      },
      template:
        '<div id="ngProgress-container"><div id="ngProgress"></div></div>',
    };
    return directiveObj;
  },
]);
angular.module("ngProgress", ["ngProgress.directive", "ngProgress.provider"]);
/*! jQuery v2.1.3 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */
!(function (a, b) {
  "object" == typeof module && "object" == typeof module.exports
    ? (module.exports = a.document
        ? b(a, !0)
        : function (a) {
            if (!a.document)
              throw new Error("jQuery requires a window with a document");
            return b(a);
          })
    : b(a);
})("undefined" != typeof window ? window : this, function (a, b) {
  var c = [],
    d = c.slice,
    e = c.concat,
    f = c.push,
    g = c.indexOf,
    h = {},
    i = h.toString,
    j = h.hasOwnProperty,
    k = {},
    l = a.document,
    m = "2.1.3",
    n = function (a, b) {
      return new n.fn.init(a, b);
    },
    o = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
    p = /^-ms-/,
    q = /-([\da-z])/gi,
    r = function (a, b) {
      return b.toUpperCase();
    };
  (n.fn = n.prototype =
    {
      jquery: m,
      constructor: n,
      selector: "",
      length: 0,
      toArray: function () {
        return d.call(this);
      },
      get: function (a) {
        return null != a
          ? 0 > a
            ? this[a + this.length]
            : this[a]
          : d.call(this);
      },
      pushStack: function (a) {
        var b = n.merge(this.constructor(), a);
        return (b.prevObject = this), (b.context = this.context), b;
      },
      each: function (a, b) {
        return n.each(this, a, b);
      },
      map: function (a) {
        return this.pushStack(
          n.map(this, function (b, c) {
            return a.call(b, c, b);
          })
        );
      },
      slice: function () {
        return this.pushStack(d.apply(this, arguments));
      },
      first: function () {
        return this.eq(0);
      },
      last: function () {
        return this.eq(-1);
      },
      eq: function (a) {
        var b = this.length,
          c = +a + (0 > a ? b : 0);
        return this.pushStack(c >= 0 && b > c ? [this[c]] : []);
      },
      end: function () {
        return this.prevObject || this.constructor(null);
      },
      push: f,
      sort: c.sort,
      splice: c.splice,
    }),
    (n.extend = n.fn.extend =
      function () {
        var a,
          b,
          c,
          d,
          e,
          f,
          g = arguments[0] || {},
          h = 1,
          i = arguments.length,
          j = !1;
        for (
          "boolean" == typeof g && ((j = g), (g = arguments[h] || {}), h++),
            "object" == typeof g || n.isFunction(g) || (g = {}),
            h === i && ((g = this), h--);
          i > h;
          h++
        )
          if (null != (a = arguments[h]))
            for (b in a)
              (c = g[b]),
                (d = a[b]),
                g !== d &&
                  (j && d && (n.isPlainObject(d) || (e = n.isArray(d)))
                    ? (e
                        ? ((e = !1), (f = c && n.isArray(c) ? c : []))
                        : (f = c && n.isPlainObject(c) ? c : {}),
                      (g[b] = n.extend(j, f, d)))
                    : void 0 !== d && (g[b] = d));
        return g;
      }),
    n.extend({
      expando: "jQuery" + (m + Math.random()).replace(/\D/g, ""),
      isReady: !0,
      error: function (a) {
        throw new Error(a);
      },
      noop: function () {},
      isFunction: function (a) {
        return "function" === n.type(a);
      },
      isArray: Array.isArray,
      isWindow: function (a) {
        return null != a && a === a.window;
      },
      isNumeric: function (a) {
        return !n.isArray(a) && a - parseFloat(a) + 1 >= 0;
      },
      isPlainObject: function (a) {
        return "object" !== n.type(a) || a.nodeType || n.isWindow(a)
          ? !1
          : a.constructor && !j.call(a.constructor.prototype, "isPrototypeOf")
          ? !1
          : !0;
      },
      isEmptyObject: function (a) {
        var b;
        for (b in a) return !1;
        return !0;
      },
      type: function (a) {
        return null == a
          ? a + ""
          : "object" == typeof a || "function" == typeof a
          ? h[i.call(a)] || "object"
          : typeof a;
      },
      globalEval: function (a) {
        var b,
          c = eval;
        (a = n.trim(a)),
          a &&
            (1 === a.indexOf("use strict")
              ? ((b = l.createElement("script")),
                (b.text = a),
                l.head.appendChild(b).parentNode.removeChild(b))
              : c(a));
      },
      camelCase: function (a) {
        return a.replace(p, "ms-").replace(q, r);
      },
      nodeName: function (a, b) {
        return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase();
      },
      each: function (a, b, c) {
        var d,
          e = 0,
          f = a.length,
          g = s(a);
        if (c) {
          if (g) {
            for (; f > e; e++) if (((d = b.apply(a[e], c)), d === !1)) break;
          } else for (e in a) if (((d = b.apply(a[e], c)), d === !1)) break;
        } else if (g) {
          for (; f > e; e++) if (((d = b.call(a[e], e, a[e])), d === !1)) break;
        } else for (e in a) if (((d = b.call(a[e], e, a[e])), d === !1)) break;
        return a;
      },
      trim: function (a) {
        return null == a ? "" : (a + "").replace(o, "");
      },
      makeArray: function (a, b) {
        var c = b || [];
        return (
          null != a &&
            (s(Object(a))
              ? n.merge(c, "string" == typeof a ? [a] : a)
              : f.call(c, a)),
          c
        );
      },
      inArray: function (a, b, c) {
        return null == b ? -1 : g.call(b, a, c);
      },
      merge: function (a, b) {
        for (var c = +b.length, d = 0, e = a.length; c > d; d++) a[e++] = b[d];
        return (a.length = e), a;
      },
      grep: function (a, b, c) {
        for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++)
          (d = !b(a[f], f)), d !== h && e.push(a[f]);
        return e;
      },
      map: function (a, b, c) {
        var d,
          f = 0,
          g = a.length,
          h = s(a),
          i = [];
        if (h) for (; g > f; f++) (d = b(a[f], f, c)), null != d && i.push(d);
        else for (f in a) (d = b(a[f], f, c)), null != d && i.push(d);
        return e.apply([], i);
      },
      guid: 1,
      proxy: function (a, b) {
        var c, e, f;
        return (
          "string" == typeof b && ((c = a[b]), (b = a), (a = c)),
          n.isFunction(a)
            ? ((e = d.call(arguments, 2)),
              (f = function () {
                return a.apply(b || this, e.concat(d.call(arguments)));
              }),
              (f.guid = a.guid = a.guid || n.guid++),
              f)
            : void 0
        );
      },
      now: Date.now,
      support: k,
    }),
    n.each(
      "Boolean Number String Function Array Date RegExp Object Error".split(
        " "
      ),
      function (a, b) {
        h["[object " + b + "]"] = b.toLowerCase();
      }
    );
  function s(a) {
    var b = a.length,
      c = n.type(a);
    return "function" === c || n.isWindow(a)
      ? !1
      : 1 === a.nodeType && b
      ? !0
      : "array" === c ||
        0 === b ||
        ("number" == typeof b && b > 0 && b - 1 in a);
  }
  var t = (function (a) {
    var b,
      c,
      d,
      e,
      f,
      g,
      h,
      i,
      j,
      k,
      l,
      m,
      n,
      o,
      p,
      q,
      r,
      s,
      t,
      u = "sizzle" + 1 * new Date(),
      v = a.document,
      w = 0,
      x = 0,
      y = hb(),
      z = hb(),
      A = hb(),
      B = function (a, b) {
        return a === b && (l = !0), 0;
      },
      C = 1 << 31,
      D = {}.hasOwnProperty,
      E = [],
      F = E.pop,
      G = E.push,
      H = E.push,
      I = E.slice,
      J = function (a, b) {
        for (var c = 0, d = a.length; d > c; c++) if (a[c] === b) return c;
        return -1;
      },
      K =
        "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
      L = "[\\x20\\t\\r\\n\\f]",
      M = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
      N = M.replace("w", "w#"),
      O =
        "\\[" +
        L +
        "*(" +
        M +
        ")(?:" +
        L +
        "*([*^$|!~]?=)" +
        L +
        "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" +
        N +
        "))|)" +
        L +
        "*\\]",
      P =
        ":(" +
        M +
        ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" +
        O +
        ")*)|.*)\\)|)",
      Q = new RegExp(L + "+", "g"),
      R = new RegExp("^" + L + "+|((?:^|[^\\\\])(?:\\\\.)*)" + L + "+$", "g"),
      S = new RegExp("^" + L + "*," + L + "*"),
      T = new RegExp("^" + L + "*([>+~]|" + L + ")" + L + "*"),
      U = new RegExp("=" + L + "*([^\\]'\"]*?)" + L + "*\\]", "g"),
      V = new RegExp(P),
      W = new RegExp("^" + N + "$"),
      X = {
        ID: new RegExp("^#(" + M + ")"),
        CLASS: new RegExp("^\\.(" + M + ")"),
        TAG: new RegExp("^(" + M.replace("w", "w*") + ")"),
        ATTR: new RegExp("^" + O),
        PSEUDO: new RegExp("^" + P),
        CHILD: new RegExp(
          "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
            L +
            "*(even|odd|(([+-]|)(\\d*)n|)" +
            L +
            "*(?:([+-]|)" +
            L +
            "*(\\d+)|))" +
            L +
            "*\\)|)",
          "i"
        ),
        bool: new RegExp("^(?:" + K + ")$", "i"),
        needsContext: new RegExp(
          "^" +
            L +
            "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
            L +
            "*((?:-\\d)?\\d*)" +
            L +
            "*\\)|)(?=[^-]|$)",
          "i"
        ),
      },
      Y = /^(?:input|select|textarea|button)$/i,
      Z = /^h\d$/i,
      $ = /^[^{]+\{\s*\[native \w/,
      _ = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
      ab = /[+~]/,
      bb = /'|\\/g,
      cb = new RegExp("\\\\([\\da-f]{1,6}" + L + "?|(" + L + ")|.)", "ig"),
      db = function (a, b, c) {
        var d = "0x" + b - 65536;
        return d !== d || c
          ? b
          : 0 > d
          ? String.fromCharCode(d + 65536)
          : String.fromCharCode((d >> 10) | 55296, (1023 & d) | 56320);
      },
      eb = function () {
        m();
      };
    try {
      H.apply((E = I.call(v.childNodes)), v.childNodes),
        E[v.childNodes.length].nodeType;
    } catch (fb) {
      H = {
        apply: E.length
          ? function (a, b) {
              G.apply(a, I.call(b));
            }
          : function (a, b) {
              var c = a.length,
                d = 0;
              while ((a[c++] = b[d++]));
              a.length = c - 1;
            },
      };
    }
    function gb(a, b, d, e) {
      var f, h, j, k, l, o, r, s, w, x;
      if (
        ((b ? b.ownerDocument || b : v) !== n && m(b),
        (b = b || n),
        (d = d || []),
        (k = b.nodeType),
        "string" != typeof a || !a || (1 !== k && 9 !== k && 11 !== k))
      )
        return d;
      if (!e && p) {
        if (11 !== k && (f = _.exec(a)))
          if ((j = f[1])) {
            if (9 === k) {
              if (((h = b.getElementById(j)), !h || !h.parentNode)) return d;
              if (h.id === j) return d.push(h), d;
            } else if (
              b.ownerDocument &&
              (h = b.ownerDocument.getElementById(j)) &&
              t(b, h) &&
              h.id === j
            )
              return d.push(h), d;
          } else {
            if (f[2]) return H.apply(d, b.getElementsByTagName(a)), d;
            if ((j = f[3]) && c.getElementsByClassName)
              return H.apply(d, b.getElementsByClassName(j)), d;
          }
        if (c.qsa && (!q || !q.test(a))) {
          if (
            ((s = r = u),
            (w = b),
            (x = 1 !== k && a),
            1 === k && "object" !== b.nodeName.toLowerCase())
          ) {
            (o = g(a)),
              (r = b.getAttribute("id"))
                ? (s = r.replace(bb, "\\$&"))
                : b.setAttribute("id", s),
              (s = "[id='" + s + "'] "),
              (l = o.length);
            while (l--) o[l] = s + rb(o[l]);
            (w = (ab.test(a) && pb(b.parentNode)) || b), (x = o.join(","));
          }
          if (x)
            try {
              return H.apply(d, w.querySelectorAll(x)), d;
            } catch (y) {
            } finally {
              r || b.removeAttribute("id");
            }
        }
      }
      return i(a.replace(R, "$1"), b, d, e);
    }
    function hb() {
      var a = [];
      function b(c, e) {
        return (
          a.push(c + " ") > d.cacheLength && delete b[a.shift()],
          (b[c + " "] = e)
        );
      }
      return b;
    }
    function ib(a) {
      return (a[u] = !0), a;
    }
    function jb(a) {
      var b = n.createElement("div");
      try {
        return !!a(b);
      } catch (c) {
        return !1;
      } finally {
        b.parentNode && b.parentNode.removeChild(b), (b = null);
      }
    }
    function kb(a, b) {
      var c = a.split("|"),
        e = a.length;
      while (e--) d.attrHandle[c[e]] = b;
    }
    function lb(a, b) {
      var c = b && a,
        d =
          c &&
          1 === a.nodeType &&
          1 === b.nodeType &&
          (~b.sourceIndex || C) - (~a.sourceIndex || C);
      if (d) return d;
      if (c) while ((c = c.nextSibling)) if (c === b) return -1;
      return a ? 1 : -1;
    }
    function mb(a) {
      return function (b) {
        var c = b.nodeName.toLowerCase();
        return "input" === c && b.type === a;
      };
    }
    function nb(a) {
      return function (b) {
        var c = b.nodeName.toLowerCase();
        return ("input" === c || "button" === c) && b.type === a;
      };
    }
    function ob(a) {
      return ib(function (b) {
        return (
          (b = +b),
          ib(function (c, d) {
            var e,
              f = a([], c.length, b),
              g = f.length;
            while (g--) c[(e = f[g])] && (c[e] = !(d[e] = c[e]));
          })
        );
      });
    }
    function pb(a) {
      return a && "undefined" != typeof a.getElementsByTagName && a;
    }
    (c = gb.support = {}),
      (f = gb.isXML =
        function (a) {
          var b = a && (a.ownerDocument || a).documentElement;
          return b ? "HTML" !== b.nodeName : !1;
        }),
      (m = gb.setDocument =
        function (a) {
          var b,
            e,
            g = a ? a.ownerDocument || a : v;
          return g !== n && 9 === g.nodeType && g.documentElement
            ? ((n = g),
              (o = g.documentElement),
              (e = g.defaultView),
              e &&
                e !== e.top &&
                (e.addEventListener
                  ? e.addEventListener("unload", eb, !1)
                  : e.attachEvent && e.attachEvent("onunload", eb)),
              (p = !f(g)),
              (c.attributes = jb(function (a) {
                return (a.className = "i"), !a.getAttribute("className");
              })),
              (c.getElementsByTagName = jb(function (a) {
                return (
                  a.appendChild(g.createComment("")),
                  !a.getElementsByTagName("*").length
                );
              })),
              (c.getElementsByClassName = $.test(g.getElementsByClassName)),
              (c.getById = jb(function (a) {
                return (
                  (o.appendChild(a).id = u),
                  !g.getElementsByName || !g.getElementsByName(u).length
                );
              })),
              c.getById
                ? ((d.find.ID = function (a, b) {
                    if ("undefined" != typeof b.getElementById && p) {
                      var c = b.getElementById(a);
                      return c && c.parentNode ? [c] : [];
                    }
                  }),
                  (d.filter.ID = function (a) {
                    var b = a.replace(cb, db);
                    return function (a) {
                      return a.getAttribute("id") === b;
                    };
                  }))
                : (delete d.find.ID,
                  (d.filter.ID = function (a) {
                    var b = a.replace(cb, db);
                    return function (a) {
                      var c =
                        "undefined" != typeof a.getAttributeNode &&
                        a.getAttributeNode("id");
                      return c && c.value === b;
                    };
                  })),
              (d.find.TAG = c.getElementsByTagName
                ? function (a, b) {
                    return "undefined" != typeof b.getElementsByTagName
                      ? b.getElementsByTagName(a)
                      : c.qsa
                      ? b.querySelectorAll(a)
                      : void 0;
                  }
                : function (a, b) {
                    var c,
                      d = [],
                      e = 0,
                      f = b.getElementsByTagName(a);
                    if ("*" === a) {
                      while ((c = f[e++])) 1 === c.nodeType && d.push(c);
                      return d;
                    }
                    return f;
                  }),
              (d.find.CLASS =
                c.getElementsByClassName &&
                function (a, b) {
                  return p ? b.getElementsByClassName(a) : void 0;
                }),
              (r = []),
              (q = []),
              (c.qsa = $.test(g.querySelectorAll)) &&
                (jb(function (a) {
                  (o.appendChild(a).innerHTML =
                    "<a id='" +
                    u +
                    "'></a><select id='" +
                    u +
                    "-\f]' msallowcapture=''><option selected=''></option></select>"),
                    a.querySelectorAll("[msallowcapture^='']").length &&
                      q.push("[*^$]=" + L + "*(?:''|\"\")"),
                    a.querySelectorAll("[selected]").length ||
                      q.push("\\[" + L + "*(?:value|" + K + ")"),
                    a.querySelectorAll("[id~=" + u + "-]").length ||
                      q.push("~="),
                    a.querySelectorAll(":checked").length || q.push(":checked"),
                    a.querySelectorAll("a#" + u + "+*").length ||
                      q.push(".#.+[+~]");
                }),
                jb(function (a) {
                  var b = g.createElement("input");
                  b.setAttribute("type", "hidden"),
                    a.appendChild(b).setAttribute("name", "D"),
                    a.querySelectorAll("[name=d]").length &&
                      q.push("name" + L + "*[*^$|!~]?="),
                    a.querySelectorAll(":enabled").length ||
                      q.push(":enabled", ":disabled"),
                    a.querySelectorAll("*,:x"),
                    q.push(",.*:");
                })),
              (c.matchesSelector = $.test(
                (s =
                  o.matches ||
                  o.webkitMatchesSelector ||
                  o.mozMatchesSelector ||
                  o.oMatchesSelector ||
                  o.msMatchesSelector)
              )) &&
                jb(function (a) {
                  (c.disconnectedMatch = s.call(a, "div")),
                    s.call(a, "[s!='']:x"),
                    r.push("!=", P);
                }),
              (q = q.length && new RegExp(q.join("|"))),
              (r = r.length && new RegExp(r.join("|"))),
              (b = $.test(o.compareDocumentPosition)),
              (t =
                b || $.test(o.contains)
                  ? function (a, b) {
                      var c = 9 === a.nodeType ? a.documentElement : a,
                        d = b && b.parentNode;
                      return (
                        a === d ||
                        !(
                          !d ||
                          1 !== d.nodeType ||
                          !(c.contains
                            ? c.contains(d)
                            : a.compareDocumentPosition &&
                              16 & a.compareDocumentPosition(d))
                        )
                      );
                    }
                  : function (a, b) {
                      if (b) while ((b = b.parentNode)) if (b === a) return !0;
                      return !1;
                    }),
              (B = b
                ? function (a, b) {
                    if (a === b) return (l = !0), 0;
                    var d =
                      !a.compareDocumentPosition - !b.compareDocumentPosition;
                    return d
                      ? d
                      : ((d =
                          (a.ownerDocument || a) === (b.ownerDocument || b)
                            ? a.compareDocumentPosition(b)
                            : 1),
                        1 & d ||
                        (!c.sortDetached && b.compareDocumentPosition(a) === d)
                          ? a === g || (a.ownerDocument === v && t(v, a))
                            ? -1
                            : b === g || (b.ownerDocument === v && t(v, b))
                            ? 1
                            : k
                            ? J(k, a) - J(k, b)
                            : 0
                          : 4 & d
                          ? -1
                          : 1);
                  }
                : function (a, b) {
                    if (a === b) return (l = !0), 0;
                    var c,
                      d = 0,
                      e = a.parentNode,
                      f = b.parentNode,
                      h = [a],
                      i = [b];
                    if (!e || !f)
                      return a === g
                        ? -1
                        : b === g
                        ? 1
                        : e
                        ? -1
                        : f
                        ? 1
                        : k
                        ? J(k, a) - J(k, b)
                        : 0;
                    if (e === f) return lb(a, b);
                    c = a;
                    while ((c = c.parentNode)) h.unshift(c);
                    c = b;
                    while ((c = c.parentNode)) i.unshift(c);
                    while (h[d] === i[d]) d++;
                    return d
                      ? lb(h[d], i[d])
                      : h[d] === v
                      ? -1
                      : i[d] === v
                      ? 1
                      : 0;
                  }),
              g)
            : n;
        }),
      (gb.matches = function (a, b) {
        return gb(a, null, null, b);
      }),
      (gb.matchesSelector = function (a, b) {
        if (
          ((a.ownerDocument || a) !== n && m(a),
          (b = b.replace(U, "='$1']")),
          !(!c.matchesSelector || !p || (r && r.test(b)) || (q && q.test(b))))
        )
          try {
            var d = s.call(a, b);
            if (
              d ||
              c.disconnectedMatch ||
              (a.document && 11 !== a.document.nodeType)
            )
              return d;
          } catch (e) {}
        return gb(b, n, null, [a]).length > 0;
      }),
      (gb.contains = function (a, b) {
        return (a.ownerDocument || a) !== n && m(a), t(a, b);
      }),
      (gb.attr = function (a, b) {
        (a.ownerDocument || a) !== n && m(a);
        var e = d.attrHandle[b.toLowerCase()],
          f = e && D.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0;
        return void 0 !== f
          ? f
          : c.attributes || !p
          ? a.getAttribute(b)
          : (f = a.getAttributeNode(b)) && f.specified
          ? f.value
          : null;
      }),
      (gb.error = function (a) {
        throw new Error("Syntax error, unrecognized expression: " + a);
      }),
      (gb.uniqueSort = function (a) {
        var b,
          d = [],
          e = 0,
          f = 0;
        if (
          ((l = !c.detectDuplicates),
          (k = !c.sortStable && a.slice(0)),
          a.sort(B),
          l)
        ) {
          while ((b = a[f++])) b === a[f] && (e = d.push(f));
          while (e--) a.splice(d[e], 1);
        }
        return (k = null), a;
      }),
      (e = gb.getText =
        function (a) {
          var b,
            c = "",
            d = 0,
            f = a.nodeType;
          if (f) {
            if (1 === f || 9 === f || 11 === f) {
              if ("string" == typeof a.textContent) return a.textContent;
              for (a = a.firstChild; a; a = a.nextSibling) c += e(a);
            } else if (3 === f || 4 === f) return a.nodeValue;
          } else while ((b = a[d++])) c += e(b);
          return c;
        }),
      (d = gb.selectors =
        {
          cacheLength: 50,
          createPseudo: ib,
          match: X,
          attrHandle: {},
          find: {},
          relative: {
            ">": { dir: "parentNode", first: !0 },
            " ": { dir: "parentNode" },
            "+": { dir: "previousSibling", first: !0 },
            "~": { dir: "previousSibling" },
          },
          preFilter: {
            ATTR: function (a) {
              return (
                (a[1] = a[1].replace(cb, db)),
                (a[3] = (a[3] || a[4] || a[5] || "").replace(cb, db)),
                "~=" === a[2] && (a[3] = " " + a[3] + " "),
                a.slice(0, 4)
              );
            },
            CHILD: function (a) {
              return (
                (a[1] = a[1].toLowerCase()),
                "nth" === a[1].slice(0, 3)
                  ? (a[3] || gb.error(a[0]),
                    (a[4] = +(a[4]
                      ? a[5] + (a[6] || 1)
                      : 2 * ("even" === a[3] || "odd" === a[3]))),
                    (a[5] = +(a[7] + a[8] || "odd" === a[3])))
                  : a[3] && gb.error(a[0]),
                a
              );
            },
            PSEUDO: function (a) {
              var b,
                c = !a[6] && a[2];
              return X.CHILD.test(a[0])
                ? null
                : (a[3]
                    ? (a[2] = a[4] || a[5] || "")
                    : c &&
                      V.test(c) &&
                      (b = g(c, !0)) &&
                      (b = c.indexOf(")", c.length - b) - c.length) &&
                      ((a[0] = a[0].slice(0, b)), (a[2] = c.slice(0, b))),
                  a.slice(0, 3));
            },
          },
          filter: {
            TAG: function (a) {
              var b = a.replace(cb, db).toLowerCase();
              return "*" === a
                ? function () {
                    return !0;
                  }
                : function (a) {
                    return a.nodeName && a.nodeName.toLowerCase() === b;
                  };
            },
            CLASS: function (a) {
              var b = y[a + " "];
              return (
                b ||
                ((b = new RegExp("(^|" + L + ")" + a + "(" + L + "|$)")) &&
                  y(a, function (a) {
                    return b.test(
                      ("string" == typeof a.className && a.className) ||
                        ("undefined" != typeof a.getAttribute &&
                          a.getAttribute("class")) ||
                        ""
                    );
                  }))
              );
            },
            ATTR: function (a, b, c) {
              return function (d) {
                var e = gb.attr(d, a);
                return null == e
                  ? "!=" === b
                  : b
                  ? ((e += ""),
                    "=" === b
                      ? e === c
                      : "!=" === b
                      ? e !== c
                      : "^=" === b
                      ? c && 0 === e.indexOf(c)
                      : "*=" === b
                      ? c && e.indexOf(c) > -1
                      : "$=" === b
                      ? c && e.slice(-c.length) === c
                      : "~=" === b
                      ? (" " + e.replace(Q, " ") + " ").indexOf(c) > -1
                      : "|=" === b
                      ? e === c || e.slice(0, c.length + 1) === c + "-"
                      : !1)
                  : !0;
              };
            },
            CHILD: function (a, b, c, d, e) {
              var f = "nth" !== a.slice(0, 3),
                g = "last" !== a.slice(-4),
                h = "of-type" === b;
              return 1 === d && 0 === e
                ? function (a) {
                    return !!a.parentNode;
                  }
                : function (b, c, i) {
                    var j,
                      k,
                      l,
                      m,
                      n,
                      o,
                      p = f !== g ? "nextSibling" : "previousSibling",
                      q = b.parentNode,
                      r = h && b.nodeName.toLowerCase(),
                      s = !i && !h;
                    if (q) {
                      if (f) {
                        while (p) {
                          l = b;
                          while ((l = l[p]))
                            if (
                              h
                                ? l.nodeName.toLowerCase() === r
                                : 1 === l.nodeType
                            )
                              return !1;
                          o = p = "only" === a && !o && "nextSibling";
                        }
                        return !0;
                      }
                      if (((o = [g ? q.firstChild : q.lastChild]), g && s)) {
                        (k = q[u] || (q[u] = {})),
                          (j = k[a] || []),
                          (n = j[0] === w && j[1]),
                          (m = j[0] === w && j[2]),
                          (l = n && q.childNodes[n]);
                        while (
                          (l = (++n && l && l[p]) || (m = n = 0) || o.pop())
                        )
                          if (1 === l.nodeType && ++m && l === b) {
                            k[a] = [w, n, m];
                            break;
                          }
                      } else if (
                        s &&
                        (j = (b[u] || (b[u] = {}))[a]) &&
                        j[0] === w
                      )
                        m = j[1];
                      else
                        while (
                          (l = (++n && l && l[p]) || (m = n = 0) || o.pop())
                        )
                          if (
                            (h
                              ? l.nodeName.toLowerCase() === r
                              : 1 === l.nodeType) &&
                            ++m &&
                            (s && ((l[u] || (l[u] = {}))[a] = [w, m]), l === b)
                          )
                            break;
                      return (m -= e), m === d || (m % d === 0 && m / d >= 0);
                    }
                  };
            },
            PSEUDO: function (a, b) {
              var c,
                e =
                  d.pseudos[a] ||
                  d.setFilters[a.toLowerCase()] ||
                  gb.error("unsupported pseudo: " + a);
              return e[u]
                ? e(b)
                : e.length > 1
                ? ((c = [a, a, "", b]),
                  d.setFilters.hasOwnProperty(a.toLowerCase())
                    ? ib(function (a, c) {
                        var d,
                          f = e(a, b),
                          g = f.length;
                        while (g--) (d = J(a, f[g])), (a[d] = !(c[d] = f[g]));
                      })
                    : function (a) {
                        return e(a, 0, c);
                      })
                : e;
            },
          },
          pseudos: {
            not: ib(function (a) {
              var b = [],
                c = [],
                d = h(a.replace(R, "$1"));
              return d[u]
                ? ib(function (a, b, c, e) {
                    var f,
                      g = d(a, null, e, []),
                      h = a.length;
                    while (h--) (f = g[h]) && (a[h] = !(b[h] = f));
                  })
                : function (a, e, f) {
                    return (
                      (b[0] = a), d(b, null, f, c), (b[0] = null), !c.pop()
                    );
                  };
            }),
            has: ib(function (a) {
              return function (b) {
                return gb(a, b).length > 0;
              };
            }),
            contains: ib(function (a) {
              return (
                (a = a.replace(cb, db)),
                function (b) {
                  return (b.textContent || b.innerText || e(b)).indexOf(a) > -1;
                }
              );
            }),
            lang: ib(function (a) {
              return (
                W.test(a || "") || gb.error("unsupported lang: " + a),
                (a = a.replace(cb, db).toLowerCase()),
                function (b) {
                  var c;
                  do
                    if (
                      (c = p
                        ? b.lang
                        : b.getAttribute("xml:lang") || b.getAttribute("lang"))
                    )
                      return (
                        (c = c.toLowerCase()),
                        c === a || 0 === c.indexOf(a + "-")
                      );
                  while ((b = b.parentNode) && 1 === b.nodeType);
                  return !1;
                }
              );
            }),
            target: function (b) {
              var c = a.location && a.location.hash;
              return c && c.slice(1) === b.id;
            },
            root: function (a) {
              return a === o;
            },
            focus: function (a) {
              return (
                a === n.activeElement &&
                (!n.hasFocus || n.hasFocus()) &&
                !!(a.type || a.href || ~a.tabIndex)
              );
            },
            enabled: function (a) {
              return a.disabled === !1;
            },
            disabled: function (a) {
              return a.disabled === !0;
            },
            checked: function (a) {
              var b = a.nodeName.toLowerCase();
              return (
                ("input" === b && !!a.checked) ||
                ("option" === b && !!a.selected)
              );
            },
            selected: function (a) {
              return (
                a.parentNode && a.parentNode.selectedIndex, a.selected === !0
              );
            },
            empty: function (a) {
              for (a = a.firstChild; a; a = a.nextSibling)
                if (a.nodeType < 6) return !1;
              return !0;
            },
            parent: function (a) {
              return !d.pseudos.empty(a);
            },
            header: function (a) {
              return Z.test(a.nodeName);
            },
            input: function (a) {
              return Y.test(a.nodeName);
            },
            button: function (a) {
              var b = a.nodeName.toLowerCase();
              return ("input" === b && "button" === a.type) || "button" === b;
            },
            text: function (a) {
              var b;
              return (
                "input" === a.nodeName.toLowerCase() &&
                "text" === a.type &&
                (null == (b = a.getAttribute("type")) ||
                  "text" === b.toLowerCase())
              );
            },
            first: ob(function () {
              return [0];
            }),
            last: ob(function (a, b) {
              return [b - 1];
            }),
            eq: ob(function (a, b, c) {
              return [0 > c ? c + b : c];
            }),
            even: ob(function (a, b) {
              for (var c = 0; b > c; c += 2) a.push(c);
              return a;
            }),
            odd: ob(function (a, b) {
              for (var c = 1; b > c; c += 2) a.push(c);
              return a;
            }),
            lt: ob(function (a, b, c) {
              for (var d = 0 > c ? c + b : c; --d >= 0; ) a.push(d);
              return a;
            }),
            gt: ob(function (a, b, c) {
              for (var d = 0 > c ? c + b : c; ++d < b; ) a.push(d);
              return a;
            }),
          },
        }),
      (d.pseudos.nth = d.pseudos.eq);
    for (b in { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 })
      d.pseudos[b] = mb(b);
    for (b in { submit: !0, reset: !0 }) d.pseudos[b] = nb(b);
    function qb() {}
    (qb.prototype = d.filters = d.pseudos),
      (d.setFilters = new qb()),
      (g = gb.tokenize =
        function (a, b) {
          var c,
            e,
            f,
            g,
            h,
            i,
            j,
            k = z[a + " "];
          if (k) return b ? 0 : k.slice(0);
          (h = a), (i = []), (j = d.preFilter);
          while (h) {
            (!c || (e = S.exec(h))) &&
              (e && (h = h.slice(e[0].length) || h), i.push((f = []))),
              (c = !1),
              (e = T.exec(h)) &&
                ((c = e.shift()),
                f.push({ value: c, type: e[0].replace(R, " ") }),
                (h = h.slice(c.length)));
            for (g in d.filter)
              !(e = X[g].exec(h)) ||
                (j[g] && !(e = j[g](e))) ||
                ((c = e.shift()),
                f.push({ value: c, type: g, matches: e }),
                (h = h.slice(c.length)));
            if (!c) break;
          }
          return b ? h.length : h ? gb.error(a) : z(a, i).slice(0);
        });
    function rb(a) {
      for (var b = 0, c = a.length, d = ""; c > b; b++) d += a[b].value;
      return d;
    }
    function sb(a, b, c) {
      var d = b.dir,
        e = c && "parentNode" === d,
        f = x++;
      return b.first
        ? function (b, c, f) {
            while ((b = b[d])) if (1 === b.nodeType || e) return a(b, c, f);
          }
        : function (b, c, g) {
            var h,
              i,
              j = [w, f];
            if (g) {
              while ((b = b[d]))
                if ((1 === b.nodeType || e) && a(b, c, g)) return !0;
            } else
              while ((b = b[d]))
                if (1 === b.nodeType || e) {
                  if (
                    ((i = b[u] || (b[u] = {})),
                    (h = i[d]) && h[0] === w && h[1] === f)
                  )
                    return (j[2] = h[2]);
                  if (((i[d] = j), (j[2] = a(b, c, g)))) return !0;
                }
          };
    }
    function tb(a) {
      return a.length > 1
        ? function (b, c, d) {
            var e = a.length;
            while (e--) if (!a[e](b, c, d)) return !1;
            return !0;
          }
        : a[0];
    }
    function ub(a, b, c) {
      for (var d = 0, e = b.length; e > d; d++) gb(a, b[d], c);
      return c;
    }
    function vb(a, b, c, d, e) {
      for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++)
        (f = a[h]) && (!c || c(f, d, e)) && (g.push(f), j && b.push(h));
      return g;
    }
    function wb(a, b, c, d, e, f) {
      return (
        d && !d[u] && (d = wb(d)),
        e && !e[u] && (e = wb(e, f)),
        ib(function (f, g, h, i) {
          var j,
            k,
            l,
            m = [],
            n = [],
            o = g.length,
            p = f || ub(b || "*", h.nodeType ? [h] : h, []),
            q = !a || (!f && b) ? p : vb(p, m, a, h, i),
            r = c ? (e || (f ? a : o || d) ? [] : g) : q;
          if ((c && c(q, r, h, i), d)) {
            (j = vb(r, n)), d(j, [], h, i), (k = j.length);
            while (k--) (l = j[k]) && (r[n[k]] = !(q[n[k]] = l));
          }
          if (f) {
            if (e || a) {
              if (e) {
                (j = []), (k = r.length);
                while (k--) (l = r[k]) && j.push((q[k] = l));
                e(null, (r = []), j, i);
              }
              k = r.length;
              while (k--)
                (l = r[k]) &&
                  (j = e ? J(f, l) : m[k]) > -1 &&
                  (f[j] = !(g[j] = l));
            }
          } else (r = vb(r === g ? r.splice(o, r.length) : r)), e ? e(null, g, r, i) : H.apply(g, r);
        })
      );
    }
    function xb(a) {
      for (
        var b,
          c,
          e,
          f = a.length,
          g = d.relative[a[0].type],
          h = g || d.relative[" "],
          i = g ? 1 : 0,
          k = sb(
            function (a) {
              return a === b;
            },
            h,
            !0
          ),
          l = sb(
            function (a) {
              return J(b, a) > -1;
            },
            h,
            !0
          ),
          m = [
            function (a, c, d) {
              var e =
                (!g && (d || c !== j)) ||
                ((b = c).nodeType ? k(a, c, d) : l(a, c, d));
              return (b = null), e;
            },
          ];
        f > i;
        i++
      )
        if ((c = d.relative[a[i].type])) m = [sb(tb(m), c)];
        else {
          if (((c = d.filter[a[i].type].apply(null, a[i].matches)), c[u])) {
            for (e = ++i; f > e; e++) if (d.relative[a[e].type]) break;
            return wb(
              i > 1 && tb(m),
              i > 1 &&
                rb(
                  a
                    .slice(0, i - 1)
                    .concat({ value: " " === a[i - 2].type ? "*" : "" })
                ).replace(R, "$1"),
              c,
              e > i && xb(a.slice(i, e)),
              f > e && xb((a = a.slice(e))),
              f > e && rb(a)
            );
          }
          m.push(c);
        }
      return tb(m);
    }
    function yb(a, b) {
      var c = b.length > 0,
        e = a.length > 0,
        f = function (f, g, h, i, k) {
          var l,
            m,
            o,
            p = 0,
            q = "0",
            r = f && [],
            s = [],
            t = j,
            u = f || (e && d.find.TAG("*", k)),
            v = (w += null == t ? 1 : Math.random() || 0.1),
            x = u.length;
          for (k && (j = g !== n && g); q !== x && null != (l = u[q]); q++) {
            if (e && l) {
              m = 0;
              while ((o = a[m++]))
                if (o(l, g, h)) {
                  i.push(l);
                  break;
                }
              k && (w = v);
            }
            c && ((l = !o && l) && p--, f && r.push(l));
          }
          if (((p += q), c && q !== p)) {
            m = 0;
            while ((o = b[m++])) o(r, s, g, h);
            if (f) {
              if (p > 0) while (q--) r[q] || s[q] || (s[q] = F.call(i));
              s = vb(s);
            }
            H.apply(i, s),
              k && !f && s.length > 0 && p + b.length > 1 && gb.uniqueSort(i);
          }
          return k && ((w = v), (j = t)), r;
        };
      return c ? ib(f) : f;
    }
    return (
      (h = gb.compile =
        function (a, b) {
          var c,
            d = [],
            e = [],
            f = A[a + " "];
          if (!f) {
            b || (b = g(a)), (c = b.length);
            while (c--) (f = xb(b[c])), f[u] ? d.push(f) : e.push(f);
            (f = A(a, yb(e, d))), (f.selector = a);
          }
          return f;
        }),
      (i = gb.select =
        function (a, b, e, f) {
          var i,
            j,
            k,
            l,
            m,
            n = "function" == typeof a && a,
            o = !f && g((a = n.selector || a));
          if (((e = e || []), 1 === o.length)) {
            if (
              ((j = o[0] = o[0].slice(0)),
              j.length > 2 &&
                "ID" === (k = j[0]).type &&
                c.getById &&
                9 === b.nodeType &&
                p &&
                d.relative[j[1].type])
            ) {
              if (
                ((b = (d.find.ID(k.matches[0].replace(cb, db), b) || [])[0]),
                !b)
              )
                return e;
              n && (b = b.parentNode), (a = a.slice(j.shift().value.length));
            }
            i = X.needsContext.test(a) ? 0 : j.length;
            while (i--) {
              if (((k = j[i]), d.relative[(l = k.type)])) break;
              if (
                (m = d.find[l]) &&
                (f = m(
                  k.matches[0].replace(cb, db),
                  (ab.test(j[0].type) && pb(b.parentNode)) || b
                ))
              ) {
                if ((j.splice(i, 1), (a = f.length && rb(j)), !a))
                  return H.apply(e, f), e;
                break;
              }
            }
          }
          return (
            (n || h(a, o))(f, b, !p, e, (ab.test(a) && pb(b.parentNode)) || b),
            e
          );
        }),
      (c.sortStable = u.split("").sort(B).join("") === u),
      (c.detectDuplicates = !!l),
      m(),
      (c.sortDetached = jb(function (a) {
        return 1 & a.compareDocumentPosition(n.createElement("div"));
      })),
      jb(function (a) {
        return (
          (a.innerHTML = "<a href='#'></a>"),
          "#" === a.firstChild.getAttribute("href")
        );
      }) ||
        kb("type|href|height|width", function (a, b, c) {
          return c
            ? void 0
            : a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2);
        }),
      (c.attributes &&
        jb(function (a) {
          return (
            (a.innerHTML = "<input/>"),
            a.firstChild.setAttribute("value", ""),
            "" === a.firstChild.getAttribute("value")
          );
        })) ||
        kb("value", function (a, b, c) {
          return c || "input" !== a.nodeName.toLowerCase()
            ? void 0
            : a.defaultValue;
        }),
      jb(function (a) {
        return null == a.getAttribute("disabled");
      }) ||
        kb(K, function (a, b, c) {
          var d;
          return c
            ? void 0
            : a[b] === !0
            ? b.toLowerCase()
            : (d = a.getAttributeNode(b)) && d.specified
            ? d.value
            : null;
        }),
      gb
    );
  })(a);
  (n.find = t),
    (n.expr = t.selectors),
    (n.expr[":"] = n.expr.pseudos),
    (n.unique = t.uniqueSort),
    (n.text = t.getText),
    (n.isXMLDoc = t.isXML),
    (n.contains = t.contains);
  var u = n.expr.match.needsContext,
    v = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
    w = /^.[^:#\[\.,]*$/;
  function x(a, b, c) {
    if (n.isFunction(b))
      return n.grep(a, function (a, d) {
        return !!b.call(a, d, a) !== c;
      });
    if (b.nodeType)
      return n.grep(a, function (a) {
        return (a === b) !== c;
      });
    if ("string" == typeof b) {
      if (w.test(b)) return n.filter(b, a, c);
      b = n.filter(b, a);
    }
    return n.grep(a, function (a) {
      return g.call(b, a) >= 0 !== c;
    });
  }
  (n.filter = function (a, b, c) {
    var d = b[0];
    return (
      c && (a = ":not(" + a + ")"),
      1 === b.length && 1 === d.nodeType
        ? n.find.matchesSelector(d, a)
          ? [d]
          : []
        : n.find.matches(
            a,
            n.grep(b, function (a) {
              return 1 === a.nodeType;
            })
          )
    );
  }),
    n.fn.extend({
      find: function (a) {
        var b,
          c = this.length,
          d = [],
          e = this;
        if ("string" != typeof a)
          return this.pushStack(
            n(a).filter(function () {
              for (b = 0; c > b; b++) if (n.contains(e[b], this)) return !0;
            })
          );
        for (b = 0; c > b; b++) n.find(a, e[b], d);
        return (
          (d = this.pushStack(c > 1 ? n.unique(d) : d)),
          (d.selector = this.selector ? this.selector + " " + a : a),
          d
        );
      },
      filter: function (a) {
        return this.pushStack(x(this, a || [], !1));
      },
      not: function (a) {
        return this.pushStack(x(this, a || [], !0));
      },
      is: function (a) {
        return !!x(this, "string" == typeof a && u.test(a) ? n(a) : a || [], !1)
          .length;
      },
    });
  var y,
    z = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
    A = (n.fn.init = function (a, b) {
      var c, d;
      if (!a) return this;
      if ("string" == typeof a) {
        if (
          ((c =
            "<" === a[0] && ">" === a[a.length - 1] && a.length >= 3
              ? [null, a, null]
              : z.exec(a)),
          !c || (!c[1] && b))
        )
          return !b || b.jquery
            ? (b || y).find(a)
            : this.constructor(b).find(a);
        if (c[1]) {
          if (
            ((b = b instanceof n ? b[0] : b),
            n.merge(
              this,
              n.parseHTML(c[1], b && b.nodeType ? b.ownerDocument || b : l, !0)
            ),
            v.test(c[1]) && n.isPlainObject(b))
          )
            for (c in b)
              n.isFunction(this[c]) ? this[c](b[c]) : this.attr(c, b[c]);
          return this;
        }
        return (
          (d = l.getElementById(c[2])),
          d && d.parentNode && ((this.length = 1), (this[0] = d)),
          (this.context = l),
          (this.selector = a),
          this
        );
      }
      return a.nodeType
        ? ((this.context = this[0] = a), (this.length = 1), this)
        : n.isFunction(a)
        ? "undefined" != typeof y.ready
          ? y.ready(a)
          : a(n)
        : (void 0 !== a.selector &&
            ((this.selector = a.selector), (this.context = a.context)),
          n.makeArray(a, this));
    });
  (A.prototype = n.fn), (y = n(l));
  var B = /^(?:parents|prev(?:Until|All))/,
    C = { children: !0, contents: !0, next: !0, prev: !0 };
  n.extend({
    dir: function (a, b, c) {
      var d = [],
        e = void 0 !== c;
      while ((a = a[b]) && 9 !== a.nodeType)
        if (1 === a.nodeType) {
          if (e && n(a).is(c)) break;
          d.push(a);
        }
      return d;
    },
    sibling: function (a, b) {
      for (var c = []; a; a = a.nextSibling)
        1 === a.nodeType && a !== b && c.push(a);
      return c;
    },
  }),
    n.fn.extend({
      has: function (a) {
        var b = n(a, this),
          c = b.length;
        return this.filter(function () {
          for (var a = 0; c > a; a++) if (n.contains(this, b[a])) return !0;
        });
      },
      closest: function (a, b) {
        for (
          var c,
            d = 0,
            e = this.length,
            f = [],
            g = u.test(a) || "string" != typeof a ? n(a, b || this.context) : 0;
          e > d;
          d++
        )
          for (c = this[d]; c && c !== b; c = c.parentNode)
            if (
              c.nodeType < 11 &&
              (g
                ? g.index(c) > -1
                : 1 === c.nodeType && n.find.matchesSelector(c, a))
            ) {
              f.push(c);
              break;
            }
        return this.pushStack(f.length > 1 ? n.unique(f) : f);
      },
      index: function (a) {
        return a
          ? "string" == typeof a
            ? g.call(n(a), this[0])
            : g.call(this, a.jquery ? a[0] : a)
          : this[0] && this[0].parentNode
          ? this.first().prevAll().length
          : -1;
      },
      add: function (a, b) {
        return this.pushStack(n.unique(n.merge(this.get(), n(a, b))));
      },
      addBack: function (a) {
        return this.add(
          null == a ? this.prevObject : this.prevObject.filter(a)
        );
      },
    });
  function D(a, b) {
    while ((a = a[b]) && 1 !== a.nodeType);
    return a;
  }
  n.each(
    {
      parent: function (a) {
        var b = a.parentNode;
        return b && 11 !== b.nodeType ? b : null;
      },
      parents: function (a) {
        return n.dir(a, "parentNode");
      },
      parentsUntil: function (a, b, c) {
        return n.dir(a, "parentNode", c);
      },
      next: function (a) {
        return D(a, "nextSibling");
      },
      prev: function (a) {
        return D(a, "previousSibling");
      },
      nextAll: function (a) {
        return n.dir(a, "nextSibling");
      },
      prevAll: function (a) {
        return n.dir(a, "previousSibling");
      },
      nextUntil: function (a, b, c) {
        return n.dir(a, "nextSibling", c);
      },
      prevUntil: function (a, b, c) {
        return n.dir(a, "previousSibling", c);
      },
      siblings: function (a) {
        return n.sibling((a.parentNode || {}).firstChild, a);
      },
      children: function (a) {
        return n.sibling(a.firstChild);
      },
      contents: function (a) {
        return a.contentDocument || n.merge([], a.childNodes);
      },
    },
    function (a, b) {
      n.fn[a] = function (c, d) {
        var e = n.map(this, b, c);
        return (
          "Until" !== a.slice(-5) && (d = c),
          d && "string" == typeof d && (e = n.filter(d, e)),
          this.length > 1 && (C[a] || n.unique(e), B.test(a) && e.reverse()),
          this.pushStack(e)
        );
      };
    }
  );
  var E = /\S+/g,
    F = {};
  function G(a) {
    var b = (F[a] = {});
    return (
      n.each(a.match(E) || [], function (a, c) {
        b[c] = !0;
      }),
      b
    );
  }
  (n.Callbacks = function (a) {
    a = "string" == typeof a ? F[a] || G(a) : n.extend({}, a);
    var b,
      c,
      d,
      e,
      f,
      g,
      h = [],
      i = !a.once && [],
      j = function (l) {
        for (
          b = a.memory && l, c = !0, g = e || 0, e = 0, f = h.length, d = !0;
          h && f > g;
          g++
        )
          if (h[g].apply(l[0], l[1]) === !1 && a.stopOnFalse) {
            b = !1;
            break;
          }
        (d = !1),
          h && (i ? i.length && j(i.shift()) : b ? (h = []) : k.disable());
      },
      k = {
        add: function () {
          if (h) {
            var c = h.length;
            !(function g(b) {
              n.each(b, function (b, c) {
                var d = n.type(c);
                "function" === d
                  ? (a.unique && k.has(c)) || h.push(c)
                  : c && c.length && "string" !== d && g(c);
              });
            })(arguments),
              d ? (f = h.length) : b && ((e = c), j(b));
          }
          return this;
        },
        remove: function () {
          return (
            h &&
              n.each(arguments, function (a, b) {
                var c;
                while ((c = n.inArray(b, h, c)) > -1)
                  h.splice(c, 1), d && (f >= c && f--, g >= c && g--);
              }),
            this
          );
        },
        has: function (a) {
          return a ? n.inArray(a, h) > -1 : !(!h || !h.length);
        },
        empty: function () {
          return (h = []), (f = 0), this;
        },
        disable: function () {
          return (h = i = b = void 0), this;
        },
        disabled: function () {
          return !h;
        },
        lock: function () {
          return (i = void 0), b || k.disable(), this;
        },
        locked: function () {
          return !i;
        },
        fireWith: function (a, b) {
          return (
            !h ||
              (c && !i) ||
              ((b = b || []),
              (b = [a, b.slice ? b.slice() : b]),
              d ? i.push(b) : j(b)),
            this
          );
        },
        fire: function () {
          return k.fireWith(this, arguments), this;
        },
        fired: function () {
          return !!c;
        },
      };
    return k;
  }),
    n.extend({
      Deferred: function (a) {
        var b = [
            ["resolve", "done", n.Callbacks("once memory"), "resolved"],
            ["reject", "fail", n.Callbacks("once memory"), "rejected"],
            ["notify", "progress", n.Callbacks("memory")],
          ],
          c = "pending",
          d = {
            state: function () {
              return c;
            },
            always: function () {
              return e.done(arguments).fail(arguments), this;
            },
            then: function () {
              var a = arguments;
              return n
                .Deferred(function (c) {
                  n.each(b, function (b, f) {
                    var g = n.isFunction(a[b]) && a[b];
                    e[f[1]](function () {
                      var a = g && g.apply(this, arguments);
                      a && n.isFunction(a.promise)
                        ? a
                            .promise()
                            .done(c.resolve)
                            .fail(c.reject)
                            .progress(c.notify)
                        : c[f[0] + "With"](
                            this === d ? c.promise() : this,
                            g ? [a] : arguments
                          );
                    });
                  }),
                    (a = null);
                })
                .promise();
            },
            promise: function (a) {
              return null != a ? n.extend(a, d) : d;
            },
          },
          e = {};
        return (
          (d.pipe = d.then),
          n.each(b, function (a, f) {
            var g = f[2],
              h = f[3];
            (d[f[1]] = g.add),
              h &&
                g.add(
                  function () {
                    c = h;
                  },
                  b[1 ^ a][2].disable,
                  b[2][2].lock
                ),
              (e[f[0]] = function () {
                return e[f[0] + "With"](this === e ? d : this, arguments), this;
              }),
              (e[f[0] + "With"] = g.fireWith);
          }),
          d.promise(e),
          a && a.call(e, e),
          e
        );
      },
      when: function (a) {
        var b = 0,
          c = d.call(arguments),
          e = c.length,
          f = 1 !== e || (a && n.isFunction(a.promise)) ? e : 0,
          g = 1 === f ? a : n.Deferred(),
          h = function (a, b, c) {
            return function (e) {
              (b[a] = this),
                (c[a] = arguments.length > 1 ? d.call(arguments) : e),
                c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c);
            };
          },
          i,
          j,
          k;
        if (e > 1)
          for (i = new Array(e), j = new Array(e), k = new Array(e); e > b; b++)
            c[b] && n.isFunction(c[b].promise)
              ? c[b]
                  .promise()
                  .done(h(b, k, c))
                  .fail(g.reject)
                  .progress(h(b, j, i))
              : --f;
        return f || g.resolveWith(k, c), g.promise();
      },
    });
  var H;
  (n.fn.ready = function (a) {
    return n.ready.promise().done(a), this;
  }),
    n.extend({
      isReady: !1,
      readyWait: 1,
      holdReady: function (a) {
        a ? n.readyWait++ : n.ready(!0);
      },
      ready: function (a) {
        (a === !0 ? --n.readyWait : n.isReady) ||
          ((n.isReady = !0),
          (a !== !0 && --n.readyWait > 0) ||
            (H.resolveWith(l, [n]),
            n.fn.triggerHandler &&
              (n(l).triggerHandler("ready"), n(l).off("ready"))));
      },
    });
  function I() {
    l.removeEventListener("DOMContentLoaded", I, !1),
      a.removeEventListener("load", I, !1),
      n.ready();
  }
  (n.ready.promise = function (b) {
    return (
      H ||
        ((H = n.Deferred()),
        "complete" === l.readyState
          ? setTimeout(n.ready)
          : (l.addEventListener("DOMContentLoaded", I, !1),
            a.addEventListener("load", I, !1))),
      H.promise(b)
    );
  }),
    n.ready.promise();
  var J = (n.access = function (a, b, c, d, e, f, g) {
    var h = 0,
      i = a.length,
      j = null == c;
    if ("object" === n.type(c)) {
      e = !0;
      for (h in c) n.access(a, b, h, c[h], !0, f, g);
    } else if (
      void 0 !== d &&
      ((e = !0),
      n.isFunction(d) || (g = !0),
      j &&
        (g
          ? (b.call(a, d), (b = null))
          : ((j = b),
            (b = function (a, b, c) {
              return j.call(n(a), c);
            }))),
      b)
    )
      for (; i > h; h++) b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));
    return e ? a : j ? b.call(a) : i ? b(a[0], c) : f;
  });
  n.acceptData = function (a) {
    return 1 === a.nodeType || 9 === a.nodeType || !+a.nodeType;
  };
  function K() {
    Object.defineProperty((this.cache = {}), 0, {
      get: function () {
        return {};
      },
    }),
      (this.expando = n.expando + K.uid++);
  }
  (K.uid = 1),
    (K.accepts = n.acceptData),
    (K.prototype = {
      key: function (a) {
        if (!K.accepts(a)) return 0;
        var b = {},
          c = a[this.expando];
        if (!c) {
          c = K.uid++;
          try {
            (b[this.expando] = { value: c }), Object.defineProperties(a, b);
          } catch (d) {
            (b[this.expando] = c), n.extend(a, b);
          }
        }
        return this.cache[c] || (this.cache[c] = {}), c;
      },
      set: function (a, b, c) {
        var d,
          e = this.key(a),
          f = this.cache[e];
        if ("string" == typeof b) f[b] = c;
        else if (n.isEmptyObject(f)) n.extend(this.cache[e], b);
        else for (d in b) f[d] = b[d];
        return f;
      },
      get: function (a, b) {
        var c = this.cache[this.key(a)];
        return void 0 === b ? c : c[b];
      },
      access: function (a, b, c) {
        var d;
        return void 0 === b || (b && "string" == typeof b && void 0 === c)
          ? ((d = this.get(a, b)),
            void 0 !== d ? d : this.get(a, n.camelCase(b)))
          : (this.set(a, b, c), void 0 !== c ? c : b);
      },
      remove: function (a, b) {
        var c,
          d,
          e,
          f = this.key(a),
          g = this.cache[f];
        if (void 0 === b) this.cache[f] = {};
        else {
          n.isArray(b)
            ? (d = b.concat(b.map(n.camelCase)))
            : ((e = n.camelCase(b)),
              b in g
                ? (d = [b, e])
                : ((d = e), (d = d in g ? [d] : d.match(E) || []))),
            (c = d.length);
          while (c--) delete g[d[c]];
        }
      },
      hasData: function (a) {
        return !n.isEmptyObject(this.cache[a[this.expando]] || {});
      },
      discard: function (a) {
        a[this.expando] && delete this.cache[a[this.expando]];
      },
    });
  var L = new K(),
    M = new K(),
    N = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
    O = /([A-Z])/g;
  function P(a, b, c) {
    var d;
    if (void 0 === c && 1 === a.nodeType)
      if (
        ((d = "data-" + b.replace(O, "-$1").toLowerCase()),
        (c = a.getAttribute(d)),
        "string" == typeof c)
      ) {
        try {
          c =
            "true" === c
              ? !0
              : "false" === c
              ? !1
              : "null" === c
              ? null
              : +c + "" === c
              ? +c
              : N.test(c)
              ? n.parseJSON(c)
              : c;
        } catch (e) {}
        M.set(a, b, c);
      } else c = void 0;
    return c;
  }
  n.extend({
    hasData: function (a) {
      return M.hasData(a) || L.hasData(a);
    },
    data: function (a, b, c) {
      return M.access(a, b, c);
    },
    removeData: function (a, b) {
      M.remove(a, b);
    },
    _data: function (a, b, c) {
      return L.access(a, b, c);
    },
    _removeData: function (a, b) {
      L.remove(a, b);
    },
  }),
    n.fn.extend({
      data: function (a, b) {
        var c,
          d,
          e,
          f = this[0],
          g = f && f.attributes;
        if (void 0 === a) {
          if (
            this.length &&
            ((e = M.get(f)), 1 === f.nodeType && !L.get(f, "hasDataAttrs"))
          ) {
            c = g.length;
            while (c--)
              g[c] &&
                ((d = g[c].name),
                0 === d.indexOf("data-") &&
                  ((d = n.camelCase(d.slice(5))), P(f, d, e[d])));
            L.set(f, "hasDataAttrs", !0);
          }
          return e;
        }
        return "object" == typeof a
          ? this.each(function () {
              M.set(this, a);
            })
          : J(
              this,
              function (b) {
                var c,
                  d = n.camelCase(a);
                if (f && void 0 === b) {
                  if (((c = M.get(f, a)), void 0 !== c)) return c;
                  if (((c = M.get(f, d)), void 0 !== c)) return c;
                  if (((c = P(f, d, void 0)), void 0 !== c)) return c;
                } else
                  this.each(function () {
                    var c = M.get(this, d);
                    M.set(this, d, b),
                      -1 !== a.indexOf("-") &&
                        void 0 !== c &&
                        M.set(this, a, b);
                  });
              },
              null,
              b,
              arguments.length > 1,
              null,
              !0
            );
      },
      removeData: function (a) {
        return this.each(function () {
          M.remove(this, a);
        });
      },
    }),
    n.extend({
      queue: function (a, b, c) {
        var d;
        return a
          ? ((b = (b || "fx") + "queue"),
            (d = L.get(a, b)),
            c &&
              (!d || n.isArray(c)
                ? (d = L.access(a, b, n.makeArray(c)))
                : d.push(c)),
            d || [])
          : void 0;
      },
      dequeue: function (a, b) {
        b = b || "fx";
        var c = n.queue(a, b),
          d = c.length,
          e = c.shift(),
          f = n._queueHooks(a, b),
          g = function () {
            n.dequeue(a, b);
          };
        "inprogress" === e && ((e = c.shift()), d--),
          e &&
            ("fx" === b && c.unshift("inprogress"),
            delete f.stop,
            e.call(a, g, f)),
          !d && f && f.empty.fire();
      },
      _queueHooks: function (a, b) {
        var c = b + "queueHooks";
        return (
          L.get(a, c) ||
          L.access(a, c, {
            empty: n.Callbacks("once memory").add(function () {
              L.remove(a, [b + "queue", c]);
            }),
          })
        );
      },
    }),
    n.fn.extend({
      queue: function (a, b) {
        var c = 2;
        return (
          "string" != typeof a && ((b = a), (a = "fx"), c--),
          arguments.length < c
            ? n.queue(this[0], a)
            : void 0 === b
            ? this
            : this.each(function () {
                var c = n.queue(this, a, b);
                n._queueHooks(this, a),
                  "fx" === a && "inprogress" !== c[0] && n.dequeue(this, a);
              })
        );
      },
      dequeue: function (a) {
        return this.each(function () {
          n.dequeue(this, a);
        });
      },
      clearQueue: function (a) {
        return this.queue(a || "fx", []);
      },
      promise: function (a, b) {
        var c,
          d = 1,
          e = n.Deferred(),
          f = this,
          g = this.length,
          h = function () {
            --d || e.resolveWith(f, [f]);
          };
        "string" != typeof a && ((b = a), (a = void 0)), (a = a || "fx");
        while (g--)
          (c = L.get(f[g], a + "queueHooks")),
            c && c.empty && (d++, c.empty.add(h));
        return h(), e.promise(b);
      },
    });
  var Q = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
    R = ["Top", "Right", "Bottom", "Left"],
    S = function (a, b) {
      return (
        (a = b || a),
        "none" === n.css(a, "display") || !n.contains(a.ownerDocument, a)
      );
    },
    T = /^(?:checkbox|radio)$/i;
  !(function () {
    var a = l.createDocumentFragment(),
      b = a.appendChild(l.createElement("div")),
      c = l.createElement("input");
    c.setAttribute("type", "radio"),
      c.setAttribute("checked", "checked"),
      c.setAttribute("name", "t"),
      b.appendChild(c),
      (k.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked),
      (b.innerHTML = "<textarea>x</textarea>"),
      (k.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue);
  })();
  var U = "undefined";
  k.focusinBubbles = "onfocusin" in a;
  var V = /^key/,
    W = /^(?:mouse|pointer|contextmenu)|click/,
    X = /^(?:focusinfocus|focusoutblur)$/,
    Y = /^([^.]*)(?:\.(.+)|)$/;
  function Z() {
    return !0;
  }
  function $() {
    return !1;
  }
  function _() {
    try {
      return l.activeElement;
    } catch (a) {}
  }
  (n.event = {
    global: {},
    add: function (a, b, c, d, e) {
      var f,
        g,
        h,
        i,
        j,
        k,
        l,
        m,
        o,
        p,
        q,
        r = L.get(a);
      if (r) {
        c.handler && ((f = c), (c = f.handler), (e = f.selector)),
          c.guid || (c.guid = n.guid++),
          (i = r.events) || (i = r.events = {}),
          (g = r.handle) ||
            (g = r.handle =
              function (b) {
                return typeof n !== U && n.event.triggered !== b.type
                  ? n.event.dispatch.apply(a, arguments)
                  : void 0;
              }),
          (b = (b || "").match(E) || [""]),
          (j = b.length);
        while (j--)
          (h = Y.exec(b[j]) || []),
            (o = q = h[1]),
            (p = (h[2] || "").split(".").sort()),
            o &&
              ((l = n.event.special[o] || {}),
              (o = (e ? l.delegateType : l.bindType) || o),
              (l = n.event.special[o] || {}),
              (k = n.extend(
                {
                  type: o,
                  origType: q,
                  data: d,
                  handler: c,
                  guid: c.guid,
                  selector: e,
                  needsContext: e && n.expr.match.needsContext.test(e),
                  namespace: p.join("."),
                },
                f
              )),
              (m = i[o]) ||
                ((m = i[o] = []),
                (m.delegateCount = 0),
                (l.setup && l.setup.call(a, d, p, g) !== !1) ||
                  (a.addEventListener && a.addEventListener(o, g, !1))),
              l.add &&
                (l.add.call(a, k), k.handler.guid || (k.handler.guid = c.guid)),
              e ? m.splice(m.delegateCount++, 0, k) : m.push(k),
              (n.event.global[o] = !0));
      }
    },
    remove: function (a, b, c, d, e) {
      var f,
        g,
        h,
        i,
        j,
        k,
        l,
        m,
        o,
        p,
        q,
        r = L.hasData(a) && L.get(a);
      if (r && (i = r.events)) {
        (b = (b || "").match(E) || [""]), (j = b.length);
        while (j--)
          if (
            ((h = Y.exec(b[j]) || []),
            (o = q = h[1]),
            (p = (h[2] || "").split(".").sort()),
            o)
          ) {
            (l = n.event.special[o] || {}),
              (o = (d ? l.delegateType : l.bindType) || o),
              (m = i[o] || []),
              (h =
                h[2] &&
                new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)")),
              (g = f = m.length);
            while (f--)
              (k = m[f]),
                (!e && q !== k.origType) ||
                  (c && c.guid !== k.guid) ||
                  (h && !h.test(k.namespace)) ||
                  (d && d !== k.selector && ("**" !== d || !k.selector)) ||
                  (m.splice(f, 1),
                  k.selector && m.delegateCount--,
                  l.remove && l.remove.call(a, k));
            g &&
              !m.length &&
              ((l.teardown && l.teardown.call(a, p, r.handle) !== !1) ||
                n.removeEvent(a, o, r.handle),
              delete i[o]);
          } else for (o in i) n.event.remove(a, o + b[j], c, d, !0);
        n.isEmptyObject(i) && (delete r.handle, L.remove(a, "events"));
      }
    },
    trigger: function (b, c, d, e) {
      var f,
        g,
        h,
        i,
        k,
        m,
        o,
        p = [d || l],
        q = j.call(b, "type") ? b.type : b,
        r = j.call(b, "namespace") ? b.namespace.split(".") : [];
      if (
        ((g = h = d = d || l),
        3 !== d.nodeType &&
          8 !== d.nodeType &&
          !X.test(q + n.event.triggered) &&
          (q.indexOf(".") >= 0 &&
            ((r = q.split(".")), (q = r.shift()), r.sort()),
          (k = q.indexOf(":") < 0 && "on" + q),
          (b = b[n.expando] ? b : new n.Event(q, "object" == typeof b && b)),
          (b.isTrigger = e ? 2 : 3),
          (b.namespace = r.join(".")),
          (b.namespace_re = b.namespace
            ? new RegExp("(^|\\.)" + r.join("\\.(?:.*\\.|)") + "(\\.|$)")
            : null),
          (b.result = void 0),
          b.target || (b.target = d),
          (c = null == c ? [b] : n.makeArray(c, [b])),
          (o = n.event.special[q] || {}),
          e || !o.trigger || o.trigger.apply(d, c) !== !1))
      ) {
        if (!e && !o.noBubble && !n.isWindow(d)) {
          for (
            i = o.delegateType || q, X.test(i + q) || (g = g.parentNode);
            g;
            g = g.parentNode
          )
            p.push(g), (h = g);
          h === (d.ownerDocument || l) &&
            p.push(h.defaultView || h.parentWindow || a);
        }
        f = 0;
        while ((g = p[f++]) && !b.isPropagationStopped())
          (b.type = f > 1 ? i : o.bindType || q),
            (m = (L.get(g, "events") || {})[b.type] && L.get(g, "handle")),
            m && m.apply(g, c),
            (m = k && g[k]),
            m &&
              m.apply &&
              n.acceptData(g) &&
              ((b.result = m.apply(g, c)),
              b.result === !1 && b.preventDefault());
        return (
          (b.type = q),
          e ||
            b.isDefaultPrevented() ||
            (o._default && o._default.apply(p.pop(), c) !== !1) ||
            !n.acceptData(d) ||
            (k &&
              n.isFunction(d[q]) &&
              !n.isWindow(d) &&
              ((h = d[k]),
              h && (d[k] = null),
              (n.event.triggered = q),
              d[q](),
              (n.event.triggered = void 0),
              h && (d[k] = h))),
          b.result
        );
      }
    },
    dispatch: function (a) {
      a = n.event.fix(a);
      var b,
        c,
        e,
        f,
        g,
        h = [],
        i = d.call(arguments),
        j = (L.get(this, "events") || {})[a.type] || [],
        k = n.event.special[a.type] || {};
      if (
        ((i[0] = a),
        (a.delegateTarget = this),
        !k.preDispatch || k.preDispatch.call(this, a) !== !1)
      ) {
        (h = n.event.handlers.call(this, a, j)), (b = 0);
        while ((f = h[b++]) && !a.isPropagationStopped()) {
          (a.currentTarget = f.elem), (c = 0);
          while ((g = f.handlers[c++]) && !a.isImmediatePropagationStopped())
            (!a.namespace_re || a.namespace_re.test(g.namespace)) &&
              ((a.handleObj = g),
              (a.data = g.data),
              (e = (
                (n.event.special[g.origType] || {}).handle || g.handler
              ).apply(f.elem, i)),
              void 0 !== e &&
                (a.result = e) === !1 &&
                (a.preventDefault(), a.stopPropagation()));
        }
        return k.postDispatch && k.postDispatch.call(this, a), a.result;
      }
    },
    handlers: function (a, b) {
      var c,
        d,
        e,
        f,
        g = [],
        h = b.delegateCount,
        i = a.target;
      if (h && i.nodeType && (!a.button || "click" !== a.type))
        for (; i !== this; i = i.parentNode || this)
          if (i.disabled !== !0 || "click" !== a.type) {
            for (d = [], c = 0; h > c; c++)
              (f = b[c]),
                (e = f.selector + " "),
                void 0 === d[e] &&
                  (d[e] = f.needsContext
                    ? n(e, this).index(i) >= 0
                    : n.find(e, this, null, [i]).length),
                d[e] && d.push(f);
            d.length && g.push({ elem: i, handlers: d });
          }
      return h < b.length && g.push({ elem: this, handlers: b.slice(h) }), g;
    },
    props:
      "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(
        " "
      ),
    fixHooks: {},
    keyHooks: {
      props: "char charCode key keyCode".split(" "),
      filter: function (a, b) {
        return (
          null == a.which &&
            (a.which = null != b.charCode ? b.charCode : b.keyCode),
          a
        );
      },
    },
    mouseHooks: {
      props:
        "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(
          " "
        ),
      filter: function (a, b) {
        var c,
          d,
          e,
          f = b.button;
        return (
          null == a.pageX &&
            null != b.clientX &&
            ((c = a.target.ownerDocument || l),
            (d = c.documentElement),
            (e = c.body),
            (a.pageX =
              b.clientX +
              ((d && d.scrollLeft) || (e && e.scrollLeft) || 0) -
              ((d && d.clientLeft) || (e && e.clientLeft) || 0)),
            (a.pageY =
              b.clientY +
              ((d && d.scrollTop) || (e && e.scrollTop) || 0) -
              ((d && d.clientTop) || (e && e.clientTop) || 0))),
          a.which ||
            void 0 === f ||
            (a.which = 1 & f ? 1 : 2 & f ? 3 : 4 & f ? 2 : 0),
          a
        );
      },
    },
    fix: function (a) {
      if (a[n.expando]) return a;
      var b,
        c,
        d,
        e = a.type,
        f = a,
        g = this.fixHooks[e];
      g ||
        (this.fixHooks[e] = g =
          W.test(e) ? this.mouseHooks : V.test(e) ? this.keyHooks : {}),
        (d = g.props ? this.props.concat(g.props) : this.props),
        (a = new n.Event(f)),
        (b = d.length);
      while (b--) (c = d[b]), (a[c] = f[c]);
      return (
        a.target || (a.target = l),
        3 === a.target.nodeType && (a.target = a.target.parentNode),
        g.filter ? g.filter(a, f) : a
      );
    },
    special: {
      load: { noBubble: !0 },
      focus: {
        trigger: function () {
          return this !== _() && this.focus ? (this.focus(), !1) : void 0;
        },
        delegateType: "focusin",
      },
      blur: {
        trigger: function () {
          return this === _() && this.blur ? (this.blur(), !1) : void 0;
        },
        delegateType: "focusout",
      },
      click: {
        trigger: function () {
          return "checkbox" === this.type &&
            this.click &&
            n.nodeName(this, "input")
            ? (this.click(), !1)
            : void 0;
        },
        _default: function (a) {
          return n.nodeName(a.target, "a");
        },
      },
      beforeunload: {
        postDispatch: function (a) {
          void 0 !== a.result &&
            a.originalEvent &&
            (a.originalEvent.returnValue = a.result);
        },
      },
    },
    simulate: function (a, b, c, d) {
      var e = n.extend(new n.Event(), c, {
        type: a,
        isSimulated: !0,
        originalEvent: {},
      });
      d ? n.event.trigger(e, null, b) : n.event.dispatch.call(b, e),
        e.isDefaultPrevented() && c.preventDefault();
    },
  }),
    (n.removeEvent = function (a, b, c) {
      a.removeEventListener && a.removeEventListener(b, c, !1);
    }),
    (n.Event = function (a, b) {
      return this instanceof n.Event
        ? (a && a.type
            ? ((this.originalEvent = a),
              (this.type = a.type),
              (this.isDefaultPrevented =
                a.defaultPrevented ||
                (void 0 === a.defaultPrevented && a.returnValue === !1)
                  ? Z
                  : $))
            : (this.type = a),
          b && n.extend(this, b),
          (this.timeStamp = (a && a.timeStamp) || n.now()),
          void (this[n.expando] = !0))
        : new n.Event(a, b);
    }),
    (n.Event.prototype = {
      isDefaultPrevented: $,
      isPropagationStopped: $,
      isImmediatePropagationStopped: $,
      preventDefault: function () {
        var a = this.originalEvent;
        (this.isDefaultPrevented = Z),
          a && a.preventDefault && a.preventDefault();
      },
      stopPropagation: function () {
        var a = this.originalEvent;
        (this.isPropagationStopped = Z),
          a && a.stopPropagation && a.stopPropagation();
      },
      stopImmediatePropagation: function () {
        var a = this.originalEvent;
        (this.isImmediatePropagationStopped = Z),
          a && a.stopImmediatePropagation && a.stopImmediatePropagation(),
          this.stopPropagation();
      },
    }),
    n.each(
      {
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout",
      },
      function (a, b) {
        n.event.special[a] = {
          delegateType: b,
          bindType: b,
          handle: function (a) {
            var c,
              d = this,
              e = a.relatedTarget,
              f = a.handleObj;
            return (
              (!e || (e !== d && !n.contains(d, e))) &&
                ((a.type = f.origType),
                (c = f.handler.apply(this, arguments)),
                (a.type = b)),
              c
            );
          },
        };
      }
    ),
    k.focusinBubbles ||
      n.each({ focus: "focusin", blur: "focusout" }, function (a, b) {
        var c = function (a) {
          n.event.simulate(b, a.target, n.event.fix(a), !0);
        };
        n.event.special[b] = {
          setup: function () {
            var d = this.ownerDocument || this,
              e = L.access(d, b);
            e || d.addEventListener(a, c, !0), L.access(d, b, (e || 0) + 1);
          },
          teardown: function () {
            var d = this.ownerDocument || this,
              e = L.access(d, b) - 1;
            e
              ? L.access(d, b, e)
              : (d.removeEventListener(a, c, !0), L.remove(d, b));
          },
        };
      }),
    n.fn.extend({
      on: function (a, b, c, d, e) {
        var f, g;
        if ("object" == typeof a) {
          "string" != typeof b && ((c = c || b), (b = void 0));
          for (g in a) this.on(g, b, c, a[g], e);
          return this;
        }
        if (
          (null == c && null == d
            ? ((d = b), (c = b = void 0))
            : null == d &&
              ("string" == typeof b
                ? ((d = c), (c = void 0))
                : ((d = c), (c = b), (b = void 0))),
          d === !1)
        )
          d = $;
        else if (!d) return this;
        return (
          1 === e &&
            ((f = d),
            (d = function (a) {
              return n().off(a), f.apply(this, arguments);
            }),
            (d.guid = f.guid || (f.guid = n.guid++))),
          this.each(function () {
            n.event.add(this, a, d, c, b);
          })
        );
      },
      one: function (a, b, c, d) {
        return this.on(a, b, c, d, 1);
      },
      off: function (a, b, c) {
        var d, e;
        if (a && a.preventDefault && a.handleObj)
          return (
            (d = a.handleObj),
            n(a.delegateTarget).off(
              d.namespace ? d.origType + "." + d.namespace : d.origType,
              d.selector,
              d.handler
            ),
            this
          );
        if ("object" == typeof a) {
          for (e in a) this.off(e, b, a[e]);
          return this;
        }
        return (
          (b === !1 || "function" == typeof b) && ((c = b), (b = void 0)),
          c === !1 && (c = $),
          this.each(function () {
            n.event.remove(this, a, c, b);
          })
        );
      },
      trigger: function (a, b) {
        return this.each(function () {
          n.event.trigger(a, b, this);
        });
      },
      triggerHandler: function (a, b) {
        var c = this[0];
        return c ? n.event.trigger(a, b, c, !0) : void 0;
      },
    });
  var ab =
      /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
    bb = /<([\w:]+)/,
    cb = /<|&#?\w+;/,
    db = /<(?:script|style|link)/i,
    eb = /checked\s*(?:[^=]|=\s*.checked.)/i,
    fb = /^$|\/(?:java|ecma)script/i,
    gb = /^true\/(.*)/,
    hb = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
    ib = {
      option: [1, "<select multiple='multiple'>", "</select>"],
      thead: [1, "<table>", "</table>"],
      col: [2, "<table><colgroup>", "</colgroup></table>"],
      tr: [2, "<table><tbody>", "</tbody></table>"],
      td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
      _default: [0, "", ""],
    };
  (ib.optgroup = ib.option),
    (ib.tbody = ib.tfoot = ib.colgroup = ib.caption = ib.thead),
    (ib.th = ib.td);
  function jb(a, b) {
    return n.nodeName(a, "table") &&
      n.nodeName(11 !== b.nodeType ? b : b.firstChild, "tr")
      ? a.getElementsByTagName("tbody")[0] ||
          a.appendChild(a.ownerDocument.createElement("tbody"))
      : a;
  }
  function kb(a) {
    return (a.type = (null !== a.getAttribute("type")) + "/" + a.type), a;
  }
  function lb(a) {
    var b = gb.exec(a.type);
    return b ? (a.type = b[1]) : a.removeAttribute("type"), a;
  }
  function mb(a, b) {
    for (var c = 0, d = a.length; d > c; c++)
      L.set(a[c], "globalEval", !b || L.get(b[c], "globalEval"));
  }
  function nb(a, b) {
    var c, d, e, f, g, h, i, j;
    if (1 === b.nodeType) {
      if (
        L.hasData(a) &&
        ((f = L.access(a)), (g = L.set(b, f)), (j = f.events))
      ) {
        delete g.handle, (g.events = {});
        for (e in j)
          for (c = 0, d = j[e].length; d > c; c++) n.event.add(b, e, j[e][c]);
      }
      M.hasData(a) && ((h = M.access(a)), (i = n.extend({}, h)), M.set(b, i));
    }
  }
  function ob(a, b) {
    var c = a.getElementsByTagName
      ? a.getElementsByTagName(b || "*")
      : a.querySelectorAll
      ? a.querySelectorAll(b || "*")
      : [];
    return void 0 === b || (b && n.nodeName(a, b)) ? n.merge([a], c) : c;
  }
  function pb(a, b) {
    var c = b.nodeName.toLowerCase();
    "input" === c && T.test(a.type)
      ? (b.checked = a.checked)
      : ("input" === c || "textarea" === c) &&
        (b.defaultValue = a.defaultValue);
  }
  n.extend({
    clone: function (a, b, c) {
      var d,
        e,
        f,
        g,
        h = a.cloneNode(!0),
        i = n.contains(a.ownerDocument, a);
      if (
        !(
          k.noCloneChecked ||
          (1 !== a.nodeType && 11 !== a.nodeType) ||
          n.isXMLDoc(a)
        )
      )
        for (g = ob(h), f = ob(a), d = 0, e = f.length; e > d; d++)
          pb(f[d], g[d]);
      if (b)
        if (c)
          for (f = f || ob(a), g = g || ob(h), d = 0, e = f.length; e > d; d++)
            nb(f[d], g[d]);
        else nb(a, h);
      return (
        (g = ob(h, "script")), g.length > 0 && mb(g, !i && ob(a, "script")), h
      );
    },
    buildFragment: function (a, b, c, d) {
      for (
        var e,
          f,
          g,
          h,
          i,
          j,
          k = b.createDocumentFragment(),
          l = [],
          m = 0,
          o = a.length;
        o > m;
        m++
      )
        if (((e = a[m]), e || 0 === e))
          if ("object" === n.type(e)) n.merge(l, e.nodeType ? [e] : e);
          else if (cb.test(e)) {
            (f = f || k.appendChild(b.createElement("div"))),
              (g = (bb.exec(e) || ["", ""])[1].toLowerCase()),
              (h = ib[g] || ib._default),
              (f.innerHTML = h[1] + e.replace(ab, "<$1></$2>") + h[2]),
              (j = h[0]);
            while (j--) f = f.lastChild;
            n.merge(l, f.childNodes), (f = k.firstChild), (f.textContent = "");
          } else l.push(b.createTextNode(e));
      (k.textContent = ""), (m = 0);
      while ((e = l[m++]))
        if (
          (!d || -1 === n.inArray(e, d)) &&
          ((i = n.contains(e.ownerDocument, e)),
          (f = ob(k.appendChild(e), "script")),
          i && mb(f),
          c)
        ) {
          j = 0;
          while ((e = f[j++])) fb.test(e.type || "") && c.push(e);
        }
      return k;
    },
    cleanData: function (a) {
      for (
        var b, c, d, e, f = n.event.special, g = 0;
        void 0 !== (c = a[g]);
        g++
      ) {
        if (n.acceptData(c) && ((e = c[L.expando]), e && (b = L.cache[e]))) {
          if (b.events)
            for (d in b.events)
              f[d] ? n.event.remove(c, d) : n.removeEvent(c, d, b.handle);
          L.cache[e] && delete L.cache[e];
        }
        delete M.cache[c[M.expando]];
      }
    },
  }),
    n.fn.extend({
      text: function (a) {
        return J(
          this,
          function (a) {
            return void 0 === a
              ? n.text(this)
              : this.empty().each(function () {
                  (1 === this.nodeType ||
                    11 === this.nodeType ||
                    9 === this.nodeType) &&
                    (this.textContent = a);
                });
          },
          null,
          a,
          arguments.length
        );
      },
      append: function () {
        return this.domManip(arguments, function (a) {
          if (
            1 === this.nodeType ||
            11 === this.nodeType ||
            9 === this.nodeType
          ) {
            var b = jb(this, a);
            b.appendChild(a);
          }
        });
      },
      prepend: function () {
        return this.domManip(arguments, function (a) {
          if (
            1 === this.nodeType ||
            11 === this.nodeType ||
            9 === this.nodeType
          ) {
            var b = jb(this, a);
            b.insertBefore(a, b.firstChild);
          }
        });
      },
      before: function () {
        return this.domManip(arguments, function (a) {
          this.parentNode && this.parentNode.insertBefore(a, this);
        });
      },
      after: function () {
        return this.domManip(arguments, function (a) {
          this.parentNode && this.parentNode.insertBefore(a, this.nextSibling);
        });
      },
      remove: function (a, b) {
        for (
          var c, d = a ? n.filter(a, this) : this, e = 0;
          null != (c = d[e]);
          e++
        )
          b || 1 !== c.nodeType || n.cleanData(ob(c)),
            c.parentNode &&
              (b && n.contains(c.ownerDocument, c) && mb(ob(c, "script")),
              c.parentNode.removeChild(c));
        return this;
      },
      empty: function () {
        for (var a, b = 0; null != (a = this[b]); b++)
          1 === a.nodeType && (n.cleanData(ob(a, !1)), (a.textContent = ""));
        return this;
      },
      clone: function (a, b) {
        return (
          (a = null == a ? !1 : a),
          (b = null == b ? a : b),
          this.map(function () {
            return n.clone(this, a, b);
          })
        );
      },
      html: function (a) {
        return J(
          this,
          function (a) {
            var b = this[0] || {},
              c = 0,
              d = this.length;
            if (void 0 === a && 1 === b.nodeType) return b.innerHTML;
            if (
              "string" == typeof a &&
              !db.test(a) &&
              !ib[(bb.exec(a) || ["", ""])[1].toLowerCase()]
            ) {
              a = a.replace(ab, "<$1></$2>");
              try {
                for (; d > c; c++)
                  (b = this[c] || {}),
                    1 === b.nodeType &&
                      (n.cleanData(ob(b, !1)), (b.innerHTML = a));
                b = 0;
              } catch (e) {}
            }
            b && this.empty().append(a);
          },
          null,
          a,
          arguments.length
        );
      },
      replaceWith: function () {
        var a = arguments[0];
        return (
          this.domManip(arguments, function (b) {
            (a = this.parentNode),
              n.cleanData(ob(this)),
              a && a.replaceChild(b, this);
          }),
          a && (a.length || a.nodeType) ? this : this.remove()
        );
      },
      detach: function (a) {
        return this.remove(a, !0);
      },
      domManip: function (a, b) {
        a = e.apply([], a);
        var c,
          d,
          f,
          g,
          h,
          i,
          j = 0,
          l = this.length,
          m = this,
          o = l - 1,
          p = a[0],
          q = n.isFunction(p);
        if (q || (l > 1 && "string" == typeof p && !k.checkClone && eb.test(p)))
          return this.each(function (c) {
            var d = m.eq(c);
            q && (a[0] = p.call(this, c, d.html())), d.domManip(a, b);
          });
        if (
          l &&
          ((c = n.buildFragment(a, this[0].ownerDocument, !1, this)),
          (d = c.firstChild),
          1 === c.childNodes.length && (c = d),
          d)
        ) {
          for (f = n.map(ob(c, "script"), kb), g = f.length; l > j; j++)
            (h = c),
              j !== o &&
                ((h = n.clone(h, !0, !0)), g && n.merge(f, ob(h, "script"))),
              b.call(this[j], h, j);
          if (g)
            for (
              i = f[f.length - 1].ownerDocument, n.map(f, lb), j = 0;
              g > j;
              j++
            )
              (h = f[j]),
                fb.test(h.type || "") &&
                  !L.access(h, "globalEval") &&
                  n.contains(i, h) &&
                  (h.src
                    ? n._evalUrl && n._evalUrl(h.src)
                    : n.globalEval(h.textContent.replace(hb, "")));
        }
        return this;
      },
    }),
    n.each(
      {
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith",
      },
      function (a, b) {
        n.fn[a] = function (a) {
          for (var c, d = [], e = n(a), g = e.length - 1, h = 0; g >= h; h++)
            (c = h === g ? this : this.clone(!0)),
              n(e[h])[b](c),
              f.apply(d, c.get());
          return this.pushStack(d);
        };
      }
    );
  var qb,
    rb = {};
  function sb(b, c) {
    var d,
      e = n(c.createElement(b)).appendTo(c.body),
      f =
        a.getDefaultComputedStyle && (d = a.getDefaultComputedStyle(e[0]))
          ? d.display
          : n.css(e[0], "display");
    return e.detach(), f;
  }
  function tb(a) {
    var b = l,
      c = rb[a];
    return (
      c ||
        ((c = sb(a, b)),
        ("none" !== c && c) ||
          ((qb = (
            qb || n("<iframe frameborder='0' width='0' height='0'/>")
          ).appendTo(b.documentElement)),
          (b = qb[0].contentDocument),
          b.write(),
          b.close(),
          (c = sb(a, b)),
          qb.detach()),
        (rb[a] = c)),
      c
    );
  }
  var ub = /^margin/,
    vb = new RegExp("^(" + Q + ")(?!px)[a-z%]+$", "i"),
    wb = function (b) {
      return b.ownerDocument.defaultView.opener
        ? b.ownerDocument.defaultView.getComputedStyle(b, null)
        : a.getComputedStyle(b, null);
    };
  function xb(a, b, c) {
    var d,
      e,
      f,
      g,
      h = a.style;
    return (
      (c = c || wb(a)),
      c && (g = c.getPropertyValue(b) || c[b]),
      c &&
        ("" !== g || n.contains(a.ownerDocument, a) || (g = n.style(a, b)),
        vb.test(g) &&
          ub.test(b) &&
          ((d = h.width),
          (e = h.minWidth),
          (f = h.maxWidth),
          (h.minWidth = h.maxWidth = h.width = g),
          (g = c.width),
          (h.width = d),
          (h.minWidth = e),
          (h.maxWidth = f))),
      void 0 !== g ? g + "" : g
    );
  }
  function yb(a, b) {
    return {
      get: function () {
        return a()
          ? void delete this.get
          : (this.get = b).apply(this, arguments);
      },
    };
  }
  !(function () {
    var b,
      c,
      d = l.documentElement,
      e = l.createElement("div"),
      f = l.createElement("div");
    if (f.style) {
      (f.style.backgroundClip = "content-box"),
        (f.cloneNode(!0).style.backgroundClip = ""),
        (k.clearCloneStyle = "content-box" === f.style.backgroundClip),
        (e.style.cssText =
          "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute"),
        e.appendChild(f);
      function g() {
        (f.style.cssText =
          "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute"),
          (f.innerHTML = ""),
          d.appendChild(e);
        var g = a.getComputedStyle(f, null);
        (b = "1%" !== g.top), (c = "4px" === g.width), d.removeChild(e);
      }
      a.getComputedStyle &&
        n.extend(k, {
          pixelPosition: function () {
            return g(), b;
          },
          boxSizingReliable: function () {
            return null == c && g(), c;
          },
          reliableMarginRight: function () {
            var b,
              c = f.appendChild(l.createElement("div"));
            return (
              (c.style.cssText = f.style.cssText =
                "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0"),
              (c.style.marginRight = c.style.width = "0"),
              (f.style.width = "1px"),
              d.appendChild(e),
              (b = !parseFloat(a.getComputedStyle(c, null).marginRight)),
              d.removeChild(e),
              f.removeChild(c),
              b
            );
          },
        });
    }
  })(),
    (n.swap = function (a, b, c, d) {
      var e,
        f,
        g = {};
      for (f in b) (g[f] = a.style[f]), (a.style[f] = b[f]);
      e = c.apply(a, d || []);
      for (f in b) a.style[f] = g[f];
      return e;
    });
  var zb = /^(none|table(?!-c[ea]).+)/,
    Ab = new RegExp("^(" + Q + ")(.*)$", "i"),
    Bb = new RegExp("^([+-])=(" + Q + ")", "i"),
    Cb = { position: "absolute", visibility: "hidden", display: "block" },
    Db = { letterSpacing: "0", fontWeight: "400" },
    Eb = ["Webkit", "O", "Moz", "ms"];
  function Fb(a, b) {
    if (b in a) return b;
    var c = b[0].toUpperCase() + b.slice(1),
      d = b,
      e = Eb.length;
    while (e--) if (((b = Eb[e] + c), b in a)) return b;
    return d;
  }
  function Gb(a, b, c) {
    var d = Ab.exec(b);
    return d ? Math.max(0, d[1] - (c || 0)) + (d[2] || "px") : b;
  }
  function Hb(a, b, c, d, e) {
    for (
      var f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0,
        g = 0;
      4 > f;
      f += 2
    )
      "margin" === c && (g += n.css(a, c + R[f], !0, e)),
        d
          ? ("content" === c && (g -= n.css(a, "padding" + R[f], !0, e)),
            "margin" !== c && (g -= n.css(a, "border" + R[f] + "Width", !0, e)))
          : ((g += n.css(a, "padding" + R[f], !0, e)),
            "padding" !== c &&
              (g += n.css(a, "border" + R[f] + "Width", !0, e)));
    return g;
  }
  function Ib(a, b, c) {
    var d = !0,
      e = "width" === b ? a.offsetWidth : a.offsetHeight,
      f = wb(a),
      g = "border-box" === n.css(a, "boxSizing", !1, f);
    if (0 >= e || null == e) {
      if (
        ((e = xb(a, b, f)),
        (0 > e || null == e) && (e = a.style[b]),
        vb.test(e))
      )
        return e;
      (d = g && (k.boxSizingReliable() || e === a.style[b])),
        (e = parseFloat(e) || 0);
    }
    return e + Hb(a, b, c || (g ? "border" : "content"), d, f) + "px";
  }
  function Jb(a, b) {
    for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++)
      (d = a[g]),
        d.style &&
          ((f[g] = L.get(d, "olddisplay")),
          (c = d.style.display),
          b
            ? (f[g] || "none" !== c || (d.style.display = ""),
              "" === d.style.display &&
                S(d) &&
                (f[g] = L.access(d, "olddisplay", tb(d.nodeName))))
            : ((e = S(d)),
              ("none" === c && e) ||
                L.set(d, "olddisplay", e ? c : n.css(d, "display"))));
    for (g = 0; h > g; g++)
      (d = a[g]),
        d.style &&
          ((b && "none" !== d.style.display && "" !== d.style.display) ||
            (d.style.display = b ? f[g] || "" : "none"));
    return a;
  }
  n.extend({
    cssHooks: {
      opacity: {
        get: function (a, b) {
          if (b) {
            var c = xb(a, "opacity");
            return "" === c ? "1" : c;
          }
        },
      },
    },
    cssNumber: {
      columnCount: !0,
      fillOpacity: !0,
      flexGrow: !0,
      flexShrink: !0,
      fontWeight: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
    },
    cssProps: { float: "cssFloat" },
    style: function (a, b, c, d) {
      if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {
        var e,
          f,
          g,
          h = n.camelCase(b),
          i = a.style;
        return (
          (b = n.cssProps[h] || (n.cssProps[h] = Fb(i, h))),
          (g = n.cssHooks[b] || n.cssHooks[h]),
          void 0 === c
            ? g && "get" in g && void 0 !== (e = g.get(a, !1, d))
              ? e
              : i[b]
            : ((f = typeof c),
              "string" === f &&
                (e = Bb.exec(c)) &&
                ((c = (e[1] + 1) * e[2] + parseFloat(n.css(a, b))),
                (f = "number")),
              null != c &&
                c === c &&
                ("number" !== f || n.cssNumber[h] || (c += "px"),
                k.clearCloneStyle ||
                  "" !== c ||
                  0 !== b.indexOf("background") ||
                  (i[b] = "inherit"),
                (g && "set" in g && void 0 === (c = g.set(a, c, d))) ||
                  (i[b] = c)),
              void 0)
        );
      }
    },
    css: function (a, b, c, d) {
      var e,
        f,
        g,
        h = n.camelCase(b);
      return (
        (b = n.cssProps[h] || (n.cssProps[h] = Fb(a.style, h))),
        (g = n.cssHooks[b] || n.cssHooks[h]),
        g && "get" in g && (e = g.get(a, !0, c)),
        void 0 === e && (e = xb(a, b, d)),
        "normal" === e && b in Db && (e = Db[b]),
        "" === c || c
          ? ((f = parseFloat(e)), c === !0 || n.isNumeric(f) ? f || 0 : e)
          : e
      );
    },
  }),
    n.each(["height", "width"], function (a, b) {
      n.cssHooks[b] = {
        get: function (a, c, d) {
          return c
            ? zb.test(n.css(a, "display")) && 0 === a.offsetWidth
              ? n.swap(a, Cb, function () {
                  return Ib(a, b, d);
                })
              : Ib(a, b, d)
            : void 0;
        },
        set: function (a, c, d) {
          var e = d && wb(a);
          return Gb(
            a,
            c,
            d
              ? Hb(a, b, d, "border-box" === n.css(a, "boxSizing", !1, e), e)
              : 0
          );
        },
      };
    }),
    (n.cssHooks.marginRight = yb(k.reliableMarginRight, function (a, b) {
      return b
        ? n.swap(a, { display: "inline-block" }, xb, [a, "marginRight"])
        : void 0;
    })),
    n.each({ margin: "", padding: "", border: "Width" }, function (a, b) {
      (n.cssHooks[a + b] = {
        expand: function (c) {
          for (
            var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [c];
            4 > d;
            d++
          )
            e[a + R[d] + b] = f[d] || f[d - 2] || f[0];
          return e;
        },
      }),
        ub.test(a) || (n.cssHooks[a + b].set = Gb);
    }),
    n.fn.extend({
      css: function (a, b) {
        return J(
          this,
          function (a, b, c) {
            var d,
              e,
              f = {},
              g = 0;
            if (n.isArray(b)) {
              for (d = wb(a), e = b.length; e > g; g++)
                f[b[g]] = n.css(a, b[g], !1, d);
              return f;
            }
            return void 0 !== c ? n.style(a, b, c) : n.css(a, b);
          },
          a,
          b,
          arguments.length > 1
        );
      },
      show: function () {
        return Jb(this, !0);
      },
      hide: function () {
        return Jb(this);
      },
      toggle: function (a) {
        return "boolean" == typeof a
          ? a
            ? this.show()
            : this.hide()
          : this.each(function () {
              S(this) ? n(this).show() : n(this).hide();
            });
      },
    });
  function Kb(a, b, c, d, e) {
    return new Kb.prototype.init(a, b, c, d, e);
  }
  (n.Tween = Kb),
    (Kb.prototype = {
      constructor: Kb,
      init: function (a, b, c, d, e, f) {
        (this.elem = a),
          (this.prop = c),
          (this.easing = e || "swing"),
          (this.options = b),
          (this.start = this.now = this.cur()),
          (this.end = d),
          (this.unit = f || (n.cssNumber[c] ? "" : "px"));
      },
      cur: function () {
        var a = Kb.propHooks[this.prop];
        return a && a.get ? a.get(this) : Kb.propHooks._default.get(this);
      },
      run: function (a) {
        var b,
          c = Kb.propHooks[this.prop];
        return (
          (this.pos = b =
            this.options.duration
              ? n.easing[this.easing](
                  a,
                  this.options.duration * a,
                  0,
                  1,
                  this.options.duration
                )
              : a),
          (this.now = (this.end - this.start) * b + this.start),
          this.options.step &&
            this.options.step.call(this.elem, this.now, this),
          c && c.set ? c.set(this) : Kb.propHooks._default.set(this),
          this
        );
      },
    }),
    (Kb.prototype.init.prototype = Kb.prototype),
    (Kb.propHooks = {
      _default: {
        get: function (a) {
          var b;
          return null == a.elem[a.prop] ||
            (a.elem.style && null != a.elem.style[a.prop])
            ? ((b = n.css(a.elem, a.prop, "")), b && "auto" !== b ? b : 0)
            : a.elem[a.prop];
        },
        set: function (a) {
          n.fx.step[a.prop]
            ? n.fx.step[a.prop](a)
            : a.elem.style &&
              (null != a.elem.style[n.cssProps[a.prop]] || n.cssHooks[a.prop])
            ? n.style(a.elem, a.prop, a.now + a.unit)
            : (a.elem[a.prop] = a.now);
        },
      },
    }),
    (Kb.propHooks.scrollTop = Kb.propHooks.scrollLeft =
      {
        set: function (a) {
          a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now);
        },
      }),
    (n.easing = {
      linear: function (a) {
        return a;
      },
      swing: function (a) {
        return 0.5 - Math.cos(a * Math.PI) / 2;
      },
    }),
    (n.fx = Kb.prototype.init),
    (n.fx.step = {});
  var Lb,
    Mb,
    Nb = /^(?:toggle|show|hide)$/,
    Ob = new RegExp("^(?:([+-])=|)(" + Q + ")([a-z%]*)$", "i"),
    Pb = /queueHooks$/,
    Qb = [Vb],
    Rb = {
      "*": [
        function (a, b) {
          var c = this.createTween(a, b),
            d = c.cur(),
            e = Ob.exec(b),
            f = (e && e[3]) || (n.cssNumber[a] ? "" : "px"),
            g =
              (n.cssNumber[a] || ("px" !== f && +d)) &&
              Ob.exec(n.css(c.elem, a)),
            h = 1,
            i = 20;
          if (g && g[3] !== f) {
            (f = f || g[3]), (e = e || []), (g = +d || 1);
            do (h = h || ".5"), (g /= h), n.style(c.elem, a, g + f);
            while (h !== (h = c.cur() / d) && 1 !== h && --i);
          }
          return (
            e &&
              ((g = c.start = +g || +d || 0),
              (c.unit = f),
              (c.end = e[1] ? g + (e[1] + 1) * e[2] : +e[2])),
            c
          );
        },
      ],
    };
  function Sb() {
    return (
      setTimeout(function () {
        Lb = void 0;
      }),
      (Lb = n.now())
    );
  }
  function Tb(a, b) {
    var c,
      d = 0,
      e = { height: a };
    for (b = b ? 1 : 0; 4 > d; d += 2 - b)
      (c = R[d]), (e["margin" + c] = e["padding" + c] = a);
    return b && (e.opacity = e.width = a), e;
  }
  function Ub(a, b, c) {
    for (
      var d, e = (Rb[b] || []).concat(Rb["*"]), f = 0, g = e.length;
      g > f;
      f++
    )
      if ((d = e[f].call(c, b, a))) return d;
  }
  function Vb(a, b, c) {
    var d,
      e,
      f,
      g,
      h,
      i,
      j,
      k,
      l = this,
      m = {},
      o = a.style,
      p = a.nodeType && S(a),
      q = L.get(a, "fxshow");
    c.queue ||
      ((h = n._queueHooks(a, "fx")),
      null == h.unqueued &&
        ((h.unqueued = 0),
        (i = h.empty.fire),
        (h.empty.fire = function () {
          h.unqueued || i();
        })),
      h.unqueued++,
      l.always(function () {
        l.always(function () {
          h.unqueued--, n.queue(a, "fx").length || h.empty.fire();
        });
      })),
      1 === a.nodeType &&
        ("height" in b || "width" in b) &&
        ((c.overflow = [o.overflow, o.overflowX, o.overflowY]),
        (j = n.css(a, "display")),
        (k = "none" === j ? L.get(a, "olddisplay") || tb(a.nodeName) : j),
        "inline" === k &&
          "none" === n.css(a, "float") &&
          (o.display = "inline-block")),
      c.overflow &&
        ((o.overflow = "hidden"),
        l.always(function () {
          (o.overflow = c.overflow[0]),
            (o.overflowX = c.overflow[1]),
            (o.overflowY = c.overflow[2]);
        }));
    for (d in b)
      if (((e = b[d]), Nb.exec(e))) {
        if (
          (delete b[d], (f = f || "toggle" === e), e === (p ? "hide" : "show"))
        ) {
          if ("show" !== e || !q || void 0 === q[d]) continue;
          p = !0;
        }
        m[d] = (q && q[d]) || n.style(a, d);
      } else j = void 0;
    if (n.isEmptyObject(m))
      "inline" === ("none" === j ? tb(a.nodeName) : j) && (o.display = j);
    else {
      q ? "hidden" in q && (p = q.hidden) : (q = L.access(a, "fxshow", {})),
        f && (q.hidden = !p),
        p
          ? n(a).show()
          : l.done(function () {
              n(a).hide();
            }),
        l.done(function () {
          var b;
          L.remove(a, "fxshow");
          for (b in m) n.style(a, b, m[b]);
        });
      for (d in m)
        (g = Ub(p ? q[d] : 0, d, l)),
          d in q ||
            ((q[d] = g.start),
            p &&
              ((g.end = g.start),
              (g.start = "width" === d || "height" === d ? 1 : 0)));
    }
  }
  function Wb(a, b) {
    var c, d, e, f, g;
    for (c in a)
      if (
        ((d = n.camelCase(c)),
        (e = b[d]),
        (f = a[c]),
        n.isArray(f) && ((e = f[1]), (f = a[c] = f[0])),
        c !== d && ((a[d] = f), delete a[c]),
        (g = n.cssHooks[d]),
        g && "expand" in g)
      ) {
        (f = g.expand(f)), delete a[d];
        for (c in f) c in a || ((a[c] = f[c]), (b[c] = e));
      } else b[d] = e;
  }
  function Xb(a, b, c) {
    var d,
      e,
      f = 0,
      g = Qb.length,
      h = n.Deferred().always(function () {
        delete i.elem;
      }),
      i = function () {
        if (e) return !1;
        for (
          var b = Lb || Sb(),
            c = Math.max(0, j.startTime + j.duration - b),
            d = c / j.duration || 0,
            f = 1 - d,
            g = 0,
            i = j.tweens.length;
          i > g;
          g++
        )
          j.tweens[g].run(f);
        return (
          h.notifyWith(a, [j, f, c]),
          1 > f && i ? c : (h.resolveWith(a, [j]), !1)
        );
      },
      j = h.promise({
        elem: a,
        props: n.extend({}, b),
        opts: n.extend(!0, { specialEasing: {} }, c),
        originalProperties: b,
        originalOptions: c,
        startTime: Lb || Sb(),
        duration: c.duration,
        tweens: [],
        createTween: function (b, c) {
          var d = n.Tween(
            a,
            j.opts,
            b,
            c,
            j.opts.specialEasing[b] || j.opts.easing
          );
          return j.tweens.push(d), d;
        },
        stop: function (b) {
          var c = 0,
            d = b ? j.tweens.length : 0;
          if (e) return this;
          for (e = !0; d > c; c++) j.tweens[c].run(1);
          return b ? h.resolveWith(a, [j, b]) : h.rejectWith(a, [j, b]), this;
        },
      }),
      k = j.props;
    for (Wb(k, j.opts.specialEasing); g > f; f++)
      if ((d = Qb[f].call(j, a, k, j.opts))) return d;
    return (
      n.map(k, Ub, j),
      n.isFunction(j.opts.start) && j.opts.start.call(a, j),
      n.fx.timer(n.extend(i, { elem: a, anim: j, queue: j.opts.queue })),
      j
        .progress(j.opts.progress)
        .done(j.opts.done, j.opts.complete)
        .fail(j.opts.fail)
        .always(j.opts.always)
    );
  }
  (n.Animation = n.extend(Xb, {
    tweener: function (a, b) {
      n.isFunction(a) ? ((b = a), (a = ["*"])) : (a = a.split(" "));
      for (var c, d = 0, e = a.length; e > d; d++)
        (c = a[d]), (Rb[c] = Rb[c] || []), Rb[c].unshift(b);
    },
    prefilter: function (a, b) {
      b ? Qb.unshift(a) : Qb.push(a);
    },
  })),
    (n.speed = function (a, b, c) {
      var d =
        a && "object" == typeof a
          ? n.extend({}, a)
          : {
              complete: c || (!c && b) || (n.isFunction(a) && a),
              duration: a,
              easing: (c && b) || (b && !n.isFunction(b) && b),
            };
      return (
        (d.duration = n.fx.off
          ? 0
          : "number" == typeof d.duration
          ? d.duration
          : d.duration in n.fx.speeds
          ? n.fx.speeds[d.duration]
          : n.fx.speeds._default),
        (null == d.queue || d.queue === !0) && (d.queue = "fx"),
        (d.old = d.complete),
        (d.complete = function () {
          n.isFunction(d.old) && d.old.call(this),
            d.queue && n.dequeue(this, d.queue);
        }),
        d
      );
    }),
    n.fn.extend({
      fadeTo: function (a, b, c, d) {
        return this.filter(S)
          .css("opacity", 0)
          .show()
          .end()
          .animate({ opacity: b }, a, c, d);
      },
      animate: function (a, b, c, d) {
        var e = n.isEmptyObject(a),
          f = n.speed(b, c, d),
          g = function () {
            var b = Xb(this, n.extend({}, a), f);
            (e || L.get(this, "finish")) && b.stop(!0);
          };
        return (
          (g.finish = g),
          e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g)
        );
      },
      stop: function (a, b, c) {
        var d = function (a) {
          var b = a.stop;
          delete a.stop, b(c);
        };
        return (
          "string" != typeof a && ((c = b), (b = a), (a = void 0)),
          b && a !== !1 && this.queue(a || "fx", []),
          this.each(function () {
            var b = !0,
              e = null != a && a + "queueHooks",
              f = n.timers,
              g = L.get(this);
            if (e) g[e] && g[e].stop && d(g[e]);
            else for (e in g) g[e] && g[e].stop && Pb.test(e) && d(g[e]);
            for (e = f.length; e--; )
              f[e].elem !== this ||
                (null != a && f[e].queue !== a) ||
                (f[e].anim.stop(c), (b = !1), f.splice(e, 1));
            (b || !c) && n.dequeue(this, a);
          })
        );
      },
      finish: function (a) {
        return (
          a !== !1 && (a = a || "fx"),
          this.each(function () {
            var b,
              c = L.get(this),
              d = c[a + "queue"],
              e = c[a + "queueHooks"],
              f = n.timers,
              g = d ? d.length : 0;
            for (
              c.finish = !0,
                n.queue(this, a, []),
                e && e.stop && e.stop.call(this, !0),
                b = f.length;
              b--;

            )
              f[b].elem === this &&
                f[b].queue === a &&
                (f[b].anim.stop(!0), f.splice(b, 1));
            for (b = 0; g > b; b++)
              d[b] && d[b].finish && d[b].finish.call(this);
            delete c.finish;
          })
        );
      },
    }),
    n.each(["toggle", "show", "hide"], function (a, b) {
      var c = n.fn[b];
      n.fn[b] = function (a, d, e) {
        return null == a || "boolean" == typeof a
          ? c.apply(this, arguments)
          : this.animate(Tb(b, !0), a, d, e);
      };
    }),
    n.each(
      {
        slideDown: Tb("show"),
        slideUp: Tb("hide"),
        slideToggle: Tb("toggle"),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" },
        fadeToggle: { opacity: "toggle" },
      },
      function (a, b) {
        n.fn[a] = function (a, c, d) {
          return this.animate(b, a, c, d);
        };
      }
    ),
    (n.timers = []),
    (n.fx.tick = function () {
      var a,
        b = 0,
        c = n.timers;
      for (Lb = n.now(); b < c.length; b++)
        (a = c[b]), a() || c[b] !== a || c.splice(b--, 1);
      c.length || n.fx.stop(), (Lb = void 0);
    }),
    (n.fx.timer = function (a) {
      n.timers.push(a), a() ? n.fx.start() : n.timers.pop();
    }),
    (n.fx.interval = 13),
    (n.fx.start = function () {
      Mb || (Mb = setInterval(n.fx.tick, n.fx.interval));
    }),
    (n.fx.stop = function () {
      clearInterval(Mb), (Mb = null);
    }),
    (n.fx.speeds = { slow: 600, fast: 200, _default: 400 }),
    (n.fn.delay = function (a, b) {
      return (
        (a = n.fx ? n.fx.speeds[a] || a : a),
        (b = b || "fx"),
        this.queue(b, function (b, c) {
          var d = setTimeout(b, a);
          c.stop = function () {
            clearTimeout(d);
          };
        })
      );
    }),
    (function () {
      var a = l.createElement("input"),
        b = l.createElement("select"),
        c = b.appendChild(l.createElement("option"));
      (a.type = "checkbox"),
        (k.checkOn = "" !== a.value),
        (k.optSelected = c.selected),
        (b.disabled = !0),
        (k.optDisabled = !c.disabled),
        (a = l.createElement("input")),
        (a.value = "t"),
        (a.type = "radio"),
        (k.radioValue = "t" === a.value);
    })();
  var Yb,
    Zb,
    $b = n.expr.attrHandle;
  n.fn.extend({
    attr: function (a, b) {
      return J(this, n.attr, a, b, arguments.length > 1);
    },
    removeAttr: function (a) {
      return this.each(function () {
        n.removeAttr(this, a);
      });
    },
  }),
    n.extend({
      attr: function (a, b, c) {
        var d,
          e,
          f = a.nodeType;
        if (a && 3 !== f && 8 !== f && 2 !== f)
          return typeof a.getAttribute === U
            ? n.prop(a, b, c)
            : ((1 === f && n.isXMLDoc(a)) ||
                ((b = b.toLowerCase()),
                (d = n.attrHooks[b] || (n.expr.match.bool.test(b) ? Zb : Yb))),
              void 0 === c
                ? d && "get" in d && null !== (e = d.get(a, b))
                  ? e
                  : ((e = n.find.attr(a, b)), null == e ? void 0 : e)
                : null !== c
                ? d && "set" in d && void 0 !== (e = d.set(a, c, b))
                  ? e
                  : (a.setAttribute(b, c + ""), c)
                : void n.removeAttr(a, b));
      },
      removeAttr: function (a, b) {
        var c,
          d,
          e = 0,
          f = b && b.match(E);
        if (f && 1 === a.nodeType)
          while ((c = f[e++]))
            (d = n.propFix[c] || c),
              n.expr.match.bool.test(c) && (a[d] = !1),
              a.removeAttribute(c);
      },
      attrHooks: {
        type: {
          set: function (a, b) {
            if (!k.radioValue && "radio" === b && n.nodeName(a, "input")) {
              var c = a.value;
              return a.setAttribute("type", b), c && (a.value = c), b;
            }
          },
        },
      },
    }),
    (Zb = {
      set: function (a, b, c) {
        return b === !1 ? n.removeAttr(a, c) : a.setAttribute(c, c), c;
      },
    }),
    n.each(n.expr.match.bool.source.match(/\w+/g), function (a, b) {
      var c = $b[b] || n.find.attr;
      $b[b] = function (a, b, d) {
        var e, f;
        return (
          d ||
            ((f = $b[b]),
            ($b[b] = e),
            (e = null != c(a, b, d) ? b.toLowerCase() : null),
            ($b[b] = f)),
          e
        );
      };
    });
  var _b = /^(?:input|select|textarea|button)$/i;
  n.fn.extend({
    prop: function (a, b) {
      return J(this, n.prop, a, b, arguments.length > 1);
    },
    removeProp: function (a) {
      return this.each(function () {
        delete this[n.propFix[a] || a];
      });
    },
  }),
    n.extend({
      propFix: { for: "htmlFor", class: "className" },
      prop: function (a, b, c) {
        var d,
          e,
          f,
          g = a.nodeType;
        if (a && 3 !== g && 8 !== g && 2 !== g)
          return (
            (f = 1 !== g || !n.isXMLDoc(a)),
            f && ((b = n.propFix[b] || b), (e = n.propHooks[b])),
            void 0 !== c
              ? e && "set" in e && void 0 !== (d = e.set(a, c, b))
                ? d
                : (a[b] = c)
              : e && "get" in e && null !== (d = e.get(a, b))
              ? d
              : a[b]
          );
      },
      propHooks: {
        tabIndex: {
          get: function (a) {
            return a.hasAttribute("tabindex") || _b.test(a.nodeName) || a.href
              ? a.tabIndex
              : -1;
          },
        },
      },
    }),
    k.optSelected ||
      (n.propHooks.selected = {
        get: function (a) {
          var b = a.parentNode;
          return b && b.parentNode && b.parentNode.selectedIndex, null;
        },
      }),
    n.each(
      [
        "tabIndex",
        "readOnly",
        "maxLength",
        "cellSpacing",
        "cellPadding",
        "rowSpan",
        "colSpan",
        "useMap",
        "frameBorder",
        "contentEditable",
      ],
      function () {
        n.propFix[this.toLowerCase()] = this;
      }
    );
  var ac = /[\t\r\n\f]/g;
  n.fn.extend({
    addClass: function (a) {
      var b,
        c,
        d,
        e,
        f,
        g,
        h = "string" == typeof a && a,
        i = 0,
        j = this.length;
      if (n.isFunction(a))
        return this.each(function (b) {
          n(this).addClass(a.call(this, b, this.className));
        });
      if (h)
        for (b = (a || "").match(E) || []; j > i; i++)
          if (
            ((c = this[i]),
            (d =
              1 === c.nodeType &&
              (c.className ? (" " + c.className + " ").replace(ac, " ") : " ")))
          ) {
            f = 0;
            while ((e = b[f++])) d.indexOf(" " + e + " ") < 0 && (d += e + " ");
            (g = n.trim(d)), c.className !== g && (c.className = g);
          }
      return this;
    },
    removeClass: function (a) {
      var b,
        c,
        d,
        e,
        f,
        g,
        h = 0 === arguments.length || ("string" == typeof a && a),
        i = 0,
        j = this.length;
      if (n.isFunction(a))
        return this.each(function (b) {
          n(this).removeClass(a.call(this, b, this.className));
        });
      if (h)
        for (b = (a || "").match(E) || []; j > i; i++)
          if (
            ((c = this[i]),
            (d =
              1 === c.nodeType &&
              (c.className ? (" " + c.className + " ").replace(ac, " ") : "")))
          ) {
            f = 0;
            while ((e = b[f++]))
              while (d.indexOf(" " + e + " ") >= 0)
                d = d.replace(" " + e + " ", " ");
            (g = a ? n.trim(d) : ""), c.className !== g && (c.className = g);
          }
      return this;
    },
    toggleClass: function (a, b) {
      var c = typeof a;
      return "boolean" == typeof b && "string" === c
        ? b
          ? this.addClass(a)
          : this.removeClass(a)
        : this.each(
            n.isFunction(a)
              ? function (c) {
                  n(this).toggleClass(a.call(this, c, this.className, b), b);
                }
              : function () {
                  if ("string" === c) {
                    var b,
                      d = 0,
                      e = n(this),
                      f = a.match(E) || [];
                    while ((b = f[d++]))
                      e.hasClass(b) ? e.removeClass(b) : e.addClass(b);
                  } else
                    (c === U || "boolean" === c) &&
                      (this.className &&
                        L.set(this, "__className__", this.className),
                      (this.className =
                        this.className || a === !1
                          ? ""
                          : L.get(this, "__className__") || ""));
                }
          );
    },
    hasClass: function (a) {
      for (var b = " " + a + " ", c = 0, d = this.length; d > c; c++)
        if (
          1 === this[c].nodeType &&
          (" " + this[c].className + " ").replace(ac, " ").indexOf(b) >= 0
        )
          return !0;
      return !1;
    },
  });
  var bc = /\r/g;
  n.fn.extend({
    val: function (a) {
      var b,
        c,
        d,
        e = this[0];
      {
        if (arguments.length)
          return (
            (d = n.isFunction(a)),
            this.each(function (c) {
              var e;
              1 === this.nodeType &&
                ((e = d ? a.call(this, c, n(this).val()) : a),
                null == e
                  ? (e = "")
                  : "number" == typeof e
                  ? (e += "")
                  : n.isArray(e) &&
                    (e = n.map(e, function (a) {
                      return null == a ? "" : a + "";
                    })),
                (b =
                  n.valHooks[this.type] ||
                  n.valHooks[this.nodeName.toLowerCase()]),
                (b && "set" in b && void 0 !== b.set(this, e, "value")) ||
                  (this.value = e));
            })
          );
        if (e)
          return (
            (b = n.valHooks[e.type] || n.valHooks[e.nodeName.toLowerCase()]),
            b && "get" in b && void 0 !== (c = b.get(e, "value"))
              ? c
              : ((c = e.value),
                "string" == typeof c ? c.replace(bc, "") : null == c ? "" : c)
          );
      }
    },
  }),
    n.extend({
      valHooks: {
        option: {
          get: function (a) {
            var b = n.find.attr(a, "value");
            return null != b ? b : n.trim(n.text(a));
          },
        },
        select: {
          get: function (a) {
            for (
              var b,
                c,
                d = a.options,
                e = a.selectedIndex,
                f = "select-one" === a.type || 0 > e,
                g = f ? null : [],
                h = f ? e + 1 : d.length,
                i = 0 > e ? h : f ? e : 0;
              h > i;
              i++
            )
              if (
                ((c = d[i]),
                !(
                  (!c.selected && i !== e) ||
                  (k.optDisabled
                    ? c.disabled
                    : null !== c.getAttribute("disabled")) ||
                  (c.parentNode.disabled &&
                    n.nodeName(c.parentNode, "optgroup"))
                ))
              ) {
                if (((b = n(c).val()), f)) return b;
                g.push(b);
              }
            return g;
          },
          set: function (a, b) {
            var c,
              d,
              e = a.options,
              f = n.makeArray(b),
              g = e.length;
            while (g--)
              (d = e[g]), (d.selected = n.inArray(d.value, f) >= 0) && (c = !0);
            return c || (a.selectedIndex = -1), f;
          },
        },
      },
    }),
    n.each(["radio", "checkbox"], function () {
      (n.valHooks[this] = {
        set: function (a, b) {
          return n.isArray(b)
            ? (a.checked = n.inArray(n(a).val(), b) >= 0)
            : void 0;
        },
      }),
        k.checkOn ||
          (n.valHooks[this].get = function (a) {
            return null === a.getAttribute("value") ? "on" : a.value;
          });
    }),
    n.each(
      "blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(
        " "
      ),
      function (a, b) {
        n.fn[b] = function (a, c) {
          return arguments.length > 0
            ? this.on(b, null, a, c)
            : this.trigger(b);
        };
      }
    ),
    n.fn.extend({
      hover: function (a, b) {
        return this.mouseenter(a).mouseleave(b || a);
      },
      bind: function (a, b, c) {
        return this.on(a, null, b, c);
      },
      unbind: function (a, b) {
        return this.off(a, null, b);
      },
      delegate: function (a, b, c, d) {
        return this.on(b, a, c, d);
      },
      undelegate: function (a, b, c) {
        return 1 === arguments.length
          ? this.off(a, "**")
          : this.off(b, a || "**", c);
      },
    });
  var cc = n.now(),
    dc = /\?/;
  (n.parseJSON = function (a) {
    return JSON.parse(a + "");
  }),
    (n.parseXML = function (a) {
      var b, c;
      if (!a || "string" != typeof a) return null;
      try {
        (c = new DOMParser()), (b = c.parseFromString(a, "text/xml"));
      } catch (d) {
        b = void 0;
      }
      return (
        (!b || b.getElementsByTagName("parsererror").length) &&
          n.error("Invalid XML: " + a),
        b
      );
    });
  var ec = /#.*$/,
    fc = /([?&])_=[^&]*/,
    gc = /^(.*?):[ \t]*([^\r\n]*)$/gm,
    hc = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
    ic = /^(?:GET|HEAD)$/,
    jc = /^\/\//,
    kc = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
    lc = {},
    mc = {},
    nc = "*/".concat("*"),
    oc = a.location.href,
    pc = kc.exec(oc.toLowerCase()) || [];
  function qc(a) {
    return function (b, c) {
      "string" != typeof b && ((c = b), (b = "*"));
      var d,
        e = 0,
        f = b.toLowerCase().match(E) || [];
      if (n.isFunction(c))
        while ((d = f[e++]))
          "+" === d[0]
            ? ((d = d.slice(1) || "*"), (a[d] = a[d] || []).unshift(c))
            : (a[d] = a[d] || []).push(c);
    };
  }
  function rc(a, b, c, d) {
    var e = {},
      f = a === mc;
    function g(h) {
      var i;
      return (
        (e[h] = !0),
        n.each(a[h] || [], function (a, h) {
          var j = h(b, c, d);
          return "string" != typeof j || f || e[j]
            ? f
              ? !(i = j)
              : void 0
            : (b.dataTypes.unshift(j), g(j), !1);
        }),
        i
      );
    }
    return g(b.dataTypes[0]) || (!e["*"] && g("*"));
  }
  function sc(a, b) {
    var c,
      d,
      e = n.ajaxSettings.flatOptions || {};
    for (c in b) void 0 !== b[c] && ((e[c] ? a : d || (d = {}))[c] = b[c]);
    return d && n.extend(!0, a, d), a;
  }
  function tc(a, b, c) {
    var d,
      e,
      f,
      g,
      h = a.contents,
      i = a.dataTypes;
    while ("*" === i[0])
      i.shift(),
        void 0 === d && (d = a.mimeType || b.getResponseHeader("Content-Type"));
    if (d)
      for (e in h)
        if (h[e] && h[e].test(d)) {
          i.unshift(e);
          break;
        }
    if (i[0] in c) f = i[0];
    else {
      for (e in c) {
        if (!i[0] || a.converters[e + " " + i[0]]) {
          f = e;
          break;
        }
        g || (g = e);
      }
      f = f || g;
    }
    return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0;
  }
  function uc(a, b, c, d) {
    var e,
      f,
      g,
      h,
      i,
      j = {},
      k = a.dataTypes.slice();
    if (k[1]) for (g in a.converters) j[g.toLowerCase()] = a.converters[g];
    f = k.shift();
    while (f)
      if (
        (a.responseFields[f] && (c[a.responseFields[f]] = b),
        !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)),
        (i = f),
        (f = k.shift()))
      )
        if ("*" === f) f = i;
        else if ("*" !== i && i !== f) {
          if (((g = j[i + " " + f] || j["* " + f]), !g))
            for (e in j)
              if (
                ((h = e.split(" ")),
                h[1] === f && (g = j[i + " " + h[0]] || j["* " + h[0]]))
              ) {
                g === !0
                  ? (g = j[e])
                  : j[e] !== !0 && ((f = h[0]), k.unshift(h[1]));
                break;
              }
          if (g !== !0)
            if (g && a["throws"]) b = g(b);
            else
              try {
                b = g(b);
              } catch (l) {
                return {
                  state: "parsererror",
                  error: g ? l : "No conversion from " + i + " to " + f,
                };
              }
        }
    return { state: "success", data: b };
  }
  n.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: oc,
      type: "GET",
      isLocal: hc.test(pc[1]),
      global: !0,
      processData: !0,
      async: !0,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": nc,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript",
      },
      contents: { xml: /xml/, html: /html/, json: /json/ },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON",
      },
      converters: {
        "* text": String,
        "text html": !0,
        "text json": n.parseJSON,
        "text xml": n.parseXML,
      },
      flatOptions: { url: !0, context: !0 },
    },
    ajaxSetup: function (a, b) {
      return b ? sc(sc(a, n.ajaxSettings), b) : sc(n.ajaxSettings, a);
    },
    ajaxPrefilter: qc(lc),
    ajaxTransport: qc(mc),
    ajax: function (a, b) {
      "object" == typeof a && ((b = a), (a = void 0)), (b = b || {});
      var c,
        d,
        e,
        f,
        g,
        h,
        i,
        j,
        k = n.ajaxSetup({}, b),
        l = k.context || k,
        m = k.context && (l.nodeType || l.jquery) ? n(l) : n.event,
        o = n.Deferred(),
        p = n.Callbacks("once memory"),
        q = k.statusCode || {},
        r = {},
        s = {},
        t = 0,
        u = "canceled",
        v = {
          readyState: 0,
          getResponseHeader: function (a) {
            var b;
            if (2 === t) {
              if (!f) {
                f = {};
                while ((b = gc.exec(e))) f[b[1].toLowerCase()] = b[2];
              }
              b = f[a.toLowerCase()];
            }
            return null == b ? null : b;
          },
          getAllResponseHeaders: function () {
            return 2 === t ? e : null;
          },
          setRequestHeader: function (a, b) {
            var c = a.toLowerCase();
            return t || ((a = s[c] = s[c] || a), (r[a] = b)), this;
          },
          overrideMimeType: function (a) {
            return t || (k.mimeType = a), this;
          },
          statusCode: function (a) {
            var b;
            if (a)
              if (2 > t) for (b in a) q[b] = [q[b], a[b]];
              else v.always(a[v.status]);
            return this;
          },
          abort: function (a) {
            var b = a || u;
            return c && c.abort(b), x(0, b), this;
          },
        };
      if (
        ((o.promise(v).complete = p.add),
        (v.success = v.done),
        (v.error = v.fail),
        (k.url = ((a || k.url || oc) + "")
          .replace(ec, "")
          .replace(jc, pc[1] + "//")),
        (k.type = b.method || b.type || k.method || k.type),
        (k.dataTypes = n
          .trim(k.dataType || "*")
          .toLowerCase()
          .match(E) || [""]),
        null == k.crossDomain &&
          ((h = kc.exec(k.url.toLowerCase())),
          (k.crossDomain = !(
            !h ||
            (h[1] === pc[1] &&
              h[2] === pc[2] &&
              (h[3] || ("http:" === h[1] ? "80" : "443")) ===
                (pc[3] || ("http:" === pc[1] ? "80" : "443")))
          ))),
        k.data &&
          k.processData &&
          "string" != typeof k.data &&
          (k.data = n.param(k.data, k.traditional)),
        rc(lc, k, b, v),
        2 === t)
      )
        return v;
      (i = n.event && k.global),
        i && 0 === n.active++ && n.event.trigger("ajaxStart"),
        (k.type = k.type.toUpperCase()),
        (k.hasContent = !ic.test(k.type)),
        (d = k.url),
        k.hasContent ||
          (k.data &&
            ((d = k.url += (dc.test(d) ? "&" : "?") + k.data), delete k.data),
          k.cache === !1 &&
            (k.url = fc.test(d)
              ? d.replace(fc, "$1_=" + cc++)
              : d + (dc.test(d) ? "&" : "?") + "_=" + cc++)),
        k.ifModified &&
          (n.lastModified[d] &&
            v.setRequestHeader("If-Modified-Since", n.lastModified[d]),
          n.etag[d] && v.setRequestHeader("If-None-Match", n.etag[d])),
        ((k.data && k.hasContent && k.contentType !== !1) || b.contentType) &&
          v.setRequestHeader("Content-Type", k.contentType),
        v.setRequestHeader(
          "Accept",
          k.dataTypes[0] && k.accepts[k.dataTypes[0]]
            ? k.accepts[k.dataTypes[0]] +
                ("*" !== k.dataTypes[0] ? ", " + nc + "; q=0.01" : "")
            : k.accepts["*"]
        );
      for (j in k.headers) v.setRequestHeader(j, k.headers[j]);
      if (k.beforeSend && (k.beforeSend.call(l, v, k) === !1 || 2 === t))
        return v.abort();
      u = "abort";
      for (j in { success: 1, error: 1, complete: 1 }) v[j](k[j]);
      if ((c = rc(mc, k, b, v))) {
        (v.readyState = 1),
          i && m.trigger("ajaxSend", [v, k]),
          k.async &&
            k.timeout > 0 &&
            (g = setTimeout(function () {
              v.abort("timeout");
            }, k.timeout));
        try {
          (t = 1), c.send(r, x);
        } catch (w) {
          if (!(2 > t)) throw w;
          x(-1, w);
        }
      } else x(-1, "No Transport");
      function x(a, b, f, h) {
        var j,
          r,
          s,
          u,
          w,
          x = b;
        2 !== t &&
          ((t = 2),
          g && clearTimeout(g),
          (c = void 0),
          (e = h || ""),
          (v.readyState = a > 0 ? 4 : 0),
          (j = (a >= 200 && 300 > a) || 304 === a),
          f && (u = tc(k, v, f)),
          (u = uc(k, u, v, j)),
          j
            ? (k.ifModified &&
                ((w = v.getResponseHeader("Last-Modified")),
                w && (n.lastModified[d] = w),
                (w = v.getResponseHeader("etag")),
                w && (n.etag[d] = w)),
              204 === a || "HEAD" === k.type
                ? (x = "nocontent")
                : 304 === a
                ? (x = "notmodified")
                : ((x = u.state), (r = u.data), (s = u.error), (j = !s)))
            : ((s = x), (a || !x) && ((x = "error"), 0 > a && (a = 0))),
          (v.status = a),
          (v.statusText = (b || x) + ""),
          j ? o.resolveWith(l, [r, x, v]) : o.rejectWith(l, [v, x, s]),
          v.statusCode(q),
          (q = void 0),
          i && m.trigger(j ? "ajaxSuccess" : "ajaxError", [v, k, j ? r : s]),
          p.fireWith(l, [v, x]),
          i &&
            (m.trigger("ajaxComplete", [v, k]),
            --n.active || n.event.trigger("ajaxStop")));
      }
      return v;
    },
    getJSON: function (a, b, c) {
      return n.get(a, b, c, "json");
    },
    getScript: function (a, b) {
      return n.get(a, void 0, b, "script");
    },
  }),
    n.each(["get", "post"], function (a, b) {
      n[b] = function (a, c, d, e) {
        return (
          n.isFunction(c) && ((e = e || d), (d = c), (c = void 0)),
          n.ajax({ url: a, type: b, dataType: e, data: c, success: d })
        );
      };
    }),
    (n._evalUrl = function (a) {
      return n.ajax({
        url: a,
        type: "GET",
        dataType: "script",
        async: !1,
        global: !1,
        throws: !0,
      });
    }),
    n.fn.extend({
      wrapAll: function (a) {
        var b;
        return n.isFunction(a)
          ? this.each(function (b) {
              n(this).wrapAll(a.call(this, b));
            })
          : (this[0] &&
              ((b = n(a, this[0].ownerDocument).eq(0).clone(!0)),
              this[0].parentNode && b.insertBefore(this[0]),
              b
                .map(function () {
                  var a = this;
                  while (a.firstElementChild) a = a.firstElementChild;
                  return a;
                })
                .append(this)),
            this);
      },
      wrapInner: function (a) {
        return this.each(
          n.isFunction(a)
            ? function (b) {
                n(this).wrapInner(a.call(this, b));
              }
            : function () {
                var b = n(this),
                  c = b.contents();
                c.length ? c.wrapAll(a) : b.append(a);
              }
        );
      },
      wrap: function (a) {
        var b = n.isFunction(a);
        return this.each(function (c) {
          n(this).wrapAll(b ? a.call(this, c) : a);
        });
      },
      unwrap: function () {
        return this.parent()
          .each(function () {
            n.nodeName(this, "body") || n(this).replaceWith(this.childNodes);
          })
          .end();
      },
    }),
    (n.expr.filters.hidden = function (a) {
      return a.offsetWidth <= 0 && a.offsetHeight <= 0;
    }),
    (n.expr.filters.visible = function (a) {
      return !n.expr.filters.hidden(a);
    });
  var vc = /%20/g,
    wc = /\[\]$/,
    xc = /\r?\n/g,
    yc = /^(?:submit|button|image|reset|file)$/i,
    zc = /^(?:input|select|textarea|keygen)/i;
  function Ac(a, b, c, d) {
    var e;
    if (n.isArray(b))
      n.each(b, function (b, e) {
        c || wc.test(a)
          ? d(a, e)
          : Ac(a + "[" + ("object" == typeof e ? b : "") + "]", e, c, d);
      });
    else if (c || "object" !== n.type(b)) d(a, b);
    else for (e in b) Ac(a + "[" + e + "]", b[e], c, d);
  }
  (n.param = function (a, b) {
    var c,
      d = [],
      e = function (a, b) {
        (b = n.isFunction(b) ? b() : null == b ? "" : b),
          (d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(b));
      };
    if (
      (void 0 === b && (b = n.ajaxSettings && n.ajaxSettings.traditional),
      n.isArray(a) || (a.jquery && !n.isPlainObject(a)))
    )
      n.each(a, function () {
        e(this.name, this.value);
      });
    else for (c in a) Ac(c, a[c], b, e);
    return d.join("&").replace(vc, "+");
  }),
    n.fn.extend({
      serialize: function () {
        return n.param(this.serializeArray());
      },
      serializeArray: function () {
        return this.map(function () {
          var a = n.prop(this, "elements");
          return a ? n.makeArray(a) : this;
        })
          .filter(function () {
            var a = this.type;
            return (
              this.name &&
              !n(this).is(":disabled") &&
              zc.test(this.nodeName) &&
              !yc.test(a) &&
              (this.checked || !T.test(a))
            );
          })
          .map(function (a, b) {
            var c = n(this).val();
            return null == c
              ? null
              : n.isArray(c)
              ? n.map(c, function (a) {
                  return { name: b.name, value: a.replace(xc, "\r\n") };
                })
              : { name: b.name, value: c.replace(xc, "\r\n") };
          })
          .get();
      },
    }),
    (n.ajaxSettings.xhr = function () {
      try {
        return new XMLHttpRequest();
      } catch (a) {}
    });
  var Bc = 0,
    Cc = {},
    Dc = { 0: 200, 1223: 204 },
    Ec = n.ajaxSettings.xhr();
  a.attachEvent &&
    a.attachEvent("onunload", function () {
      for (var a in Cc) Cc[a]();
    }),
    (k.cors = !!Ec && "withCredentials" in Ec),
    (k.ajax = Ec = !!Ec),
    n.ajaxTransport(function (a) {
      var b;
      return k.cors || (Ec && !a.crossDomain)
        ? {
            send: function (c, d) {
              var e,
                f = a.xhr(),
                g = ++Bc;
              if (
                (f.open(a.type, a.url, a.async, a.username, a.password),
                a.xhrFields)
              )
                for (e in a.xhrFields) f[e] = a.xhrFields[e];
              a.mimeType &&
                f.overrideMimeType &&
                f.overrideMimeType(a.mimeType),
                a.crossDomain ||
                  c["X-Requested-With"] ||
                  (c["X-Requested-With"] = "XMLHttpRequest");
              for (e in c) f.setRequestHeader(e, c[e]);
              (b = function (a) {
                return function () {
                  b &&
                    (delete Cc[g],
                    (b = f.onload = f.onerror = null),
                    "abort" === a
                      ? f.abort()
                      : "error" === a
                      ? d(f.status, f.statusText)
                      : d(
                          Dc[f.status] || f.status,
                          f.statusText,
                          "string" == typeof f.responseText
                            ? { text: f.responseText }
                            : void 0,
                          f.getAllResponseHeaders()
                        ));
                };
              }),
                (f.onload = b()),
                (f.onerror = b("error")),
                (b = Cc[g] = b("abort"));
              try {
                f.send((a.hasContent && a.data) || null);
              } catch (h) {
                if (b) throw h;
              }
            },
            abort: function () {
              b && b();
            },
          }
        : void 0;
    }),
    n.ajaxSetup({
      accepts: {
        script:
          "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript",
      },
      contents: { script: /(?:java|ecma)script/ },
      converters: {
        "text script": function (a) {
          return n.globalEval(a), a;
        },
      },
    }),
    n.ajaxPrefilter("script", function (a) {
      void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = "GET");
    }),
    n.ajaxTransport("script", function (a) {
      if (a.crossDomain) {
        var b, c;
        return {
          send: function (d, e) {
            (b = n("<script>")
              .prop({ async: !0, charset: a.scriptCharset, src: a.url })
              .on(
                "load error",
                (c = function (a) {
                  b.remove(),
                    (c = null),
                    a && e("error" === a.type ? 404 : 200, a.type);
                })
              )),
              l.head.appendChild(b[0]);
          },
          abort: function () {
            c && c();
          },
        };
      }
    });
  var Fc = [],
    Gc = /(=)\?(?=&|$)|\?\?/;
  n.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function () {
      var a = Fc.pop() || n.expando + "_" + cc++;
      return (this[a] = !0), a;
    },
  }),
    n.ajaxPrefilter("json jsonp", function (b, c, d) {
      var e,
        f,
        g,
        h =
          b.jsonp !== !1 &&
          (Gc.test(b.url)
            ? "url"
            : "string" == typeof b.data &&
              !(b.contentType || "").indexOf(
                "application/x-www-form-urlencoded"
              ) &&
              Gc.test(b.data) &&
              "data");
      return h || "jsonp" === b.dataTypes[0]
        ? ((e = b.jsonpCallback =
            n.isFunction(b.jsonpCallback)
              ? b.jsonpCallback()
              : b.jsonpCallback),
          h
            ? (b[h] = b[h].replace(Gc, "$1" + e))
            : b.jsonp !== !1 &&
              (b.url += (dc.test(b.url) ? "&" : "?") + b.jsonp + "=" + e),
          (b.converters["script json"] = function () {
            return g || n.error(e + " was not called"), g[0];
          }),
          (b.dataTypes[0] = "json"),
          (f = a[e]),
          (a[e] = function () {
            g = arguments;
          }),
          d.always(function () {
            (a[e] = f),
              b[e] && ((b.jsonpCallback = c.jsonpCallback), Fc.push(e)),
              g && n.isFunction(f) && f(g[0]),
              (g = f = void 0);
          }),
          "script")
        : void 0;
    }),
    (n.parseHTML = function (a, b, c) {
      if (!a || "string" != typeof a) return null;
      "boolean" == typeof b && ((c = b), (b = !1)), (b = b || l);
      var d = v.exec(a),
        e = !c && [];
      return d
        ? [b.createElement(d[1])]
        : ((d = n.buildFragment([a], b, e)),
          e && e.length && n(e).remove(),
          n.merge([], d.childNodes));
    });
  var Hc = n.fn.load;
  (n.fn.load = function (a, b, c) {
    if ("string" != typeof a && Hc) return Hc.apply(this, arguments);
    var d,
      e,
      f,
      g = this,
      h = a.indexOf(" ");
    return (
      h >= 0 && ((d = n.trim(a.slice(h))), (a = a.slice(0, h))),
      n.isFunction(b)
        ? ((c = b), (b = void 0))
        : b && "object" == typeof b && (e = "POST"),
      g.length > 0 &&
        n
          .ajax({ url: a, type: e, dataType: "html", data: b })
          .done(function (a) {
            (f = arguments),
              g.html(d ? n("<div>").append(n.parseHTML(a)).find(d) : a);
          })
          .complete(
            c &&
              function (a, b) {
                g.each(c, f || [a.responseText, b, a]);
              }
          ),
      this
    );
  }),
    n.each(
      [
        "ajaxStart",
        "ajaxStop",
        "ajaxComplete",
        "ajaxError",
        "ajaxSuccess",
        "ajaxSend",
      ],
      function (a, b) {
        n.fn[b] = function (a) {
          return this.on(b, a);
        };
      }
    ),
    (n.expr.filters.animated = function (a) {
      return n.grep(n.timers, function (b) {
        return a === b.elem;
      }).length;
    });
  var Ic = a.document.documentElement;
  function Jc(a) {
    return n.isWindow(a) ? a : 9 === a.nodeType && a.defaultView;
  }
  (n.offset = {
    setOffset: function (a, b, c) {
      var d,
        e,
        f,
        g,
        h,
        i,
        j,
        k = n.css(a, "position"),
        l = n(a),
        m = {};
      "static" === k && (a.style.position = "relative"),
        (h = l.offset()),
        (f = n.css(a, "top")),
        (i = n.css(a, "left")),
        (j =
          ("absolute" === k || "fixed" === k) && (f + i).indexOf("auto") > -1),
        j
          ? ((d = l.position()), (g = d.top), (e = d.left))
          : ((g = parseFloat(f) || 0), (e = parseFloat(i) || 0)),
        n.isFunction(b) && (b = b.call(a, c, h)),
        null != b.top && (m.top = b.top - h.top + g),
        null != b.left && (m.left = b.left - h.left + e),
        "using" in b ? b.using.call(a, m) : l.css(m);
    },
  }),
    n.fn.extend({
      offset: function (a) {
        if (arguments.length)
          return void 0 === a
            ? this
            : this.each(function (b) {
                n.offset.setOffset(this, a, b);
              });
        var b,
          c,
          d = this[0],
          e = { top: 0, left: 0 },
          f = d && d.ownerDocument;
        if (f)
          return (
            (b = f.documentElement),
            n.contains(b, d)
              ? (typeof d.getBoundingClientRect !== U &&
                  (e = d.getBoundingClientRect()),
                (c = Jc(f)),
                {
                  top: e.top + c.pageYOffset - b.clientTop,
                  left: e.left + c.pageXOffset - b.clientLeft,
                })
              : e
          );
      },
      position: function () {
        if (this[0]) {
          var a,
            b,
            c = this[0],
            d = { top: 0, left: 0 };
          return (
            "fixed" === n.css(c, "position")
              ? (b = c.getBoundingClientRect())
              : ((a = this.offsetParent()),
                (b = this.offset()),
                n.nodeName(a[0], "html") || (d = a.offset()),
                (d.top += n.css(a[0], "borderTopWidth", !0)),
                (d.left += n.css(a[0], "borderLeftWidth", !0))),
            {
              top: b.top - d.top - n.css(c, "marginTop", !0),
              left: b.left - d.left - n.css(c, "marginLeft", !0),
            }
          );
        }
      },
      offsetParent: function () {
        return this.map(function () {
          var a = this.offsetParent || Ic;
          while (
            a &&
            !n.nodeName(a, "html") &&
            "static" === n.css(a, "position")
          )
            a = a.offsetParent;
          return a || Ic;
        });
      },
    }),
    n.each(
      { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" },
      function (b, c) {
        var d = "pageYOffset" === c;
        n.fn[b] = function (e) {
          return J(
            this,
            function (b, e, f) {
              var g = Jc(b);
              return void 0 === f
                ? g
                  ? g[c]
                  : b[e]
                : void (g
                    ? g.scrollTo(d ? a.pageXOffset : f, d ? f : a.pageYOffset)
                    : (b[e] = f));
            },
            b,
            e,
            arguments.length,
            null
          );
        };
      }
    ),
    n.each(["top", "left"], function (a, b) {
      n.cssHooks[b] = yb(k.pixelPosition, function (a, c) {
        return c
          ? ((c = xb(a, b)), vb.test(c) ? n(a).position()[b] + "px" : c)
          : void 0;
      });
    }),
    n.each({ Height: "height", Width: "width" }, function (a, b) {
      n.each(
        { padding: "inner" + a, content: b, "": "outer" + a },
        function (c, d) {
          n.fn[d] = function (d, e) {
            var f = arguments.length && (c || "boolean" != typeof d),
              g = c || (d === !0 || e === !0 ? "margin" : "border");
            return J(
              this,
              function (b, c, d) {
                var e;
                return n.isWindow(b)
                  ? b.document.documentElement["client" + a]
                  : 9 === b.nodeType
                  ? ((e = b.documentElement),
                    Math.max(
                      b.body["scroll" + a],
                      e["scroll" + a],
                      b.body["offset" + a],
                      e["offset" + a],
                      e["client" + a]
                    ))
                  : void 0 === d
                  ? n.css(b, c, g)
                  : n.style(b, c, d, g);
              },
              b,
              f ? d : void 0,
              f,
              null
            );
          };
        }
      );
    }),
    (n.fn.size = function () {
      return this.length;
    }),
    (n.fn.andSelf = n.fn.addBack),
    "function" == typeof define &&
      define.amd &&
      define("jquery", [], function () {
        return n;
      });
  var Kc = a.jQuery,
    Lc = a.$;
  return (
    (n.noConflict = function (b) {
      return a.$ === n && (a.$ = Lc), b && a.jQuery === n && (a.jQuery = Kc), n;
    }),
    typeof b === U && (a.jQuery = a.$ = n),
    n
  );
});

(function (root, factory) {
  if (typeof define === "function" && define.amd) {
    define([], factory);
  } else if (typeof exports === "object") {
    module.exports = factory();
  } else {
    root.loki = factory();
  }
})(this, function () {
  return (function () {
    "use strict";
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var Utils = {
      copyProperties: function (src, dest) {
        var prop;
        for (prop in src) {
          dest[prop] = src[prop];
        }
      },
      resolveTransformObject: function (subObj, params, depth) {
        var prop, pname;
        if (typeof depth !== "number") {
          depth = 0;
        }
        if (++depth >= 10) return subObj;
        for (prop in subObj) {
          if (
            typeof subObj[prop] === "string" &&
            subObj[prop].indexOf("[%lktxp]") === 0
          ) {
            pname = subObj[prop].substring(8);
            if (params.hasOwnProperty(pname)) {
              subObj[prop] = params[pname];
            }
          } else if (typeof subObj[prop] === "object") {
            subObj[prop] = Utils.resolveTransformObject(
              subObj[prop],
              params,
              depth
            );
          }
        }
        return subObj;
      },
      resolveTransformParams: function (transform, params) {
        var idx,
          clonedStep,
          resolvedTransform = [];
        if (typeof params === "undefined") return transform;
        for (idx = 0; idx < transform.length; idx++) {
          clonedStep = JSON.parse(JSON.stringify(transform[idx]));
          resolvedTransform.push(
            Utils.resolveTransformObject(clonedStep, params)
          );
        }
        return resolvedTransform;
      },
    };
    function ltHelper(prop1, prop2, equal) {
      var cv1, cv2;
      if (!prop1 || !prop2 || prop1 === true || prop2 === true) {
        if (
          (prop1 === true || prop1 === false) &&
          (prop2 === true || prop2 === false)
        ) {
          if (equal) {
            return prop1 === prop2;
          } else {
            if (prop1) {
              return false;
            } else {
              return prop2;
            }
          }
        }
        if (
          prop2 === undefined ||
          prop2 === null ||
          prop1 === true ||
          prop2 === false
        ) {
          return equal;
        }
        if (
          prop1 === undefined ||
          prop1 === null ||
          prop1 === false ||
          prop2 === true
        ) {
          return true;
        }
      }
      if (prop1 === prop2) {
        return equal;
      }
      if (prop1 < prop2) {
        return true;
      }
      if (prop1 > prop2) {
        return false;
      }
      cv1 = prop1.toString();
      cv2 = prop2.toString();
      if (cv1 == cv2) {
        return equal;
      }
      if (cv1 < cv2) {
        return true;
      }
      return false;
    }
    function gtHelper(prop1, prop2, equal) {
      var cv1, cv2;
      if (!prop1 || !prop2 || prop1 === true || prop2 === true) {
        if (
          (prop1 === true || prop1 === false) &&
          (prop2 === true || prop2 === false)
        ) {
          if (equal) {
            return prop1 === prop2;
          } else {
            if (prop1) {
              return !prop2;
            } else {
              return false;
            }
          }
        }
        if (
          prop1 === undefined ||
          prop1 === null ||
          prop1 === false ||
          prop2 === true
        ) {
          return equal;
        }
        if (
          prop2 === undefined ||
          prop2 === null ||
          prop1 === true ||
          prop2 === false
        ) {
          return true;
        }
      }
      if (prop1 === prop2) {
        return equal;
      }
      if (prop1 > prop2) {
        return true;
      }
      if (prop1 < prop2) {
        return false;
      }
      cv1 = prop1.toString();
      cv2 = prop2.toString();
      if (cv1 == cv2) {
        return equal;
      }
      if (cv1 > cv2) {
        return true;
      }
      return false;
    }
    function sortHelper(prop1, prop2, desc) {
      if (prop1 === prop2) {
        return 0;
      }
      if (ltHelper(prop1, prop2, false)) {
        return desc ? 1 : -1;
      }
      if (gtHelper(prop1, prop2, false)) {
        return desc ? -1 : 1;
      }
      return 0;
    }
    function compoundeval(properties, obj1, obj2) {
      var res = 0;
      var prop, field;
      for (var i = 0, len = properties.length; i < len; i++) {
        prop = properties[i];
        field = prop[0];
        res = sortHelper(obj1[field], obj2[field], prop[1]);
        if (res !== 0) {
          return res;
        }
      }
      return 0;
    }
    function dotSubScan(root, paths, fun, value, poffset) {
      var pathOffset = poffset || 0;
      var path = paths[pathOffset];
      if (
        root === undefined ||
        root === null ||
        !hasOwnProperty.call(root, path)
      ) {
        return false;
      }
      var valueFound = false;
      var element = root[path];
      if (pathOffset + 1 >= paths.length) {
        valueFound = fun(element, value);
      } else if (Array.isArray(element)) {
        for (var index = 0, len = element.length; index < len; index += 1) {
          valueFound = dotSubScan(
            element[index],
            paths,
            fun,
            value,
            pathOffset + 1
          );
          if (valueFound === true) {
            break;
          }
        }
      } else {
        valueFound = dotSubScan(element, paths, fun, value, pathOffset + 1);
      }
      return valueFound;
    }
    function containsCheckFn(a) {
      if (typeof a === "string" || Array.isArray(a)) {
        return function (b) {
          return a.indexOf(b) !== -1;
        };
      } else if (typeof a === "object" && a !== null) {
        return function (b) {
          return hasOwnProperty.call(a, b);
        };
      }
      return null;
    }
    function doQueryOp(val, op) {
      for (var p in op) {
        if (hasOwnProperty.call(op, p)) {
          return LokiOps[p](val, op[p]);
        }
      }
      return false;
    }
    var LokiOps = {
      $eq: function (a, b) {
        return a === b;
      },
      $aeq: function (a, b) {
        return a == b;
      },
      $ne: function (a, b) {
        if (b !== b) {
          return a === a;
        }
        return a !== b;
      },
      $dteq: function (a, b) {
        if (ltHelper(a, b, false)) {
          return false;
        }
        return !gtHelper(a, b, false);
      },
      $gt: function (a, b) {
        return gtHelper(a, b, false);
      },
      $gte: function (a, b) {
        return gtHelper(a, b, true);
      },
      $lt: function (a, b) {
        return ltHelper(a, b, false);
      },
      $lte: function (a, b) {
        return ltHelper(a, b, true);
      },
      $in: function (a, b) {
        return b.indexOf(a) !== -1;
      },
      $nin: function (a, b) {
        return b.indexOf(a) === -1;
      },
      $keyin: function (a, b) {
        return a in b;
      },
      $nkeyin: function (a, b) {
        return !(a in b);
      },
      $definedin: function (a, b) {
        return b[a] !== undefined;
      },
      $undefinedin: function (a, b) {
        return b[a] === undefined;
      },
      $regex: function (a, b) {
        return b.test(a);
      },
      $containsString: function (a, b) {
        return typeof a === "string" && a.indexOf(b) !== -1;
      },
      $containsNone: function (a, b) {
        return !LokiOps.$containsAny(a, b);
      },
      $containsAny: function (a, b) {
        var checkFn = containsCheckFn(a);
        if (checkFn !== null) {
          return Array.isArray(b) ? b.some(checkFn) : checkFn(b);
        }
        return false;
      },
      $contains: function (a, b) {
        var checkFn = containsCheckFn(a);
        if (checkFn !== null) {
          return Array.isArray(b) ? b.every(checkFn) : checkFn(b);
        }
        return false;
      },
      $type: function (a, b) {
        var type = typeof a;
        if (type === "object") {
          if (Array.isArray(a)) {
            type = "array";
          } else if (a instanceof Date) {
            type = "date";
          }
        }
        return typeof b !== "object" ? type === b : doQueryOp(type, b);
      },
      $size: function (a, b) {
        if (Array.isArray(a)) {
          return typeof b !== "object"
            ? a.length === b
            : doQueryOp(a.length, b);
        }
        return false;
      },
      $len: function (a, b) {
        if (typeof a === "string") {
          return typeof b !== "object"
            ? a.length === b
            : doQueryOp(a.length, b);
        }
        return false;
      },
      $where: function (a, b) {
        return b(a) === true;
      },
      $not: function (a, b) {
        return !doQueryOp(a, b);
      },
      $and: function (a, b) {
        for (var idx = 0, len = b.length; idx < len; idx += 1) {
          if (!doQueryOp(a, b[idx])) {
            return false;
          }
        }
        return true;
      },
      $or: function (a, b) {
        for (var idx = 0, len = b.length; idx < len; idx += 1) {
          if (doQueryOp(a, b[idx])) {
            return true;
          }
        }
        return false;
      },
    };
    var indexedOpsList = [
      "$eq",
      "$aeq",
      "$dteq",
      "$gt",
      "$gte",
      "$lt",
      "$lte",
      "$in",
    ];
    function clone(data, method) {
      var cloneMethod = method || "parse-stringify",
        cloned;
      switch (cloneMethod) {
        case "parse-stringify":
          cloned = JSON.parse(JSON.stringify(data));
          break;
        case "jquery-extend-deep":
          cloned = jQuery.extend(true, {}, data);
          break;
        case "shallow":
          cloned = Object.create(data.prototype || null);
          Object.keys(data).map(function (i) {
            cloned[i] = data[i];
          });
          break;
        default:
          break;
      }
      return cloned;
    }
    function cloneObjectArray(objarray, method) {
      var i,
        result = [];
      if (method == "parse-stringify") {
        return clone(objarray, method);
      }
      i = objarray.length - 1;
      for (; i <= 0; i--) {
        result.push(clone(objarray[i], method));
      }
      return result;
    }
    function localStorageAvailable() {
      try {
        return (
          window &&
          window.localStorage !== undefined &&
          window.localStorage !== null
        );
      } catch (e) {
        return false;
      }
    }
    function LokiEventEmitter() {}
    LokiEventEmitter.prototype.events = {};
    LokiEventEmitter.prototype.asyncListeners = false;
    LokiEventEmitter.prototype.on = function (eventName, listener) {
      var event;
      var self = this;
      if (Array.isArray(eventName)) {
        eventName.forEach(function (currentEventName) {
          self.on(currentEventName, listener);
        });
        return listener;
      }
      event = this.events[eventName];
      if (!event) {
        event = this.events[eventName] = [];
      }
      event.push(listener);
      return listener;
    };
    LokiEventEmitter.prototype.emit = function (eventName, data) {
      var self = this;
      if (eventName && this.events[eventName]) {
        this.events[eventName].forEach(function (listener) {
          if (self.asyncListeners) {
            setTimeout(function () {
              listener(data);
            }, 1);
          } else {
            listener(data);
          }
        });
      } else {
        throw new Error("No event " + eventName + " defined");
      }
    };
    LokiEventEmitter.prototype.addListener = LokiEventEmitter.prototype.on;
    LokiEventEmitter.prototype.removeListener = function (eventName, listener) {
      var self = this;
      if (Array.isArray(eventName)) {
        eventName.forEach(function (currentEventName) {
          self.removeListener(currentEventName, listen);
        });
      }
      if (this.events[eventName]) {
        var listeners = this.events[eventName];
        listeners.splice(listeners.indexOf(listener), 1);
      }
    };
    function Loki(filename, options) {
      this.filename = filename || "loki.db";
      this.collections = [];
      this.databaseVersion = 1.1;
      this.engineVersion = 1.1;
      this.autosave = false;
      this.autosaveInterval = 5e3;
      this.autosaveHandle = null;
      this.options = {};
      this.persistenceMethod = null;
      this.persistenceAdapter = null;
      this.verbose =
        options && options.hasOwnProperty("verbose") ? options.verbose : false;
      this.events = {
        init: [],
        loaded: [],
        flushChanges: [],
        close: [],
        changes: [],
        warning: [],
      };
      var getENV = function () {
        if (typeof window === "undefined") {
          return "NODEJS";
        }
        if (typeof global !== "undefined" && global.window) {
          return "NODEJS";
        }
        if (typeof document !== "undefined") {
          if (
            document.URL.indexOf("http://") === -1 &&
            document.URL.indexOf("https://") === -1
          ) {
            return "CORDOVA";
          }
          return "BROWSER";
        }
        return "CORDOVA";
      };
      if (options && options.hasOwnProperty("env")) {
        this.ENV = options.env;
      } else {
        this.ENV = getENV();
      }
      if (this.ENV === "undefined") {
        this.ENV = "NODEJS";
      }
      this.configureOptions(options, true);
      this.on("init", this.clearChanges);
    }
    Loki.prototype = new LokiEventEmitter();
    Loki.prototype.constructor = Loki;
    Loki.prototype.getIndexedAdapter = function () {
      var adapter;
      if (typeof require === "function") {
        adapter = require("./loki-indexed-adapter.js");
      }
      return adapter;
    };
    Loki.prototype.configureOptions = function (options, initialConfig) {
      var defaultPersistence = {
          NODEJS: "fs",
          BROWSER: "localStorage",
          CORDOVA: "localStorage",
        },
        persistenceMethods = {
          fs: LokiFsAdapter,
          localStorage: LokiLocalStorageAdapter,
        };
      this.options = {};
      this.persistenceMethod = null;
      this.persistenceAdapter = null;
      if (typeof options !== "undefined") {
        this.options = options;
        if (this.options.hasOwnProperty("persistenceMethod")) {
          if (
            typeof persistenceMethods[options.persistenceMethod] == "function"
          ) {
            this.persistenceMethod = options.persistenceMethod;
            this.persistenceAdapter = new persistenceMethods[
              options.persistenceMethod
            ]();
          }
        }
        if (this.options.hasOwnProperty("adapter")) {
          this.persistenceMethod = "adapter";
          this.persistenceAdapter = options.adapter;
          this.options.adapter = null;
        }
        if (options.autoload && initialConfig) {
          var self = this;
          setTimeout(function () {
            self.loadDatabase(options, options.autoloadCallback);
          }, 1);
        }
        if (this.options.hasOwnProperty("autosaveInterval")) {
          this.autosaveDisable();
          this.autosaveInterval = parseInt(this.options.autosaveInterval, 10);
        }
        if (this.options.hasOwnProperty("autosave") && this.options.autosave) {
          this.autosaveDisable();
          this.autosave = true;
          if (this.options.hasOwnProperty("autosaveCallback")) {
            this.autosaveEnable(options, options.autosaveCallback);
          } else {
            this.autosaveEnable();
          }
        }
      }
      if (!this.options.hasOwnProperty("serializationMethod")) {
        this.options.serializationMethod = "normal";
      }
      if (!this.options.hasOwnProperty("destructureDelimiter")) {
        this.options.destructureDelimiter = "$<\n";
      }
      if (this.persistenceAdapter === null) {
        this.persistenceMethod = defaultPersistence[this.ENV];
        if (this.persistenceMethod) {
          this.persistenceAdapter = new persistenceMethods[
            this.persistenceMethod
          ]();
        }
      }
    };
    Loki.prototype.copy = function (options) {
      var databaseCopy = new Loki(this.filename);
      var clen, idx;
      options = options || {};
      databaseCopy.loadJSONObject(this, { retainDirtyFlags: true });
      if (
        options.hasOwnProperty("removeNonSerializable") &&
        options.removeNonSerializable === true
      ) {
        databaseCopy.autosaveHandle = null;
        databaseCopy.persistenceAdapter = null;
        clen = databaseCopy.collections.length;
        for (idx = 0; idx < clen; idx++) {
          databaseCopy.collections[idx].constraints = null;
          databaseCopy.collections[idx].ttl = null;
        }
      }
      return databaseCopy;
    };
    Loki.prototype.anonym = function (docs, options) {
      var collection = new Collection("anonym", options);
      collection.insert(docs);
      if (this.verbose) collection.console = console;
      return collection;
    };
    Loki.prototype.addCollection = function (name, options) {
      var collection = new Collection(name, options);
      this.collections.push(collection);
      if (this.verbose) collection.console = console;
      return collection;
    };
    Loki.prototype.loadCollection = function (collection) {
      if (!collection.name) {
        throw new Error("Collection must have a name property to be loaded");
      }
      this.collections.push(collection);
    };
    Loki.prototype.getCollection = function (collectionName) {
      var i,
        len = this.collections.length;
      for (i = 0; i < len; i += 1) {
        if (this.collections[i].name === collectionName) {
          return this.collections[i];
        }
      }
      this.emit("warning", "collection " + collectionName + " not found");
      return null;
    };
    Loki.prototype.listCollections = function () {
      var i = this.collections.length,
        colls = [];
      while (i--) {
        colls.push({
          name: this.collections[i].name,
          type: this.collections[i].objType,
          count: this.collections[i].data.length,
        });
      }
      return colls;
    };
    Loki.prototype.removeCollection = function (collectionName) {
      var i,
        len = this.collections.length;
      for (i = 0; i < len; i += 1) {
        if (this.collections[i].name === collectionName) {
          var tmpcol = new Collection(collectionName, {});
          var curcol = this.collections[i];
          for (var prop in curcol) {
            if (curcol.hasOwnProperty(prop) && tmpcol.hasOwnProperty(prop)) {
              curcol[prop] = tmpcol[prop];
            }
          }
          this.collections.splice(i, 1);
          return;
        }
      }
    };
    Loki.prototype.getName = function () {
      return this.name;
    };
    Loki.prototype.serializeReplacer = function (key, value) {
      switch (key) {
        case "autosaveHandle":
        case "persistenceAdapter":
        case "constraints":
        case "ttl":
          return null;
        default:
          return value;
      }
    };
    Loki.prototype.serialize = function (options) {
      options = options || {};
      if (!options.hasOwnProperty("serializationMethod")) {
        options.serializationMethod = this.options.serializationMethod;
      }
      switch (options.serializationMethod) {
        case "normal":
          return JSON.stringify(this, this.serializeReplacer);
        case "pretty":
          return JSON.stringify(this, this.serializeReplacer, 2);
        case "destructured":
          return this.serializeDestructured();
        default:
          return JSON.stringify(this, this.serializeReplacer);
      }
    };
    Loki.prototype.toJson = Loki.prototype.serialize;
    Loki.prototype.serializeDestructured = function (options) {
      var idx, sidx, result, resultlen;
      var reconstruct = [];
      var dbcopy;
      options = options || {};
      if (!options.hasOwnProperty("partitioned")) {
        options.partitioned = false;
      }
      if (!options.hasOwnProperty("delimited")) {
        options.delimited = true;
      }
      if (!options.hasOwnProperty("delimiter")) {
        options.delimiter = this.options.destructureDelimiter;
      }
      if (
        options.partitioned === true &&
        options.hasOwnProperty("partition") &&
        options.partition >= 0
      ) {
        return this.serializeCollection({
          delimited: options.delimited,
          delimiter: options.delimiter,
          collectionIndex: options.partition,
        });
      }
      dbcopy = new Loki(this.filename);
      dbcopy.loadJSONObject(this);
      for (idx = 0; idx < dbcopy.collections.length; idx++) {
        dbcopy.collections[idx].data = [];
      }
      if (options.partitioned === true && options.partition === -1) {
        return dbcopy.serialize({ serializationMethod: "normal" });
      }
      reconstruct.push(dbcopy.serialize({ serializationMethod: "normal" }));
      dbcopy = null;
      for (idx = 0; idx < this.collections.length; idx++) {
        result = this.serializeCollection({
          delimited: options.delimited,
          delimiter: options.delimiter,
          collectionIndex: idx,
        });
        if (options.partitioned === false && options.delimited === false) {
          if (!Array.isArray(result)) {
            throw new Error(
              "a nondelimited, non partitioned collection serialization did not return an expected array"
            );
          }
          resultlen = result.length;
          for (sidx = 0; sidx < resultlen; sidx++) {
            reconstruct.push(result[sidx]);
            result[sidx] = null;
          }
          reconstruct.push("");
        } else {
          reconstruct.push(result);
        }
      }
      if (options.partitioned) {
        if (options.delimited) {
          return reconstruct;
        } else {
          return reconstruct;
        }
      } else {
        if (options.delimited) {
          reconstruct.push("");
          return reconstruct.join(options.delimiter);
        } else {
          reconstruct.push("");
          return reconstruct;
        }
      }
      reconstruct.push("");
      return reconstruct.join(delim);
    };
    Loki.prototype.serializeCollection = function (options) {
      var doccount,
        docidx,
        resultlines = [];
      options = options || {};
      if (!options.hasOwnProperty("delimited")) {
        options.delimited = true;
      }
      if (!options.hasOwnProperty("collectionIndex")) {
        throw new Error(
          "serializeCollection called without 'collectionIndex' option"
        );
      }
      doccount = this.collections[options.collectionIndex].data.length;
      resultlines = [];
      for (docidx = 0; docidx < doccount; docidx++) {
        resultlines.push(
          JSON.stringify(this.collections[options.collectionIndex].data[docidx])
        );
      }
      if (options.delimited) {
        resultlines.push("");
        return resultlines.join(options.delimiter);
      } else {
        return resultlines;
      }
    };
    Loki.prototype.deserializeDestructured = function (
      destructuredSource,
      options
    ) {
      var workarray = [];
      var len, cdb;
      var idx,
        collIndex = 0,
        collCount,
        lineIndex = 1,
        done = false;
      var currLine, currObject;
      options = options || {};
      if (!options.hasOwnProperty("partitioned")) {
        options.partitioned = false;
      }
      if (!options.hasOwnProperty("delimited")) {
        options.delimited = true;
      }
      if (!options.hasOwnProperty("delimiter")) {
        options.delimiter = this.options.destructureDelimiter;
      }
      if (options.partitioned) {
        if (options.hasOwnProperty("partition")) {
          if (options.partition === -1) {
            cdb = JSON.parse(destructuredSource[0]);
            return cdb;
          }
          return this.deserializeCollection(
            destructuredSource[options.partition + 1],
            options
          );
        }
        cdb = JSON.parse(destructuredSource[0]);
        collCount = cdb.collections.length;
        for (collIndex = 0; collIndex < collCount; collIndex++) {
          cdb.collections[collIndex].data = this.deserializeCollection(
            destructuredSource[collIndex + 1],
            options
          );
        }
        return cdb;
      }
      if (options.delimited) {
        workarray = destructuredSource.split(options.delimiter);
        destructuredSource = null;
        len = workarray.length;
        if (len === 0) {
          return null;
        }
      } else {
        workarray = destructuredSource;
      }
      cdb = JSON.parse(workarray[0]);
      collCount = cdb.collections.length;
      workarray[0] = null;
      while (!done) {
        currLine = workarray[lineIndex];
        if (workarray[lineIndex] === "") {
          if (++collIndex > collCount) {
            done = true;
          }
        } else {
          currObject = JSON.parse(workarray[lineIndex]);
          cdb.collections[collIndex].data.push(currObject);
        }
        workarray[lineIndex++] = null;
      }
      return cdb;
    };
    Loki.prototype.deserializeCollection = function (
      destructuredSource,
      options
    ) {
      var workarray = [];
      var idx, len;
      options = options || {};
      if (!options.hasOwnProperty("partitioned")) {
        options.partitioned = false;
      }
      if (!options.hasOwnProperty("delimited")) {
        options.delimited = true;
      }
      if (!options.hasOwnProperty("delimiter")) {
        options.delimiter = this.options.destructureDelimiter;
      }
      if (options.delimited) {
        workarray = destructuredSource.split(options.delimiter);
        workarray.pop();
      } else {
        workarray = destructuredSource;
      }
      len = workarray.length;
      for (idx = 0; idx < len; idx++) {
        workarray[idx] = JSON.parse(workarray[idx]);
      }
      return workarray;
    };
    Loki.prototype.loadJSON = function (serializedDb, options) {
      var dbObject;
      if (serializedDb.length === 0) {
        dbObject = {};
      } else {
        switch (this.options.serializationMethod) {
          case "normal":
          case "pretty":
            dbObject = JSON.parse(serializedDb);
            break;
          case "destructured":
            dbObject = this.deserializeDestructured(serializedDb);
            break;
          default:
            dbObject = JSON.parse(serializedDb);
            break;
        }
      }
      this.loadJSONObject(dbObject, options);
    };
    Loki.prototype.loadJSONObject = function (dbObject, options) {
      var i = 0,
        len = dbObject.collections ? dbObject.collections.length : 0,
        coll,
        copyColl,
        clen,
        j,
        loader,
        collObj;
      this.name = dbObject.name;
      this.databaseVersion = 1;
      if (dbObject.hasOwnProperty("databaseVersion")) {
        this.databaseVersion = dbObject.databaseVersion;
      }
      this.collections = [];
      function makeLoader(coll) {
        var collOptions = options[coll.name];
        var inflater;
        if (collOptions.proto) {
          inflater = collOptions.inflate || Utils.copyProperties;
          return function (data) {
            var collObj = new collOptions.proto();
            inflater(data, collObj);
            return collObj;
          };
        }
        return collOptions.inflate;
      }
      for (i; i < len; i += 1) {
        coll = dbObject.collections[i];
        copyColl = this.addCollection(coll.name);
        copyColl.adaptiveBinaryIndices = coll.hasOwnProperty(
          "adaptiveBinaryIndices"
        )
          ? coll.adaptiveBinaryIndices === true
          : false;
        copyColl.transactional = coll.transactional;
        copyColl.asyncListeners = coll.asyncListeners;
        copyColl.disableChangesApi = coll.disableChangesApi;
        copyColl.cloneObjects = coll.cloneObjects;
        copyColl.cloneMethod = coll.cloneMethod || "parse-stringify";
        copyColl.autoupdate = coll.autoupdate;
        if (options && options.retainDirtyFlags === true) {
          copyColl.dirty = coll.dirty;
        } else {
          copyColl.dirty = false;
        }
        clen = coll.data.length;
        j = 0;
        if (options && options.hasOwnProperty(coll.name)) {
          loader = makeLoader(coll);
          for (j; j < clen; j++) {
            collObj = loader(coll.data[j]);
            copyColl.data[j] = collObj;
            copyColl.addAutoUpdateObserver(collObj);
          }
        } else {
          for (j; j < clen; j++) {
            copyColl.data[j] = coll.data[j];
            copyColl.addAutoUpdateObserver(copyColl.data[j]);
          }
        }
        copyColl.maxId = coll.data.length === 0 ? 0 : coll.maxId;
        copyColl.idIndex = coll.idIndex;
        if (typeof coll.binaryIndices !== "undefined") {
          copyColl.binaryIndices = coll.binaryIndices;
        }
        if (typeof coll.transforms !== "undefined") {
          copyColl.transforms = coll.transforms;
        }
        copyColl.ensureId();
        copyColl.uniqueNames = [];
        if (coll.hasOwnProperty("uniqueNames")) {
          copyColl.uniqueNames = coll.uniqueNames;
          for (j = 0; j < copyColl.uniqueNames.length; j++) {
            copyColl.ensureUniqueIndex(copyColl.uniqueNames[j]);
          }
        }
        if (typeof coll.DynamicViews === "undefined") continue;
        for (var idx = 0; idx < coll.DynamicViews.length; idx++) {
          var colldv = coll.DynamicViews[idx];
          var dv = copyColl.addDynamicView(colldv.name, colldv.options);
          dv.resultdata = colldv.resultdata;
          dv.resultsdirty = colldv.resultsdirty;
          dv.filterPipeline = colldv.filterPipeline;
          dv.sortCriteria = colldv.sortCriteria;
          dv.sortFunction = null;
          dv.sortDirty = colldv.sortDirty;
          dv.resultset.filteredrows = colldv.resultset.filteredrows;
          dv.resultset.searchIsChained = colldv.resultset.searchIsChained;
          dv.resultset.filterInitialized = colldv.resultset.filterInitialized;
          dv.rematerialize({ removeWhereFilters: true });
        }
      }
    };
    Loki.prototype.close = function (callback) {
      if (this.autosave) {
        this.autosaveDisable();
        if (this.autosaveDirty()) {
          this.saveDatabase(callback);
          callback = undefined;
        }
      }
      if (callback) {
        this.on("close", callback);
      }
      this.emit("close");
    };
    Loki.prototype.generateChangesNotification = function (
      arrayOfCollectionNames
    ) {
      function getCollName(coll) {
        return coll.name;
      }
      var changes = [],
        selectedCollections =
          arrayOfCollectionNames || this.collections.map(getCollName);
      this.collections.forEach(function (coll) {
        if (selectedCollections.indexOf(getCollName(coll)) !== -1) {
          changes = changes.concat(coll.getChanges());
        }
      });
      return changes;
    };
    Loki.prototype.serializeChanges = function (collectionNamesArray) {
      return JSON.stringify(
        this.generateChangesNotification(collectionNamesArray)
      );
    };
    Loki.prototype.clearChanges = function () {
      this.collections.forEach(function (coll) {
        if (coll.flushChanges) {
          coll.flushChanges();
        }
      });
    };
    function LokiMemoryAdapter() {
      this.hashStore = {};
    }
    LokiMemoryAdapter.prototype.loadDatabase = function (dbname, callback) {
      if (this.hashStore.hasOwnProperty(dbname)) {
        callback(this.hashStore[dbname].value);
      } else {
        callback(
          new Error(
            "unable to load database, " +
              dbname +
              " was not found in memory adapter"
          )
        );
      }
    };
    LokiMemoryAdapter.prototype.saveDatabase = function (
      dbname,
      dbstring,
      callback
    ) {
      var saveCount = this.hashStore.hasOwnProperty(dbname)
        ? this.hashStore[dbname].savecount
        : 0;
      this.hashStore[dbname] = {
        savecount: saveCount + 1,
        lastsave: new Date(),
        value: dbstring,
      };
      callback();
    };
    function LokiPartitioningAdapter(adapter) {
      this.mode = "reference";
      this.adapter = null;
      if (adapter) {
        if (adapter.mode === "reference") {
          throw new Error(
            "LokiPartitioningAdapter cannot be instantiated with a reference mode adapter"
          );
        } else {
          this.adapter = adapter;
        }
      } else {
        throw new Error(
          "LokiPartitioningAdapter requires a (non-reference mode) adapter on construction"
        );
      }
    }
    LokiPartitioningAdapter.prototype.loadDatabase = function (
      dbname,
      callback
    ) {
      var self = this;
      this.adapter.loadDatabase(dbname, function (result) {
        if (typeof result !== "string") {
          callback(
            new Error(
              "LokiPartitioningAdapter received an unexpected response from inner adapter loadDatabase()"
            )
          );
        }
        var db = JSON.parse(result);
        var dbref = new Loki(dbname);
        dbref.loadJSONObject(db);
        db = null;
        var clen = dbref.collections.length;
        if (dbref.collections.length === 0) {
          callback(dbref);
          return;
        }
        self.loadNextPartition(dbname, dbref, 0, function () {
          callback(dbref);
        });
      });
    };
    LokiPartitioningAdapter.prototype.loadNextPartition = function (
      dbname,
      db,
      partition,
      callback
    ) {
      var keyname = dbname + "." + partition;
      var self = this;
      this.adapter.loadDatabase(keyname, function (result) {
        var data = db.deserializeCollection(result, {
          delimited: true,
          collectionIndex: partition,
        });
        db.collections[partition].data = data;
        if (++partition < db.collections.length) {
          self.loadNextPartition(dbname, db, partition, callback);
        } else {
          callback();
        }
      });
    };
    LokiPartitioningAdapter.prototype.exportDatabase = function (
      dbname,
      dbref,
      callback
    ) {
      var self = this;
      var idx,
        clen = dbref.collections.length;
      var dirtyPartitions = [-1];
      for (idx = 0; idx < clen; idx++) {
        if (dbref.collections[idx].dirty) {
          dirtyPartitions.push(idx);
        }
      }
      this.saveNextPartition(dbname, dbref, dirtyPartitions, function (err) {
        callback(err);
      });
    };
    LokiPartitioningAdapter.prototype.saveNextPartition = function (
      dbname,
      dbref,
      dirtyPartitions,
      callback
    ) {
      var self = this;
      var partition = dirtyPartitions.shift();
      var keyname = dbname + (partition === -1 ? "" : "." + partition);
      var result = dbref.serializeDestructured({
        partitioned: true,
        delimited: true,
        partition: partition,
      });
      this.adapter.saveDatabase(keyname, result, function (err) {
        if (err) {
          callback(err);
          return;
        }
        if (dirtyPartitions.length === 0) {
          callback(null);
        } else {
          self.saveNextPartition(dbname, dbref, dirtyPartitions, callback);
        }
      });
    };
    function LokiFsAdapter() {
      this.fs = require("fs");
    }
    LokiFsAdapter.prototype.loadDatabase = function loadDatabase(
      dbname,
      callback
    ) {
      var self = this;
      this.fs.stat(dbname, function (err, stats) {
        if (!err && stats.isFile()) {
          self.fs.readFile(
            dbname,
            { encoding: "utf8" },
            function readFileCallback(err, data) {
              if (err) {
                callback(new Error(err));
              } else {
                callback(data);
              }
            }
          );
        } else {
          callback(null);
        }
      });
    };
    LokiFsAdapter.prototype.saveDatabase = function saveDatabase(
      dbname,
      dbstring,
      callback
    ) {
      var self = this;
      var tmpdbname = dbname + "~";
      this.fs.writeFile(tmpdbname, dbstring, function writeFileCallback(err) {
        if (err) {
          callback(new Error(err));
        } else {
          self.fs.rename(tmpdbname, dbname, callback);
        }
      });
    };
    LokiFsAdapter.prototype.deleteDatabase = function deleteDatabase(
      dbname,
      callback
    ) {
      this.fs.unlink(dbname, function deleteDatabaseCallback(err) {
        if (err) {
          callback(new Error(err));
        } else {
          callback();
        }
      });
    };
    function LokiLocalStorageAdapter() {}
    LokiLocalStorageAdapter.prototype.loadDatabase = function loadDatabase(
      dbname,
      callback
    ) {
      if (localStorageAvailable()) {
        callback(localStorage.getItem(dbname));
      } else {
        callback(new Error("localStorage is not available"));
      }
    };
    LokiLocalStorageAdapter.prototype.saveDatabase = function saveDatabase(
      dbname,
      dbstring,
      callback
    ) {
      if (localStorageAvailable()) {
        localStorage.setItem(dbname, dbstring);
        callback(null);
      } else {
        callback(new Error("localStorage is not available"));
      }
    };
    LokiLocalStorageAdapter.prototype.deleteDatabase = function deleteDatabase(
      dbname,
      callback
    ) {
      if (localStorageAvailable()) {
        localStorage.removeItem(dbname);
        callback(null);
      } else {
        callback(new Error("localStorage is not available"));
      }
    };
    Loki.prototype.loadDatabase = function (options, callback) {
      var cFun =
          callback ||
          function (err, data) {
            if (err) {
              throw err;
            }
          },
        self = this;
      if (this.persistenceAdapter !== null) {
        this.persistenceAdapter.loadDatabase(
          this.filename,
          function loadDatabaseCallback(dbString) {
            if (typeof dbString === "string") {
              var parseSuccess = false;
              try {
                self.loadJSON(dbString, options || {});
                parseSuccess = true;
              } catch (err) {
                cFun(err);
              }
              if (parseSuccess) {
                cFun(null);
                self.emit("loaded", "database " + self.filename + " loaded");
              }
            } else {
              if (
                typeof dbString === "object" &&
                dbString !== null &&
                !(dbString instanceof Error)
              ) {
                self.loadJSONObject(dbString, options || {});
                cFun(null);
                self.emit("loaded", "database " + self.filename + " loaded");
              } else {
                cFun(dbString);
              }
            }
          }
        );
      } else {
        cFun(new Error("persistenceAdapter not configured"));
      }
    };
    Loki.prototype.saveDatabase = function (callback) {
      var cFun =
          callback ||
          function (err) {
            if (err) {
              throw err;
            }
            return;
          },
        self = this;
      if (this.persistenceAdapter !== null) {
        if (
          this.persistenceAdapter.mode === "reference" &&
          typeof this.persistenceAdapter.exportDatabase === "function"
        ) {
          this.persistenceAdapter.exportDatabase(
            this.filename,
            this.copy({ removeNonSerializable: true }),
            function exportDatabaseCallback(err) {
              self.autosaveClearFlags();
              cFun(err);
            }
          );
        } else {
          this.persistenceAdapter.saveDatabase(
            this.filename,
            self.serialize(),
            function saveDatabasecallback(err) {
              self.autosaveClearFlags();
              cFun(err);
            }
          );
        }
      } else {
        cFun(new Error("persistenceAdapter not configured"));
      }
    };
    Loki.prototype.save = Loki.prototype.saveDatabase;
    Loki.prototype.deleteDatabase = function (options, callback) {
      var cFun =
        callback ||
        function (err, data) {
          if (err) {
            throw err;
          }
        };
      if (this.persistenceAdapter !== null) {
        this.persistenceAdapter.deleteDatabase(
          this.filename,
          function deleteDatabaseCallback(err) {
            cFun(err);
          }
        );
      } else {
        cFun(new Error("persistenceAdapter not configured"));
      }
    };
    Loki.prototype.autosaveDirty = function () {
      for (var idx = 0; idx < this.collections.length; idx++) {
        if (this.collections[idx].dirty) {
          return true;
        }
      }
      return false;
    };
    Loki.prototype.autosaveClearFlags = function () {
      for (var idx = 0; idx < this.collections.length; idx++) {
        this.collections[idx].dirty = false;
      }
    };
    Loki.prototype.autosaveEnable = function (options, callback) {
      this.autosave = true;
      var delay = 5e3,
        self = this;
      if (
        typeof this.autosaveInterval !== "undefined" &&
        this.autosaveInterval !== null
      ) {
        delay = this.autosaveInterval;
      }
      this.autosaveHandle = setInterval(function autosaveHandleInterval() {
        if (self.autosaveDirty()) {
          self.saveDatabase(callback);
        }
      }, delay);
    };
    Loki.prototype.autosaveDisable = function () {
      if (
        typeof this.autosaveHandle !== "undefined" &&
        this.autosaveHandle !== null
      ) {
        clearInterval(this.autosaveHandle);
        this.autosaveHandle = null;
      }
    };
    function Resultset(collection, options) {
      options = options || {};
      options.queryObj = options.queryObj || null;
      options.queryFunc = options.queryFunc || null;
      options.firstOnly = options.firstOnly || false;
      this.collection = collection;
      this.searchIsChained = !options.queryObj && !options.queryFunc;
      this.filteredrows = [];
      this.filterInitialized = false;
      if (
        typeof options.queryObj !== "undefined" &&
        options.queryObj !== null
      ) {
        return this.find(options.queryObj, options.firstOnly);
      }
      if (
        typeof options.queryFunc !== "undefined" &&
        options.queryFunc !== null
      ) {
        return this.where(options.queryFunc);
      }
      return this;
    }
    Resultset.prototype.reset = function () {
      if (this.filteredrows.length > 0) {
        this.filteredrows = [];
      }
      this.filterInitialized = false;
      return this;
    };
    Resultset.prototype.toJSON = function () {
      var copy = this.copy();
      copy.collection = null;
      return copy;
    };
    Resultset.prototype.limit = function (qty) {
      if (
        this.searchIsChained &&
        !this.filterInitialized &&
        this.filteredrows.length === 0
      ) {
        this.filteredrows = this.collection.prepareFullDocIndex();
      }
      var rscopy = new Resultset(this.collection);
      rscopy.filteredrows = this.filteredrows.slice(0, qty);
      rscopy.filterInitialized = true;
      return rscopy;
    };
    Resultset.prototype.offset = function (pos) {
      if (
        this.searchIsChained &&
        !this.filterInitialized &&
        this.filteredrows.length === 0
      ) {
        this.filteredrows = this.collection.prepareFullDocIndex();
      }
      var rscopy = new Resultset(this.collection);
      rscopy.filteredrows = this.filteredrows.slice(pos);
      rscopy.filterInitialized = true;
      return rscopy;
    };
    Resultset.prototype.copy = function () {
      var result = new Resultset(this.collection);
      if (this.filteredrows.length > 0) {
        result.filteredrows = this.filteredrows.slice();
      }
      result.filterInitialized = this.filterInitialized;
      return result;
    };
    Resultset.prototype.branch = Resultset.prototype.copy;
    Resultset.prototype.transform = function (transform, parameters) {
      var idx,
        step,
        rs = this;
      if (typeof transform === "string") {
        if (this.collection.transforms.hasOwnProperty(transform)) {
          transform = this.collection.transforms[transform];
        }
      }
      if (typeof transform !== "object" || !Array.isArray(transform)) {
        throw new Error("Invalid transform");
      }
      if (typeof parameters !== "undefined") {
        transform = Utils.resolveTransformParams(transform, parameters);
      }
      for (idx = 0; idx < transform.length; idx++) {
        step = transform[idx];
        switch (step.type) {
          case "find":
            rs.find(step.value);
            break;
          case "where":
            rs.where(step.value);
            break;
          case "simplesort":
            rs.simplesort(step.property, step.desc);
            break;
          case "compoundsort":
            rs.compoundsort(step.value);
            break;
          case "sort":
            rs.sort(step.value);
            break;
          case "limit":
            rs = rs.limit(step.value);
            break;
          case "offset":
            rs = rs.offset(step.value);
            break;
          case "map":
            rs = rs.map(step.value);
            break;
          case "eqJoin":
            rs = rs.eqJoin(
              step.joinData,
              step.leftJoinKey,
              step.rightJoinKey,
              step.mapFun
            );
            break;
          case "mapReduce":
            rs = rs.mapReduce(step.mapFunction, step.reduceFunction);
            break;
          case "update":
            rs.update(step.value);
            break;
          case "remove":
            rs.remove();
            break;
          default:
            break;
        }
      }
      return rs;
    };
    Resultset.prototype.sort = function (comparefun) {
      if (
        this.searchIsChained &&
        !this.filterInitialized &&
        this.filteredrows.length === 0
      ) {
        this.filteredrows = this.collection.prepareFullDocIndex();
      }
      var wrappedComparer = (function (userComparer, data) {
        return function (a, b) {
          return userComparer(data[a], data[b]);
        };
      })(comparefun, this.collection.data);
      this.filteredrows.sort(wrappedComparer);
      return this;
    };
    Resultset.prototype.simplesort = function (propname, isdesc) {
      if (
        this.searchIsChained &&
        !this.filterInitialized &&
        this.filteredrows.length === 0
      ) {
        this.filteredrows = this.collection.prepareFullDocIndex();
      }
      if (typeof isdesc === "undefined") {
        isdesc = false;
      }
      var wrappedComparer = (function (prop, desc, data) {
        return function (a, b) {
          return sortHelper(data[a][prop], data[b][prop], desc);
        };
      })(propname, isdesc, this.collection.data);
      this.filteredrows.sort(wrappedComparer);
      return this;
    };
    Resultset.prototype.compoundsort = function (properties) {
      if (properties.length === 0) {
        throw new Error(
          "Invalid call to compoundsort, need at least one property"
        );
      }
      var prop;
      if (properties.length === 1) {
        prop = properties[0];
        if (Array.isArray(prop)) {
          return this.simplesort(prop[0], prop[1]);
        }
        return this.simplesort(prop, false);
      }
      for (var i = 0, len = properties.length; i < len; i += 1) {
        prop = properties[i];
        if (!Array.isArray(prop)) {
          properties[i] = [prop, false];
        }
      }
      if (
        this.searchIsChained &&
        !this.filterInitialized &&
        this.filteredrows.length === 0
      ) {
        this.filteredrows = this.collection.prepareFullDocIndex();
      }
      var wrappedComparer = (function (props, data) {
        return function (a, b) {
          return compoundeval(props, data[a], data[b]);
        };
      })(properties, this.collection.data);
      this.filteredrows.sort(wrappedComparer);
      return this;
    };
    Resultset.prototype.findOr = function (expressionArray) {
      var fr = null,
        fri = 0,
        frlen = 0,
        docset = [],
        idxset = [],
        idx = 0,
        origCount = this.count();
      for (var ei = 0, elen = expressionArray.length; ei < elen; ei++) {
        fr = this.branch().find(expressionArray[ei]).filteredrows;
        frlen = fr.length;
        if (frlen === origCount) {
          return this;
        }
        for (fri = 0; fri < frlen; fri++) {
          idx = fr[fri];
          if (idxset[idx] === undefined) {
            idxset[idx] = true;
            docset.push(idx);
          }
        }
      }
      this.filteredrows = docset;
      this.filterInitialized = true;
      return this;
    };
    Resultset.prototype.$or = Resultset.prototype.findOr;
    Resultset.prototype.findAnd = function (expressionArray) {
      for (var i = 0, len = expressionArray.length; i < len; i++) {
        if (this.count() === 0) {
          return this;
        }
        this.find(expressionArray[i]);
      }
      return this;
    };
    Resultset.prototype.$and = Resultset.prototype.findAnd;
    Resultset.prototype.find = function (query, firstOnly) {
      if (this.collection.data.length === 0) {
        if (this.searchIsChained) {
          this.filteredrows = [];
          this.filterInitialized = true;
          return this;
        }
        return [];
      }
      var queryObject = query || "getAll",
        p,
        property,
        queryObjectOp,
        operator,
        value,
        key,
        searchByIndex = false,
        result = [],
        index = null;
      firstOnly = firstOnly || false;
      if (typeof queryObject === "object") {
        for (p in queryObject) {
          if (hasOwnProperty.call(queryObject, p)) {
            property = p;
            queryObjectOp = queryObject[p];
            break;
          }
        }
      }
      if (!property || queryObject === "getAll") {
        if (firstOnly) {
          return this.collection.data.length > 0
            ? this.collection.data[0]
            : null;
        }
        return this.searchIsChained ? this : this.collection.data.slice();
      }
      if (property === "$and" || property === "$or") {
        if (this.searchIsChained) {
          this[property](queryObjectOp);
          if (firstOnly && this.filteredrows.length > 1) {
            this.filteredrows = this.filteredrows.slice(0, 1);
          }
          return this;
        } else {
          result = this.collection.chain()[property](queryObjectOp).data();
          if (firstOnly) {
            return result.length === 0 ? [] : result[0];
          }
          return result;
        }
      }
      if (
        queryObjectOp === null ||
        typeof queryObjectOp !== "object" ||
        queryObjectOp instanceof Date
      ) {
        operator = "$eq";
        value = queryObjectOp;
      } else if (typeof queryObjectOp === "object") {
        for (key in queryObjectOp) {
          if (hasOwnProperty.call(queryObjectOp, key)) {
            operator = key;
            value = queryObjectOp[key];
            break;
          }
        }
      } else {
        throw new Error("Do not know what you want to do.");
      }
      if (operator === "$regex") {
        if (Array.isArray(value)) {
          value = new RegExp(value[0], value[1]);
        } else if (!(value instanceof RegExp)) {
          value = new RegExp(value);
        }
      }
      var usingDotNotation = property.indexOf(".") !== -1;
      var doIndexCheck =
        !usingDotNotation && (!this.searchIsChained || !this.filterInitialized);
      if (
        doIndexCheck &&
        this.collection.binaryIndices[property] &&
        indexedOpsList.indexOf(operator) !== -1
      ) {
        if (this.collection.adaptiveBinaryIndices !== true) {
          this.collection.ensureIndex(property);
        }
        searchByIndex = true;
        index = this.collection.binaryIndices[property];
      }
      var fun = LokiOps[operator];
      var t = this.collection.data;
      var i = 0,
        len = 0;
      if (!this.searchIsChained) {
        if (!searchByIndex) {
          i = t.length;
          if (firstOnly) {
            if (usingDotNotation) {
              property = property.split(".");
              while (i--) {
                if (dotSubScan(t[i], property, fun, value)) {
                  return t[i];
                }
              }
            } else {
              while (i--) {
                if (fun(t[i][property], value)) {
                  return t[i];
                }
              }
            }
            return [];
          }
          if (usingDotNotation) {
            property = property.split(".");
            while (i--) {
              if (dotSubScan(t[i], property, fun, value)) {
                result.push(t[i]);
              }
            }
          } else {
            while (i--) {
              if (fun(t[i][property], value)) {
                result.push(t[i]);
              }
            }
          }
        } else {
          var seg = this.collection.calculateRange(operator, property, value);
          if (firstOnly) {
            if (seg[1] !== -1) {
              return t[index.values[seg[0]]];
            }
            return [];
          }
          if (operator !== "$in") {
            for (i = seg[0]; i <= seg[1]; i++) {
              result.push(t[index.values[i]]);
            }
          } else {
            for (i = 0, len = seg.length; i < len; i++) {
              result.push(t[index.values[seg[i]]]);
            }
          }
        }
        return result;
      }
      var filter,
        rowIdx = 0;
      if (this.filterInitialized) {
        filter = this.filteredrows;
        i = filter.length;
        if (usingDotNotation) {
          property = property.split(".");
          while (i--) {
            rowIdx = filter[i];
            if (dotSubScan(t[rowIdx], property, fun, value)) {
              result.push(rowIdx);
            }
          }
        } else {
          while (i--) {
            rowIdx = filter[i];
            if (fun(t[rowIdx][property], value)) {
              result.push(rowIdx);
            }
          }
        }
      } else {
        if (!searchByIndex) {
          i = t.length;
          if (usingDotNotation) {
            property = property.split(".");
            while (i--) {
              if (dotSubScan(t[i], property, fun, value)) {
                result.push(i);
              }
            }
          } else {
            while (i--) {
              if (fun(t[i][property], value)) {
                result.push(i);
              }
            }
          }
        } else {
          var segm = this.collection.calculateRange(operator, property, value);
          if (operator !== "$in") {
            for (i = segm[0]; i <= segm[1]; i++) {
              result.push(index.values[i]);
            }
          } else {
            for (i = 0, len = segm.length; i < len; i++) {
              result.push(index.values[segm[i]]);
            }
          }
        }
        this.filterInitialized = true;
      }
      this.filteredrows = result;
      return this;
    };
    Resultset.prototype.where = function (fun) {
      var viewFunction,
        result = [];
      if ("function" === typeof fun) {
        viewFunction = fun;
      } else {
        throw new TypeError("Argument is not a stored view or a function");
      }
      try {
        if (!this.searchIsChained) {
          var i = this.collection.data.length;
          while (i--) {
            if (viewFunction(this.collection.data[i]) === true) {
              result.push(this.collection.data[i]);
            }
          }
          return result;
        } else {
          if (this.filterInitialized) {
            var j = this.filteredrows.length;
            while (j--) {
              if (
                viewFunction(this.collection.data[this.filteredrows[j]]) ===
                true
              ) {
                result.push(this.filteredrows[j]);
              }
            }
            this.filteredrows = result;
            return this;
          } else {
            var k = this.collection.data.length;
            while (k--) {
              if (viewFunction(this.collection.data[k]) === true) {
                result.push(k);
              }
            }
            this.filteredrows = result;
            this.filterInitialized = true;
            return this;
          }
        }
      } catch (err) {
        throw err;
      }
    };
    Resultset.prototype.count = function () {
      if (this.searchIsChained && this.filterInitialized) {
        return this.filteredrows.length;
      }
      return this.collection.count();
    };
    Resultset.prototype.data = function (options) {
      var result = [],
        data = this.collection.data,
        len,
        i,
        method;
      options = options || {};
      if (this.searchIsChained && !this.filterInitialized) {
        if (this.filteredrows.length === 0) {
          if (this.collection.cloneObjects || options.forceClones) {
            len = data.length;
            method = options.forceCloneMethod || this.collection.cloneMethod;
            for (i = 0; i < len; i++) {
              result.push(clone(data[i], method));
            }
            return result;
          } else {
            return data.slice();
          }
        } else {
          this.filterInitialized = true;
        }
      }
      var fr = this.filteredrows;
      len = fr.length;
      if (this.collection.cloneObjects || options.forceClones) {
        method = options.forceCloneMethod || this.collection.cloneMethod;
        for (i = 0; i < len; i++) {
          result.push(clone(data[fr[i]], method));
        }
      } else {
        for (i = 0; i < len; i++) {
          result.push(data[fr[i]]);
        }
      }
      return result;
    };
    Resultset.prototype.update = function (updateFunction) {
      if (typeof updateFunction !== "function") {
        throw new TypeError("Argument is not a function");
      }
      if (
        this.searchIsChained &&
        !this.filterInitialized &&
        this.filteredrows.length === 0
      ) {
        this.filteredrows = this.collection.prepareFullDocIndex();
      }
      var len = this.filteredrows.length,
        rcd = this.collection.data;
      for (var idx = 0; idx < len; idx++) {
        updateFunction(rcd[this.filteredrows[idx]]);
        this.collection.update(rcd[this.filteredrows[idx]]);
      }
      return this;
    };
    Resultset.prototype.remove = function () {
      if (
        this.searchIsChained &&
        !this.filterInitialized &&
        this.filteredrows.length === 0
      ) {
        this.filteredrows = this.collection.prepareFullDocIndex();
      }
      this.collection.remove(this.data());
      this.filteredrows = [];
      return this;
    };
    Resultset.prototype.mapReduce = function (mapFunction, reduceFunction) {
      try {
        return reduceFunction(this.data().map(mapFunction));
      } catch (err) {
        throw err;
      }
    };
    Resultset.prototype.eqJoin = function (
      joinData,
      leftJoinKey,
      rightJoinKey,
      mapFun
    ) {
      var leftData = [],
        leftDataLength,
        rightData = [],
        rightDataLength,
        key,
        result = [],
        leftKeyisFunction = typeof leftJoinKey === "function",
        rightKeyisFunction = typeof rightJoinKey === "function",
        joinMap = {};
      leftData = this.data();
      leftDataLength = leftData.length;
      if (joinData instanceof Resultset) {
        rightData = joinData.data();
      } else if (Array.isArray(joinData)) {
        rightData = joinData;
      } else {
        throw new TypeError("joinData needs to be an array or result set");
      }
      rightDataLength = rightData.length;
      for (var i = 0; i < rightDataLength; i++) {
        key = rightKeyisFunction
          ? rightJoinKey(rightData[i])
          : rightData[i][rightJoinKey];
        joinMap[key] = rightData[i];
      }
      if (!mapFun) {
        mapFun = function (left, right) {
          return { left: left, right: right };
        };
      }
      for (var j = 0; j < leftDataLength; j++) {
        key = leftKeyisFunction
          ? leftJoinKey(leftData[j])
          : leftData[j][leftJoinKey];
        result.push(mapFun(leftData[j], joinMap[key] || {}));
      }
      this.collection = new Collection("joinData");
      this.collection.insert(result);
      this.filteredrows = [];
      this.filterInitialized = false;
      return this;
    };
    Resultset.prototype.map = function (mapFun) {
      var data = this.data().map(mapFun);
      this.collection = new Collection("mappedData");
      this.collection.insert(data);
      this.filteredrows = [];
      this.filterInitialized = false;
      return this;
    };
    function DynamicView(collection, name, options) {
      this.collection = collection;
      this.name = name;
      this.rebuildPending = false;
      this.options = options || {};
      if (!this.options.hasOwnProperty("persistent")) {
        this.options.persistent = false;
      }
      if (!this.options.hasOwnProperty("sortPriority")) {
        this.options.sortPriority = "passive";
      }
      if (!this.options.hasOwnProperty("minRebuildInterval")) {
        this.options.minRebuildInterval = 1;
      }
      this.resultset = new Resultset(collection);
      this.resultdata = [];
      this.resultsdirty = false;
      this.cachedresultset = null;
      this.filterPipeline = [];
      this.sortFunction = null;
      this.sortCriteria = null;
      this.sortDirty = false;
      this.events = { rebuild: [] };
    }
    DynamicView.prototype = new LokiEventEmitter();
    DynamicView.prototype.rematerialize = function (options) {
      var fpl, fpi, idx;
      options = options || {};
      this.resultdata = [];
      this.resultsdirty = true;
      this.resultset = new Resultset(this.collection);
      if (this.sortFunction || this.sortCriteria) {
        this.sortDirty = true;
      }
      if (options.hasOwnProperty("removeWhereFilters")) {
        fpl = this.filterPipeline.length;
        fpi = fpl;
        while (fpi--) {
          if (this.filterPipeline[fpi].type === "where") {
            if (fpi !== this.filterPipeline.length - 1) {
              this.filterPipeline[fpi] =
                this.filterPipeline[this.filterPipeline.length - 1];
            }
            this.filterPipeline.length--;
          }
        }
      }
      var ofp = this.filterPipeline;
      this.filterPipeline = [];
      fpl = ofp.length;
      for (idx = 0; idx < fpl; idx++) {
        this.applyFind(ofp[idx].val);
      }
      this.data();
      this.emit("rebuild", this);
      return this;
    };
    DynamicView.prototype.branchResultset = function (transform, parameters) {
      var rs = this.resultset.branch();
      if (typeof transform === "undefined") {
        return rs;
      }
      return rs.transform(transform, parameters);
    };
    DynamicView.prototype.toJSON = function () {
      var copy = new DynamicView(this.collection, this.name, this.options);
      copy.resultset = this.resultset;
      copy.resultdata = [];
      copy.resultsdirty = true;
      copy.filterPipeline = this.filterPipeline;
      copy.sortFunction = this.sortFunction;
      copy.sortCriteria = this.sortCriteria;
      copy.sortDirty = this.sortDirty;
      copy.collection = null;
      return copy;
    };
    DynamicView.prototype.removeFilters = function () {
      this.rebuildPending = false;
      this.resultset.reset();
      this.resultdata = [];
      this.resultsdirty = false;
      this.cachedresultset = null;
      this.filterPipeline = [];
      this.sortFunction = null;
      this.sortCriteria = null;
      this.sortDirty = false;
    };
    DynamicView.prototype.applySort = function (comparefun) {
      this.sortFunction = comparefun;
      this.sortCriteria = null;
      this.queueSortPhase();
      return this;
    };
    DynamicView.prototype.applySimpleSort = function (propname, isdesc) {
      this.sortCriteria = [[propname, isdesc || false]];
      this.sortFunction = null;
      this.queueSortPhase();
      return this;
    };
    DynamicView.prototype.applySortCriteria = function (criteria) {
      this.sortCriteria = criteria;
      this.sortFunction = null;
      this.queueSortPhase();
      return this;
    };
    DynamicView.prototype.startTransaction = function () {
      this.cachedresultset = this.resultset.copy();
      return this;
    };
    DynamicView.prototype.commit = function () {
      this.cachedresultset = null;
      return this;
    };
    DynamicView.prototype.rollback = function () {
      this.resultset = this.cachedresultset;
      if (this.options.persistent) {
        this.resultdata = this.resultset.data();
        this.emit("rebuild", this);
      }
      return this;
    };
    DynamicView.prototype._indexOfFilterWithId = function (uid) {
      if (typeof uid === "string" || typeof uid === "number") {
        for (
          var idx = 0, len = this.filterPipeline.length;
          idx < len;
          idx += 1
        ) {
          if (uid === this.filterPipeline[idx].uid) {
            return idx;
          }
        }
      }
      return -1;
    };
    DynamicView.prototype._addFilter = function (filter) {
      this.filterPipeline.push(filter);
      this.resultset[filter.type](filter.val);
    };
    DynamicView.prototype.reapplyFilters = function () {
      this.resultset.reset();
      this.cachedresultset = null;
      if (this.options.persistent) {
        this.resultdata = [];
        this.resultsdirty = true;
      }
      var filters = this.filterPipeline;
      this.filterPipeline = [];
      for (var idx = 0, len = filters.length; idx < len; idx += 1) {
        this._addFilter(filters[idx]);
      }
      if (this.sortFunction || this.sortCriteria) {
        this.queueSortPhase();
      } else {
        this.queueRebuildEvent();
      }
      return this;
    };
    DynamicView.prototype.applyFilter = function (filter) {
      var idx = this._indexOfFilterWithId(filter.uid);
      if (idx >= 0) {
        this.filterPipeline[idx] = filter;
        return this.reapplyFilters();
      }
      this.cachedresultset = null;
      if (this.options.persistent) {
        this.resultdata = [];
        this.resultsdirty = true;
      }
      this._addFilter(filter);
      if (this.sortFunction || this.sortCriteria) {
        this.queueSortPhase();
      } else {
        this.queueRebuildEvent();
      }
      return this;
    };
    DynamicView.prototype.applyFind = function (query, uid) {
      this.applyFilter({ type: "find", val: query, uid: uid });
      return this;
    };
    DynamicView.prototype.applyWhere = function (fun, uid) {
      this.applyFilter({ type: "where", val: fun, uid: uid });
      return this;
    };
    DynamicView.prototype.removeFilter = function (uid) {
      var idx = this._indexOfFilterWithId(uid);
      if (idx < 0) {
        throw new Error(
          "Dynamic view does not contain a filter with ID: " + uid
        );
      }
      this.filterPipeline.splice(idx, 1);
      this.reapplyFilters();
      return this;
    };
    DynamicView.prototype.count = function () {
      if (this.options.persistent) {
        return this.resultdata.length;
      }
      return this.resultset.count();
    };
    DynamicView.prototype.data = function () {
      if (this.sortDirty || this.resultsdirty) {
        this.performSortPhase({ suppressRebuildEvent: true });
      }
      return this.options.persistent ? this.resultdata : this.resultset.data();
    };
    DynamicView.prototype.queueRebuildEvent = function () {
      if (this.rebuildPending) {
        return;
      }
      this.rebuildPending = true;
      var self = this;
      setTimeout(function () {
        if (self.rebuildPending) {
          self.rebuildPending = false;
          self.emit("rebuild", self);
        }
      }, this.options.minRebuildInterval);
    };
    DynamicView.prototype.queueSortPhase = function () {
      if (this.sortDirty) {
        return;
      }
      this.sortDirty = true;
      var self = this;
      if (this.options.sortPriority === "active") {
        setTimeout(function () {
          self.performSortPhase();
        }, this.options.minRebuildInterval);
      } else {
        this.queueRebuildEvent();
      }
    };
    DynamicView.prototype.performSortPhase = function (options) {
      if (!this.sortDirty && !this.resultsdirty) {
        return;
      }
      options = options || {};
      if (this.sortDirty) {
        if (this.sortFunction) {
          this.resultset.sort(this.sortFunction);
        } else if (this.sortCriteria) {
          this.resultset.compoundsort(this.sortCriteria);
        }
        this.sortDirty = false;
      }
      if (this.options.persistent) {
        this.resultdata = this.resultset.data();
        this.resultsdirty = false;
      }
      if (!options.suppressRebuildEvent) {
        this.emit("rebuild", this);
      }
    };
    DynamicView.prototype.evaluateDocument = function (objIndex, isNew) {
      if (!this.resultset.filterInitialized) {
        if (this.options.persistent) {
          this.resultdata = this.resultset.data();
        }
        if (this.sortFunction || this.sortCriteria) {
          this.queueSortPhase();
        } else {
          this.queueRebuildEvent();
        }
        return;
      }
      var ofr = this.resultset.filteredrows;
      var oldPos = isNew ? -1 : ofr.indexOf(+objIndex);
      var oldlen = ofr.length;
      var evalResultset = new Resultset(this.collection);
      evalResultset.filteredrows = [objIndex];
      evalResultset.filterInitialized = true;
      var filter;
      for (var idx = 0, len = this.filterPipeline.length; idx < len; idx++) {
        filter = this.filterPipeline[idx];
        evalResultset[filter.type](filter.val);
      }
      var newPos = evalResultset.filteredrows.length === 0 ? -1 : 0;
      if (oldPos === -1 && newPos === -1) return;
      if (oldPos === -1 && newPos !== -1) {
        ofr.push(objIndex);
        if (this.options.persistent) {
          this.resultdata.push(this.collection.data[objIndex]);
        }
        if (this.sortFunction || this.sortCriteria) {
          this.queueSortPhase();
        } else {
          this.queueRebuildEvent();
        }
        return;
      }
      if (oldPos !== -1 && newPos === -1) {
        if (oldPos < oldlen - 1) {
          ofr.splice(oldPos, 1);
          if (this.options.persistent) {
            this.resultdata.splice(oldPos, 1);
          }
        } else {
          ofr.length = oldlen - 1;
          if (this.options.persistent) {
            this.resultdata.length = oldlen - 1;
          }
        }
        if (this.sortFunction || this.sortCriteria) {
          this.queueSortPhase();
        } else {
          this.queueRebuildEvent();
        }
        return;
      }
      if (oldPos !== -1 && newPos !== -1) {
        if (this.options.persistent) {
          this.resultdata[oldPos] = this.collection.data[objIndex];
        }
        if (this.sortFunction || this.sortCriteria) {
          this.queueSortPhase();
        } else {
          this.queueRebuildEvent();
        }
        return;
      }
    };
    DynamicView.prototype.removeDocument = function (objIndex) {
      if (!this.resultset.filterInitialized) {
        if (this.options.persistent) {
          this.resultdata = this.resultset.data();
        }
        if (this.sortFunction || this.sortCriteria) {
          this.queueSortPhase();
        } else {
          this.queueRebuildEvent();
        }
        return;
      }
      var ofr = this.resultset.filteredrows;
      var oldPos = ofr.indexOf(+objIndex);
      var oldlen = ofr.length;
      var idx;
      if (oldPos !== -1) {
        if (oldPos < oldlen - 1) {
          ofr[oldPos] = ofr[oldlen - 1];
          ofr.length = oldlen - 1;
          if (this.options.persistent) {
            this.resultdata[oldPos] = this.resultdata[oldlen - 1];
            this.resultdata.length = oldlen - 1;
          }
        } else {
          ofr.length = oldlen - 1;
          if (this.options.persistent) {
            this.resultdata.length = oldlen - 1;
          }
        }
        if (this.sortFunction || this.sortCriteria) {
          this.queueSortPhase();
        } else {
          this.queueRebuildEvent();
        }
      }
      oldlen = ofr.length;
      for (idx = 0; idx < oldlen; idx++) {
        if (ofr[idx] > objIndex) {
          ofr[idx]--;
        }
      }
    };
    DynamicView.prototype.mapReduce = function (mapFunction, reduceFunction) {
      try {
        return reduceFunction(this.data().map(mapFunction));
      } catch (err) {
        throw err;
      }
    };
    function Collection(name, options) {
      this.name = name;
      this.data = [];
      this.idIndex = [];
      this.binaryIndices = {};
      this.constraints = { unique: {}, exact: {} };
      this.uniqueNames = [];
      this.transforms = {};
      this.objType = name;
      this.dirty = true;
      this.cachedIndex = null;
      this.cachedBinaryIndex = null;
      this.cachedData = null;
      var self = this;
      options = options || {};
      if (options.hasOwnProperty("unique")) {
        if (!Array.isArray(options.unique)) {
          options.unique = [options.unique];
        }
        options.unique.forEach(function (prop) {
          self.uniqueNames.push(prop);
          self.constraints.unique[prop] = new UniqueIndex(prop);
        });
      }
      if (options.hasOwnProperty("exact")) {
        options.exact.forEach(function (prop) {
          self.constraints.exact[prop] = new ExactIndex(prop);
        });
      }
      this.adaptiveBinaryIndices = options.hasOwnProperty(
        "adaptiveBinaryIndices"
      )
        ? options.adaptiveBinaryIndices
        : true;
      this.transactional = options.hasOwnProperty("transactional")
        ? options.transactional
        : false;
      this.cloneObjects = options.hasOwnProperty("clone")
        ? options.clone
        : false;
      this.cloneMethod = options.hasOwnProperty("cloneMethod")
        ? options.cloneMethod
        : "parse-stringify";
      this.asyncListeners = options.hasOwnProperty("asyncListeners")
        ? options.asyncListeners
        : false;
      this.disableChangesApi = options.hasOwnProperty("disableChangesApi")
        ? options.disableChangesApi
        : true;
      this.autoupdate = options.hasOwnProperty("autoupdate")
        ? options.autoupdate
        : false;
      this.ttl = { age: null, ttlInterval: null, daemon: null };
      this.setTTL(options.ttl || -1, options.ttlInterval);
      this.maxId = 0;
      this.DynamicViews = [];
      this.events = {
        insert: [],
        update: [],
        "pre-insert": [],
        "pre-update": [],
        close: [],
        flushbuffer: [],
        error: [],
        delete: [],
        warning: [],
      };
      this.changes = [];
      this.ensureId();
      var indices = [];
      if (options && options.indices) {
        if (
          Object.prototype.toString.call(options.indices) === "[object Array]"
        ) {
          indices = options.indices;
        } else if (typeof options.indices === "string") {
          indices = [options.indices];
        } else {
          throw new TypeError(
            "Indices needs to be a string or an array of strings"
          );
        }
      }
      for (var idx = 0; idx < indices.length; idx++) {
        this.ensureIndex(indices[idx]);
      }
      function observerCallback(changes) {
        var changedObjects = typeof Set === "function" ? new Set() : [];
        if (!changedObjects.add)
          changedObjects.add = function (object) {
            if (this.indexOf(object) === -1) this.push(object);
            return this;
          };
        changes.forEach(function (change) {
          changedObjects.add(change.object);
        });
        changedObjects.forEach(function (object) {
          if (!hasOwnProperty.call(object, "$loki"))
            return self.removeAutoUpdateObserver(object);
          try {
            self.update(object);
          } catch (err) {}
        });
      }
      this.observerCallback = observerCallback;
      function createChange(name, op, obj) {
        self.changes.push({
          name: name,
          operation: op,
          obj: JSON.parse(JSON.stringify(obj)),
        });
      }
      function flushChanges() {
        self.changes = [];
      }
      this.getChanges = function () {
        return self.changes;
      };
      this.flushChanges = flushChanges;
      function insertMeta(obj) {
        if (!obj) {
          return;
        }
        if (!obj.meta) {
          obj.meta = {};
        }
        obj.meta.created = new Date().getTime();
        obj.meta.revision = 0;
      }
      function updateMeta(obj) {
        if (!obj) {
          return;
        }
        obj.meta.updated = new Date().getTime();
        obj.meta.revision += 1;
      }
      function createInsertChange(obj) {
        createChange(self.name, "I", obj);
      }
      function createUpdateChange(obj) {
        createChange(self.name, "U", obj);
      }
      function insertMetaWithChange(obj) {
        insertMeta(obj);
        createInsertChange(obj);
      }
      function updateMetaWithChange(obj) {
        updateMeta(obj);
        createUpdateChange(obj);
      }
      var insertHandler, updateHandler;
      function setHandlers() {
        insertHandler = self.disableChangesApi
          ? insertMeta
          : insertMetaWithChange;
        updateHandler = self.disableChangesApi
          ? updateMeta
          : updateMetaWithChange;
      }
      setHandlers();
      this.setChangesApi = function (enabled) {
        self.disableChangesApi = !enabled;
        setHandlers();
      };
      this.on("insert", function insertCallback(obj) {
        insertHandler(obj);
      });
      this.on("update", function updateCallback(obj) {
        updateHandler(obj);
      });
      this.on("delete", function deleteCallback(obj) {
        if (!self.disableChangesApi) {
          createChange(self.name, "R", obj);
        }
      });
      this.on("warning", function (warning) {
        self.console.warn(warning);
      });
      flushChanges();
    }
    Collection.prototype = new LokiEventEmitter();
    Collection.prototype.console = {
      log: function () {},
      warn: function () {},
      error: function () {},
    };
    Collection.prototype.addAutoUpdateObserver = function (object) {
      if (!this.autoupdate || typeof Object.observe !== "function") return;
      Object.observe(object, this.observerCallback, [
        "add",
        "update",
        "delete",
        "reconfigure",
        "setPrototype",
      ]);
    };
    Collection.prototype.removeAutoUpdateObserver = function (object) {
      if (!this.autoupdate || typeof Object.observe !== "function") return;
      Object.unobserve(object, this.observerCallback);
    };
    Collection.prototype.addTransform = function (name, transform) {
      if (this.transforms.hasOwnProperty(name)) {
        throw new Error("a transform by that name already exists");
      }
      this.transforms[name] = transform;
    };
    Collection.prototype.setTransform = function (name, transform) {
      this.transforms[name] = transform;
    };
    Collection.prototype.removeTransform = function (name) {
      delete this.transforms[name];
    };
    Collection.prototype.byExample = function (template) {
      var k, obj, query;
      query = [];
      for (k in template) {
        if (!template.hasOwnProperty(k)) continue;
        query.push(((obj = {}), (obj[k] = template[k]), obj));
      }
      return { $and: query };
    };
    Collection.prototype.findObject = function (template) {
      return this.findOne(this.byExample(template));
    };
    Collection.prototype.findObjects = function (template) {
      return this.find(this.byExample(template));
    };
    Collection.prototype.ttlDaemonFuncGen = function () {
      var collection = this;
      var age = this.ttl.age;
      return function ttlDaemon() {
        var now = Date.now();
        var toRemove = collection.chain().where(function daemonFilter(member) {
          var timestamp = member.meta.updated || member.meta.created;
          var diff = now - timestamp;
          return age < diff;
        });
        toRemove.remove();
      };
    };
    Collection.prototype.setTTL = function (age, interval) {
      if (age < 0) {
        clearInterval(this.ttl.daemon);
      } else {
        this.ttl.age = age;
        this.ttl.ttlInterval = interval;
        this.ttl.daemon = setInterval(this.ttlDaemonFuncGen(), interval);
      }
    };
    Collection.prototype.prepareFullDocIndex = function () {
      var len = this.data.length;
      var indexes = new Array(len);
      for (var i = 0; i < len; i += 1) {
        indexes[i] = i;
      }
      return indexes;
    };
    Collection.prototype.configureOptions = function (options) {
      options = options || {};
      if (options.hasOwnProperty("adaptiveBinaryIndices")) {
        this.adaptiveBinaryIndices = options.adaptiveBinaryIndices;
        if (this.adaptiveBinaryIndices) {
          this.ensureAllIndexes();
        }
      }
    };
    Collection.prototype.ensureIndex = function (property, force) {
      if (typeof force === "undefined") {
        force = false;
      }
      if (property === null || property === undefined) {
        throw new Error(
          "Attempting to set index without an associated property"
        );
      }
      if (this.binaryIndices[property] && !force) {
        if (!this.binaryIndices[property].dirty) return;
      }
      var index = {
        name: property,
        dirty: true,
        values: this.prepareFullDocIndex(),
      };
      this.binaryIndices[property] = index;
      var wrappedComparer = (function (p, data) {
        return function (a, b) {
          var objAp = data[a][p],
            objBp = data[b][p];
          if (objAp !== objBp) {
            if (ltHelper(objAp, objBp, false)) return -1;
            if (gtHelper(objAp, objBp, false)) return 1;
          }
          return 0;
        };
      })(property, this.data);
      index.values.sort(wrappedComparer);
      index.dirty = false;
      this.dirty = true;
    };
    Collection.prototype.getSequencedIndexValues = function (property) {
      var idx,
        idxvals = this.binaryIndices[property].values;
      var result = "";
      for (idx = 0; idx < idxvals.length; idx++) {
        result += " [" + idx + "] " + this.data[idxvals[idx]][property];
      }
      return result;
    };
    Collection.prototype.ensureUniqueIndex = function (field) {
      var index = this.constraints.unique[field];
      if (!index) {
        if (this.uniqueNames.indexOf(field) == -1) {
          this.uniqueNames.push(field);
        }
      }
      this.constraints.unique[field] = index = new UniqueIndex(field);
      this.data.forEach(function (obj) {
        index.set(obj);
      });
      return index;
    };
    Collection.prototype.ensureAllIndexes = function (force) {
      var key,
        bIndices = this.binaryIndices;
      for (key in bIndices) {
        if (hasOwnProperty.call(bIndices, key)) {
          this.ensureIndex(key, force);
        }
      }
    };
    Collection.prototype.flagBinaryIndexesDirty = function () {
      var key,
        bIndices = this.binaryIndices;
      for (key in bIndices) {
        if (hasOwnProperty.call(bIndices, key)) {
          bIndices[key].dirty = true;
        }
      }
    };
    Collection.prototype.flagBinaryIndexDirty = function (index) {
      if (this.binaryIndices[index]) this.binaryIndices[index].dirty = true;
    };
    Collection.prototype.count = function (query) {
      if (!query) {
        return this.data.length;
      }
      return this.chain().find(query).filteredrows.length;
    };
    Collection.prototype.ensureId = function () {
      var len = this.data.length,
        i = 0;
      this.idIndex = [];
      for (i; i < len; i += 1) {
        this.idIndex.push(this.data[i].$loki);
      }
    };
    Collection.prototype.ensureIdAsync = function (callback) {
      this.async(function () {
        this.ensureId();
      }, callback);
    };
    Collection.prototype.addDynamicView = function (name, options) {
      var dv = new DynamicView(this, name, options);
      this.DynamicViews.push(dv);
      return dv;
    };
    Collection.prototype.removeDynamicView = function (name) {
      for (var idx = 0; idx < this.DynamicViews.length; idx++) {
        if (this.DynamicViews[idx].name === name) {
          this.DynamicViews.splice(idx, 1);
        }
      }
    };
    Collection.prototype.getDynamicView = function (name) {
      for (var idx = 0; idx < this.DynamicViews.length; idx++) {
        if (this.DynamicViews[idx].name === name) {
          return this.DynamicViews[idx];
        }
      }
      return null;
    };
    Collection.prototype.findAndUpdate = function (
      filterObject,
      updateFunction
    ) {
      if (typeof filterObject === "function") {
        this.updateWhere(filterObject, updateFunction);
      } else {
        this.chain().find(filterObject).update(updateFunction);
      }
    };
    Collection.prototype.findAndRemove = function (filterObject) {
      this.chain().find(filterObject).remove();
    };
    Collection.prototype.insert = function (doc) {
      if (!Array.isArray(doc)) {
        return this.insertOne(doc);
      }
      var obj;
      var results = [];
      this.emit("pre-insert", doc);
      for (var i = 0, len = doc.length; i < len; i++) {
        obj = this.insertOne(doc[i], true);
        if (!obj) {
          return undefined;
        }
        results.push(obj);
      }
      this.emit("insert", doc);
      return results.length === 1 ? results[0] : results;
    };
    Collection.prototype.insertOne = function (doc, bulkInsert) {
      var err = null;
      var returnObj;
      if (typeof doc !== "object") {
        err = new TypeError("Document needs to be an object");
      } else if (doc === null) {
        err = new TypeError("Object cannot be null");
      }
      if (err !== null) {
        this.emit("error", err);
        throw err;
      }
      var obj = this.cloneObjects ? clone(doc, this.cloneMethod) : doc;
      if (typeof obj.meta === "undefined") {
        obj.meta = { revision: 0, created: 0 };
      }
      returnObj = this.cloneObjects ? clone(obj, this.cloneMethod) : obj;
      if (!bulkInsert) {
        this.emit("pre-insert", obj);
      }
      if (!this.add(obj)) {
        return undefined;
      }
      this.addAutoUpdateObserver(returnObj);
      if (!bulkInsert) {
        this.emit("insert", returnObj);
      }
      return returnObj;
    };
    Collection.prototype.clear = function () {
      this.data = [];
      this.idIndex = [];
      this.binaryIndices = {};
      this.cachedIndex = null;
      this.cachedBinaryIndex = null;
      this.cachedData = null;
      this.maxId = 0;
      this.DynamicViews = [];
      this.dirty = true;
    };
    Collection.prototype.update = function (doc) {
      if (Array.isArray(doc)) {
        var k = 0,
          len = doc.length;
        for (k; k < len; k += 1) {
          this.update(doc[k]);
        }
        return;
      }
      if (!hasOwnProperty.call(doc, "$loki")) {
        throw new Error(
          "Trying to update unsynced document. Please save the document first by using insert() or addMany()"
        );
      }
      try {
        this.startTransaction();
        var arr = this.get(doc.$loki, true),
          oldInternal,
          newInternal,
          position,
          self = this;
        if (!arr) {
          throw new Error("Trying to update a document not in collection.");
        }
        oldInternal = arr[0];
        position = arr[1];
        newInternal = this.cloneObjects ? clone(doc, this.cloneMethod) : doc;
        this.emit("pre-update", doc);
        Object.keys(this.constraints.unique).forEach(function (key) {
          self.constraints.unique[key].update(oldInternal, newInternal);
        });
        this.data[position] = newInternal;
        if (newInternal !== doc) {
          this.addAutoUpdateObserver(doc);
        }
        for (var idx = 0; idx < this.DynamicViews.length; idx++) {
          this.DynamicViews[idx].evaluateDocument(position, false);
        }
        var key;
        if (this.adaptiveBinaryIndices) {
          var bIndices = this.binaryIndices;
          for (key in bIndices) {
            this.adaptiveBinaryIndexUpdate(position, key);
          }
        } else {
          this.flagBinaryIndexesDirty();
        }
        this.idIndex[position] = newInternal.$loki;
        this.commit();
        this.dirty = true;
        this.emit(
          "update",
          doc,
          this.cloneObjects ? clone(oldInternal, this.cloneMethod) : null
        );
        return doc;
      } catch (err) {
        this.rollback();
        this.console.error(err.message);
        this.emit("error", err);
        throw err;
      }
    };
    Collection.prototype.add = function (obj) {
      if ("object" !== typeof obj) {
        throw new TypeError("Object being added needs to be an object");
      }
      if (typeof obj.$loki !== "undefined") {
        throw new Error(
          "Document is already in collection, please use update()"
        );
      }
      try {
        this.startTransaction();
        this.maxId++;
        if (isNaN(this.maxId)) {
          this.maxId = this.data[this.data.length - 1].$loki + 1;
        }
        obj.$loki = this.maxId;
        obj.meta.version = 0;
        var key,
          constrUnique = this.constraints.unique;
        for (key in constrUnique) {
          if (hasOwnProperty.call(constrUnique, key)) {
            constrUnique[key].set(obj);
          }
        }
        this.idIndex.push(obj.$loki);
        this.data.push(obj);
        var addedPos = this.data.length - 1;
        var dvlen = this.DynamicViews.length;
        for (var i = 0; i < dvlen; i++) {
          this.DynamicViews[i].evaluateDocument(addedPos, true);
        }
        if (this.adaptiveBinaryIndices) {
          var bIndices = this.binaryIndices;
          for (key in bIndices) {
            this.adaptiveBinaryIndexInsert(addedPos, key);
          }
        } else {
          this.flagBinaryIndexesDirty();
        }
        this.commit();
        this.dirty = true;
        return this.cloneObjects ? clone(obj, this.cloneMethod) : obj;
      } catch (err) {
        this.rollback();
        this.console.error(err.message);
        this.emit("error", err);
        throw err;
      }
    };
    Collection.prototype.updateWhere = function (
      filterFunction,
      updateFunction
    ) {
      var results = this.where(filterFunction),
        i = 0,
        obj;
      try {
        for (i; i < results.length; i++) {
          obj = updateFunction(results[i]);
          this.update(obj);
        }
      } catch (err) {
        this.rollback();
        this.console.error(err.message);
      }
    };
    Collection.prototype.removeWhere = function (query) {
      var list;
      if (typeof query === "function") {
        list = this.data.filter(query);
        this.remove(list);
      } else {
        this.chain().find(query).remove();
      }
    };
    Collection.prototype.removeDataOnly = function () {
      this.remove(this.data.slice());
    };
    Collection.prototype.remove = function (doc) {
      if (typeof doc === "number") {
        doc = this.get(doc);
      }
      if ("object" !== typeof doc) {
        throw new Error("Parameter is not an object");
      }
      if (Array.isArray(doc)) {
        var k = 0,
          len = doc.length;
        for (k; k < len; k += 1) {
          this.remove(doc[k]);
        }
        return;
      }
      if (!hasOwnProperty.call(doc, "$loki")) {
        throw new Error("Object is not a document stored in the collection");
      }
      try {
        this.startTransaction();
        var arr = this.get(doc.$loki, true),
          position = arr[1];
        var self = this;
        Object.keys(this.constraints.unique).forEach(function (key) {
          if (doc[key] !== null && typeof doc[key] !== "undefined") {
            self.constraints.unique[key].remove(doc[key]);
          }
        });
        for (var idx = 0; idx < this.DynamicViews.length; idx++) {
          this.DynamicViews[idx].removeDocument(position);
        }
        if (this.adaptiveBinaryIndices) {
          var key,
            bIndices = this.binaryIndices;
          for (key in bIndices) {
            this.adaptiveBinaryIndexRemove(position, key);
          }
        } else {
          this.flagBinaryIndexesDirty();
        }
        this.data.splice(position, 1);
        this.removeAutoUpdateObserver(doc);
        this.idIndex.splice(position, 1);
        this.commit();
        this.dirty = true;
        this.emit("delete", arr[0]);
        delete doc.$loki;
        delete doc.meta;
        return doc;
      } catch (err) {
        this.rollback();
        this.console.error(err.message);
        this.emit("error", err);
        return null;
      }
    };
    Collection.prototype.get = function (id, returnPosition) {
      var retpos = returnPosition || false,
        data = this.idIndex,
        max = data.length - 1,
        min = 0,
        mid = (min + max) >> 1;
      id = typeof id === "number" ? id : parseInt(id, 10);
      if (isNaN(id)) {
        throw new TypeError("Passed id is not an integer");
      }
      while (data[min] < data[max]) {
        mid = (min + max) >> 1;
        if (data[mid] < id) {
          min = mid + 1;
        } else {
          max = mid;
        }
      }
      if (max === min && data[min] === id) {
        if (retpos) {
          return [this.data[min], min];
        }
        return this.data[min];
      }
      return null;
    };
    Collection.prototype.getBinaryIndexPosition = function (
      dataPosition,
      binaryIndexName
    ) {
      var val = this.data[dataPosition][binaryIndexName];
      var index = this.binaryIndices[binaryIndexName].values;
      var range = this.calculateRange("$eq", binaryIndexName, val);
      if (range[0] === 0 && range[1] === -1) {
        return null;
      }
      var min = range[0];
      var max = range[1];
      for (var idx = min; idx <= max; idx++) {
        if (index[idx] === dataPosition) return idx;
      }
      return null;
    };
    Collection.prototype.adaptiveBinaryIndexInsert = function (
      dataPosition,
      binaryIndexName
    ) {
      var index = this.binaryIndices[binaryIndexName].values;
      var val = this.data[dataPosition][binaryIndexName];
      var idxPos = this.calculateRangeStart(binaryIndexName, val);
      this.binaryIndices[binaryIndexName].values.splice(
        idxPos,
        0,
        dataPosition
      );
    };
    Collection.prototype.adaptiveBinaryIndexUpdate = function (
      dataPosition,
      binaryIndexName
    ) {
      var idxPos,
        index = this.binaryIndices[binaryIndexName].values,
        len = index.length;
      for (idxPos = 0; idxPos < len; idxPos++) {
        if (index[idxPos] === dataPosition) break;
      }
      this.binaryIndices[binaryIndexName].values.splice(idxPos, 1);
      this.adaptiveBinaryIndexInsert(dataPosition, binaryIndexName);
    };
    Collection.prototype.adaptiveBinaryIndexRemove = function (
      dataPosition,
      binaryIndexName,
      removedFromIndexOnly
    ) {
      var idxPos = this.getBinaryIndexPosition(dataPosition, binaryIndexName);
      var index = this.binaryIndices[binaryIndexName].values;
      var len, idx;
      if (idxPos === null) {
        return null;
      }
      this.binaryIndices[binaryIndexName].values.splice(idxPos, 1);
      if (removedFromIndexOnly === true) {
        return;
      }
      len = index.length;
      for (idx = 0; idx < len; idx++) {
        if (index[idx] > dataPosition) {
          index[idx]--;
        }
      }
    };
    Collection.prototype.calculateRangeStart = function (prop, val) {
      var rcd = this.data;
      var index = this.binaryIndices[prop].values;
      var min = 0;
      var max = index.length - 1;
      var mid = 0;
      if (index.length === 0) {
        return 0;
      }
      var minVal = rcd[index[min]][prop];
      var maxVal = rcd[index[max]][prop];
      while (min < max) {
        mid = (min + max) >> 1;
        if (ltHelper(rcd[index[mid]][prop], val, false)) {
          min = mid + 1;
        } else {
          max = mid;
        }
      }
      var lbound = min;
      if (ltHelper(rcd[index[lbound]][prop], val, false)) {
        return lbound + 1;
      } else {
        return lbound;
      }
    };
    Collection.prototype.calculateRange = function (op, prop, val) {
      var rcd = this.data;
      var index = this.binaryIndices[prop].values;
      var min = 0;
      var max = index.length - 1;
      var mid = 0;
      if (rcd.length === 0) {
        return [0, -1];
      }
      var minVal = rcd[index[min]][prop];
      var maxVal = rcd[index[max]][prop];
      switch (op) {
        case "$eq":
        case "$aeq":
          if (ltHelper(val, minVal, false) || gtHelper(val, maxVal, false)) {
            return [0, -1];
          }
          break;
        case "$dteq":
          if (ltHelper(val, minVal, false) || gtHelper(val, maxVal, false)) {
            return [0, -1];
          }
          break;
        case "$gt":
          if (gtHelper(val, maxVal, true)) {
            return [0, -1];
          }
          break;
        case "$gte":
          if (gtHelper(val, maxVal, false)) {
            return [0, -1];
          }
          break;
        case "$lt":
          if (ltHelper(val, minVal, true)) {
            return [0, -1];
          }
          if (ltHelper(maxVal, val, false)) {
            return [0, rcd.length - 1];
          }
          break;
        case "$lte":
          if (ltHelper(val, minVal, false)) {
            return [0, -1];
          }
          if (ltHelper(maxVal, val, true)) {
            return [0, rcd.length - 1];
          }
          break;
        case "$in":
          var idxset = [],
            segResult = [];
          for (var j = 0, len = val.length; j < len; j++) {
            var seg = this.calculateRange("$eq", prop, val[j]);
            for (var i = seg[0]; i <= seg[1]; i++) {
              if (idxset[i] === undefined) {
                idxset[i] = true;
                segResult.push(i);
              }
            }
          }
          return segResult;
      }
      while (min < max) {
        mid = (min + max) >> 1;
        if (ltHelper(rcd[index[mid]][prop], val, false)) {
          min = mid + 1;
        } else {
          max = mid;
        }
      }
      var lbound = min;
      max = index.length - 1;
      while (min < max) {
        mid = (min + max) >> 1;
        if (ltHelper(val, rcd[index[mid]][prop], false)) {
          max = mid;
        } else {
          min = mid + 1;
        }
      }
      var ubound = max;
      var lval = rcd[index[lbound]][prop];
      var uval = rcd[index[ubound]][prop];
      switch (op) {
        case "$eq":
          if (lval !== val) {
            return [0, -1];
          }
          if (uval !== val) {
            ubound--;
          }
          return [lbound, ubound];
        case "$dteq":
          if (lval > val || lval < val) {
            return [0, -1];
          }
          if (uval > val || uval < val) {
            ubound--;
          }
          return [lbound, ubound];
        case "$gt":
          if (ltHelper(uval, val, true)) {
            return [0, -1];
          }
          return [ubound, rcd.length - 1];
        case "$gte":
          if (ltHelper(lval, val, false)) {
            return [0, -1];
          }
          return [lbound, rcd.length - 1];
        case "$lt":
          if (lbound === 0 && ltHelper(lval, val, false)) {
            return [0, 0];
          }
          return [0, lbound - 1];
        case "$lte":
          if (uval !== val) {
            ubound--;
          }
          if (ubound === 0 && ltHelper(uval, val, false)) {
            return [0, 0];
          }
          return [0, ubound];
        default:
          return [0, rcd.length - 1];
      }
    };
    Collection.prototype.by = function (field, value) {
      var self;
      if (value === undefined) {
        self = this;
        return function (value) {
          return self.by(field, value);
        };
      }
      var result = this.constraints.unique[field].get(value);
      if (!this.cloneObjects) {
        return result;
      } else {
        return clone(result, this.cloneMethod);
      }
    };
    Collection.prototype.findOne = function (query) {
      query = query || {};
      var result = new Resultset(this, { queryObj: query, firstOnly: true });
      if (Array.isArray(result) && result.length === 0) {
        return null;
      } else {
        if (!this.cloneObjects) {
          return result;
        } else {
          return clone(result, this.cloneMethod);
        }
      }
    };
    Collection.prototype.chain = function (transform, parameters) {
      var rs = new Resultset(this);
      if (typeof transform === "undefined") {
        return rs;
      }
      return rs.transform(transform, parameters);
    };
    Collection.prototype.find = function (query) {
      if (typeof query === "undefined") {
        query = "getAll";
      }
      var results = new Resultset(this, { queryObj: query });
      if (!this.cloneObjects) {
        return results;
      } else {
        return cloneObjectArray(results, this.cloneMethod);
      }
    };
    Collection.prototype.findOneUnindexed = function (prop, value) {
      var i = this.data.length,
        doc;
      while (i--) {
        if (this.data[i][prop] === value) {
          doc = this.data[i];
          return doc;
        }
      }
      return null;
    };
    Collection.prototype.startTransaction = function () {
      if (this.transactional) {
        this.cachedData = clone(this.data, this.cloneMethod);
        this.cachedIndex = this.idIndex;
        this.cachedBinaryIndex = this.binaryIndices;
        for (var idx = 0; idx < this.DynamicViews.length; idx++) {
          this.DynamicViews[idx].startTransaction();
        }
      }
    };
    Collection.prototype.commit = function () {
      if (this.transactional) {
        this.cachedData = null;
        this.cachedIndex = null;
        this.cachedBinaryIndex = null;
        for (var idx = 0; idx < this.DynamicViews.length; idx++) {
          this.DynamicViews[idx].commit();
        }
      }
    };
    Collection.prototype.rollback = function () {
      if (this.transactional) {
        if (this.cachedData !== null && this.cachedIndex !== null) {
          this.data = this.cachedData;
          this.idIndex = this.cachedIndex;
          this.binaryIndices = this.cachedBinaryIndex;
        }
        for (var idx = 0; idx < this.DynamicViews.length; idx++) {
          this.DynamicViews[idx].rollback();
        }
      }
    };
    Collection.prototype.async = function (fun, callback) {
      setTimeout(function () {
        if (typeof fun === "function") {
          fun();
          callback();
        } else {
          throw new TypeError(
            "Argument passed for async execution is not a function"
          );
        }
      }, 0);
    };
    Collection.prototype.where = function (fun) {
      var results = new Resultset(this, { queryFunc: fun });
      if (!this.cloneObjects) {
        return results;
      } else {
        return cloneObjectArray(results, this.cloneMethod);
      }
    };
    Collection.prototype.mapReduce = function (mapFunction, reduceFunction) {
      try {
        return reduceFunction(this.data.map(mapFunction));
      } catch (err) {
        throw err;
      }
    };
    Collection.prototype.eqJoin = function (
      joinData,
      leftJoinProp,
      rightJoinProp,
      mapFun
    ) {
      return new Resultset(this).eqJoin(
        joinData,
        leftJoinProp,
        rightJoinProp,
        mapFun
      );
    };
    Collection.prototype.stages = {};
    Collection.prototype.getStage = function (name) {
      if (!this.stages[name]) {
        this.stages[name] = {};
      }
      return this.stages[name];
    };
    Collection.prototype.commitLog = [];
    Collection.prototype.stage = function (stageName, obj) {
      var copy = JSON.parse(JSON.stringify(obj));
      this.getStage(stageName)[obj.$loki] = copy;
      return copy;
    };
    Collection.prototype.commitStage = function (stageName, message) {
      var stage = this.getStage(stageName),
        prop,
        timestamp = new Date().getTime();
      for (prop in stage) {
        this.update(stage[prop]);
        this.commitLog.push({
          timestamp: timestamp,
          message: message,
          data: JSON.parse(JSON.stringify(stage[prop])),
        });
      }
      this.stages[stageName] = {};
    };
    Collection.prototype.no_op = function () {
      return;
    };
    Collection.prototype.extract = function (field) {
      var i = 0,
        len = this.data.length,
        isDotNotation = isDeepProperty(field),
        result = [];
      for (i; i < len; i += 1) {
        result.push(deepProperty(this.data[i], field, isDotNotation));
      }
      return result;
    };
    Collection.prototype.max = function (field) {
      return Math.max.apply(null, this.extract(field));
    };
    Collection.prototype.min = function (field) {
      return Math.min.apply(null, this.extract(field));
    };
    Collection.prototype.maxRecord = function (field) {
      var i = 0,
        len = this.data.length,
        deep = isDeepProperty(field),
        result = { index: 0, value: undefined },
        max;
      for (i; i < len; i += 1) {
        if (max !== undefined) {
          if (max < deepProperty(this.data[i], field, deep)) {
            max = deepProperty(this.data[i], field, deep);
            result.index = this.data[i].$loki;
          }
        } else {
          max = deepProperty(this.data[i], field, deep);
          result.index = this.data[i].$loki;
        }
      }
      result.value = max;
      return result;
    };
    Collection.prototype.minRecord = function (field) {
      var i = 0,
        len = this.data.length,
        deep = isDeepProperty(field),
        result = { index: 0, value: undefined },
        min;
      for (i; i < len; i += 1) {
        if (min !== undefined) {
          if (min > deepProperty(this.data[i], field, deep)) {
            min = deepProperty(this.data[i], field, deep);
            result.index = this.data[i].$loki;
          }
        } else {
          min = deepProperty(this.data[i], field, deep);
          result.index = this.data[i].$loki;
        }
      }
      result.value = min;
      return result;
    };
    Collection.prototype.extractNumerical = function (field) {
      return this.extract(field)
        .map(parseBase10)
        .filter(Number)
        .filter(function (n) {
          return !isNaN(n);
        });
    };
    Collection.prototype.avg = function (field) {
      return average(this.extractNumerical(field));
    };
    Collection.prototype.stdDev = function (field) {
      return standardDeviation(this.extractNumerical(field));
    };
    Collection.prototype.mode = function (field) {
      var dict = {},
        data = this.extract(field);
      data.forEach(function (obj) {
        if (dict[obj]) {
          dict[obj] += 1;
        } else {
          dict[obj] = 1;
        }
      });
      var max, prop, mode;
      for (prop in dict) {
        if (max) {
          if (max < dict[prop]) {
            mode = prop;
          }
        } else {
          mode = prop;
          max = dict[prop];
        }
      }
      return mode;
    };
    Collection.prototype.median = function (field) {
      var values = this.extractNumerical(field);
      values.sort(sub);
      var half = Math.floor(values.length / 2);
      if (values.length % 2) {
        return values[half];
      } else {
        return (values[half - 1] + values[half]) / 2;
      }
    };
    function isDeepProperty(field) {
      return field.indexOf(".") !== -1;
    }
    function parseBase10(num) {
      return parseFloat(num, 10);
    }
    function isNotUndefined(obj) {
      return obj !== undefined;
    }
    function add(a, b) {
      return a + b;
    }
    function sub(a, b) {
      return a - b;
    }
    function median(values) {
      values.sort(sub);
      var half = Math.floor(values.length / 2);
      return values.length % 2
        ? values[half]
        : (values[half - 1] + values[half]) / 2;
    }
    function average(array) {
      return array.reduce(add, 0) / array.length;
    }
    function standardDeviation(values) {
      var avg = average(values);
      var squareDiffs = values.map(function (value) {
        var diff = value - avg;
        var sqrDiff = diff * diff;
        return sqrDiff;
      });
      var avgSquareDiff = average(squareDiffs);
      var stdDev = Math.sqrt(avgSquareDiff);
      return stdDev;
    }
    function deepProperty(obj, property, isDeep) {
      if (isDeep === false) {
        return obj[property];
      }
      var pieces = property.split("."),
        root = obj;
      while (pieces.length > 0) {
        root = root[pieces.shift()];
      }
      return root;
    }
    function binarySearch(array, item, fun) {
      var lo = 0,
        hi = array.length,
        compared,
        mid;
      while (lo < hi) {
        mid = (lo + hi) >> 1;
        compared = fun.apply(null, [item, array[mid]]);
        if (compared === 0) {
          return { found: true, index: mid };
        } else if (compared < 0) {
          hi = mid;
        } else {
          lo = mid + 1;
        }
      }
      return { found: false, index: hi };
    }
    function BSonSort(fun) {
      return function (array, item) {
        return binarySearch(array, item, fun);
      };
    }
    function KeyValueStore() {}
    KeyValueStore.prototype = {
      keys: [],
      values: [],
      sort: function (a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      },
      setSort: function (fun) {
        this.bs = new BSonSort(fun);
      },
      bs: function () {
        return new BSonSort(this.sort);
      },
      set: function (key, value) {
        var pos = this.bs(this.keys, key);
        if (pos.found) {
          this.values[pos.index] = value;
        } else {
          this.keys.splice(pos.index, 0, key);
          this.values.splice(pos.index, 0, value);
        }
      },
      get: function (key) {
        return this.values[binarySearch(this.keys, key, this.sort).index];
      },
    };
    function UniqueIndex(uniqueField) {
      this.field = uniqueField;
      this.keyMap = {};
      this.lokiMap = {};
    }
    UniqueIndex.prototype.keyMap = {};
    UniqueIndex.prototype.lokiMap = {};
    UniqueIndex.prototype.set = function (obj) {
      var fieldValue = obj[this.field];
      if (fieldValue !== null && typeof fieldValue !== "undefined") {
        if (this.keyMap[fieldValue]) {
          throw new Error(
            "Duplicate key for property " + this.field + ": " + fieldValue
          );
        } else {
          this.keyMap[fieldValue] = obj;
          this.lokiMap[obj.$loki] = fieldValue;
        }
      }
    };
    UniqueIndex.prototype.get = function (key) {
      return this.keyMap[key];
    };
    UniqueIndex.prototype.byId = function (id) {
      return this.keyMap[this.lokiMap[id]];
    };
    UniqueIndex.prototype.update = function (obj, doc) {
      if (this.lokiMap[obj.$loki] !== doc[this.field]) {
        var old = this.lokiMap[obj.$loki];
        this.set(doc);
        this.keyMap[old] = undefined;
      } else {
        this.keyMap[obj[this.field]] = doc;
      }
    };
    UniqueIndex.prototype.remove = function (key) {
      var obj = this.keyMap[key];
      if (obj !== null && typeof obj !== "undefined") {
        this.keyMap[key] = undefined;
        this.lokiMap[obj.$loki] = undefined;
      } else {
        throw new Error("Key is not in unique index: " + this.field);
      }
    };
    UniqueIndex.prototype.clear = function () {
      this.keyMap = {};
      this.lokiMap = {};
    };
    function ExactIndex(exactField) {
      this.index = {};
      this.field = exactField;
    }
    ExactIndex.prototype = {
      set: function add(key, val) {
        if (this.index[key]) {
          this.index[key].push(val);
        } else {
          this.index[key] = [val];
        }
      },
      remove: function remove(key, val) {
        var idxSet = this.index[key];
        for (var i in idxSet) {
          if (idxSet[i] == val) {
            idxSet.splice(i, 1);
          }
        }
        if (idxSet.length < 1) {
          this.index[key] = undefined;
        }
      },
      get: function get(key) {
        return this.index[key];
      },
      clear: function clear(key) {
        this.index = {};
      },
    };
    function SortedIndex(sortedField) {
      this.field = sortedField;
    }
    SortedIndex.prototype = {
      keys: [],
      values: [],
      sort: function (a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      },
      bs: function () {
        return new BSonSort(this.sort);
      },
      setSort: function (fun) {
        this.bs = new BSonSort(fun);
      },
      set: function (key, value) {
        var pos = binarySearch(this.keys, key, this.sort);
        if (pos.found) {
          this.values[pos.index].push(value);
        } else {
          this.keys.splice(pos.index, 0, key);
          this.values.splice(pos.index, 0, [value]);
        }
      },
      get: function (key) {
        var bsr = binarySearch(this.keys, key, this.sort);
        if (bsr.found) {
          return this.values[bsr.index];
        } else {
          return [];
        }
      },
      getLt: function (key) {
        var bsr = binarySearch(this.keys, key, this.sort);
        var pos = bsr.index;
        if (bsr.found) pos--;
        return this.getAll(key, 0, pos);
      },
      getGt: function (key) {
        var bsr = binarySearch(this.keys, key, this.sort);
        var pos = bsr.index;
        if (bsr.found) pos++;
        return this.getAll(key, pos, this.keys.length);
      },
      getAll: function (key, start, end) {
        var results = [];
        for (var i = start; i < end; i++) {
          results = results.concat(this.values[i]);
        }
        return results;
      },
      getPos: function (key) {
        return binarySearch(this.keys, key, this.sort);
      },
      remove: function (key, value) {
        var pos = binarySearch(this.keys, key, this.sort).index;
        var idxSet = this.values[pos];
        for (var i in idxSet) {
          if (idxSet[i] == value) idxSet.splice(i, 1);
        }
        if (idxSet.length < 1) {
          this.keys.splice(pos, 1);
          this.values.splice(pos, 1);
        }
      },
      clear: function () {
        this.keys = [];
        this.values = [];
      },
    };
    Loki.LokiOps = LokiOps;
    Loki.Collection = Collection;
    Loki.KeyValueStore = KeyValueStore;
    Loki.LokiMemoryAdapter = LokiMemoryAdapter;
    Loki.LokiPartitioningAdapter = LokiPartitioningAdapter;
    Loki.LokiLocalStorageAdapter = LokiLocalStorageAdapter;
    Loki.LokiFsAdapter = LokiFsAdapter;
    Loki.persistenceAdapters = {
      fs: LokiFsAdapter,
      localStorage: LokiLocalStorageAdapter,
    };
    return Loki;
  })();
});

/**
 * This js file has been created in order to push chat events to OneTag server
 */

var eGainOneTagUtil = {
  regexForImg: /<\s*img[^>]+>/,
  documentUrl: document.URL,
  chatStartedPrefix: "",
  chatStartedSuffix: "",
  chatEndedPrefix: "",
  chatEndedSuffix: "",
  systemTimeOutMessage: "",
  lastAgentRequestMessageTime: -1,
  lastCustomerRequestMessageTime: -1,
  requiredUrlParams: [
    "entryPointId",
    "templateName",
    "ver",
    "locale",
    "eglvrefname",
    "eglvcaseid",
    "offercorrelationid",
    "interactionid",
    "eglvPriorityChat",
    "referer",
    "aid",
    "sid",
    "uid",
    "clientKey",
  ],
  removeURLParameter: function (url, parameter) {
    //prefer to use l.search if you have a location/link object
    var urlparts = url.split("?");
    if (urlparts.length >= 2) {
      var prefix = encodeURIComponent(parameter) + "=";
      var pars = urlparts[1].split(/[&;]/g);
      //reverse iteration as may be destructive
      for (var i = pars.length; i-- > 0; ) {
        //idiom for string.startsWith
        if (pars[i].lastIndexOf(prefix, 0) !== -1) {
          pars.splice(i, 1);
        }
      }
      url = urlparts[0] + (pars.length > 0 ? "?" + pars.join("&") : "");
      return url;
    } else {
      return url;
    }
  },
  /*
   * EGS-39529 : Removing url parameters that are not required to be sent to Onetag and only used for maintaining chat session
   *
   */
  cleanIFrameUrl: function () {
    var url = document.URL;
    var urlString = window.location.search.substring(1);
    var urlParams = urlString.split("&");
    for (var i = 0; i < urlParams.length; i++) {
      var param = urlParams[i].split("=");
      var key = param[0];
      var value = param[1];
      if (eGainOneTagUtil.requiredUrlParams.indexOf(key) == -1) {
        url = eGainOneTagUtil.removeURLParameter(url, key);
      }
    }
    eGainOneTagUtil.documentUrl = url;
  },
  loadOneTag: function (chatInitializationData) {
    var EG_ACT_ID = chatInitializationData.oneTagAId;
    (function (e, f) {
      var d,
        c,
        b,
        a = e.createElement("iframe");
      a.src = "about:blank";
      a.title = "";
      a.id = "egot_iframe";
      (a.frameElement || a).style.cssText = "width:0;height:0;border:0";
      b = e.getElementsByTagName("script");
      b = b[b.length - 1];
      b.parentNode.insertBefore(a, b);
      try {
        c = a.contentWindow.document;
      } catch (g) {
        (d = e.domain),
          (a.src =
            "javascript:var d=document.open();d.domain='" + d + "';void(0);"),
          (c = a.contentWindow.document);
      }
      c.open()._d = function () {
        var a = this.createElement("script");
        d && (this.domain = d);
        a.src = f;
        this.isEGFIF = !0;
        this.body.appendChild(a);
      };
      c.write('<body onload="document._d();">');
      c.close();
    })(
      document,
      "//" +
        chatInitializationData.oneTagServerDomainName +
        "/onetag/" +
        EG_ACT_ID
    );
  },
  pushChatEvent: function (eventType, eventInfo) {
    var EG_CALL_Q = window.EG_CALL_Q || [];
    EG_CALL_Q.push([
      "send",
      "cht",
      eventType,
      eGainOneTagUtil.documentUrl,
      101,
      eventInfo,
    ]);
  },
  pushChatAgentMsg: function (messageHtml) {
    var curTime = Date.now();
    if (eGainOneTagUtil.lastAgentRequestMessageTime == -1) {
      eGainOneTagUtil.lastAgentRequestMessageTime = curTime;
    }
    var agentSideTimeElapsed =
      curTime - eGainOneTagUtil.lastCustomerRequestMessageTime;
    eGainOneTagUtil.lastAgentRequestMessageTime = curTime;

    /* EGS-43655: Removing personal data from onetag information */
    //var messageToBePushed = eGainOneTagUtil.parseSmileysInMessage(messageHtml);
    eGainOneTagUtil.pushChatEvent("uac", {
      EventName: "ChatAgentMsg",
      "Time-to-respond": agentSideTimeElapsed,
    });
  },
  pushChatCustomerMsg: function (messageHtml) {
    var curTime = Date.now();
    if (eGainOneTagUtil.lastCustomerRequestMessageTime == -1) {
      eGainOneTagUtil.lastCustomerRequestMessageTime = curTime;
    }
    var customerSideTimeElapsed =
      curTime - eGainOneTagUtil.lastAgentRequestMessageTime;
    eGainOneTagUtil.lastCustomerRequestMessageTime = curTime;

    /* EGS-43655: Removing personal data from onetag information */
    //var messageToBePushed = eGainOneTagUtil.parseSmileysInMessage(messageHtml);
    eGainOneTagUtil.pushChatEvent("uac", {
      EventName: "ChatCustomerMsg",
      "Time-to-respond": customerSideTimeElapsed,
    });
  },
  parseSmileysInMessage: function (messageHtml) {
    var messageToBePushed = messageHtml;
    if (eGainOneTagUtil.regexForImg.test(messageHtml)) {
      var el = document.createElement("el");
      el.innerHTML = messageHtml;
      var smileys = el.getElementsByTagName("img");
      if (smileys) {
        var noOfSmileys = smileys.length;
        for (var i = 0; i < noOfSmileys; i++) {
          var abridgedImg =
            "&lt;img alt='" + (smileys[0].getAttribute("alt") || "") + "'&gt;";
          smileys[0].outerHTML = abridgedImg;
        }
        messageToBePushed = el.innerHTML;
      }
    }
    messageToBePushed = $.trim($("<div/>").html(messageToBePushed).text());
    return messageToBePushed;
  },
  pushChatSystemMsg: function (messageHtml) {
    if (
      messageHtml.search(eGainOneTagUtil.chatStartedPrefix) != -1 &&
      messageHtml.search(eGainOneTagUtil.chatStartedSuffix) != -1
    ) {
      var mode =
        window.location.search.search("video=1") != -1
          ? window.location.search.search("avmode=4") != -1
            ? "Audio"
            : "Video"
          : "Text";
      eGainOneTagUtil.pushChatEvent("aev", {
        EventName: "ChatEngaged",
        ChatType: mode,
      });
    }
    if (
      messageHtml.search(eGainOneTagUtil.chatAgentTransferPrefix) != -1 &&
      messageHtml.search(eGainOneTagUtil.chatAgentTransferSuffix) != -1
    ) {
      eGainOneTagUtil.pushChatEvent("ctx", {
        EventName: "ChatTransfer",
        TransferType: "Agent",
      });
      this.chatAwaitingAgentCaptured = false;
    }
    if (
      messageHtml.search(eGainOneTagUtil.chatQueueTransferPrefix) != -1 &&
      messageHtml.search(eGainOneTagUtil.chatQueueTransferSuffix) != -1
    ) {
      eGainOneTagUtil.pushChatEvent("ctx", {
        EventName: "ChatTransfer",
        TransferType: "Queue",
      });
      this.chatAwaitingAgentCaptured = false;
    }
    if (
      messageHtml.search(eGainOneTagUtil.chatDeptTransferPrefix) != -1 &&
      messageHtml.search(eGainOneTagUtil.chatDeptTransferSuffix) != -1
    ) {
      eGainOneTagUtil.pushChatEvent("ctx", {
        EventName: "ChatTransfer",
        TransferType: "Department",
      });
      this.chatAwaitingAgentCaptured = false;
    }
    if (
      messageHtml.search(eGainOneTagUtil.chatEndedPrefix) != -1 &&
      messageHtml.search(eGainOneTagUtil.chatEndedSuffix) != -1
    ) {
      eGainOneTagUtil.pushChatEvent("uac", {
        EventName: "ChatExit",
        "Termination-Initiation": "Agent",
      });
    }
    if (messageHtml.search(eGainOneTagUtil.systemTimeOutMessage) != -1) {
      eGainOneTagUtil.pushChatEvent("aev", {
        EventName: "ChatExit",
        "Termination-Initiation": "System",
      });
    }
  },
  chatAwaitingAgentCaptured: false,
  pushChatAwaitingMsg: function (waitTime) {
    if (this.chatAwaitingAgentCaptured === false) {
      eGainOneTagUtil.pushChatEvent("aev", {
        EventName: "ChatAwaitingAgent",
        EstimatedWaitTime: waitTime,
      });
      this.chatAwaitingAgentCaptured = true;
    }
    return this.chatAwaitingAgentCaptured;
  },
  pushChatEngagedMsg: function () {
    var mode =
      window.location.search.search("video=1") != -1 ? "Video" : "Text";
    eGainOneTagUtil.pushChatEvent("aev", {
      EventName: "ChatEngaged",
      ChatType: mode,
    });
  },
  parseMessages: function (messagingProperty) {
    if (messagingProperty) {
      var mesagingPropertyVariables = messagingProperty.split("\n");
      var foundStartChatString = false;
      var foundEndChatString = false;
      var foundTransferAgentString = false;
      var foundTransferQueueString = false;
      var foundTransferDeptString = false;
      var foundsystemTimeOutMsg = false;
      for (i = 0; i < mesagingPropertyVariables.length; i++) {
        if (mesagingPropertyVariables[i].indexOf("agent_join_msg") === 0) {
          var keyValuePair = mesagingPropertyVariables[i].split("=");
          var chatStartedString = $.trim(keyValuePair[1]);
          var temp = chatStartedString.split("{0}");
          eGainOneTagUtil.chatStartedPrefix = temp[0];
          eGainOneTagUtil.chatStartedSuffix = temp[1];
          foundStartChatString = true;
        } else if (
          mesagingPropertyVariables[i].indexOf("agent_transfer_msg") === 0
        ) {
          var keyValuePair = mesagingPropertyVariables[i].split("=");
          var chatTransferString = $.trim(keyValuePair[1]);
          var temp = chatTransferString.split("{0}");
          eGainOneTagUtil.chatAgentTransferPrefix = temp[0];
          eGainOneTagUtil.chatAgentTransferSuffix = temp[1];
          foundTransferAgentString = true;
        } else if (
          mesagingPropertyVariables[i].indexOf("queue_transfer_msg") === 0
        ) {
          var keyValuePair = mesagingPropertyVariables[i].split("=");
          var chatTransferString = $.trim(keyValuePair[1]);
          var temp = chatTransferString.split("{0}");
          eGainOneTagUtil.chatQueueTransferPrefix = temp[0];
          eGainOneTagUtil.chatQueueTransferSuffix = temp[1];
          foundTransferQueueString = true;
        } else if (
          mesagingPropertyVariables[i].indexOf("deptt_transfer_msg") === 0
        ) {
          var keyValuePair = mesagingPropertyVariables[i].split("=");
          var chatTransferString = $.trim(keyValuePair[1]);
          var temp = chatTransferString.split("{0}");
          eGainOneTagUtil.chatDeptTransferPrefix = temp[0];
          eGainOneTagUtil.chatDeptTransferSuffix = temp[1];
          foundTransferDeptString = true;
        } else if (
          mesagingPropertyVariables[i].indexOf("agent_close_session") === 0
        ) {
          var keyValuePair = mesagingPropertyVariables[i].split("=");
          var chatEndedString = $.trim(keyValuePair[1]);
          var temp = chatEndedString.split("{0}");
          eGainOneTagUtil.chatEndedPrefix = temp[0];
          eGainOneTagUtil.chatEndedSuffix = temp[1];
          foundEndChatString = true;
        } else if (
          mesagingPropertyVariables[i].indexOf("system_close_session") === 0
        ) {
          var keyValuePair = mesagingPropertyVariables[i].split("=");
          eGainOneTagUtil.systemTimeOutMessage = $.trim(keyValuePair[1]);
          foundsystemTimeOutMsg = true;
        } else if (
          foundStartChatString === true &&
          foundEndChatString === true &&
          foundsystemTimeOutMsg === true &&
          foundTransferAgentString === true &&
          foundTransferQueueString === true &&
          foundTransferDeptString === true
        )
          break;
      }
    }
  },
  disableTracker: function (eventType, eventInfo) {
    //to prevent OneTag Tracker default behaviour
    EG_CALL_Q = window.EG_CALL_Q || [];
    EG_CALL_Q.push(["disableTrackOnLoad"]);
  },
};
/*
CryptoJS v3.0.2
code.google.com/p/crypto-js
(c) 2009-2012 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS =
  CryptoJS ||
  (function (o, q) {
    var l = {},
      m = (l.lib = {}),
      n = (m.Base = (function () {
        function a() {}
        return {
          extend: function (e) {
            a.prototype = this;
            var c = new a();
            e && c.mixIn(e);
            c.$super = this;
            return c;
          },
          create: function () {
            var a = this.extend();
            a.init.apply(a, arguments);
            return a;
          },
          init: function () {},
          mixIn: function (a) {
            for (var c in a) a.hasOwnProperty(c) && (this[c] = a[c]);
            a.hasOwnProperty("toString") && (this.toString = a.toString);
          },
          clone: function () {
            return this.$super.extend(this);
          },
        };
      })()),
      j = (m.WordArray = n.extend({
        init: function (a, e) {
          a = this.words = a || [];
          this.sigBytes = e != q ? e : 4 * a.length;
        },
        toString: function (a) {
          return (a || r).stringify(this);
        },
        concat: function (a) {
          var e = this.words,
            c = a.words,
            d = this.sigBytes,
            a = a.sigBytes;
          this.clamp();
          if (d % 4)
            for (var b = 0; b < a; b++)
              e[(d + b) >>> 2] |=
                ((c[b >>> 2] >>> (24 - 8 * (b % 4))) & 255) <<
                (24 - 8 * ((d + b) % 4));
          else if (65535 < c.length)
            for (b = 0; b < a; b += 4) e[(d + b) >>> 2] = c[b >>> 2];
          else e.push.apply(e, c);
          this.sigBytes += a;
          return this;
        },
        clamp: function () {
          var a = this.words,
            e = this.sigBytes;
          a[e >>> 2] &= 4294967295 << (32 - 8 * (e % 4));
          a.length = o.ceil(e / 4);
        },
        clone: function () {
          var a = n.clone.call(this);
          a.words = this.words.slice(0);
          return a;
        },
        random: function (a) {
          for (var e = [], c = 0; c < a; c += 4)
            e.push((4294967296 * o.random()) | 0);
          return j.create(e, a);
        },
      })),
      k = (l.enc = {}),
      r = (k.Hex = {
        stringify: function (a) {
          for (var e = a.words, a = a.sigBytes, c = [], d = 0; d < a; d++) {
            var b = (e[d >>> 2] >>> (24 - 8 * (d % 4))) & 255;
            c.push((b >>> 4).toString(16));
            c.push((b & 15).toString(16));
          }
          return c.join("");
        },
        parse: function (a) {
          for (var b = a.length, c = [], d = 0; d < b; d += 2)
            c[d >>> 3] |= parseInt(a.substr(d, 2), 16) << (24 - 4 * (d % 8));
          return j.create(c, b / 2);
        },
      }),
      p = (k.Latin1 = {
        stringify: function (a) {
          for (var b = a.words, a = a.sigBytes, c = [], d = 0; d < a; d++)
            c.push(
              String.fromCharCode((b[d >>> 2] >>> (24 - 8 * (d % 4))) & 255)
            );
          return c.join("");
        },
        parse: function (a) {
          for (var b = a.length, c = [], d = 0; d < b; d++)
            c[d >>> 2] |= (a.charCodeAt(d) & 255) << (24 - 8 * (d % 4));
          return j.create(c, b);
        },
      }),
      h = (k.Utf8 = {
        stringify: function (a) {
          try {
            return decodeURIComponent(escape(p.stringify(a)));
          } catch (b) {
            throw Error("Malformed UTF-8 data");
          }
        },
        parse: function (a) {
          return p.parse(unescape(encodeURIComponent(a)));
        },
      }),
      b = (m.BufferedBlockAlgorithm = n.extend({
        reset: function () {
          this._data = j.create();
          this._nDataBytes = 0;
        },
        _append: function (a) {
          "string" == typeof a && (a = h.parse(a));
          this._data.concat(a);
          this._nDataBytes += a.sigBytes;
        },
        _process: function (a) {
          var b = this._data,
            c = b.words,
            d = b.sigBytes,
            f = this.blockSize,
            i = d / (4 * f),
            i = a ? o.ceil(i) : o.max((i | 0) - this._minBufferSize, 0),
            a = i * f,
            d = o.min(4 * a, d);
          if (a) {
            for (var h = 0; h < a; h += f) this._doProcessBlock(c, h);
            h = c.splice(0, a);
            b.sigBytes -= d;
          }
          return j.create(h, d);
        },
        clone: function () {
          var a = n.clone.call(this);
          a._data = this._data.clone();
          return a;
        },
        _minBufferSize: 0,
      }));
    m.Hasher = b.extend({
      init: function () {
        this.reset();
      },
      reset: function () {
        b.reset.call(this);
        this._doReset();
      },
      update: function (a) {
        this._append(a);
        this._process();
        return this;
      },
      finalize: function (a) {
        a && this._append(a);
        this._doFinalize();
        return this._hash;
      },
      clone: function () {
        var a = b.clone.call(this);
        a._hash = this._hash.clone();
        return a;
      },
      blockSize: 16,
      _createHelper: function (a) {
        return function (b, c) {
          return a.create(c).finalize(b);
        };
      },
      _createHmacHelper: function (a) {
        return function (b, c) {
          return f.HMAC.create(a, c).finalize(b);
        };
      },
    });
    var f = (l.algo = {});
    return l;
  })(Math);
(function (o) {
  function q(b, f, a, e, c, d, g) {
    b = b + ((f & a) | (~f & e)) + c + g;
    return ((b << d) | (b >>> (32 - d))) + f;
  }
  function l(b, f, a, e, c, d, g) {
    b = b + ((f & e) | (a & ~e)) + c + g;
    return ((b << d) | (b >>> (32 - d))) + f;
  }
  function m(b, f, a, e, c, d, g) {
    b = b + (f ^ a ^ e) + c + g;
    return ((b << d) | (b >>> (32 - d))) + f;
  }
  function n(b, f, a, e, c, d, g) {
    b = b + (a ^ (f | ~e)) + c + g;
    return ((b << d) | (b >>> (32 - d))) + f;
  }
  var j = CryptoJS,
    k = j.lib,
    r = k.WordArray,
    k = k.Hasher,
    p = j.algo,
    h = [];
  (function () {
    for (var b = 0; 64 > b; b++) h[b] = (4294967296 * o.abs(o.sin(b + 1))) | 0;
  })();
  p = p.MD5 = k.extend({
    _doReset: function () {
      this._hash = r.create([1732584193, 4023233417, 2562383102, 271733878]);
    },
    _doProcessBlock: function (b, f) {
      for (var a = 0; 16 > a; a++) {
        var e = f + a,
          c = b[e];
        b[e] =
          (((c << 8) | (c >>> 24)) & 16711935) |
          (((c << 24) | (c >>> 8)) & 4278255360);
      }
      for (
        var e = this._hash.words, c = e[0], d = e[1], g = e[2], i = e[3], a = 0;
        64 > a;
        a += 4
      )
        16 > a
          ? ((c = q(c, d, g, i, b[f + a], 7, h[a])),
            (i = q(i, c, d, g, b[f + a + 1], 12, h[a + 1])),
            (g = q(g, i, c, d, b[f + a + 2], 17, h[a + 2])),
            (d = q(d, g, i, c, b[f + a + 3], 22, h[a + 3])))
          : 32 > a
          ? ((c = l(c, d, g, i, b[f + ((a + 1) % 16)], 5, h[a])),
            (i = l(i, c, d, g, b[f + ((a + 6) % 16)], 9, h[a + 1])),
            (g = l(g, i, c, d, b[f + ((a + 11) % 16)], 14, h[a + 2])),
            (d = l(d, g, i, c, b[f + (a % 16)], 20, h[a + 3])))
          : 48 > a
          ? ((c = m(c, d, g, i, b[f + ((3 * a + 5) % 16)], 4, h[a])),
            (i = m(i, c, d, g, b[f + ((3 * a + 8) % 16)], 11, h[a + 1])),
            (g = m(g, i, c, d, b[f + ((3 * a + 11) % 16)], 16, h[a + 2])),
            (d = m(d, g, i, c, b[f + ((3 * a + 14) % 16)], 23, h[a + 3])))
          : ((c = n(c, d, g, i, b[f + ((3 * a) % 16)], 6, h[a])),
            (i = n(i, c, d, g, b[f + ((3 * a + 7) % 16)], 10, h[a + 1])),
            (g = n(g, i, c, d, b[f + ((3 * a + 14) % 16)], 15, h[a + 2])),
            (d = n(d, g, i, c, b[f + ((3 * a + 5) % 16)], 21, h[a + 3])));
      e[0] = (e[0] + c) | 0;
      e[1] = (e[1] + d) | 0;
      e[2] = (e[2] + g) | 0;
      e[3] = (e[3] + i) | 0;
    },
    _doFinalize: function () {
      var b = this._data,
        f = b.words,
        a = 8 * this._nDataBytes,
        e = 8 * b.sigBytes;
      f[e >>> 5] |= 128 << (24 - (e % 32));
      f[(((e + 64) >>> 9) << 4) + 14] =
        (((a << 8) | (a >>> 24)) & 16711935) |
        (((a << 24) | (a >>> 8)) & 4278255360);
      b.sigBytes = 4 * (f.length + 1);
      this._process();
      b = this._hash.words;
      for (f = 0; 4 > f; f++)
        (a = b[f]),
          (b[f] =
            (((a << 8) | (a >>> 24)) & 16711935) |
            (((a << 24) | (a >>> 8)) & 4278255360));
    },
  });
  j.MD5 = k._createHelper(p);
  j.HmacMD5 = k._createHmacHelper(p);
})(Math);

/*

Copyright (C) 2011 by Yehuda Katz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

// lib/handlebars/base.js

/*jshint eqnull:true*/
this.Handlebars = {};

(function (Handlebars) {
  Handlebars.VERSION = "1.0.0-rc.3";
  Handlebars.COMPILER_REVISION = 2;

  Handlebars.REVISION_CHANGES = {
    1: "<= 1.0.rc.2", // 1.0.rc.2 is actually rev2 but doesn't report it
    2: ">= 1.0.0-rc.3",
  };

  Handlebars.helpers = {};
  Handlebars.partials = {};

  Handlebars.registerHelper = function (name, fn, inverse) {
    if (inverse) {
      fn.not = inverse;
    }
    this.helpers[name] = fn;
  };

  Handlebars.registerPartial = function (name, str) {
    this.partials[name] = str;
  };

  Handlebars.registerHelper("helperMissing", function (arg) {
    if (arguments.length === 2) {
      return undefined;
    } else {
      throw new Error("Could not find property '" + arg + "'");
    }
  });

  var toString = Object.prototype.toString,
    functionType = "[object Function]";

  Handlebars.registerHelper("blockHelperMissing", function (context, options) {
    var inverse = options.inverse || function () {},
      fn = options.fn;

    var ret = "";
    var type = toString.call(context);

    if (type === functionType) {
      context = context.call(this);
    }

    if (context === true) {
      return fn(this);
    } else if (context === false || context == null) {
      return inverse(this);
    } else if (type === "[object Array]") {
      if (context.length > 0) {
        return Handlebars.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      return fn(context);
    }
  });

  Handlebars.K = function () {};

  Handlebars.createFrame =
    Object.create ||
    function (object) {
      Handlebars.K.prototype = object;
      var obj = new Handlebars.K();
      Handlebars.K.prototype = null;
      return obj;
    };

  Handlebars.logger = {
    DEBUG: 0,
    INFO: 1,
    WARN: 2,
    ERROR: 3,
    level: 3,

    methodMap: { 0: "debug", 1: "info", 2: "warn", 3: "error" },

    // can be overridden in the host environment
    log: function (level, obj) {
      if (Handlebars.logger.level <= level) {
        var method = Handlebars.logger.methodMap[level];
        if (typeof console !== "undefined" && console[method]) {
          console[method].call(console, obj);
        }
      }
    },
  };

  Handlebars.log = function (level, obj) {
    Handlebars.logger.log(level, obj);
  };

  Handlebars.registerHelper("each", function (context, options) {
    var fn = options.fn,
      inverse = options.inverse;
    var i = 0,
      ret = "",
      data;

    if (options.data) {
      data = Handlebars.createFrame(options.data);
    }

    if (context && typeof context === "object") {
      if (context instanceof Array) {
        for (var j = context.length; i < j; i++) {
          if (data) {
            data.index = i;
          }
          ret = ret + fn(context[i], { data: data });
        }
      } else {
        for (var key in context) {
          if (context.hasOwnProperty(key)) {
            if (data) {
              data.key = key;
            }
            ret = ret + fn(context[key], { data: data });
            i++;
          }
        }
      }
    }

    if (i === 0) {
      ret = inverse(this);
    }

    return ret;
  });

  Handlebars.registerHelper("if", function (context, options) {
    var type = toString.call(context);
    if (type === functionType) {
      context = context.call(this);
    }

    if (!context || Handlebars.Utils.isEmpty(context)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });

  Handlebars.registerHelper("unless", function (context, options) {
    var fn = options.fn,
      inverse = options.inverse;
    options.fn = inverse;
    options.inverse = fn;

    return Handlebars.helpers["if"].call(this, context, options);
  });

  Handlebars.registerHelper("with", function (context, options) {
    return options.fn(context);
  });

  Handlebars.registerHelper("log", function (context, options) {
    var level =
      options.data && options.data.level != null
        ? parseInt(options.data.level, 10)
        : 1;
    Handlebars.log(level, context);
  });
})(this.Handlebars);
// lib/handlebars/compiler/parser.js
/* Jison generated parser */
var handlebars = (function () {
  var parser = {
    trace: function trace() {},
    yy: {},
    symbols_: {
      error: 2,
      root: 3,
      program: 4,
      EOF: 5,
      simpleInverse: 6,
      statements: 7,
      statement: 8,
      openInverse: 9,
      closeBlock: 10,
      openBlock: 11,
      mustache: 12,
      partial: 13,
      CONTENT: 14,
      COMMENT: 15,
      OPEN_BLOCK: 16,
      inMustache: 17,
      CLOSE: 18,
      OPEN_INVERSE: 19,
      OPEN_ENDBLOCK: 20,
      path: 21,
      OPEN: 22,
      OPEN_UNESCAPED: 23,
      OPEN_PARTIAL: 24,
      partialName: 25,
      params: 26,
      hash: 27,
      DATA: 28,
      param: 29,
      STRING: 30,
      INTEGER: 31,
      BOOLEAN: 32,
      hashSegments: 33,
      hashSegment: 34,
      ID: 35,
      EQUALS: 36,
      PARTIAL_NAME: 37,
      pathSegments: 38,
      SEP: 39,
      $accept: 0,
      $end: 1,
    },
    terminals_: {
      2: "error",
      5: "EOF",
      14: "CONTENT",
      15: "COMMENT",
      16: "OPEN_BLOCK",
      18: "CLOSE",
      19: "OPEN_INVERSE",
      20: "OPEN_ENDBLOCK",
      22: "OPEN",
      23: "OPEN_UNESCAPED",
      24: "OPEN_PARTIAL",
      28: "DATA",
      30: "STRING",
      31: "INTEGER",
      32: "BOOLEAN",
      35: "ID",
      36: "EQUALS",
      37: "PARTIAL_NAME",
      39: "SEP",
    },
    productions_: [
      0,
      [3, 2],
      [4, 2],
      [4, 3],
      [4, 2],
      [4, 1],
      [4, 1],
      [4, 0],
      [7, 1],
      [7, 2],
      [8, 3],
      [8, 3],
      [8, 1],
      [8, 1],
      [8, 1],
      [8, 1],
      [11, 3],
      [9, 3],
      [10, 3],
      [12, 3],
      [12, 3],
      [13, 3],
      [13, 4],
      [6, 2],
      [17, 3],
      [17, 2],
      [17, 2],
      [17, 1],
      [17, 1],
      [26, 2],
      [26, 1],
      [29, 1],
      [29, 1],
      [29, 1],
      [29, 1],
      [29, 1],
      [27, 1],
      [33, 2],
      [33, 1],
      [34, 3],
      [34, 3],
      [34, 3],
      [34, 3],
      [34, 3],
      [25, 1],
      [21, 1],
      [38, 3],
      [38, 1],
    ],
    performAction: function anonymous(
      yytext,
      yyleng,
      yylineno,
      yy,
      yystate,
      $$,
      _$
    ) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 1:
          return $$[$0 - 1];
          break;
        case 2:
          this.$ = new yy.ProgramNode([], $$[$0]);
          break;
        case 3:
          this.$ = new yy.ProgramNode($$[$0 - 2], $$[$0]);
          break;
        case 4:
          this.$ = new yy.ProgramNode($$[$0 - 1], []);
          break;
        case 5:
          this.$ = new yy.ProgramNode($$[$0]);
          break;
        case 6:
          this.$ = new yy.ProgramNode([], []);
          break;
        case 7:
          this.$ = new yy.ProgramNode([]);
          break;
        case 8:
          this.$ = [$$[$0]];
          break;
        case 9:
          $$[$0 - 1].push($$[$0]);
          this.$ = $$[$0 - 1];
          break;
        case 10:
          this.$ = new yy.BlockNode(
            $$[$0 - 2],
            $$[$0 - 1].inverse,
            $$[$0 - 1],
            $$[$0]
          );
          break;
        case 11:
          this.$ = new yy.BlockNode(
            $$[$0 - 2],
            $$[$0 - 1],
            $$[$0 - 1].inverse,
            $$[$0]
          );
          break;
        case 12:
          this.$ = $$[$0];
          break;
        case 13:
          this.$ = $$[$0];
          break;
        case 14:
          this.$ = new yy.ContentNode($$[$0]);
          break;
        case 15:
          this.$ = new yy.CommentNode($$[$0]);
          break;
        case 16:
          this.$ = new yy.MustacheNode($$[$0 - 1][0], $$[$0 - 1][1]);
          break;
        case 17:
          this.$ = new yy.MustacheNode($$[$0 - 1][0], $$[$0 - 1][1]);
          break;
        case 18:
          this.$ = $$[$0 - 1];
          break;
        case 19:
          this.$ = new yy.MustacheNode($$[$0 - 1][0], $$[$0 - 1][1]);
          break;
        case 20:
          this.$ = new yy.MustacheNode($$[$0 - 1][0], $$[$0 - 1][1], true);
          break;
        case 21:
          this.$ = new yy.PartialNode($$[$0 - 1]);
          break;
        case 22:
          this.$ = new yy.PartialNode($$[$0 - 2], $$[$0 - 1]);
          break;
        case 23:
          break;
        case 24:
          this.$ = [[$$[$0 - 2]].concat($$[$0 - 1]), $$[$0]];
          break;
        case 25:
          this.$ = [[$$[$0 - 1]].concat($$[$0]), null];
          break;
        case 26:
          this.$ = [[$$[$0 - 1]], $$[$0]];
          break;
        case 27:
          this.$ = [[$$[$0]], null];
          break;
        case 28:
          this.$ = [[new yy.DataNode($$[$0])], null];
          break;
        case 29:
          $$[$0 - 1].push($$[$0]);
          this.$ = $$[$0 - 1];
          break;
        case 30:
          this.$ = [$$[$0]];
          break;
        case 31:
          this.$ = $$[$0];
          break;
        case 32:
          this.$ = new yy.StringNode($$[$0]);
          break;
        case 33:
          this.$ = new yy.IntegerNode($$[$0]);
          break;
        case 34:
          this.$ = new yy.BooleanNode($$[$0]);
          break;
        case 35:
          this.$ = new yy.DataNode($$[$0]);
          break;
        case 36:
          this.$ = new yy.HashNode($$[$0]);
          break;
        case 37:
          $$[$0 - 1].push($$[$0]);
          this.$ = $$[$0 - 1];
          break;
        case 38:
          this.$ = [$$[$0]];
          break;
        case 39:
          this.$ = [$$[$0 - 2], $$[$0]];
          break;
        case 40:
          this.$ = [$$[$0 - 2], new yy.StringNode($$[$0])];
          break;
        case 41:
          this.$ = [$$[$0 - 2], new yy.IntegerNode($$[$0])];
          break;
        case 42:
          this.$ = [$$[$0 - 2], new yy.BooleanNode($$[$0])];
          break;
        case 43:
          this.$ = [$$[$0 - 2], new yy.DataNode($$[$0])];
          break;
        case 44:
          this.$ = new yy.PartialNameNode($$[$0]);
          break;
        case 45:
          this.$ = new yy.IdNode($$[$0]);
          break;
        case 46:
          $$[$0 - 2].push($$[$0]);
          this.$ = $$[$0 - 2];
          break;
        case 47:
          this.$ = [$$[$0]];
          break;
      }
    },
    table: [
      {
        3: 1,
        4: 2,
        5: [2, 7],
        6: 3,
        7: 4,
        8: 6,
        9: 7,
        11: 8,
        12: 9,
        13: 10,
        14: [1, 11],
        15: [1, 12],
        16: [1, 13],
        19: [1, 5],
        22: [1, 14],
        23: [1, 15],
        24: [1, 16],
      },
      { 1: [3] },
      { 5: [1, 17] },
      {
        5: [2, 6],
        7: 18,
        8: 6,
        9: 7,
        11: 8,
        12: 9,
        13: 10,
        14: [1, 11],
        15: [1, 12],
        16: [1, 13],
        19: [1, 19],
        20: [2, 6],
        22: [1, 14],
        23: [1, 15],
        24: [1, 16],
      },
      {
        5: [2, 5],
        6: 20,
        8: 21,
        9: 7,
        11: 8,
        12: 9,
        13: 10,
        14: [1, 11],
        15: [1, 12],
        16: [1, 13],
        19: [1, 5],
        20: [2, 5],
        22: [1, 14],
        23: [1, 15],
        24: [1, 16],
      },
      { 17: 23, 18: [1, 22], 21: 24, 28: [1, 25], 35: [1, 27], 38: 26 },
      {
        5: [2, 8],
        14: [2, 8],
        15: [2, 8],
        16: [2, 8],
        19: [2, 8],
        20: [2, 8],
        22: [2, 8],
        23: [2, 8],
        24: [2, 8],
      },
      {
        4: 28,
        6: 3,
        7: 4,
        8: 6,
        9: 7,
        11: 8,
        12: 9,
        13: 10,
        14: [1, 11],
        15: [1, 12],
        16: [1, 13],
        19: [1, 5],
        20: [2, 7],
        22: [1, 14],
        23: [1, 15],
        24: [1, 16],
      },
      {
        4: 29,
        6: 3,
        7: 4,
        8: 6,
        9: 7,
        11: 8,
        12: 9,
        13: 10,
        14: [1, 11],
        15: [1, 12],
        16: [1, 13],
        19: [1, 5],
        20: [2, 7],
        22: [1, 14],
        23: [1, 15],
        24: [1, 16],
      },
      {
        5: [2, 12],
        14: [2, 12],
        15: [2, 12],
        16: [2, 12],
        19: [2, 12],
        20: [2, 12],
        22: [2, 12],
        23: [2, 12],
        24: [2, 12],
      },
      {
        5: [2, 13],
        14: [2, 13],
        15: [2, 13],
        16: [2, 13],
        19: [2, 13],
        20: [2, 13],
        22: [2, 13],
        23: [2, 13],
        24: [2, 13],
      },
      {
        5: [2, 14],
        14: [2, 14],
        15: [2, 14],
        16: [2, 14],
        19: [2, 14],
        20: [2, 14],
        22: [2, 14],
        23: [2, 14],
        24: [2, 14],
      },
      {
        5: [2, 15],
        14: [2, 15],
        15: [2, 15],
        16: [2, 15],
        19: [2, 15],
        20: [2, 15],
        22: [2, 15],
        23: [2, 15],
        24: [2, 15],
      },
      { 17: 30, 21: 24, 28: [1, 25], 35: [1, 27], 38: 26 },
      { 17: 31, 21: 24, 28: [1, 25], 35: [1, 27], 38: 26 },
      { 17: 32, 21: 24, 28: [1, 25], 35: [1, 27], 38: 26 },
      { 25: 33, 37: [1, 34] },
      { 1: [2, 1] },
      {
        5: [2, 2],
        8: 21,
        9: 7,
        11: 8,
        12: 9,
        13: 10,
        14: [1, 11],
        15: [1, 12],
        16: [1, 13],
        19: [1, 19],
        20: [2, 2],
        22: [1, 14],
        23: [1, 15],
        24: [1, 16],
      },
      { 17: 23, 21: 24, 28: [1, 25], 35: [1, 27], 38: 26 },
      {
        5: [2, 4],
        7: 35,
        8: 6,
        9: 7,
        11: 8,
        12: 9,
        13: 10,
        14: [1, 11],
        15: [1, 12],
        16: [1, 13],
        19: [1, 19],
        20: [2, 4],
        22: [1, 14],
        23: [1, 15],
        24: [1, 16],
      },
      {
        5: [2, 9],
        14: [2, 9],
        15: [2, 9],
        16: [2, 9],
        19: [2, 9],
        20: [2, 9],
        22: [2, 9],
        23: [2, 9],
        24: [2, 9],
      },
      {
        5: [2, 23],
        14: [2, 23],
        15: [2, 23],
        16: [2, 23],
        19: [2, 23],
        20: [2, 23],
        22: [2, 23],
        23: [2, 23],
        24: [2, 23],
      },
      { 18: [1, 36] },
      {
        18: [2, 27],
        21: 41,
        26: 37,
        27: 38,
        28: [1, 45],
        29: 39,
        30: [1, 42],
        31: [1, 43],
        32: [1, 44],
        33: 40,
        34: 46,
        35: [1, 47],
        38: 26,
      },
      { 18: [2, 28] },
      {
        18: [2, 45],
        28: [2, 45],
        30: [2, 45],
        31: [2, 45],
        32: [2, 45],
        35: [2, 45],
        39: [1, 48],
      },
      {
        18: [2, 47],
        28: [2, 47],
        30: [2, 47],
        31: [2, 47],
        32: [2, 47],
        35: [2, 47],
        39: [2, 47],
      },
      { 10: 49, 20: [1, 50] },
      { 10: 51, 20: [1, 50] },
      { 18: [1, 52] },
      { 18: [1, 53] },
      { 18: [1, 54] },
      { 18: [1, 55], 21: 56, 35: [1, 27], 38: 26 },
      { 18: [2, 44], 35: [2, 44] },
      {
        5: [2, 3],
        8: 21,
        9: 7,
        11: 8,
        12: 9,
        13: 10,
        14: [1, 11],
        15: [1, 12],
        16: [1, 13],
        19: [1, 19],
        20: [2, 3],
        22: [1, 14],
        23: [1, 15],
        24: [1, 16],
      },
      {
        14: [2, 17],
        15: [2, 17],
        16: [2, 17],
        19: [2, 17],
        20: [2, 17],
        22: [2, 17],
        23: [2, 17],
        24: [2, 17],
      },
      {
        18: [2, 25],
        21: 41,
        27: 57,
        28: [1, 45],
        29: 58,
        30: [1, 42],
        31: [1, 43],
        32: [1, 44],
        33: 40,
        34: 46,
        35: [1, 47],
        38: 26,
      },
      { 18: [2, 26] },
      {
        18: [2, 30],
        28: [2, 30],
        30: [2, 30],
        31: [2, 30],
        32: [2, 30],
        35: [2, 30],
      },
      { 18: [2, 36], 34: 59, 35: [1, 60] },
      {
        18: [2, 31],
        28: [2, 31],
        30: [2, 31],
        31: [2, 31],
        32: [2, 31],
        35: [2, 31],
      },
      {
        18: [2, 32],
        28: [2, 32],
        30: [2, 32],
        31: [2, 32],
        32: [2, 32],
        35: [2, 32],
      },
      {
        18: [2, 33],
        28: [2, 33],
        30: [2, 33],
        31: [2, 33],
        32: [2, 33],
        35: [2, 33],
      },
      {
        18: [2, 34],
        28: [2, 34],
        30: [2, 34],
        31: [2, 34],
        32: [2, 34],
        35: [2, 34],
      },
      {
        18: [2, 35],
        28: [2, 35],
        30: [2, 35],
        31: [2, 35],
        32: [2, 35],
        35: [2, 35],
      },
      { 18: [2, 38], 35: [2, 38] },
      {
        18: [2, 47],
        28: [2, 47],
        30: [2, 47],
        31: [2, 47],
        32: [2, 47],
        35: [2, 47],
        36: [1, 61],
        39: [2, 47],
      },
      { 35: [1, 62] },
      {
        5: [2, 10],
        14: [2, 10],
        15: [2, 10],
        16: [2, 10],
        19: [2, 10],
        20: [2, 10],
        22: [2, 10],
        23: [2, 10],
        24: [2, 10],
      },
      { 21: 63, 35: [1, 27], 38: 26 },
      {
        5: [2, 11],
        14: [2, 11],
        15: [2, 11],
        16: [2, 11],
        19: [2, 11],
        20: [2, 11],
        22: [2, 11],
        23: [2, 11],
        24: [2, 11],
      },
      {
        14: [2, 16],
        15: [2, 16],
        16: [2, 16],
        19: [2, 16],
        20: [2, 16],
        22: [2, 16],
        23: [2, 16],
        24: [2, 16],
      },
      {
        5: [2, 19],
        14: [2, 19],
        15: [2, 19],
        16: [2, 19],
        19: [2, 19],
        20: [2, 19],
        22: [2, 19],
        23: [2, 19],
        24: [2, 19],
      },
      {
        5: [2, 20],
        14: [2, 20],
        15: [2, 20],
        16: [2, 20],
        19: [2, 20],
        20: [2, 20],
        22: [2, 20],
        23: [2, 20],
        24: [2, 20],
      },
      {
        5: [2, 21],
        14: [2, 21],
        15: [2, 21],
        16: [2, 21],
        19: [2, 21],
        20: [2, 21],
        22: [2, 21],
        23: [2, 21],
        24: [2, 21],
      },
      { 18: [1, 64] },
      { 18: [2, 24] },
      {
        18: [2, 29],
        28: [2, 29],
        30: [2, 29],
        31: [2, 29],
        32: [2, 29],
        35: [2, 29],
      },
      { 18: [2, 37], 35: [2, 37] },
      { 36: [1, 61] },
      {
        21: 65,
        28: [1, 69],
        30: [1, 66],
        31: [1, 67],
        32: [1, 68],
        35: [1, 27],
        38: 26,
      },
      {
        18: [2, 46],
        28: [2, 46],
        30: [2, 46],
        31: [2, 46],
        32: [2, 46],
        35: [2, 46],
        39: [2, 46],
      },
      { 18: [1, 70] },
      {
        5: [2, 22],
        14: [2, 22],
        15: [2, 22],
        16: [2, 22],
        19: [2, 22],
        20: [2, 22],
        22: [2, 22],
        23: [2, 22],
        24: [2, 22],
      },
      { 18: [2, 39], 35: [2, 39] },
      { 18: [2, 40], 35: [2, 40] },
      { 18: [2, 41], 35: [2, 41] },
      { 18: [2, 42], 35: [2, 42] },
      { 18: [2, 43], 35: [2, 43] },
      {
        5: [2, 18],
        14: [2, 18],
        15: [2, 18],
        16: [2, 18],
        19: [2, 18],
        20: [2, 18],
        22: [2, 18],
        23: [2, 18],
        24: [2, 18],
      },
    ],
    defaultActions: { 17: [2, 1], 25: [2, 28], 38: [2, 26], 57: [2, 24] },
    parseError: function parseError(str, hash) {
      throw new Error(str);
    },
    parse: function parse(input) {
      var self = this,
        stack = [0],
        vstack = [null],
        lstack = [],
        table = this.table,
        yytext = "",
        yylineno = 0,
        yyleng = 0,
        recovering = 0,
        TERROR = 2,
        EOF = 1;
      this.lexer.setInput(input);
      this.lexer.yy = this.yy;
      this.yy.lexer = this.lexer;
      this.yy.parser = this;
      if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
      var yyloc = this.lexer.yylloc;
      lstack.push(yyloc);
      var ranges = this.lexer.options && this.lexer.options.ranges;
      if (typeof this.yy.parseError === "function")
        this.parseError = this.yy.parseError;
      function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
      }
      function lex() {
        var token;
        token = self.lexer.lex() || 1;
        if (typeof token !== "number") {
          token = self.symbols_[token] || token;
        }
        return token;
      }
      var symbol,
        preErrorSymbol,
        state,
        action,
        a,
        r,
        yyval = {},
        p,
        len,
        newState,
        expected;
      while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol === null || typeof symbol == "undefined") {
            symbol = lex();
          }
          action = table[state] && table[state][symbol];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          if (!recovering) {
            expected = [];
            for (p in table[state])
              if (this.terminals_[p] && p > 2) {
                expected.push("'" + this.terminals_[p] + "'");
              }
            if (this.lexer.showPosition) {
              errStr =
                "Parse error on line " +
                (yylineno + 1) +
                ":\n" +
                this.lexer.showPosition() +
                "\nExpecting " +
                expected.join(", ") +
                ", got '" +
                (this.terminals_[symbol] || symbol) +
                "'";
            } else {
              errStr =
                "Parse error on line " +
                (yylineno + 1) +
                ": Unexpected " +
                (symbol == 1
                  ? "end of input"
                  : "'" + (this.terminals_[symbol] || symbol) + "'");
            }
            this.parseError(errStr, {
              text: this.lexer.match,
              token: this.terminals_[symbol] || symbol,
              line: this.lexer.yylineno,
              loc: yyloc,
              expected: expected,
            });
          }
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error(
            "Parse Error: multiple actions possible at state: " +
              state +
              ", token: " +
              symbol
          );
        }
        switch (action[0]) {
          case 1:
            stack.push(symbol);
            vstack.push(this.lexer.yytext);
            lstack.push(this.lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
              yyleng = this.lexer.yyleng;
              yytext = this.lexer.yytext;
              yylineno = this.lexer.yylineno;
              yyloc = this.lexer.yylloc;
              if (recovering > 0) recovering--;
            } else {
              symbol = preErrorSymbol;
              preErrorSymbol = null;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column,
            };
            if (ranges) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1],
              ];
            }
            r = this.performAction.call(
              yyval,
              yytext,
              yyleng,
              yylineno,
              this.yy,
              action[1],
              vstack,
              lstack
            );
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack = stack.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    },
  };
  /* Jison generated lexer */
  var lexer = (function () {
    var lexer = {
      EOF: 1,
      parseError: function parseError(str, hash) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash);
        } else {
          throw new Error(str);
        }
      },
      setInput: function (input) {
        this._input = input;
        this._more = this._less = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0,
        };
        if (this.options.ranges) this.yylloc.range = [0, 0];
        this.offset = 0;
        return this;
      },
      input: function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) this.yylloc.range[1]++;

        this._input = this._input.slice(1);
        return ch;
      },
      unput: function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) this.yylineno -= lines.length - 1;
        var r = this.yylloc.range;

        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines
            ? (lines.length === oldLines.length
                ? this.yylloc.first_column
                : 0) +
              oldLines[oldLines.length - lines.length].length -
              lines[0].length
            : this.yylloc.first_column - len,
        };

        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        return this;
      },
      more: function () {
        this._more = true;
        return this;
      },
      less: function (n) {
        this.unput(this.match.slice(n));
      },
      pastInput: function () {
        var past = this.matched.substr(
          0,
          this.matched.length - this.match.length
        );
        return (
          (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "")
        );
      },
      upcomingInput: function () {
        var next = this.match;
        if (next.length < 20) {
          next += this._input.substr(0, 20 - next.length);
        }
        return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(
          /\n/g,
          ""
        );
      },
      showPosition: function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
      },
      next: function () {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) this.done = true;

        var token, match, tempMatch, index, col, lines;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index = i;
            if (!this.options.flex) break;
          }
        }
        if (match) {
          lines = match[0].match(/(?:\r\n?|\n).*/g);
          if (lines) this.yylineno += lines.length;
          this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines
              ? lines[lines.length - 1].length -
                lines[lines.length - 1].match(/\r?\n?/)[0].length
              : this.yylloc.last_column + match[0].length,
          };
          this.yytext += match[0];
          this.match += match[0];
          this.matches = match;
          this.yyleng = this.yytext.length;
          if (this.options.ranges) {
            this.yylloc.range = [this.offset, (this.offset += this.yyleng)];
          }
          this._more = false;
          this._input = this._input.slice(match[0].length);
          this.matched += match[0];
          token = this.performAction.call(
            this,
            this.yy,
            this,
            rules[index],
            this.conditionStack[this.conditionStack.length - 1]
          );
          if (this.done && this._input) this.done = false;
          if (token) return token;
          else return;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError(
            "Lexical error on line " +
              (this.yylineno + 1) +
              ". Unrecognized text.\n" +
              this.showPosition(),
            { text: "", token: null, line: this.yylineno }
          );
        }
      },
      lex: function lex() {
        var r = this.next();
        if (typeof r !== "undefined") {
          return r;
        } else {
          return this.lex();
        }
      },
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      popState: function popState() {
        return this.conditionStack.pop();
      },
      _currentRules: function _currentRules() {
        return this.conditions[
          this.conditionStack[this.conditionStack.length - 1]
        ].rules;
      },
      topState: function () {
        return this.conditionStack[this.conditionStack.length - 2];
      },
      pushState: function begin(condition) {
        this.begin(condition);
      },
    };
    lexer.options = {};
    lexer.performAction = function anonymous(
      yy,
      yy_,
      $avoiding_name_collisions,
      YY_START
    ) {
      var YYSTATE = YY_START;
      switch ($avoiding_name_collisions) {
        case 0:
          if (yy_.yytext.slice(-1) !== "\\") this.begin("mu");
          if (yy_.yytext.slice(-1) === "\\")
            (yy_.yytext = yy_.yytext.substr(0, yy_.yyleng - 1)),
              this.begin("emu");
          if (yy_.yytext) return 14;

          break;
        case 1:
          return 14;
          break;
        case 2:
          if (yy_.yytext.slice(-1) !== "\\") this.popState();
          if (yy_.yytext.slice(-1) === "\\")
            yy_.yytext = yy_.yytext.substr(0, yy_.yyleng - 1);
          return 14;

          break;
        case 3:
          yy_.yytext = yy_.yytext.substr(0, yy_.yyleng - 4);
          this.popState();
          return 15;
          break;
        case 4:
          this.begin("par");
          return 24;
          break;
        case 5:
          return 16;
          break;
        case 6:
          return 20;
          break;
        case 7:
          return 19;
          break;
        case 8:
          return 19;
          break;
        case 9:
          return 23;
          break;
        case 10:
          return 23;
          break;
        case 11:
          this.popState();
          this.begin("com");
          break;
        case 12:
          yy_.yytext = yy_.yytext.substr(3, yy_.yyleng - 5);
          this.popState();
          return 15;
          break;
        case 13:
          return 22;
          break;
        case 14:
          return 36;
          break;
        case 15:
          return 35;
          break;
        case 16:
          return 35;
          break;
        case 17:
          return 39;
          break;
        case 18 /*ignore whitespace*/:
          break;
        case 19:
          this.popState();
          return 18;
          break;
        case 20:
          this.popState();
          return 18;
          break;
        case 21:
          yy_.yytext = yy_.yytext
            .substr(1, yy_.yyleng - 2)
            .replace(/\\"/g, '"');
          return 30;
          break;
        case 22:
          yy_.yytext = yy_.yytext
            .substr(1, yy_.yyleng - 2)
            .replace(/\\'/g, "'");
          return 30;
          break;
        case 23:
          yy_.yytext = yy_.yytext.substr(1);
          return 28;
          break;
        case 24:
          return 32;
          break;
        case 25:
          return 32;
          break;
        case 26:
          return 31;
          break;
        case 27:
          return 35;
          break;
        case 28:
          yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2);
          return 35;
          break;
        case 29:
          return "INVALID";
          break;
        case 30 /*ignore whitespace*/:
          break;
        case 31:
          this.popState();
          return 37;
          break;
        case 32:
          return 5;
          break;
      }
    };
    lexer.rules = [
      /^(?:[^\x00]*?(?=(\{\{)))/,
      /^(?:[^\x00]+)/,
      /^(?:[^\x00]{2,}?(?=(\{\{|$)))/,
      /^(?:[\s\S]*?--\}\})/,
      /^(?:\{\{>)/,
      /^(?:\{\{#)/,
      /^(?:\{\{\/)/,
      /^(?:\{\{\^)/,
      /^(?:\{\{\s*else\b)/,
      /^(?:\{\{\{)/,
      /^(?:\{\{&)/,
      /^(?:\{\{!--)/,
      /^(?:\{\{![\s\S]*?\}\})/,
      /^(?:\{\{)/,
      /^(?:=)/,
      /^(?:\.(?=[} ]))/,
      /^(?:\.\.)/,
      /^(?:[\/.])/,
      /^(?:\s+)/,
      /^(?:\}\}\})/,
      /^(?:\}\})/,
      /^(?:"(\\["]|[^"])*")/,
      /^(?:'(\\[']|[^'])*')/,
      /^(?:@[a-zA-Z]+)/,
      /^(?:true(?=[}\s]))/,
      /^(?:false(?=[}\s]))/,
      /^(?:[0-9]+(?=[}\s]))/,
      /^(?:[a-zA-Z0-9_$-]+(?=[=}\s\/.]))/,
      /^(?:\[[^\]]*\])/,
      /^(?:.)/,
      /^(?:\s+)/,
      /^(?:[a-zA-Z0-9_$-/]+)/,
      /^(?:$)/,
    ];
    lexer.conditions = {
      mu: {
        rules: [
          4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
          23, 24, 25, 26, 27, 28, 29, 32,
        ],
        inclusive: false,
      },
      emu: { rules: [2], inclusive: false },
      com: { rules: [3], inclusive: false },
      par: { rules: [30, 31], inclusive: false },
      INITIAL: { rules: [0, 1, 32], inclusive: true },
    };
    return lexer;
  })();
  parser.lexer = lexer;
  function Parser() {
    this.yy = {};
  }
  Parser.prototype = parser;
  parser.Parser = Parser;
  return new Parser();
})();
// lib/handlebars/compiler/base.js
Handlebars.Parser = handlebars;

Handlebars.parse = function (input) {
  // Just return if an already-compile AST was passed in.
  if (input.constructor === Handlebars.AST.ProgramNode) {
    return input;
  }

  Handlebars.Parser.yy = Handlebars.AST;
  return Handlebars.Parser.parse(input);
};

Handlebars.print = function (ast) {
  return new Handlebars.PrintVisitor().accept(ast);
};
// lib/handlebars/compiler/ast.js
(function () {
  Handlebars.AST = {};

  Handlebars.AST.ProgramNode = function (statements, inverse) {
    this.type = "program";
    this.statements = statements;
    if (inverse) {
      this.inverse = new Handlebars.AST.ProgramNode(inverse);
    }
  };

  Handlebars.AST.MustacheNode = function (rawParams, hash, unescaped) {
    this.type = "mustache";
    this.escaped = !unescaped;
    this.hash = hash;

    var id = (this.id = rawParams[0]);
    var params = (this.params = rawParams.slice(1));

    // a mustache is an eligible helper if:
    // * its id is simple (a single part, not `this` or `..`)
    var eligibleHelper = (this.eligibleHelper = id.isSimple);

    // a mustache is definitely a helper if:
    // * it is an eligible helper, and
    // * it has at least one parameter or hash segment
    this.isHelper = eligibleHelper && (params.length || hash);

    // if a mustache is an eligible helper but not a definite
    // helper, it is ambiguous, and will be resolved in a later
    // pass or at runtime.
  };

  Handlebars.AST.PartialNode = function (partialName, context) {
    this.type = "partial";
    this.partialName = partialName;
    this.context = context;
  };

  var verifyMatch = function (open, close) {
    if (open.original !== close.original) {
      throw new Handlebars.Exception(
        open.original + " doesn't match " + close.original
      );
    }
  };

  Handlebars.AST.BlockNode = function (mustache, program, inverse, close) {
    verifyMatch(mustache.id, close);
    this.type = "block";
    this.mustache = mustache;
    this.program = program;
    this.inverse = inverse;

    if (this.inverse && !this.program) {
      this.isInverse = true;
    }
  };

  Handlebars.AST.ContentNode = function (string) {
    this.type = "content";
    this.string = string;
  };

  Handlebars.AST.HashNode = function (pairs) {
    this.type = "hash";
    this.pairs = pairs;
  };

  Handlebars.AST.IdNode = function (parts) {
    this.type = "ID";
    this.original = parts.join(".");

    var dig = [],
      depth = 0;

    for (var i = 0, l = parts.length; i < l; i++) {
      var part = parts[i];

      if (part === ".." || part === "." || part === "this") {
        if (dig.length > 0) {
          throw new Handlebars.Exception("Invalid path: " + this.original);
        } else if (part === "..") {
          depth++;
        } else {
          this.isScoped = true;
        }
      } else {
        dig.push(part);
      }
    }

    this.parts = dig;
    this.string = dig.join(".");
    this.depth = depth;

    // an ID is simple if it only has one part, and that part is not
    // `..` or `this`.
    this.isSimple = parts.length === 1 && !this.isScoped && depth === 0;

    this.stringModeValue = this.string;
  };

  Handlebars.AST.PartialNameNode = function (name) {
    this.type = "PARTIAL_NAME";
    this.name = name;
  };

  Handlebars.AST.DataNode = function (id) {
    this.type = "DATA";
    this.id = id;
  };

  Handlebars.AST.StringNode = function (string) {
    this.type = "STRING";
    this.string = string;
    this.stringModeValue = string;
  };

  Handlebars.AST.IntegerNode = function (integer) {
    this.type = "INTEGER";
    this.integer = integer;
    this.stringModeValue = Number(integer);
  };

  Handlebars.AST.BooleanNode = function (bool) {
    this.type = "BOOLEAN";
    this.bool = bool;
    this.stringModeValue = bool === "true";
  };

  Handlebars.AST.CommentNode = function (comment) {
    this.type = "comment";
    this.comment = comment;
  };
})();
// lib/handlebars/utils.js

var errorProps = [
  "description",
  "fileName",
  "lineNumber",
  "message",
  "name",
  "number",
  "stack",
];

Handlebars.Exception = function (message) {
  var tmp = Error.prototype.constructor.apply(this, arguments);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }
};
Handlebars.Exception.prototype = new Error();

// Build out our basic SafeString type
Handlebars.SafeString = function (string) {
  this.string = string;
};
Handlebars.SafeString.prototype.toString = function () {
  return this.string.toString();
};

(function () {
  var escape = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#x27;",
    "`": "&#x60;",
  };

  var badChars = /[&<>"'`]/g;
  var possible = /[&<>"'`]/;

  var escapeChar = function (chr) {
    return escape[chr] || "&amp;";
  };

  Handlebars.Utils = {
    escapeExpression: function (string) {
      // don't escape SafeStrings, since they're already safe
      if (string instanceof Handlebars.SafeString) {
        return string.toString();
      } else if (string == null || string === false) {
        return "";
      }

      if (!possible.test(string)) {
        return string;
      }
      return string.replace(badChars, escapeChar);
    },

    isEmpty: function (value) {
      if (!value && value !== 0) {
        return true;
      } else if (
        Object.prototype.toString.call(value) === "[object Array]" &&
        value.length === 0
      ) {
        return true;
      } else {
        return false;
      }
    },
  };
})();
// lib/handlebars/compiler/compiler.js

/*jshint eqnull:true*/
Handlebars.Compiler = function () {};
Handlebars.JavaScriptCompiler = function () {};

(function (Compiler, JavaScriptCompiler) {
  // the foundHelper register will disambiguate helper lookup from finding a
  // function in a context. This is necessary for mustache compatibility, which
  // requires that context functions in blocks are evaluated by blockHelperMissing,
  // and then proceed as if the resulting value was provided to blockHelperMissing.

  Compiler.prototype = {
    compiler: Compiler,

    disassemble: function () {
      var opcodes = this.opcodes,
        opcode,
        out = [],
        params,
        param;

      for (var i = 0, l = opcodes.length; i < l; i++) {
        opcode = opcodes[i];

        if (opcode.opcode === "DECLARE") {
          out.push("DECLARE " + opcode.name + "=" + opcode.value);
        } else {
          params = [];
          for (var j = 0; j < opcode.args.length; j++) {
            param = opcode.args[j];
            if (typeof param === "string") {
              param = '"' + param.replace("\n", "\\n") + '"';
            }
            params.push(param);
          }
          out.push(opcode.opcode + " " + params.join(" "));
        }
      }

      return out.join("\n");
    },
    equals: function (other) {
      var len = this.opcodes.length;
      if (other.opcodes.length !== len) {
        return false;
      }

      for (var i = 0; i < len; i++) {
        var opcode = this.opcodes[i],
          otherOpcode = other.opcodes[i];
        if (
          opcode.opcode !== otherOpcode.opcode ||
          opcode.args.length !== otherOpcode.args.length
        ) {
          return false;
        }
        for (var j = 0; j < opcode.args.length; j++) {
          if (opcode.args[j] !== otherOpcode.args[j]) {
            return false;
          }
        }
      }
      return true;
    },

    guid: 0,

    compile: function (program, options) {
      this.children = [];
      this.depths = { list: [] };
      this.options = options;

      // These changes will propagate to the other compiler components
      var knownHelpers = this.options.knownHelpers;
      this.options.knownHelpers = {
        helperMissing: true,
        blockHelperMissing: true,
        each: true,
        if: true,
        unless: true,
        with: true,
        log: true,
      };
      if (knownHelpers) {
        for (var name in knownHelpers) {
          this.options.knownHelpers[name] = knownHelpers[name];
        }
      }

      return this.program(program);
    },

    accept: function (node) {
      return this[node.type](node);
    },

    program: function (program) {
      var statements = program.statements,
        statement;
      this.opcodes = [];

      for (var i = 0, l = statements.length; i < l; i++) {
        statement = statements[i];
        this[statement.type](statement);
      }
      this.isSimple = l === 1;

      this.depths.list = this.depths.list.sort(function (a, b) {
        return a - b;
      });

      return this;
    },

    compileProgram: function (program) {
      var result = new this.compiler().compile(program, this.options);
      var guid = this.guid++,
        depth;

      this.usePartial = this.usePartial || result.usePartial;

      this.children[guid] = result;

      for (var i = 0, l = result.depths.list.length; i < l; i++) {
        depth = result.depths.list[i];

        if (depth < 2) {
          continue;
        } else {
          this.addDepth(depth - 1);
        }
      }

      return guid;
    },

    block: function (block) {
      var mustache = block.mustache,
        program = block.program,
        inverse = block.inverse;

      if (program) {
        program = this.compileProgram(program);
      }

      if (inverse) {
        inverse = this.compileProgram(inverse);
      }

      var type = this.classifyMustache(mustache);

      if (type === "helper") {
        this.helperMustache(mustache, program, inverse);
      } else if (type === "simple") {
        this.simpleMustache(mustache);

        // now that the simple mustache is resolved, we need to
        // evaluate it by executing `blockHelperMissing`
        this.opcode("pushProgram", program);
        this.opcode("pushProgram", inverse);
        this.opcode("emptyHash");
        this.opcode("blockValue");
      } else {
        this.ambiguousMustache(mustache, program, inverse);

        // now that the simple mustache is resolved, we need to
        // evaluate it by executing `blockHelperMissing`
        this.opcode("pushProgram", program);
        this.opcode("pushProgram", inverse);
        this.opcode("emptyHash");
        this.opcode("ambiguousBlockValue");
      }

      this.opcode("append");
    },

    hash: function (hash) {
      var pairs = hash.pairs,
        pair,
        val;

      this.opcode("pushHash");

      for (var i = 0, l = pairs.length; i < l; i++) {
        pair = pairs[i];
        val = pair[1];

        if (this.options.stringParams) {
          this.opcode("pushStringParam", val.stringModeValue, val.type);
        } else {
          this.accept(val);
        }

        this.opcode("assignToHash", pair[0]);
      }
      this.opcode("popHash");
    },

    partial: function (partial) {
      var partialName = partial.partialName;
      this.usePartial = true;

      if (partial.context) {
        this.ID(partial.context);
      } else {
        this.opcode("push", "depth0");
      }

      this.opcode("invokePartial", partialName.name);
      this.opcode("append");
    },

    content: function (content) {
      this.opcode("appendContent", content.string);
    },

    mustache: function (mustache) {
      var options = this.options;
      var type = this.classifyMustache(mustache);

      if (type === "simple") {
        this.simpleMustache(mustache);
      } else if (type === "helper") {
        this.helperMustache(mustache);
      } else {
        this.ambiguousMustache(mustache);
      }

      if (mustache.escaped && !options.noEscape) {
        this.opcode("appendEscaped");
      } else {
        this.opcode("append");
      }
    },

    ambiguousMustache: function (mustache, program, inverse) {
      var id = mustache.id,
        name = id.parts[0],
        isBlock = program != null || inverse != null;

      this.opcode("getContext", id.depth);

      this.opcode("pushProgram", program);
      this.opcode("pushProgram", inverse);

      this.opcode("invokeAmbiguous", name, isBlock);
    },

    simpleMustache: function (mustache) {
      var id = mustache.id;

      if (id.type === "DATA") {
        this.DATA(id);
      } else if (id.parts.length) {
        this.ID(id);
      } else {
        // Simplified ID for `this`
        this.addDepth(id.depth);
        this.opcode("getContext", id.depth);
        this.opcode("pushContext");
      }

      this.opcode("resolvePossibleLambda");
    },

    helperMustache: function (mustache, program, inverse) {
      var params = this.setupFullMustacheParams(mustache, program, inverse),
        name = mustache.id.parts[0];

      if (this.options.knownHelpers[name]) {
        this.opcode("invokeKnownHelper", params.length, name);
      } else if (this.knownHelpersOnly) {
        throw new Error(
          "You specified knownHelpersOnly, but used the unknown helper " + name
        );
      } else {
        this.opcode("invokeHelper", params.length, name);
      }
    },

    ID: function (id) {
      this.addDepth(id.depth);
      this.opcode("getContext", id.depth);

      var name = id.parts[0];
      if (!name) {
        this.opcode("pushContext");
      } else {
        this.opcode("lookupOnContext", id.parts[0]);
      }

      for (var i = 1, l = id.parts.length; i < l; i++) {
        this.opcode("lookup", id.parts[i]);
      }
    },

    DATA: function (data) {
      this.options.data = true;
      this.opcode("lookupData", data.id);
    },

    STRING: function (string) {
      this.opcode("pushString", string.string);
    },

    INTEGER: function (integer) {
      this.opcode("pushLiteral", integer.integer);
    },

    BOOLEAN: function (bool) {
      this.opcode("pushLiteral", bool.bool);
    },

    comment: function () {},

    // HELPERS
    opcode: function (name) {
      this.opcodes.push({ opcode: name, args: [].slice.call(arguments, 1) });
    },

    declare: function (name, value) {
      this.opcodes.push({ opcode: "DECLARE", name: name, value: value });
    },

    addDepth: function (depth) {
      if (isNaN(depth)) {
        throw new Error("EWOT");
      }
      if (depth === 0) {
        return;
      }

      if (!this.depths[depth]) {
        this.depths[depth] = true;
        this.depths.list.push(depth);
      }
    },

    classifyMustache: function (mustache) {
      var isHelper = mustache.isHelper;
      var isEligible = mustache.eligibleHelper;
      var options = this.options;

      // if ambiguous, we can possibly resolve the ambiguity now
      if (isEligible && !isHelper) {
        var name = mustache.id.parts[0];

        if (options.knownHelpers[name]) {
          isHelper = true;
        } else if (options.knownHelpersOnly) {
          isEligible = false;
        }
      }

      if (isHelper) {
        return "helper";
      } else if (isEligible) {
        return "ambiguous";
      } else {
        return "simple";
      }
    },

    pushParams: function (params) {
      var i = params.length,
        param;

      while (i--) {
        param = params[i];

        if (this.options.stringParams) {
          if (param.depth) {
            this.addDepth(param.depth);
          }

          this.opcode("getContext", param.depth || 0);
          this.opcode("pushStringParam", param.stringModeValue, param.type);
        } else {
          this[param.type](param);
        }
      }
    },

    setupMustacheParams: function (mustache) {
      var params = mustache.params;
      this.pushParams(params);

      if (mustache.hash) {
        this.hash(mustache.hash);
      } else {
        this.opcode("emptyHash");
      }

      return params;
    },

    // this will replace setupMustacheParams when we're done
    setupFullMustacheParams: function (mustache, program, inverse) {
      var params = mustache.params;
      this.pushParams(params);

      this.opcode("pushProgram", program);
      this.opcode("pushProgram", inverse);

      if (mustache.hash) {
        this.hash(mustache.hash);
      } else {
        this.opcode("emptyHash");
      }

      return params;
    },
  };

  var Literal = function (value) {
    this.value = value;
  };

  JavaScriptCompiler.prototype = {
    // PUBLIC API: You can override these methods in a subclass to provide
    // alternative compiled forms for name lookup and buffering semantics
    nameLookup: function (parent, name /* , type*/) {
      if (/^[0-9]+$/.test(name)) {
        return parent + "[" + name + "]";
      } else if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
        return parent + "." + name;
      } else {
        return parent + "['" + name + "']";
      }
    },

    appendToBuffer: function (string) {
      if (this.environment.isSimple) {
        return "return " + string + ";";
      } else {
        return {
          appendToBuffer: true,
          content: string,
          toString: function () {
            return "buffer += " + string + ";";
          },
        };
      }
    },

    initializeBuffer: function () {
      return this.quotedString("");
    },

    namespace: "Handlebars",
    // END PUBLIC API

    compile: function (environment, options, context, asObject) {
      this.environment = environment;
      this.options = options || {};

      Handlebars.log(
        Handlebars.logger.DEBUG,
        this.environment.disassemble() + "\n\n"
      );

      this.name = this.environment.name;
      this.isChild = !!context;
      this.context = context || {
        programs: [],
        environments: [],
        aliases: {},
      };

      this.preamble();

      this.stackSlot = 0;
      this.stackVars = [];
      this.registers = { list: [] };
      this.compileStack = [];
      this.inlineStack = [];

      this.compileChildren(environment, options);

      var opcodes = environment.opcodes,
        opcode;

      this.i = 0;

      for (l = opcodes.length; this.i < l; this.i++) {
        opcode = opcodes[this.i];

        if (opcode.opcode === "DECLARE") {
          this[opcode.name] = opcode.value;
        } else {
          this[opcode.opcode].apply(this, opcode.args);
        }
      }

      return this.createFunctionContext(asObject);
    },

    nextOpcode: function () {
      var opcodes = this.environment.opcodes;
      return opcodes[this.i + 1];
    },

    eat: function () {
      this.i = this.i + 1;
    },

    preamble: function () {
      var out = [];

      if (!this.isChild) {
        var namespace = this.namespace;
        var copies = "helpers = helpers || " + namespace + ".helpers;";
        if (this.environment.usePartial) {
          copies =
            copies + " partials = partials || " + namespace + ".partials;";
        }
        if (this.options.data) {
          copies = copies + " data = data || {};";
        }
        out.push(copies);
      } else {
        out.push("");
      }

      if (!this.environment.isSimple) {
        out.push(", buffer = " + this.initializeBuffer());
      } else {
        out.push("");
      }

      // track the last context pushed into place to allow skipping the
      // getContext opcode when it would be a noop
      this.lastContext = 0;
      this.source = out;
    },

    createFunctionContext: function (asObject) {
      var locals = this.stackVars.concat(this.registers.list);

      if (locals.length > 0) {
        this.source[1] = this.source[1] + ", " + locals.join(", ");
      }

      // Generate minimizer alias mappings
      if (!this.isChild) {
        for (var alias in this.context.aliases) {
          this.source[1] =
            this.source[1] + ", " + alias + "=" + this.context.aliases[alias];
        }
      }

      if (this.source[1]) {
        this.source[1] = "var " + this.source[1].substring(2) + ";";
      }

      // Merge children
      if (!this.isChild) {
        this.source[1] += "\n" + this.context.programs.join("\n") + "\n";
      }

      if (!this.environment.isSimple) {
        this.source.push("return buffer;");
      }

      var params = this.isChild
        ? ["depth0", "data"]
        : ["Handlebars", "depth0", "helpers", "partials", "data"];

      for (var i = 0, l = this.environment.depths.list.length; i < l; i++) {
        params.push("depth" + this.environment.depths.list[i]);
      }

      // Perform a second pass over the output to merge content when possible
      var source = this.mergeSource();

      if (!this.isChild) {
        var revision = Handlebars.COMPILER_REVISION,
          versions = Handlebars.REVISION_CHANGES[revision];
        source =
          "this.compilerInfo = [" +
          revision +
          ",'" +
          versions +
          "'];\n" +
          source;
      }

      if (asObject) {
        params.push(source);

        return Function.apply(this, params);
      } else {
        var functionSource =
          "function " +
          (this.name || "") +
          "(" +
          params.join(",") +
          ") {\n  " +
          source +
          "}";
        Handlebars.log(Handlebars.logger.DEBUG, functionSource + "\n\n");
        return functionSource;
      }
    },
    mergeSource: function () {
      // WARN: We are not handling the case where buffer is still populated as the source should
      // not have buffer append operations as their final action.
      var source = "",
        buffer;
      for (var i = 0, len = this.source.length; i < len; i++) {
        var line = this.source[i];
        if (line.appendToBuffer) {
          if (buffer) {
            buffer = buffer + "\n    + " + line.content;
          } else {
            buffer = line.content;
          }
        } else {
          if (buffer) {
            source += "buffer += " + buffer + ";\n  ";
            buffer = undefined;
          }
          source += line + "\n  ";
        }
      }
      return source;
    },

    // [blockValue]
    //
    // On stack, before: hash, inverse, program, value
    // On stack, after: return value of blockHelperMissing
    //
    // The purpose of this opcode is to take a block of the form
    // `{{#foo}}...{{/foo}}`, resolve the value of `foo`, and
    // replace it on the stack with the result of properly
    // invoking blockHelperMissing.
    blockValue: function () {
      this.context.aliases.blockHelperMissing = "helpers.blockHelperMissing";

      var params = ["depth0"];
      this.setupParams(0, params);

      this.replaceStack(function (current) {
        params.splice(1, 0, current);
        return "blockHelperMissing.call(" + params.join(", ") + ")";
      });
    },

    // [ambiguousBlockValue]
    //
    // On stack, before: hash, inverse, program, value
    // Compiler value, before: lastHelper=value of last found helper, if any
    // On stack, after, if no lastHelper: same as [blockValue]
    // On stack, after, if lastHelper: value
    ambiguousBlockValue: function () {
      this.context.aliases.blockHelperMissing = "helpers.blockHelperMissing";

      var params = ["depth0"];
      this.setupParams(0, params);

      var current = this.topStack();
      params.splice(1, 0, current);

      // Use the options value generated from the invocation
      params[params.length - 1] = "options";

      this.source.push(
        "if (!" +
          this.lastHelper +
          ") { " +
          current +
          " = blockHelperMissing.call(" +
          params.join(", ") +
          "); }"
      );
    },

    // [appendContent]
    //
    // On stack, before: ...
    // On stack, after: ...
    //
    // Appends the string value of `content` to the current buffer
    appendContent: function (content) {
      this.source.push(this.appendToBuffer(this.quotedString(content)));
    },

    // [append]
    //
    // On stack, before: value, ...
    // On stack, after: ...
    //
    // Coerces `value` to a String and appends it to the current buffer.
    //
    // If `value` is truthy, or 0, it is coerced into a string and appended
    // Otherwise, the empty string is appended
    append: function () {
      // Force anything that is inlined onto the stack so we don't have duplication
      // when we examine local
      this.flushInline();
      var local = this.popStack();
      this.source.push(
        "if(" +
          local +
          " || " +
          local +
          " === 0) { " +
          this.appendToBuffer(local) +
          " }"
      );
      if (this.environment.isSimple) {
        this.source.push("else { " + this.appendToBuffer("''") + " }");
      }
    },

    // [appendEscaped]
    //
    // On stack, before: value, ...
    // On stack, after: ...
    //
    // Escape `value` and append it to the buffer
    appendEscaped: function () {
      this.context.aliases.escapeExpression = "this.escapeExpression";

      this.source.push(
        this.appendToBuffer("escapeExpression(" + this.popStack() + ")")
      );
    },

    // [getContext]
    //
    // On stack, before: ...
    // On stack, after: ...
    // Compiler value, after: lastContext=depth
    //
    // Set the value of the `lastContext` compiler value to the depth
    getContext: function (depth) {
      if (this.lastContext !== depth) {
        this.lastContext = depth;
      }
    },

    // [lookupOnContext]
    //
    // On stack, before: ...
    // On stack, after: currentContext[name], ...
    //
    // Looks up the value of `name` on the current context and pushes
    // it onto the stack.
    lookupOnContext: function (name) {
      this.push(this.nameLookup("depth" + this.lastContext, name, "context"));
    },

    // [pushContext]
    //
    // On stack, before: ...
    // On stack, after: currentContext, ...
    //
    // Pushes the value of the current context onto the stack.
    pushContext: function () {
      this.pushStackLiteral("depth" + this.lastContext);
    },

    // [resolvePossibleLambda]
    //
    // On stack, before: value, ...
    // On stack, after: resolved value, ...
    //
    // If the `value` is a lambda, replace it on the stack by
    // the return value of the lambda
    resolvePossibleLambda: function () {
      this.context.aliases.functionType = '"function"';

      this.replaceStack(function (current) {
        return (
          "typeof " +
          current +
          " === functionType ? " +
          current +
          ".apply(depth0) : " +
          current
        );
      });
    },

    // [lookup]
    //
    // On stack, before: value, ...
    // On stack, after: value[name], ...
    //
    // Replace the value on the stack with the result of looking
    // up `name` on `value`
    lookup: function (name) {
      this.replaceStack(function (current) {
        return (
          current +
          " == null || " +
          current +
          " === false ? " +
          current +
          " : " +
          this.nameLookup(current, name, "context")
        );
      });
    },

    // [lookupData]
    //
    // On stack, before: ...
    // On stack, after: data[id], ...
    //
    // Push the result of looking up `id` on the current data
    lookupData: function (id) {
      this.push(this.nameLookup("data", id, "data"));
    },

    // [pushStringParam]
    //
    // On stack, before: ...
    // On stack, after: string, currentContext, ...
    //
    // This opcode is designed for use in string mode, which
    // provides the string value of a parameter along with its
    // depth rather than resolving it immediately.
    pushStringParam: function (string, type) {
      this.pushStackLiteral("depth" + this.lastContext);

      this.pushString(type);

      if (typeof string === "string") {
        this.pushString(string);
      } else {
        this.pushStackLiteral(string);
      }
    },

    emptyHash: function () {
      this.pushStackLiteral("{}");

      if (this.options.stringParams) {
        this.register("hashTypes", "{}");
      }
    },
    pushHash: function () {
      this.hash = { values: [], types: [] };
    },
    popHash: function () {
      var hash = this.hash;
      this.hash = undefined;

      if (this.options.stringParams) {
        this.register("hashTypes", "{" + hash.types.join(",") + "}");
      }
      this.push("{\n    " + hash.values.join(",\n    ") + "\n  }");
    },

    // [pushString]
    //
    // On stack, before: ...
    // On stack, after: quotedString(string), ...
    //
    // Push a quoted version of `string` onto the stack
    pushString: function (string) {
      this.pushStackLiteral(this.quotedString(string));
    },

    // [push]
    //
    // On stack, before: ...
    // On stack, after: expr, ...
    //
    // Push an expression onto the stack
    push: function (expr) {
      this.inlineStack.push(expr);
      return expr;
    },

    // [pushLiteral]
    //
    // On stack, before: ...
    // On stack, after: value, ...
    //
    // Pushes a value onto the stack. This operation prevents
    // the compiler from creating a temporary variable to hold
    // it.
    pushLiteral: function (value) {
      this.pushStackLiteral(value);
    },

    // [pushProgram]
    //
    // On stack, before: ...
    // On stack, after: program(guid), ...
    //
    // Push a program expression onto the stack. This takes
    // a compile-time guid and converts it into a runtime-accessible
    // expression.
    pushProgram: function (guid) {
      if (guid != null) {
        this.pushStackLiteral(this.programExpression(guid));
      } else {
        this.pushStackLiteral(null);
      }
    },

    // [invokeHelper]
    //
    // On stack, before: hash, inverse, program, params..., ...
    // On stack, after: result of helper invocation
    //
    // Pops off the helper's parameters, invokes the helper,
    // and pushes the helper's return value onto the stack.
    //
    // If the helper is not found, `helperMissing` is called.
    invokeHelper: function (paramSize, name) {
      this.context.aliases.helperMissing = "helpers.helperMissing";

      var helper = (this.lastHelper = this.setupHelper(paramSize, name, true));

      this.push(helper.name);
      this.replaceStack(function (name) {
        return (
          name +
          " ? " +
          name +
          ".call(" +
          helper.callParams +
          ") " +
          ": helperMissing.call(" +
          helper.helperMissingParams +
          ")"
        );
      });
    },

    // [invokeKnownHelper]
    //
    // On stack, before: hash, inverse, program, params..., ...
    // On stack, after: result of helper invocation
    //
    // This operation is used when the helper is known to exist,
    // so a `helperMissing` fallback is not required.
    invokeKnownHelper: function (paramSize, name) {
      var helper = this.setupHelper(paramSize, name);
      this.push(helper.name + ".call(" + helper.callParams + ")");
    },

    // [invokeAmbiguous]
    //
    // On stack, before: hash, inverse, program, params..., ...
    // On stack, after: result of disambiguation
    //
    // This operation is used when an expression like `{{foo}}`
    // is provided, but we don't know at compile-time whether it
    // is a helper or a path.
    //
    // This operation emits more code than the other options,
    // and can be avoided by passing the `knownHelpers` and
    // `knownHelpersOnly` flags at compile-time.
    invokeAmbiguous: function (name, helperCall) {
      this.context.aliases.functionType = '"function"';

      this.pushStackLiteral("{}"); // Hash value
      var helper = this.setupHelper(0, name, helperCall);

      var helperName = (this.lastHelper = this.nameLookup(
        "helpers",
        name,
        "helper"
      ));

      var nonHelper = this.nameLookup(
        "depth" + this.lastContext,
        name,
        "context"
      );
      var nextStack = this.nextStack();

      this.source.push(
        "if (" +
          nextStack +
          " = " +
          helperName +
          ") { " +
          nextStack +
          " = " +
          nextStack +
          ".call(" +
          helper.callParams +
          "); }"
      );
      this.source.push(
        "else { " +
          nextStack +
          " = " +
          nonHelper +
          "; " +
          nextStack +
          " = typeof " +
          nextStack +
          " === functionType ? " +
          nextStack +
          ".apply(depth0) : " +
          nextStack +
          "; }"
      );
    },

    // [invokePartial]
    //
    // On stack, before: context, ...
    // On stack after: result of partial invocation
    //
    // This operation pops off a context, invokes a partial with that context,
    // and pushes the result of the invocation back.
    invokePartial: function (name) {
      var params = [
        this.nameLookup("partials", name, "partial"),
        "'" + name + "'",
        this.popStack(),
        "helpers",
        "partials",
      ];

      if (this.options.data) {
        params.push("data");
      }

      this.context.aliases.self = "this";
      this.push("self.invokePartial(" + params.join(", ") + ")");
    },

    // [assignToHash]
    //
    // On stack, before: value, hash, ...
    // On stack, after: hash, ...
    //
    // Pops a value and hash off the stack, assigns `hash[key] = value`
    // and pushes the hash back onto the stack.
    assignToHash: function (key) {
      var value = this.popStack(),
        type;

      if (this.options.stringParams) {
        type = this.popStack();
        this.popStack();
      }

      var hash = this.hash;
      if (type) {
        hash.types.push("'" + key + "': " + type);
      }
      hash.values.push("'" + key + "': (" + value + ")");
    },

    // HELPERS

    compiler: JavaScriptCompiler,

    compileChildren: function (environment, options) {
      var children = environment.children,
        child,
        compiler;

      for (var i = 0, l = children.length; i < l; i++) {
        child = children[i];
        compiler = new this.compiler();

        var index = this.matchExistingProgram(child);

        if (index == null) {
          this.context.programs.push(""); // Placeholder to prevent name conflicts for nested children
          index = this.context.programs.length;
          child.index = index;
          child.name = "program" + index;
          this.context.programs[index] = compiler.compile(
            child,
            options,
            this.context
          );
          this.context.environments[index] = child;
        } else {
          child.index = index;
          child.name = "program" + index;
        }
      }
    },
    matchExistingProgram: function (child) {
      for (var i = 0, len = this.context.environments.length; i < len; i++) {
        var environment = this.context.environments[i];
        if (environment && environment.equals(child)) {
          return i;
        }
      }
    },

    programExpression: function (guid) {
      this.context.aliases.self = "this";

      if (guid == null) {
        return "self.noop";
      }

      var child = this.environment.children[guid],
        depths = child.depths.list,
        depth;

      var programParams = [child.index, child.name, "data"];

      for (var i = 0, l = depths.length; i < l; i++) {
        depth = depths[i];

        if (depth === 1) {
          programParams.push("depth0");
        } else {
          programParams.push("depth" + (depth - 1));
        }
      }

      if (depths.length === 0) {
        return "self.program(" + programParams.join(", ") + ")";
      } else {
        programParams.shift();
        return "self.programWithDepth(" + programParams.join(", ") + ")";
      }
    },

    register: function (name, val) {
      this.useRegister(name);
      this.source.push(name + " = " + val + ";");
    },

    useRegister: function (name) {
      if (!this.registers[name]) {
        this.registers[name] = true;
        this.registers.list.push(name);
      }
    },

    pushStackLiteral: function (item) {
      return this.push(new Literal(item));
    },

    pushStack: function (item) {
      this.flushInline();

      var stack = this.incrStack();
      if (item) {
        this.source.push(stack + " = " + item + ";");
      }
      this.compileStack.push(stack);
      return stack;
    },

    replaceStack: function (callback) {
      var prefix = "",
        inline = this.isInline(),
        stack;

      // If we are currently inline then we want to merge the inline statement into the
      // replacement statement via ','
      if (inline) {
        var top = this.popStack(true);

        if (top instanceof Literal) {
          // Literals do not need to be inlined
          stack = top.value;
        } else {
          // Get or create the current stack name for use by the inline
          var name = this.stackSlot ? this.topStackName() : this.incrStack();

          prefix = "(" + this.push(name) + " = " + top + "),";
          stack = this.topStack();
        }
      } else {
        stack = this.topStack();
      }

      var item = callback.call(this, stack);

      if (inline) {
        if (this.inlineStack.length || this.compileStack.length) {
          this.popStack();
        }
        this.push("(" + prefix + item + ")");
      } else {
        // Prevent modification of the context depth variable. Through replaceStack
        if (!/^stack/.test(stack)) {
          stack = this.nextStack();
        }

        this.source.push(stack + " = (" + prefix + item + ");");
      }
      return stack;
    },

    nextStack: function () {
      return this.pushStack();
    },

    incrStack: function () {
      this.stackSlot++;
      if (this.stackSlot > this.stackVars.length) {
        this.stackVars.push("stack" + this.stackSlot);
      }
      return this.topStackName();
    },
    topStackName: function () {
      return "stack" + this.stackSlot;
    },
    flushInline: function () {
      var inlineStack = this.inlineStack;
      if (inlineStack.length) {
        this.inlineStack = [];
        for (var i = 0, len = inlineStack.length; i < len; i++) {
          var entry = inlineStack[i];
          if (entry instanceof Literal) {
            this.compileStack.push(entry);
          } else {
            this.pushStack(entry);
          }
        }
      }
    },
    isInline: function () {
      return this.inlineStack.length;
    },

    popStack: function (wrapped) {
      var inline = this.isInline(),
        item = (inline ? this.inlineStack : this.compileStack).pop();

      if (!wrapped && item instanceof Literal) {
        return item.value;
      } else {
        if (!inline) {
          this.stackSlot--;
        }
        return item;
      }
    },

    topStack: function (wrapped) {
      var stack = this.isInline() ? this.inlineStack : this.compileStack,
        item = stack[stack.length - 1];

      if (!wrapped && item instanceof Literal) {
        return item.value;
      } else {
        return item;
      }
    },

    quotedString: function (str) {
      return (
        '"' +
        str
          .replace(/\\/g, "\\\\")
          .replace(/"/g, '\\"')
          .replace(/\n/g, "\\n")
          .replace(/\r/g, "\\r") +
        '"'
      );
    },

    setupHelper: function (paramSize, name, missingParams) {
      var params = [];
      this.setupParams(paramSize, params, missingParams);
      var foundHelper = this.nameLookup("helpers", name, "helper");

      return {
        params: params,
        name: foundHelper,
        callParams: ["depth0"].concat(params).join(", "),
        helperMissingParams:
          missingParams &&
          ["depth0", this.quotedString(name)].concat(params).join(", "),
      };
    },

    // the params and contexts arguments are passed in arrays
    // to fill in
    setupParams: function (paramSize, params, useRegister) {
      var options = [],
        contexts = [],
        types = [],
        param,
        inverse,
        program;

      options.push("hash:" + this.popStack());

      inverse = this.popStack();
      program = this.popStack();

      // Avoid setting fn and inverse if neither are set. This allows
      // helpers to do a check for `if (options.fn)`
      if (program || inverse) {
        if (!program) {
          this.context.aliases.self = "this";
          program = "self.noop";
        }

        if (!inverse) {
          this.context.aliases.self = "this";
          inverse = "self.noop";
        }

        options.push("inverse:" + inverse);
        options.push("fn:" + program);
      }

      for (var i = 0; i < paramSize; i++) {
        param = this.popStack();
        params.push(param);

        if (this.options.stringParams) {
          types.push(this.popStack());
          contexts.push(this.popStack());
        }
      }

      if (this.options.stringParams) {
        options.push("contexts:[" + contexts.join(",") + "]");
        options.push("types:[" + types.join(",") + "]");
        options.push("hashTypes:hashTypes");
      }

      if (this.options.data) {
        options.push("data:data");
      }

      options = "{" + options.join(",") + "}";
      if (useRegister) {
        this.register("options", options);
        params.push("options");
      } else {
        params.push(options);
      }
      return params.join(", ");
    },
  };

  var reservedWords = (
    "break else new var" +
    " case finally return void" +
    " catch for switch while" +
    " continue function this with" +
    " default if throw" +
    " delete in try" +
    " do instanceof typeof" +
    " abstract enum int short" +
    " boolean export interface static" +
    " byte extends long super" +
    " char final native synchronized" +
    " class float package throws" +
    " const goto private transient" +
    " debugger implements protected volatile" +
    " double import public let yield"
  ).split(" ");

  var compilerWords = (JavaScriptCompiler.RESERVED_WORDS = {});

  for (var i = 0, l = reservedWords.length; i < l; i++) {
    compilerWords[reservedWords[i]] = true;
  }

  JavaScriptCompiler.isValidJavaScriptVariableName = function (name) {
    if (
      !JavaScriptCompiler.RESERVED_WORDS[name] &&
      /^[a-zA-Z_$][0-9a-zA-Z_$]+$/.test(name)
    ) {
      return true;
    }
    return false;
  };
})(Handlebars.Compiler, Handlebars.JavaScriptCompiler);

Handlebars.precompile = function (input, options) {
  if (
    !input ||
    (typeof input !== "string" &&
      input.constructor !== Handlebars.AST.ProgramNode)
  ) {
    throw new Handlebars.Exception(
      "You must pass a string or Handlebars AST to Handlebars.compile. You passed " +
        input
    );
  }

  options = options || {};
  if (!("data" in options)) {
    options.data = true;
  }
  var ast = Handlebars.parse(input);
  var environment = new Handlebars.Compiler().compile(ast, options);
  return new Handlebars.JavaScriptCompiler().compile(environment, options);
};

Handlebars.compile = function (input, options) {
  if (
    !input ||
    (typeof input !== "string" &&
      input.constructor !== Handlebars.AST.ProgramNode)
  ) {
    throw new Handlebars.Exception(
      "You must pass a string or Handlebars AST to Handlebars.compile. You passed " +
        input
    );
  }

  options = options || {};
  if (!("data" in options)) {
    options.data = true;
  }
  var compiled;
  function compile() {
    var ast = Handlebars.parse(input);
    var environment = new Handlebars.Compiler().compile(ast, options);
    var templateSpec = new Handlebars.JavaScriptCompiler().compile(
      environment,
      options,
      undefined,
      true
    );
    return Handlebars.template(templateSpec);
  }

  // Template is only compiled on first use and cached after that point.
  return function (context, options) {
    if (!compiled) {
      compiled = compile();
    }
    return compiled.call(this, context, options);
  };
};
// lib/handlebars/runtime.js
Handlebars.VM = {
  template: function (templateSpec) {
    // Just add water
    var container = {
      escapeExpression: Handlebars.Utils.escapeExpression,
      invokePartial: Handlebars.VM.invokePartial,
      programs: [],
      program: function (i, fn, data) {
        var programWrapper = this.programs[i];
        if (data) {
          return Handlebars.VM.program(fn, data);
        } else if (programWrapper) {
          return programWrapper;
        } else {
          programWrapper = this.programs[i] = Handlebars.VM.program(fn);
          return programWrapper;
        }
      },
      programWithDepth: Handlebars.VM.programWithDepth,
      noop: Handlebars.VM.noop,
      compilerInfo: null,
    };

    return function (context, options) {
      options = options || {};
      var result = templateSpec.call(
        container,
        Handlebars,
        context,
        options.helpers,
        options.partials,
        options.data
      );

      var compilerInfo = container.compilerInfo || [],
        compilerRevision = compilerInfo[0] || 1,
        currentRevision = Handlebars.COMPILER_REVISION;

      if (compilerRevision !== currentRevision) {
        if (compilerRevision < currentRevision) {
          var runtimeVersions = Handlebars.REVISION_CHANGES[currentRevision],
            compilerVersions = Handlebars.REVISION_CHANGES[compilerRevision];
          throw (
            "Template was precompiled with an older version of Handlebars than the current runtime. " +
            "Please update your precompiler to a newer version (" +
            runtimeVersions +
            ") or downgrade your runtime to an older version (" +
            compilerVersions +
            ")."
          );
        } else {
          // Use the embedded version info since the runtime doesn't know about this revision yet
          throw (
            "Template was precompiled with a newer version of Handlebars than the current runtime. " +
            "Please update your runtime to a newer version (" +
            compilerInfo[1] +
            ")."
          );
        }
      }

      return result;
    };
  },

  programWithDepth: function (fn, data, $depth) {
    var args = Array.prototype.slice.call(arguments, 2);

    return function (context, options) {
      options = options || {};

      return fn.apply(this, [context, options.data || data].concat(args));
    };
  },
  program: function (fn, data) {
    return function (context, options) {
      options = options || {};

      return fn(context, options.data || data);
    };
  },
  noop: function () {
    return "";
  },
  invokePartial: function (partial, name, context, helpers, partials, data) {
    var options = { helpers: helpers, partials: partials, data: data };

    if (partial === undefined) {
      throw new Handlebars.Exception(
        "The partial " + name + " could not be found"
      );
    } else if (partial instanceof Function) {
      return partial(context, options);
    } else if (!Handlebars.compile) {
      throw new Handlebars.Exception(
        "The partial " +
          name +
          " could not be compiled when running in runtime-only mode"
      );
    } else {
      partials[name] = Handlebars.compile(partial, {
        data: data !== undefined,
      });
      return partials[name](context, options);
    }
  },
};

Handlebars.template = Handlebars.VM.template;
angular
  .module("angular-simple-sidebar", [])
  .directive("angularSimpleSidebar", function (hotkeys, $rootScope) {
    var tabOpen = false;
    var escObj;
    return {
      restrict: "E",
      transclude: !0,
      scope: {
        items: "=",
        state: "=",
        title: "=",
        close: "=",
        settings: "=",
        expanded: "=",
        collapsed: "=",
      },
      template:
        '<a href="#" class="ass-menu-button" aria-label="{{ariaLabel}}" title="{{::title}}" ng-click="openSidebar()" no-right-click><i class="eg-font-2 eg-bars-icon"></i></a><div title=""><aside class="ass-aside-menu ass-slide-{{slide}}"><a href="#" ng-if="settings.close" class="ass-aside-menu-close" tabindex=0 ng-click="closeSidebar()" title="{{ariaLabelClose}}" aria-label="{{ariaLabelClose}}"><span ng-if="!settings.closeIcon">[x]</span><span ng-if="settings.closeIcon"><i class="{{::settings.closeIcon}}"></i></span></a><h3 class="ass-aside-menu-title"></h3><a id="{{item.id}}" href="{{::item.link}}" target="{{::item.target}}" class="ass-aside-menu-item"  ng-click="closeSidebar()" ng-repeat="item in items" tabindex="-1" title="{{::item.name|translate}}"><i ng-if="::item.icon" class="{{::item.icon}} ass-aside-menu-icon"></i><span>{{::item.name|translate}}</span></a></aside><div ng-if="state" class="ass-aside-overlay" ng-click="closeSidebar()"></div></div>',
      link: function (a, b, c) {
        a.ariaLabel = a.title + " " + a.collapsed;
        a.ariaLabelClose = a.close;
        var element = b;
        a.slide,
          a.state && (a.slide = "in"),
          (a.openSidebar = function () {
            if (!tabOpen) {
              escObj = hotkeys.get("esc");
              hotkeys.add({
                combo: "esc",
                description: "Close sidebar",
                callback: function () {
                  if (tabOpen) {
                    a.closeSidebar();
                  }
                },
              });
              tabOpen = true;
              a.ariaLabel = a.title + " " + a.expanded;
              (a.state = !0), (a.slide = "in");
              if (a.items) {
                for (var i = 0; i < a.items.length; i++) {
                  document.getElementById(a.items[i].id).tabIndex = 0;
                }
              }
              var inputs = element[0].querySelectorAll(".ass-aside-menu a");
              var firstInput = angular.element(inputs[0]);
              var lastInput = angular.element(inputs[inputs.length - 1]);

              /*set focus on first input*/
              //firstInput.focus();

              /*redirect last tab to first input*/
              lastInput.on("keydown", function (e) {
                if (e.which === 9 && !e.shiftKey) {
                  e.preventDefault();
                  firstInput[0].focus();
                }
              });

              /*redirect first shift+tab to last input*/
              firstInput.on("keydown", function (e) {
                if (e.which === 9 && e.shiftKey) {
                  e.preventDefault();
                  lastInput[0].focus();
                }
              });
            } else {
              a.closeSidebar();
            }
          }),
          (a.closeSidebar = function () {
            tabOpen = false;
            a.ariaLabel = a.title + " " + a.collapsed;
            hotkeys.del("esc");
            hotkeys.add(escObj);
            (a.state = !1), (a.slide = "out");
            if (a.items) {
              for (var i = 0; i < a.items.length; i++) {
                document.getElementById(a.items[i].id).tabIndex = -1;
              }
            }
            $rootScope.$broadcast("application_sidebar_closed");
          });
      },
    };
  });
var app = angular.module("app", [
  "ngRoute",
  "ngCookies",
  "ngSanitize",
  "ngAnimate",
  "ui.bootstrap",
  "pascalprecht.translate",
  "ui.router",
  "ngStorage",
  "focus-if",
  "angular-simple-sidebar",
  "ngTouch",
  "cfp.hotkeys",
  "ngProgress",
]);
app.run(function (
  $state,
  $rootScope,
  $window,
  ApplicationFactory,
  SessionFactory,
  HooksFactory,
  $http
) {
  $rootScope.apiPath = applicationDefaults.eGainChatApiPath;
  var locale = ApplicationFactory.GetUrlParameter("locale");
  $window.HooksFactory = HooksFactory;
  $rootScope.locale = locale
    ? ApplicationFactory.GetCaseSensitiveLocale(locale)
    : "en-US";
  $rootScope.lang = locale.split("-").length > 0 ? locale.split("-")[0] : "en";
  ApplicationFactory.SendMultiSubDomainSupportConfigToParent();
  if (ApplicationFactory.isPoppedOut()) {
    ApplicationFactory.PersistToParentStorage(
      "egPopoutWindow",
      "true",
      "session"
    );
  }
  ApplicationFactory.ValidateApplicationState().then(
    function (isValid) {
      ApplicationFactory.InitializeApplicationState();
      if (isValid) {
        processChatData(
          $rootScope,
          $state,
          $window,
          ApplicationFactory,
          SessionFactory,
          $http
        );
      } else {
        $state.go("chat.error");
      }
    },
    function () {}
  );
});
var processChatData = function (
  $rootScope,
  $state,
  $window,
  ApplicationFactory,
  SessionFactory,
  $http
) {
  var isSmallDevice = ApplicationFactory.CheckMobile();
  var egChatSessionId = ApplicationFactory.GetUrlParameter("egSessionId");
  var egLastRequestId = ApplicationFactory.GetUrlParameter("egLastRequestId");
  var isVAEnabled =
    ApplicationFactory.GetUrlParameter("VAEnabled") === "true" ? true : false;
  var egVASessionId = ApplicationFactory.GetUrlParameter("VASessionId");
  var egVAActive =
    ApplicationFactory.GetUrlParameter("VAActive") === "true" ? true : false;
  var egVAEscalated =
    ApplicationFactory.GetUrlParameter("VAEscalated") === "true" ? true : false;
  var egOffRecordBtnState =
    ApplicationFactory.GetUrlParameter("egOffRecordBtnState") === "true"
      ? true
      : false;
  var isChatAttachmentEnabled = ApplicationFactory.GetUrlParameter(
    "isChatAttachmentEnabled"
  );
  var parentLostWhileChatInProgressInPopout =
    ApplicationFactory.GetUrlParameter("parentLost") === "true";
  if (
    true === ApplicationFactory.IsDocked() ||
    true === ApplicationFactory.isPoppedOut()
  ) {
    ApplicationFactory.RetrieveFromParentStorage(
      "egSessionId",
      clearSessionStateIfNotValid
    );
  } else {
    processChat();
  }
  function clearSessionStateIfNotValid(data) {
    if (data) {
      var req = {
        method: "POST",
        url:
          applicationDefaults.eGainChatApiPath +
          "/egain/chat/entrypoint/transcript",
        data: { sid: data },
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
        },
      };
      $http(req).then(
        function (response) {
          processChat(data);
        },
        function (error) {
          if ("400-115" === error.data.code) {
            SessionFactory.ClearSessionState();
            processChat(null);
          } else {
            $state.go("chat.error");
          }
        }
      );
    } else {
      processChat(data);
    }
  }
  function processChat(data) {
    if (data) {
      egChatSessionId = data;
    }
    var isNewChat = egChatSessionId === null || egLastRequestId === null;
    ApplicationFactory.GetXEgainSessionIDOnLoad();
    ApplicationFactory.GetTabIDOnLoad();
    if (true === ApplicationFactory.isPoppedOut()) {
      var saveSessionId = ApplicationFactory.RetrieveFromStorage(
        "egSessionId",
        "session"
      );
      if (saveSessionId && saveSessionId === egChatSessionId) {
        isNewChat = true;
      }
    } else if (true === ApplicationFactory.IsUndocked()) {
      egChatSessionId =
        ApplicationFactory.GetParameterFromUrlOrStorage("egSessionId");
      egLastRequestId = ApplicationFactory.GetCookie(
        "egain-last-success-request-id"
      );
      egLastRequestId = egLastRequestId
        ? "" + (parseInt(egLastRequestId) + 1)
        : null;
      var isInProgressFlagInLocal =
        ApplicationFactory.GetParameterFromUrlOrStorage(
          "isUnDockedChatInProgress"
        ) == "true";
      egOffRecordBtnState =
        ApplicationFactory.GetParameterFromUrlOrStorage(
          "egOffRecordBtnState"
        ) === "true"
          ? true
          : false;
      isChatAttachmentEnabled = ApplicationFactory.GetParameterFromUrlOrStorage(
        "isChatAttachmentEnabled"
      );
      isNewChat = egChatSessionId === null || egLastRequestId === null;
      if (isInProgressFlagInLocal) {
        isNewChat = true;
      }
    }
    if (egVASessionId) {
      isNewChat = false;
    }
    $rootScope.isSmallDevice = isSmallDevice;
    $rootScope.isDocked = ApplicationFactory.IsDocked();
    $rootScope.isLargeDevice = !$rootScope.isSmallDevice;
    if (isNewChat) {
      ApplicationFactory.RemoveFromStorage("agentJoined", "local");
      if (!true === ApplicationFactory.IsUndocked()) {
        SessionFactory.ClearSessionState();
      }
      if (isVAEnabled) {
        $state.go("launch-va", { launchVA: true });
      } else {
        $state.go("launch-chat", { launchChat: true });
      }
    } else {
      if (egVAActive || egVAEscalated) {
        SessionFactory.SetVASessionId(egVASessionId);
      }
      if (egVAActive) {
        $state.go("attach");
      } else if (true === parentLostWhileChatInProgressInPopout) {
        isSessionStillActive(egChatSessionId, $http, $state, SessionFactory);
      } else {
        var chatSessionData = {
          sessionID: egChatSessionId,
          lastRequestId: egLastRequestId,
          OffRecordBtnState: egOffRecordBtnState,
        };
        SessionFactory.SetSessionState(chatSessionData, egLastRequestId);
        $state.go("attach");
      }
      if (isChatAttachmentEnabled) {
        SessionFactory.SetChatTransferredFlag(true);
        SessionFactory.SetChatAttachmentEnabledFlag(
          isChatAttachmentEnabled === "true"
        );
      } else {
        SessionFactory.SetChatTransferredFlag(false);
      }
    }
  }
};
var isSessionStillActive = function (chatId, $http, $state, SessionFactory) {
  if (chatId) {
    var req = {
      method: "POST",
      url:
        applicationDefaults.eGainChatApiPath +
        "/egain/chat/entrypoint/transcript",
      data: { sid: chatId },
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json",
      },
    };
    $http(req).then(
      function (response) {},
      function (error) {
        if ("400-115" === error.data.code) {
          SessionFactory.ClearSessionState();
          $state.go("launch-chat", { launchChat: true });
        }
      }
    );
  }
};
app
  .config(function ($stateProvider) {
    var services = {
      ApplicationFactory: "ApplicationFactory",
      ConfigFactory: "ConfigFactory",
      ConnectionFactory: "ConnectionFactory",
      CustomerFactory: "CustomerFactory",
      ChatHeaderFactory: "ChatHeaderFactory",
      SessionFactory: "SessionFactory",
      VideoFactory: "VideoFactory",
      AttachmentFactory: "AttachmentFactory",
      AuthenticationFactory: "AuthenticationFactory",
    };
    $stateProvider
      .state("launch-va", {
        templateUrl:
          applicationDefaults.eGainContextPath +
          "pages/va-landing/va-landing.html",
        resolve: services,
        params: { launchVA: false },
      })
      .state("launch-chat", {
        templateUrl:
          applicationDefaults.eGainContextPath +
          "pages/chat-landing/chat-landing.html",
        resolve: services,
        params: { launchChat: false, nextChatState: null },
      })
      .state("chat", {
        templateUrl:
          applicationDefaults.eGainContextPath +
          "pages/chat-main/chat-main.html",
        resolve: services,
        params: {
          currentLocale: applicationDefaults.eGainChatDefaultLocale,
          entryPointId: applicationDefaults.eGainChatEntryPointId,
        },
      })
      .state("initialize", {
        templateUrl:
          applicationDefaults.eGainContextPath +
          "pages/chat-initialize/chat-initialize.html",
        resolve: services,
        params: {
          currentLocale: applicationDefaults.eGainChatDefaultLocale,
          entryPointId: applicationDefaults.eGainChatEntryPointId,
        },
      })
      .state("attach", {
        templateUrl:
          applicationDefaults.eGainContextPath +
          "pages/chat-attach/chat-attach.html",
        resolve: services,
      })
      .state("chat.pre-chat", {
        templateUrl:
          applicationDefaults.eGainContextPath + "pages/pre-chat/pre-chat.html",
        params: { VAEscalated: false, VAShowPreChat: false },
      })
      .state("chat.interaction", {
        templateUrl:
          applicationDefaults.eGainContextPath +
          "pages/interaction/interaction.html",
        params: { attachedChat: false, chatConnectionInfo: null },
      })
      .state("chat.post-chat", {
        templateUrl:
          applicationDefaults.eGainContextPath +
          "pages/post-chat/post-chat.html",
      })
      .state("chat.thank-you", {
        templateUrl:
          applicationDefaults.eGainContextPath +
          "pages/thanks-message/thanks-message.html",
      })
      .state("chat.deflection", {
        templateUrl:
          applicationDefaults.eGainContextPath +
          "pages/chat-deflection/chat-deflection.html",
        params: { customer: {}, oneTagCustomerInfo: {} },
      })
      .state("chat.deflection.escalation-results", {
        template:
          "<div ng-include=\"'components/escalation-search-results-list/escalation-search-results-list.html'\"></div>",
      })
      .state("chat.deflection.article", {
        template:
          "<div ng-include=\"'components/article-content/article-content.html'\"></div>",
        params: { articleId: null, searchTerm: null, portalLanguage: null },
      })
      .state("chat.chat-unavailable", {
        templateUrl:
          applicationDefaults.eGainContextPath +
          "pages/chat-unavailable/chat-unavailable.html",
        params: { condition: null },
      })
      .state("chat.error", {
        templateUrl:
          applicationDefaults.eGainContextPath + "pages/error/error.html",
        params: { errorCode: null, errorMsg: null, minimizePage: false },
      });
  })
  .config([
    "$translateProvider",
    function ($translateProvider) {
      $translateProvider.useStaticFilesLoader({
        prefix: applicationDefaults.eGainContextPath + "l10n/",
        suffix: ".json",
      });
      $translateProvider.preferredLanguage(
        applicationDefaults.eGainChatDefaultLocale
      );
      $translateProvider.useSanitizeValueStrategy("sceParameters");
    },
  ])
  .config(["$sessionStorageProvider", function ($sessionStorageProvider) {}])
  .config([
    "$httpProvider",
    function ($httpProvider) {
      $httpProvider.interceptors.push("HttpInterceptorFactory");
    },
  ])
  .config([
    "$compileProvider",
    function ($compileProvider) {
      $compileProvider.imgSrcSanitizationWhitelist(
        /^\s*(https?|ftp|blob):|data:image\//
      );
      $compileProvider.aHrefSanitizationWhitelist(
        /^\s*(https?|ftp|blob|mailto):|data:image\//
      );
    },
  ]);
app.directive("egChatLaunchButton", [
  "$state",
  "$stateParams",
  "$rootScope",
  "ApplicationFactory",
  "VAFactory",
  function ($state, $stateParams, $rootScope, ApplicationFactory, VAFactory) {
    return {
      link: function ($scope, $element, attrs) {
        $element.ready(function () {
          if (!$rootScope.isSmallDevice) {
            var lout;
            function expandLaunchButton(event, data) {
              $element.addClass("egain-hover");
              clearTimeout(lout);
              lout = setTimeout(function () {
                var resize = ApplicationFactory.CreatePayload(
                  "RESIZE_WINDOW",
                  "EG_LAUNCH_HOVER",
                  "",
                  "EGLV_DOCK_CALLER_SET"
                );
                ApplicationFactory.PostMessageToParent(resize);
              }, 0);
            }
            function collapseLaunchButton(event, data) {
              $element.removeClass("egain-hover");
              clearTimeout(lout);
              lout = setTimeout(function () {
                var resize = ApplicationFactory.CreatePayload(
                  "RESIZE_WINDOW",
                  "EG_LAUNCH_HOVER_OUT",
                  "",
                  "EGLV_DOCK_CALLER_SET"
                );
                ApplicationFactory.PostMessageToParent(resize);
              }, 800);
            }
            var chatLaunchContainer = $element.find("div");
            chatLaunchContainer.bind("focus", function (event, data) {
              expandLaunchButton(event, data);
            });
            chatLaunchContainer.bind("blur", function (event, data) {
              collapseLaunchButton(event, data);
            });
            $element.bind("mouseover", function (event, data) {
              expandLaunchButton(event, data);
            });
            $element.bind("mouseout", function (event, data) {
              collapseLaunchButton(event, data);
            });
          }
          var launchButtonHandler = function (event, data) {
            event.preventDefault();
            var enableTrackerMsg = ApplicationFactory.CreatePayload(
              "NOTIFY",
              "EG_ENABLE_TRACKER",
              "",
              "EGLV_DOCK_CALLER_SET"
            );
            ApplicationFactory.PostMessageToParent(enableTrackerMsg);
            if ($stateParams.launchVA) {
              VAFactory.SetVAActive(true);
              if (
                ApplicationFactory.GetUrlParameter("proactiveDockedOffer") ===
                "1"
              ) {
                var acceptEventData = {};
                acceptEventData = {
                  reason: ApplicationFactory.GetUrlParameter("reason"),
                  bannerid: ApplicationFactory.GetUrlParameter("bannerid"),
                  ruleId: ApplicationFactory.GetUrlParameter("ruleId"),
                  interactionId:
                    ApplicationFactory.GetUrlParameter("interactionId"),
                  proactiveDocked: "1",
                };
                ApplicationFactory.PostMessageToParent(acceptEventData);
              }
              $state.go("chat.interaction");
            } else {
              if ($scope.page.OnetagFailure === true) {
                $state.go("chat.error", { errorCode: "ONETAG_FAILURE" });
                return;
              }
              if (
                ApplicationFactory.GetUrlParameter("proactiveDockedOffer") ===
                "1"
              ) {
                var acceptEventData = {};
                acceptEventData = {
                  reason: ApplicationFactory.GetUrlParameter("reason"),
                  bannerid: ApplicationFactory.GetUrlParameter("bannerid"),
                  ruleId: ApplicationFactory.GetUrlParameter("ruleId"),
                  interactionId:
                    ApplicationFactory.GetUrlParameter("interactionId"),
                  proactiveDocked: "1",
                };
                ApplicationFactory.PostMessageToParent(acceptEventData);
              }
              $state.go("initialize");
            }
          };
          if (!$rootScope.isSmallDevice) {
            var launchButtonInputs = $element[0].querySelector(
              ".chat-launch-input-container"
            );
            if (launchButtonInputs) {
              angular
                .element(launchButtonInputs)
                .bind("click", launchButtonHandler);
            }
            $element.bind("keydown", function (event) {
              var code = event.keyCode || event.which;
              if (code === 13) {
                launchButtonHandler(event);
              }
            });
          } else {
            $element.bind("click", launchButtonHandler);
          }
        });
      },
      restrict: "A",
    };
  },
]);
app.directive("egToolbar", [
  "$window",
  "$filter",
  "$rootScope",
  "$timeout",
  "ConnectionFactory",
  "ConfigFactory",
  "TranscriptFactory",
  "VideoFactory",
  "ApplicationFactory",
  "MessageFactory",
  "$translate",
  function (
    $window,
    $filter,
    $rootScope,
    $timeout,
    ConnectionFactory,
    ConfigFactory,
    TranscriptFactory,
    VideoFactory,
    ApplicationFactory,
    MessageFactory,
    $translate
  ) {
    function download(data, filename, type) {
      if (MobileInterface) {
        MobileInterface.SaveTranscript(data);
      } else {
        var a = document.createElement("a"),
          file = new Blob([data], { type: type });
        if (window.navigator.msSaveOrOpenBlob) {
          window.navigator.msSaveOrOpenBlob(file, filename);
        } else if (
          ApplicationFactory.IsVisitorIOSPhone() ||
          ApplicationFactory.IsVisitorIOSTablet()
        ) {
          var reader = new FileReader();
          var url = [
            window.location.protocol,
            "//",
            window.location.host,
            applicationDefaults.eGainChatApiPath,
            "/templates/chat/",
            ApplicationFactory.GetUrlParameter("templateName"),
            "/transcript/blank.html",
          ].join("");
          var transcriptWindow = window.open(url);
          reader.onloadend = function (e) {
            transcriptWindow.document.write(data);
            transcriptWindow.document.close();
          };
          transcriptWindow.onload = function () {
            reader.readAsDataURL(file);
          };
        } else {
          var url = URL.createObjectURL(file);
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          setTimeout(function () {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
          }, 50);
        }
      }
    }
    function getTranscript() {
      var content = new Array();
      return TranscriptFactory.GetTranscript().then(function (
        transcriptContent
      ) {
        content.push(transcriptContent);
        content.push("</body></html>");
        var transcriptContent = content.join(" ");
        var parser = new DOMParser();
        var transcriptDoc = parser.parseFromString(
          transcriptContent,
          "text/html"
        );
        var chatMessagesStr =
          transcriptDoc.getElementById("chatMessages").innerHTML;
        chatMessagesStr = chatMessagesStr.replace(
          /onclick\s*=\s*[\"\'].*?[\"\']/gi,
          ""
        );
        chatMessagesStr = chatMessagesStr.replace(/<script.*?\/script>/gi, "");
        chatMessagesStr = chatMessagesStr.replace(/<a.*?>/gi, "<u>");
        chatMessagesStr = chatMessagesStr.replace(/<\/a>/gi, " </u>");
        transcriptDoc.getElementById("chatMessages").innerHTML =
          chatMessagesStr;
        return transcriptDoc.documentElement.innerHTML;
      });
    }
    function saveTranscript() {
      getTranscript().then(function (contentVal) {
        var div = document.createElement("div");
        div.setAttribute("id", "chatTranscript");
        div.innerHTML = contentVal;
        var x = div.getElementsByTagName("img");
        var protocol = document.location.protocol;
        var hostname = document.location.hostname;
        var baseUrl = protocol + "//" + hostname;
        for (var i = 0; i < x.length; i++) {
          var url = div.getElementsByTagName("img").item(i).getAttribute("src");
          url = ApplicationFactory.addBaseURL(url, baseUrl);
          div.getElementsByTagName("img").item(i).setAttribute("src", url);
        }
        contentVal = div.innerHTML;
        contentVal =
          "<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>" +
          contentVal;
        var sysdate = $filter("date")(new Date(), "MMMdd_yyyy_hhmma");
        download(contentVal, "transcript_" + sysdate + ".htm", "html");
      });
    }
    return {
      link: function (scope, $element, attrs) {
        var knowledgeBaseUrl =
          ConfigFactory.GetChatConfigurations().KnowledgeBaseUrl;
        var knowledgeBaseUrlTarget =
          ConfigFactory.GetChatConfigurations().KnowledgeBaseUrlTarget;
        function disableLinksIfCustomerBlocked() {
          var asideLinks = document.querySelectorAll(".ass-aside-menu-item");
          var allowedLinkIds = ["egain-save-transcript", "egain-faq"];
          for (var i = 0; i < asideLinks.length; i++) {
            if (allowedLinkIds.indexOf(asideLinks[i].id) === -1) {
              asideLinks[i].classList.add("disabled-link");
            }
          }
        }
        scope.$on(
          "application_service_customer_block_event",
          function (evt, data) {
            disableLinksIfCustomerBlocked();
          }
        );
        $element.bind("click", function (event, data) {
          var elementId = event.target.id;
          if ("" === elementId) {
            elementId = event.target.parentElement
              ? event.target.parentElement.id
              : "";
          }
          if (ApplicationFactory.GetCustomerBlocked() === true) {
            disableLinksIfCustomerBlocked();
          }
          if (elementId === "egain-save-transcript") {
            event.preventDefault();
            scope.page.menuexpanded = false;
            var oneTagEventInfo = ConnectionFactory.GetConnection().connected
              ? { EventName: "ChatMenuButton", ButtonDesc: "Save" }
              : {
                  EventName: "ChatSurveyMenuButton",
                  ButtonDesc: "Save-Transcript",
                };
            eGainOneTagUtil.pushChatEvent("uac", oneTagEventInfo);
            saveTranscript();
          }
          if (elementId === "egain-faq") {
            var subject = $rootScope.subject ? $rootScope.subject : "";
            event.preventDefault();
            var oneTagEventInfo = ConnectionFactory.GetConnection().connected
              ? { EventName: "ChatMenuButton", ButtonDesc: "FAQ" }
              : { EventName: "ChatSurveyMenuButton", ButtonDesc: "FAQ" };
            eGainOneTagUtil.pushChatEvent("uac", oneTagEventInfo);
            scope.page.menuexpanded = false;
            if (knowledgeBaseUrl && knowledgeBaseUrl.length > 0) {
              var isDocked = ApplicationFactory.IsDocked();
              var url = "";
              if (knowledgeBaseUrl.indexOf("<search_text>") != -1) {
                url = knowledgeBaseUrl.replace(
                  "<search_text>",
                  encodeURIComponent(subject)
                );
              } else {
                url = knowledgeBaseUrl;
              }
              var target = knowledgeBaseUrlTarget;
              switch (target) {
                case "_new":
                  $window.open(url);
                  break;
                case "_parent":
                  if (isDocked) {
                    parent.window.location.href = url;
                  } else {
                    if (window.opener) {
                      window.opener.location.href = url;
                    }
                  }
                  break;
                default:
                  $window.open(url);
                  break;
              }
            }
          }
          if (elementId === "egain-off-record") {
            event.preventDefault();
            var oneTagEventInfo = { EventName: "ChatOffRecord" };
            eGainOneTagUtil.pushChatEvent("uac", oneTagEventInfo);
            scope.offRecord = !scope.offRecord;
            $translate(["APP.EG_OFF_RECORD"]).then(function (translations) {
              var offRecordMsg = translations["APP.EG_OFF_RECORD"];
              MessageFactory.SendSystemMessage(offRecordMsg, "offrecord");
            });
            scope.addRemoveToolbarButton("offRecord", false);
            scope.addRemoveToolbarButton("onRecord", true);
            scope.enableAttachmentLink(true);
            scope.$apply();
          }
          if (elementId === "egain-on-record") {
            event.preventDefault();
            scope.offRecord = !scope.offRecord;
            $translate(["APP.EG_ON_RECORD"]).then(function (translations) {
              var onRecordMsg = translations["APP.EG_ON_RECORD"];
              MessageFactory.SendSystemMessage(onRecordMsg, "onrecord");
            });
            scope.addRemoveToolbarButton("offRecord", true);
            scope.addRemoveToolbarButton("onRecord", false);
            scope.enableAttachmentLink(false);
            scope.$apply();
          }
          if (elementId === "egain-video-chat") {
            event.preventDefault();
            VideoFactory.VideoClick();
          }
          if (elementId === "egain-audio-chat") {
            event.preventDefault();
            VideoFactory.AudioClick();
          }
        });
      },
      restrict: "AEC",
    };
  },
]);
app.directive("closelink", [
  "$window",
  "ApplicationFactory",
  "ConnectionFactory",
  "SessionFactory",
  "VAFactory",
  "hotkeys",
  function (
    $window,
    ApplicationFactory,
    ConnectionFactory,
    SessionFactory,
    VAFactory,
    hotkeys
  ) {
    return {
      link: function ($scope, $element, attrs) {
        var confirmMessage = "";
        ApplicationFactory.Translate("APP.EG_CONFIRM_CLOSE_CHAT").then(
          function (result) {
            confirmMessage = result;
          }
        );
        var endChat = function (element) {
          if (ConnectionFactory.GetConnection().connected) {
            if (element) {
              var closeBtn = angular.element(element);
              if (closeBtn) {
                closeBtn.addClass("disabled");
              }
            }
            ConnectionFactory.IsNetworkConnectionActive().then(function (
              response
            ) {
              if (false === response) {
                ConnectionFactory.ShowConnectionErrorMessage();
                return;
              }
              if (closeBtn && true === closeBtn.hasClass("disabled")) {
                closeBtn.removeClass("disabled");
              }
              if (confirm(confirmMessage)) {
                $window.clearInterval($window.myIntervalId);
                eGainOneTagUtil.pushChatEvent("uac", {
                  EventName: "ChatExit",
                  "Termination-Initiation": "User",
                });
                ApplicationFactory.SetChatEndedFromCustomerSide(true);
                ConnectionFactory.EndChat("close_button_click");
              }
            });
          } else if (VAFactory.IsVAActive()) {
            if (confirm(confirmMessage)) {
              if (!SessionFactory.GetDuplicateSessionFlag()) {
                SessionFactory.ClearSessionState();
              }
              ApplicationFactory.ResetChat();
              if (!ApplicationFactory.IsDocked()) {
                if (ApplicationFactory.isPoppedOut()) {
                  ApplicationFactory.PersistToParentStorage(
                    "egPopoutWindow",
                    "false",
                    "session"
                  );
                }
                $window.close();
              }
            }
          } else {
            if (!SessionFactory.GetDuplicateSessionFlag()) {
              SessionFactory.ClearSessionState();
            }
            ApplicationFactory.ResetChat();
            if (!ApplicationFactory.IsDocked()) {
              if (ApplicationFactory.isPoppedOut()) {
                ApplicationFactory.PersistToParentStorage(
                  "egPopoutWindow",
                  "false",
                  "session"
                );
              }
              $window.close();
            }
          }
        };
        hotkeys.add({
          combo: "esc",
          description: "Close chat",
          callback: function () {
            endChat();
          },
        });
        $element.on("click", function () {
          if (MobileInterface) {
            MobileInterface.SendCloseButtonClicked();
          }
          endChat(this);
        });
      },
      restrict: "A",
    };
  },
]);
app.directive("messagesubmit", [
  "$rootScope",
  "$timeout",
  "ApplicationFactory",
  "ConfigFactory",
  "VAFactory",
  function (
    $rootScope,
    $timeout,
    ApplicationFactory,
    ConfigFactory,
    VAFactory
  ) {
    return {
      restrict: "A",
      link: function ($scope, $element, $attrs) {
        $scope.isCustomerTyping = false;
        var chatConfig = ConfigFactory.GetChatConfigurations();
        var setTypingStatus = function () {
          $timeout(function () {
            try {
              var maxCharacterCount = chatConfig.MaxMessageSize;
              var currentCount = 0;
              currentCount = $scope.customerMessage.length;
              var remainderCount = maxCharacterCount - currentCount;
              if (remainderCount <= 50) {
                $scope.showTypingStatus = true;
                $scope.characterCountRemaining = remainderCount;
              } else {
                $scope.showTypingStatus = false;
              }
            } catch (error) {}
          }, 0);
        };
        $element.bind("keydown input", function (event) {
          var code = event.keyCode || event.which;
          if (!VAFactory.IsVAActive()) {
            if ($scope.scp.customerTypingTimer) {
              $timeout.cancel($scope.scp.customerTypingTimer);
              $scope.scp.customerTypingTimer = null;
            } else {
              $scope.sendCustomerStartTypingStatus();
              $scope.isCustomerTyping = true;
            }
            $scope.scp.customerTypingTimer = $timeout(function () {
              if ($scope.scp.customerTypingTimer) {
                $scope.sendCustomerStopTypingStatus();
              }
              $scope.scp.customerTypingTimer = null;
            }, chatConfig.CustomerNoTypingTimeout);
          }
          blurIfRequired = function (event) {
            var messages = angular.element(
              document.querySelectorAll("#msg_container .chat-message .message")
            );
            if (messages.length < 3) {
              event.target.blur();
            }
          };
          if (code === 13 && !event.shiftKey) {
            event.preventDefault();
            $scope.$apply(function () {
              $scope.processAndSendMessage(event);
              if (
                ApplicationFactory.IsVisitorIOSPhone() ||
                ApplicationFactory.IsVisitorIOSTablet()
              ) {
                blurIfRequired(event);
              }
            });
          }
          if (code === 9) {
            $scope.focusTextArea = false;
          }
          setTypingStatus();
        });
        var chatWindow = angular.element(
          document.querySelector("#egain-chat-overlay")
        );
        var is_landscape = false;
        var updateView = function () {
          is_landscape = screen.height < screen.width;
          if (is_landscape) {
            chatWindow.addClass("message-edit-wrapper");
          } else {
            chatWindow.removeClass("message-edit-wrapper");
          }
        };
        $element.bind("focus", function (event) {
          $scope.isEditiorFocussed = true;
          setTypingStatus();
          if ($rootScope.isSmallDevice) {
            updateView();
            window.addEventListener("resize", updateView, false);
          }
        });
        $element.bind("blur", function (event) {
          $scope.isEditiorFocussed = false;
          if ($rootScope.isSmallDevice) {
            chatWindow.removeClass("message-edit-wrapper");
            window.removeEventListener("resize", updateView, false);
          }
        });
        $element.bind("keyup", function (event) {});
        if ($rootScope.isLargeDevice) {
          $element.ready(function () {
            $element[0].focus();
          });
          $scope.$on("application_sidebar_closed", function () {
            $element[0].focus();
          });
        }
      },
    };
  },
]);
app.directive("egLoginParams", [
  "$timeout",
  "$filter",
  "ConfigFactory",
  function ($timeout, $filter, ConfigFactory) {
    return {
      restrict: "A",
      link: function ($scope, $element, $attrs) {
        if ($scope.$last) {
          $scope.preChatForm.loaded = true;
        }
      },
    };
  },
]);
app.directive("egFormInput", [
  "$timeout",
  "$rootScope",
  "ApplicationFactory",
  function ($timeout, $rootScope, ApplicationFactory) {
    return {
      restrict: "A",
      scope: { submitEnter: "=", egFormInput: "=" },
      link: function ($scope, $element, $attrs) {
        if ($attrs.checkOnLoad === "true") {
          $scope.$watch("isReady", function (newValue, oldValue) {
            if (newValue === true) {
              $timeout(function () {
                try {
                  $scope.countAttr = $element.val().length;
                } catch (error) {}
              });
            }
          });
        }
        if ($rootScope.isSmallDevice) {
          var isAndroid = false;
          if (ApplicationFactory.IsVisitorAndroid()) {
            isAndroid = true;
          }
          var is_landscape = false;
          var chatWindow = angular.element(
            document.querySelector("#egain-chat-overlay")
          );
          var $el = $element[0];
          var doneBtn = angular.element(
            $el.parentNode.getElementsByClassName("egain-done-btn")[0]
          );
          var updateView = function () {
            if (isAndroid) {
              is_landscape = screen.height < screen.width;
            } else {
              is_landscape = !(window.innerHeight > window.innerWidth);
            }
            if (is_landscape) {
              chatWindow.addClass("form-edit-wrapper");
              angular.element($el.parentNode).addClass("edit-wrapper");
              document.body.scrollTop = document.documentElement.scrollTop = 0;
            } else {
              chatWindow.removeClass("form-edit-wrapper");
              angular.element($el.parentNode).removeClass("edit-wrapper");
            }
          };
          $element.bind("focus", function () {
            updateView();
            window.addEventListener("resize", updateView, false);
          });
          doneBtn.bind("click", function () {
            chatWindow.removeClass("form-edit-wrapper");
            window.removeEventListener("resize", updateView, false);
            angular.element($el.parentNode).removeClass("edit-wrapper");
          });
          $element.bind("blur", function (event) {
            chatWindow.removeClass("form-edit-wrapper");
            window.removeEventListener("resize", updateView, false);
            angular.element($el.parentNode).removeClass("edit-wrapper");
          });
        }
        $element.bind("keydown", function (event) {
          if ($scope.egFormInput && $scope.egFormInput.error) {
            $scope.$apply(function () {
              $scope.egFormInput.error = false;
            });
          }
          if (event.keyCode == 13 && !event.shiftKey) {
            event.preventDefault();
            $scope.submitEnter = true;
            $scope.$apply();
            return false;
          }
        });
      },
    };
  },
]);
app.directive("egChatTranscript", [
  "$window",
  "$rootScope",
  "MessageFactory",
  "AttachmentFactory",
  "VideoFactory",
  "AuthenticationFactory",
  "ApplicationFactory",
  function (
    $window,
    $rootScope,
    MessageFactory,
    AttachmentFactory,
    VideoFactory,
    AuthenticationFactory,
    ApplicationFactory
  ) {
    return {
      link: function (scope, element, attrs) {
        scope.page.isScrolledToBottom = function () {
          var contentDiv = document.querySelector(".egain-chat-content");
          if (
            Math.round(contentDiv.scrollHeight - contentDiv.offsetHeight) -
              Math.round(contentDiv.scrollTop) <=
            1
          ) {
            return true;
          }
          return false;
        };
        scope.page.scrollToBottom = function () {
          var contentDiv = document.querySelector(".egain-chat-content");
          if (contentDiv) {
            contentDiv.scrollTop = contentDiv.scrollHeight;
            scope.page.showNewMessageSign = false;
          }
        };
        scope.page.isScrollingOn = function () {
          var contentDiv = document.querySelector(".egain-chat-content");
          return contentDiv.scrollHeight > contentDiv.clientHeight;
        };
        element.on("click", function (event) {
          if (event.target.id === "egcb_join_link") {
            event.preventDefault();
            var aTag = event.target;
            var sessionId = event.target.getAttribute("egcb-sessionid");
            var winName = event.target.getAttribute("egcb-winname");
            var href = event.target.getAttribute("egcb-href");
            var templateLocale = new RegExp("[\\?&]locale=([^&#]*)").exec(
              document.location.href
            );
            var locale =
              templateLocale == null
                ? "en_US"
                : decodeURIComponent(templateLocale[1].replace(/-/g, "_"));
            event.target.getAttribute("target", winName);
            if (
              scope.page.eGainDockedChatCb &&
              scope.page.eGainDockedChatCb.openCobrowseWindow
            ) {
              scope.page.eGainDockedChatCb.openCobrowseWindow(
                href,
                winName,
                sessionId,
                locale
              );
            }
          } else if (event.target.getAttribute("egainElement") === "video") {
            event.preventDefault();
            var userId = event.target.getAttribute("egainUserId");
            var avmode = event.target.getAttribute("egainAVMode");
            var eventAction = event.target.getAttribute("egainAction");
            eventAction = eventAction ? eventAction.toLowerCase() : "";
            switch (eventAction) {
              case "accept": {
                VideoFactory.AcceptVideoChat(userId, avmode);
                break;
              }
              case "reject": {
                VideoFactory.DeclineVideoChat(userId, avmode);
                break;
              }
            }
          } else if (
            event.target.id &&
            event.target.id.indexOf("va-radio-options") != -1
          ) {
            event.preventDefault();
            var message = event.target.value;
            message = decodeURIComponent(message);
            event.target.parentNode.parentNode.hidden = true;
            MessageFactory.SendMessageToAgent(message);
          } else if (event.target.id === "va-text") {
            event.preventDefault();
            var message = event.target.href;
            var offset = -1;
            if (message) {
              offset = message.indexOf("javascript:doReply");
            }
            if (offset >= 0) {
              var offset2 = message.lastIndexOf(")");
              if (offset2 > offset) {
                message = message.substring(offset + 20, offset2 - 1);
                message = decodeURIComponent(message);
                MessageFactory.SendMessageToAgent(message);
                document
                  .querySelector(
                    "#egain-chat-message-input-horizontal textarea"
                  )
                  .focus();
              }
            }
          } else if (event.target.id === "eg-attachment-link") {
            event.preventDefault();
            AttachmentFactory.GetArticleAttachment(
              event.target.getAttribute("eg-attachment-id")
            );
          } else if (
            event.target.getAttribute("egainElement") === "authenticate"
          ) {
            event.preventDefault();
            var requestId = event.target.getAttribute("authReqId");
            var eventAction = event.target.getAttribute("egainAction");
            eventAction = eventAction ? eventAction.toLowerCase() : "";
            switch (eventAction) {
              case "accept": {
                var confirmMessage = "";
                ApplicationFactory.Translate(
                  "APP.EG_AUTH_REDIRECTION_IN_PROGRESS"
                ).then(function (result) {
                  confirmMessage = result;
                  var windowFeatures =
                    "top=0,left=0,height=650,width=450,resizable=yes,scrollbars=yes,toolbar=no";
                  var windowName = "authWindow";
                  $rootScope.authWindow = $window.open(
                    "",
                    windowName,
                    windowFeatures
                  );
                  $rootScope.authWindow.document.write(confirmMessage);
                  var authReqButtonParentElement = angular
                    .element(event.target)
                    .parent();
                  if (authReqButtonParentElement) {
                    authReqButtonParentElement.children().addClass("disabled");
                  }
                  AuthenticationFactory.AcceptAuthRequest(requestId);
                });
                break;
              }
              case "reject": {
                var authReqButtonParentElement = angular
                  .element(event.target)
                  .parent();
                if (authReqButtonParentElement) {
                  authReqButtonParentElement.children().addClass("disabled");
                }
                AuthenticationFactory.DeclineAuthRequest(requestId);
                break;
              }
            }
          } else if (event.target.nodeName === "A") {
            event.preventDefault();
            var ele = angular.element(event.target);
            var url = ele.attr("href");
            if (url && "string" === typeof url && "#" !== url) {
              $window.open(url, "eGainChat");
            }
          }
        });
      },
    };
  },
]);
app.directive("scrollBottom", [
  "$timeout",
  function ($timeout) {
    function link($scope, $element, attrs) {
      $element.on("click", function () {
        $timeout(function () {
          var elem = document.getElementsByClassName(attrs.scrollWindow)[0];
          elem.scrollTop = elem.scrollHeight;
        }, 0);
      });
    }
    return { link: link, scope: { scrollBottom: "=" }, restrict: "A" };
  },
]);
app.directive("egStatusBar", function ($timeout) {
  function link(scope, element, attrs) {
    var transcriptElement;
    element.ready(function () {
      transcriptElement = document.querySelector(".egain-chat-content");
      scope.isScrolledToBottom = function () {
        if (
          Math.round(
            transcriptElement.scrollHeight - transcriptElement.offsetHeight
          ) -
            Math.round(transcriptElement.scrollTop) <=
          1
        ) {
          return true;
        }
        return false;
      };
      scope.$watch("page.showNewMessageSign", function (newValue, oldValue) {
        if (newValue) {
          angular.element(transcriptElement).on("scroll", function () {
            var ifTranscriptScrolledToBottom = scope.isScrolledToBottom();
            if (ifTranscriptScrolledToBottom && scope.page.showNewMessageSign) {
              scope.page.showNewMessageSign = false;
              scope.$apply();
            }
          });
        } else {
          angular.element(transcriptElement).off("scroll");
        }
      });
    });
  }
  return { link: link, restrict: "A" };
});
app.directive("egSearchresultArticleLink", [
  "$state",
  function ($state) {
    return {
      restrict: "A",
      link: function (scope, element, attrs) {
        element.on("click", function () {
          var oneTagEventInfo = {
            EventName: "ChatKBSearchView",
            ArticleId: scope.article.id,
            Rank: this.getAttribute("index")
              ? parseInt(this.getAttribute("index")) + 1
              : 0,
          };
          eGainOneTagUtil.pushChatEvent("uac", oneTagEventInfo);
          $state.go("chat.deflection.article", {
            articleId: scope.article.id,
            searchTerm: scope.searchTerm,
            portalLanguage: scope.portalLanguage,
          });
          scope.$apply();
        });
      },
    };
  },
]);
app.directive("egCallbackLink", [
  "$window",
  "ApplicationFactory",
  function ($window, ApplicationFactory) {
    return {
      link: function ($scope, $element, attrs) {
        $element.on("click", function () {
          if (
            $scope.contactOption.url != null &&
            $scope.contactOption.url !== ""
          ) {
            if (
              $scope.contactOption.url.toLowerCase().indexOf("mailto:") === 0
            ) {
              ApplicationFactory.SetMailLinkClicked(true);
              setTimeout(function () {
                ApplicationFactory.SetMailLinkClicked(false);
              }, 10);
            } else $window.open($scope.contactOption.url);
          }
        });
      },
      restrict: "A",
    };
  },
]);
app.directive("egMinimizeWindow", [
  "$state",
  "$rootScope",
  "ApplicationFactory",
  "MessageFactory",
  "GHFactory",
  "SessionFactory",
  function (
    $state,
    $rootScope,
    ApplicationFactory,
    MessageFactory,
    GHFactory,
    SessionFactory
  ) {
    return {
      link: function ($scope, $element, attrs) {
        var chatWindow = angular.element(
          document.querySelector("#egain-chat-overlay")
        );
        var chatHeader = angular.element(
          document.querySelector("#egain-chat-header-small")
        );
        $scope.$watch("page.visible", function (newValue) {
          if (newValue) {
            $scope.chatWindowHeight = chatWindow[0].offsetHeight;
          }
        });
        var rebuildScrollbar = function (e) {
          if (typeof $scope.page.scrollToBottom !== "undefined") {
            $scope.page.scrollToBottom();
          }
          e.target.removeEventListener("transitionend", rebuildScrollbar);
        };
        $scope.$watch("page.minimized", function (newValue, oldValue) {
          if (newValue == true) {
            if (oldValue !== true) {
              chatWindow.css("transition", "height .5s");
            }
            chatWindow.removeClass("egain-maximized");
            chatWindow.addClass("egain-minimized");
            var resize = ApplicationFactory.CreatePayload(
              "RESIZE_WINDOW",
              "EG_MINIMIZE",
              "",
              "EGLV_DOCK_CALLER_SET"
            );
            ApplicationFactory.PostMessageToParent(resize);
            if (!SessionFactory.GetDuplicateSessionFlag()) {
              ApplicationFactory.PersistToParentStorage(
                "egChatWindowState",
                $scope.page.minimized
              );
            }
          }
          if (newValue == false) {
            if (oldValue !== false) {
              chatWindow.css("transition", "height .5s");
            }
            var resize = ApplicationFactory.CreatePayload(
              "RESIZE_WINDOW",
              "EG_MAXIMIZE",
              "",
              "EGLV_DOCK_CALLER_SET"
            );
            ApplicationFactory.PostMessageToParent(resize);
            chatWindow.removeClass("egain-minimized");
            chatWindow.addClass("egain-maximized");
            if (GHFactory.GetGHActive()) {
              GHFactory.ExpandGHWindow(false);
            } else if (GHFactory.GetGHActive() === false) {
              GHFactory.CollapseGHWindow(false);
            }
            if (
              angular.equals($state.current.name, "chat.interaction") &&
              oldValue == true
            ) {
              document
                .querySelector("#egain-chat-overlay")
                .addEventListener("transitionend", rebuildScrollbar);
            }
            if ($scope.page.badgeCount > 0) {
              $scope.page.badgeCount = 0;
              MessageFactory.SetBadgeCount($scope.page.badgeCount);
            }
            if (!SessionFactory.GetDuplicateSessionFlag()) {
              ApplicationFactory.PersistToParentStorage(
                "egChatWindowState",
                $scope.page.minimized
              );
            }
          }
        });
        var savedWindowState =
          ApplicationFactory.GetUrlParameter("egChatWindowState");
        $scope.page.minimized = angular.equals("true", savedWindowState)
          ? true
          : false;
      },
      restrict: "A",
    };
  },
]);
app.directive("egResizeDiv", [
  function () {
    return {
      link: function ($scope, $element, attrs) {
        $scope.$watchGroup(
          ["page.ready", "page.headerLoaded"],
          function (newValues, oldValues) {
            if (newValues[0] && newValues[1]) {
              $scope.page.visible = true;
              removeWaitElement();
            }
          }
        );
      },
      restrict: "A",
    };
  },
]);
app.directive("egHeader", [
  function () {
    return {
      link: function ($scope, $element, attrs) {
        $element.ready(function () {
          $scope.page.progressbar.setParent($element[0]);
        });
      },
      restrict: "A",
    };
  },
]);
app.directive("egOffRecordBtn", [
  "$translate",
  "ApplicationFactory",
  "MessageFactory",
  function ($translate, ApplicationFactory, MessageFactory) {
    return {
      link: function ($scope, $element, attrs) {
        $scope.$watch("offRecord", function (newValue, oldValue) {
          if (newValue === true && oldValue === false) {
            MessageFactory.SetOffRecordFlag(true);
            ApplicationFactory.PersistToParentStorage(
              "egOffRecordBtnState",
              true
            );
          } else if (newValue === false && oldValue === true) {
            MessageFactory.SetOffRecordFlag(false);
            ApplicationFactory.PersistToParentStorage(
              "egOffRecordBtnState",
              false
            );
          }
        });
      },
      restrict: "A",
    };
  },
]);
app.directive("egArticleContent", [
  "$state",
  "$window",
  "$timeout",
  function ($state, $window, $timeout) {
    return {
      restrict: "AC",
      link: function (scope, el, attr) {
        scope.$watch("page.ready", function (newValue) {
          if (newValue) {
            $timeout(function () {
              angular
                .element(document.querySelector("#egain-chat-article-content"))
                .find("a")
                .on("click", function (e) {
                  e.preventDefault();
                  var a = document.createElement("a");
                  a.href = e.currentTarget.href;
                  a.hostname;
                  if (!(document.location.host == a.hostname)) {
                    $window.open(
                      e.currentTarget.href,
                      "_blank",
                      "toolbar=yes, scrollbars=yes, resizable=yes, top=60, left=500, width=600, height=600"
                    );
                  } else {
                    scope.page.previousArticles.push(scope.article.id);
                    $state.go("chat.deflection.article", {
                      articleId: e.target.id,
                    });
                    scope.$apply();
                  }
                });
            });
          }
        });
      },
    };
  },
]);
app.directive("egPopoutWindow", [
  "$window",
  "ApplicationFactory",
  "SessionFactory",
  function ($window, ApplicationFactory, SessionFactory) {
    return {
      link: function ($scope, $element, attrs) {
        $element.on("click", function () {
          ApplicationFactory.isPopoutButtonClicked(true);
          var p = ApplicationFactory.CreatePayload(
            "POPOUT",
            "POPOUT_START",
            "",
            "EGLV_DOCK_POPOUT"
          );
          p.compatible = { isRelayImplementedInTemplate: true };
          ApplicationFactory.PostMessageToParent(p, "*");
        });
      },
      restrict: "A",
    };
  },
]);
app.directive("egDragDrop", [
  "$timeout",
  "$filter",
  "AttachmentFactory",
  "ApplicationFactory",
  function ($timeout, $filter, AttachmentFactory, ApplicationFactory) {
    return {
      restrict: "A",
      link: function ($scope, $element, $attrs) {
        $element.ready(function () {
          function dragEnterLeave(evt) {
            evt.stopPropagation();
            evt.preventDefault();
            $scope.$apply(function () {
              $scope.dropText = "";
              $scope.dropClass = "";
            });
          }
          $element.bind("dragenter", dragEnterLeave);
          $element.bind("dragleave", dragEnterLeave);
          $element.bind("dragover", function (evt) {
            evt.stopPropagation();
            evt.preventDefault();
          });
          $element.bind("drop", function (event, data) {
            event.stopPropagation();
            event.preventDefault();
            $scope.$apply(function () {
              $scope.dropText = "";
              $scope.dropClass = "";
            });
            var files = event.dataTransfer.files;
            if (
              files.length > 0 &&
              (ApplicationFactory.isDescendent(
                "egain-chat-content",
                event.target
              ) ||
                ApplicationFactory.isDescendent(
                  "egain-chat-header-small",
                  event.target
                ) ||
                ApplicationFactory.isDescendent(
                  "egain-chat-alternate-engagement-options",
                  event.target
                ))
            ) {
              $scope.$apply(function () {
                $scope.files = [];
                for (var i = 0; i < files.length; i++) {
                  $scope.files.push(files[i]);
                }
                AttachmentFactory.ValidateAttachmentFiles($scope.files, true);
              });
            }
          });
        });
      },
    };
  },
]);
app.directive("egPagePushMessage", [
  "$window",
  "$timeout",
  function ($window, $timeout) {
    return {
      restrict: "A",
      link: function ($scope, $element, $attrs) {
        $timeout(function () {
          var anchorElements = $element.find("a");
          if (
            anchorElements &&
            anchorElements.length &&
            0 < anchorElements.length
          ) {
            var url = null;
            var ele = null;
            var isURLAvailable = false;
            for (var i = 0; i < anchorElements.length; i++) {
              ele = anchorElements[i]
                ? angular.element(anchorElements[i])
                : null;
              url = ele && ele.attr("href") ? ele.attr("href") : null;
              if (url && "string" === typeof url) {
                isURLAvailable = true;
                break;
              }
            }
            if (true === isURLAvailable) {
              $window.open(url, "eGainChat");
            }
          }
        });
      },
    };
  },
]);
app.directive("egSurveyInputField", [
  "$rootScope",
  "$timeout",
  function ($rootScope, $timeout) {
    return {
      link: function ($scope, $element, attrs) {
        if ($rootScope.isSmallDevice) {
          var chatWindow = angular.element(
            document.querySelector("#egain-chat-overlay")
          );
          var is_landscape = false;
          var $el = $element[0];
          var doneBtn = angular.element(
            $el.parentNode.getElementsByClassName("egain-done-btn")[0]
          );
          var updateView = function () {
            is_landscape = screen.height < screen.width;
            if (is_landscape) {
              chatWindow.addClass("input-edit-wrapper");
              angular.element($el.parentNode).addClass("edit-wrapper");
            } else {
              chatWindow.removeClass("input-edit-wrapper");
              angular.element($el.parentNode).removeClass("edit-wrapper");
            }
          };
          $element.bind("focus", function (event) {
            updateView();
            window.addEventListener("resize", updateView, false);
          });
          doneBtn.bind("click", function () {
            chatWindow.removeClass("input-edit-wrapper");
            window.removeEventListener("resize", updateView, false);
            angular.element($el.parentNode).removeClass("edit-wrapper");
          });
          $element.bind("blur", function (event) {
            chatWindow.removeClass("input-edit-wrapper");
            window.removeEventListener("resize", updateView, false);
            angular.element($el.parentNode).removeClass("edit-wrapper");
          });
        }
        $element.bind("keydown", function (event) {
          $timeout(function () {
            $scope.question.showCharacterCount = true;
            try {
              var maxCharacterCount = attrs.maxlength ? attrs.maxlength : 2e3;
              var currentCount = 0;
              currentCount = $scope.question.answer.length;
              var remainderCount = maxCharacterCount - currentCount;
              $scope.question.characterCount = remainderCount;
            } catch (error) {}
          });
        });
      },
      restrict: "A",
    };
  },
]);
app.directive("iframeSetDimensionsOnload", [
  function () {
    return {
      restrict: "A",
      link: function (scope, element, attrs) {
        var iFrameHeight =
          document.querySelector(".egain-chat-content").clientHeight -
          20 -
          25 +
          "px";
        var iFrameWidth = "100%";
        element.css("width", iFrameWidth);
        element.css("height", iFrameHeight);
        element.css("border", 0);
      },
    };
  },
]);
app.directive("keyNavigation", [
  "$timeout",
  "VAFactory",
  function ($timeout, VAFactory) {
    return {
      link: function ($scope, $element) {
        $element.ready(function () {
          if (VAFactory.IsVAActive()) {
            var bubble = $element[0].querySelector(".bubble");
            if (bubble) {
              bubble.focus();
            }
          }
        });
        $element.bind("keydown", function (event) {
          var focusNextChild = function (currentChild) {
            if (position >= 0) {
              currentMessageBubble.tabIndex = -1;
              currentMessageBubble.blur();
            }
            var el;
            if (currentChild && currentChild.length > 0) {
              if (currentChild[0].className.indexOf("system") > -1) {
                el = currentChild[0];
              } else {
                el = currentChild.children().children()[1];
              }
            }
            if (el) {
              el.focus();
              el.tabIndex = 0;
            }
          };
          var code = event.keyCode || event.which;
          if (code === 38 || code === 40) {
            event.preventDefault();
            var siblings = $element.parent().children();
            var position = -1;
            var currentMessageBubble;
            var isPreviousMessageAttachment = false;
            var isNextMessageAttachment = false;
            var isCurrentMessageAttachment = false;
            if (
              angular
                .element($element.children())[0]
                .className.indexOf("system") > -1
            ) {
              currentMessageBubble = $element.children()[0];
            } else {
              currentMessageBubble = $element
                .children()
                .children()
                .children()[1];
              if (
                angular
                  .element(currentMessageBubble)
                  .children()[0]
                  .className.indexOf("attachmentImageDiv") > -1
              ) {
                isCurrentMessageAttachment = true;
              }
            }
            for (var i = 0; i < siblings.length; i++) {
              if (siblings[i] === $element[0]) {
                position = i;
                break;
              }
            }
            if (code === 40) {
              var bubble = angular
                .element(siblings[position + 1])
                .children()
                .children()
                .children()
                .children();
              if (
                bubble[2] &&
                bubble[2].className.indexOf("attachmentImageDiv") > -1
              ) {
                isNextMessageAttachment = true;
              }
              var nextMessageBubble;
              if (siblings.length > position + 1) {
                if (
                  angular.element(siblings[position + 1]).children().length >
                    0 &&
                  angular
                    .element(siblings[position + 1])
                    .children()[0]
                    .className.indexOf("system") > -1
                ) {
                  nextMessageBubble = angular
                    .element(siblings[position + 1])
                    .children()[0];
                } else {
                  nextMessageBubble = angular
                    .element(siblings[position + 1])
                    .children()
                    .children()
                    .children();
                }
              }
              var flag = true;
              var checkNextAttachmentBubble = true;
              if (isCurrentMessageAttachment) {
                checkNextAttachmentBubble = false;
                var buttons = angular
                  .element(currentMessageBubble)
                  .children()
                  .children()
                  .children()
                  .children();
                var downloadImage = angular
                  .element(
                    angular
                      .element(currentMessageBubble)
                      .children()
                      .children()[0]
                  )
                  .children()
                  .children()[0];
                if (buttons && buttons.length === 3) {
                  if (buttons[2].tabIndex === -1) {
                    nextMessageBubble = currentMessageBubble;
                  }
                  if (buttons[1].tabIndex === 0) {
                    buttons[1].tabIndex = -1;
                    buttons[1].blur();
                    buttons[2].tabIndex = 0;
                    buttons[2].focus();
                  } else if (buttons[2].tabIndex === 0 && nextMessageBubble) {
                    buttons[2].tabIndex = -1;
                    buttons[2].blur();
                    if (isNextMessageAttachment) {
                      checkNextAttachmentBubble = true;
                    } else {
                      nextMessageBubble[1].focus();
                      nextMessageBubble[1].tabIndex = 0;
                    }
                  } else if (downloadImage.tabIndex === 0) {
                    downloadImage.tabIndex = -1;
                    downloadImage.blur();
                    buttons[1].tabIndex = 0;
                    buttons[1].focus();
                  }
                } else if (downloadImage) {
                  if (downloadImage.tabIndex === 0 && nextMessageBubble) {
                    downloadImage.tabIndex = -1;
                    downloadImage.blur();
                    nextMessageBubble.tabIndex = 0;
                    nextMessageBubble.focus();
                  } else {
                    downloadImage.tabIndex = 0;
                    downloadImage.focus();
                    currentMessageBubble.blur();
                    currentMessageBubble.tabIndex = -1;
                  }
                }
                flag = false;
              }
              if (
                isNextMessageAttachment &&
                nextMessageBubble &&
                checkNextAttachmentBubble
              ) {
                var buttons = angular
                  .element(nextMessageBubble)
                  .children()
                  .children()
                  .children()
                  .children();
                var downloadImage = angular
                  .element(
                    angular.element(nextMessageBubble).children().children()[0]
                  )
                  .children()
                  .children()[0];
                if (buttons && buttons.length === 3) {
                  if (buttons[1].tabIndex === 0) {
                    buttons[1].tabIndex = -1;
                    buttons[1].blur();
                    buttons[2].tabIndex = 0;
                    buttons[2].focus();
                  } else if (buttons[2].tabIndex === 0) {
                    buttons[2].tabIndex = -1;
                    buttons[2].blur();
                    nextMessageBubble.focus();
                    nextMessageBubble.tabIndex = 0;
                  } else if (downloadImage.tabIndex === 0) {
                    downloadImage.tabIndex = -1;
                    downloadImage.blur();
                    buttons[1].tabIndex = 0;
                    buttons[1].focus();
                  } else {
                    downloadImage.tabIndex = 0;
                    downloadImage.focus();
                    currentMessageBubble.tabIndex = -1;
                    currentMessageBubble.blur();
                  }
                } else if (downloadImage) {
                  if (downloadImage.tabIndex === 0) {
                    downloadImage.tabIndex = -1;
                    downloadImage.blur();
                    currentMessageBubble.tabIndex = -1;
                    currentMessageBubble.blur();
                  } else {
                    downloadImage.tabIndex = 0;
                    downloadImage.focus();
                    angular
                      .element(nextMessageBubble.children().children()[0])
                      .children()
                      .children()[0]
                      .focus();
                    angular
                      .element(nextMessageBubble.children().children()[0])
                      .children()
                      .children()[0].tabIndex = 0;
                  }
                }
                flag = false;
              }
              if (flag) {
                var currentChild = angular
                  .element(siblings[position + 1])
                  .children();
                if (currentChild && currentChild.length > 0) {
                  focusNextChild(currentChild);
                }
              }
            } else if (code === 38) {
              var bubble = angular
                .element(siblings[position - 1])
                .children()
                .children()
                .children()
                .children();
              if (
                bubble[2] &&
                bubble[2].className.indexOf("attachmentImageDiv") > -1
              ) {
                isPreviousMessageAttachment = true;
              }
              var previousMessageBubble;
              if (
                angular.element(siblings[position - 1]).children().length > 0 &&
                angular
                  .element(siblings[position - 1])
                  .children()[0]
                  .className.indexOf("system") > -1
              ) {
                previousMessageBubble = angular
                  .element(siblings[position - 1])
                  .children()[0];
              } else {
                previousMessageBubble = angular
                  .element(siblings[position - 1])
                  .children()
                  .children()
                  .children()[1];
              }
              var flag = true;
              var checkPreviousAttachmentBubble = true;
              if (isCurrentMessageAttachment) {
                checkPreviousAttachmentBubble = false;
                var buttons = angular
                  .element(currentMessageBubble)
                  .children()
                  .children()
                  .children()
                  .children();
                var downloadImage = angular
                  .element(
                    angular
                      .element(currentMessageBubble)
                      .children()
                      .children()[0]
                  )
                  .children()
                  .children()[0];
                if (buttons && buttons.length === 3) {
                  if (buttons[1].tabIndex === 0) {
                    buttons[1].tabIndex = -1;
                    buttons[1].blur();
                    downloadImage.tabIndex = 0;
                    downloadImage.focus();
                  } else if (buttons[2].tabIndex === 0) {
                    buttons[2].tabIndex = -1;
                    buttons[2].blur();
                    buttons[1].tabIndex = 0;
                    buttons[1].focus();
                  } else if (
                    downloadImage.tabIndex === 0 &&
                    previousMessageBubble
                  ) {
                    downloadImage.tabIndex = -1;
                    downloadImage.blur();
                    if (isPreviousMessageAttachment) {
                      checkPreviousAttachmentBubble = true;
                    } else {
                      previousMessageBubble.focus();
                      previousMessageBubble.tabIndex = 0;
                    }
                  }
                  flag = false;
                } else if (downloadImage) {
                  if (downloadImage.tabIndex === 0) {
                    downloadImage.tabIndex = -1;
                    downloadImage.blur();
                    previousMessageBubble.focus();
                    previousMessageBubble.tabIndex = 0;
                  } else {
                    downloadImage.tabIndex = 0;
                    downloadImage.focus();
                  }
                }
              }
              if (
                isPreviousMessageAttachment &&
                previousMessageBubble &&
                checkPreviousAttachmentBubble
              ) {
                var buttons = angular
                  .element(previousMessageBubble)
                  .children()
                  .children()
                  .children()
                  .children();
                var downloadImage = angular
                  .element(
                    angular
                      .element(previousMessageBubble)
                      .children()
                      .children()[0]
                  )
                  .children()
                  .children()[0];
                if (buttons && buttons.length === 3) {
                  if (buttons[1].tabIndex === 0) {
                    buttons[1].tabIndex = -1;
                    buttons[1].blur();
                    downloadImage.tabIndex = 0;
                    downloadImage.focus();
                  } else if (buttons[2].tabIndex === 0) {
                    buttons[2].tabIndex = -1;
                    buttons[2].blur();
                    buttons[1].tabIndex = 0;
                    buttons[1].focus();
                  } else if (downloadImage.tabIndex === 0) {
                    downloadImage.tabIndex = -1;
                    downloadImage.blur();
                    previousMessageBubble.focus();
                    previousMessageBubble.tabIndex = 0;
                  } else {
                    currentMessageBubble.tabIndex = -1;
                    currentMessageBubble.blur();
                    buttons[2].tabIndex = 0;
                    buttons[2].focus();
                  }
                  flag = false;
                } else if (downloadImage) {
                  if (downloadImage.tabIndex === 0) {
                    downloadImage.tabIndex = -1;
                    downloadImage.blur();
                    previousMessageBubble.focus();
                    previousMessageBubble.tabIndex = 0;
                  } else {
                    downloadImage.tabIndex = 0;
                    downloadImage.focus();
                  }
                }
              }
              if (flag) {
                var currentChild = angular
                  .element(siblings[position - 1])
                  .children();
                if (currentChild && currentChild.length > 0) {
                  focusNextChild(currentChild);
                }
              }
            }
          }
        });
      },
    };
  },
]);
app.directive("focus", function ($timeout) {
  return {
    restrict: "A",
    link: function (scope, element, attrs) {
      var params = scope.$eval(attrs.focus);
      if (params.index === 0) {
        $timeout(function () {
          angular.element(element)[0].focus();
        }, 1e3);
      }
    },
  };
});
app.directive("focusStar", function ($timeout) {
  return {
    restrict: "A",
    link: function (scope, element, attrs) {
      var params = scope.$eval(attrs.focusStar);
      if (
        element.length > 0 &&
        element[0].children &&
        element[0].children.length > 0
      ) {
        var childElem = angular.element(element[0].children[0]);
        childElem.attr("aria-label", attrs.arialabel);
        if (params.index === 0) {
          childElem.attr("id", "que_" + params.index);
          childElem.attr(
            "aria-labelledby",
            "surveyHeading que_" + params.index
          );
          childElem.bind("keydown", function (event) {
            if (event.keyCode === 9) {
              childElem.attr("aria-labelledby", "");
            }
          });
        }
        angular.element(element).attr("aria-label", "");
      }
      if (params.index === 0) {
        $timeout(function () {
          angular.element(element).find("span")[0].focus();
        }, 1e3);
      }
    },
  };
});
app.directive("vaildateAriaAttrs", function ($timeout) {
  return {
    restrict: "A",
    link: function ($scope, $element, attrs) {
      $timeout(function () {
        var children = angular.element($element[0].children);
        for (var i = 0; i < children.length; i++) {
          var elem = angular.element(children[i]);
          if (
            typeof elem.attr("aria-valuenow") !== "undefined" &&
            elem.attr("aria-valuenow") !== "" &&
            (typeof elem.attr("aria-valuetext") !== "undefined" ||
              elem.attr("aria-valuetext") === "")
          ) {
            elem.attr("aria-valuetext", elem.attr("aria-valuenow"));
          }
        }
      });
    },
  };
});
app.directive("minimizedLaunchButton", function ($timeout) {
  return {
    restrict: "A",
    link: function ($scope, $element) {
      $element.on("keydown", function (event) {
        var code = event.which || event.keyCode;
        if (code === 13) {
          $timeout(function () {
            $scope.page.minimized = false;
          });
        }
      });
    },
  };
});
app.directive("dropdownSizeHandler", [
  "$rootScope",
  "$timeout",
  "$window",
  "ConfigFactory",
  function ($rootScope, $timeout, $window, ConfigFactory) {
    return {
      restrict: "A",
      link: function ($scope, $element, attrs) {
        var mobileOrTablet = navigator.userAgent.match(
          /Android|BlackBerry|iPhone|iPad|iPod|Opera Mini|IEMobile/i
        );
        var edge = window.navigator.userAgent.indexOf("Edge") > -1;
        var chatConfig = ConfigFactory.GetChatConfigurations();
        $element[0].style.font = chatConfig.templateStyle.font;
        var selectElements = angular.element(
          document.querySelectorAll("#PreChatForm select")
        );
        for (var i = 0; i < selectElements.length; i++) {
          selectElements[i].style.font = chatConfig.templateStyle.font;
          if (mobileOrTablet) {
            selectElements[i].style["white-space"] = "normal";
          }
        }
        if (!mobileOrTablet && !edge) {
          var addDummy = function (text) {
            var dummyDiv = document.createElement("div");
            var textNode = document.createTextNode(text);
            dummyDiv.appendChild(textNode);
            dummyDiv.style["display"] = "inline-block";
            dummyDiv.style["font"] = chatConfig.templateStyle.font;
            dummyDiv.style["padding-left"] = "5px";
            dummyDiv.style["position"] = "fixed";
            dummyDiv.style["top"] = "-1000px";
            dummyDiv.classList.add("dummy-element");
            document.body.appendChild(dummyDiv);
            return dummyDiv;
          };
          var removeAllDummies = function () {
            var elems = document.getElementsByClassName("dummy-element");
            for (var i = 0; i < elems.length; i++) {
              document.body.removeChild(elems[i]);
            }
            if (elems.length) {
              removeAllDummies();
            }
          };
          var resizeOptions = function (element) {
            var text = $scope.option.text;
            var dummyDiv = addDummy(text);
            var parentElement = angular.element(element.parentElement)[0];
            var dummyDivWidth = angular.element(dummyDiv)[0].offsetWidth;
            if (
              parentElement.offsetWidth > 0 &&
              parentElement.offsetWidth < dummyDivWidth
            ) {
              var selectDisplayAreaWidth = parentElement.offsetWidth - 10;
              var done = false,
                d = 3;
              while (!done) {
                var maxLength = text.length - d <= 0 ? 1 : text.length - d;
                var newText = text.substr(0, maxLength) + "...";
                var newDummyDiv = addDummy(newText);
                var newDummyDivWidth =
                  angular.element(newDummyDiv)[0].offsetWidth;
                if (newDummyDivWidth <= selectDisplayAreaWidth) {
                  text = newText;
                  done = true;
                }
                d = d + 3;
              }
              $element[0].text = text;
            } else {
              $element[0].text = $scope.option.text;
            }
            removeAllDummies();
            return $scope.option;
          };
          resizeOptions($element[0]);
          $timeout(function () {
            var textData = resizeOptions($element[0]);
            $element[0].displayText = textData.displayText;
          }, 200);
          angular.element($window).bind("resize", function () {
            var textData = resizeOptions($element[0]);
            $element[0].displayText = textData.displayText;
          });
        }
      },
    };
  },
]);
app.directive("noRightClick", function ($timeout) {
  return {
    restrict: "A",
    link: function ($scope, $element, attrs) {
      $element.bind("contextmenu", function (event) {
        event.preventDefault();
      });
    },
  };
});
(function () {
  "use strict";
  angular
    .module("pascalprecht.translate")
    .directive("ariaTranslate", ariaTranslateDirectiveFactory);
  function ariaTranslateDirectiveFactory($rootScope, $translate) {
    return { link: link, priority: -1 };
    function link(scope, element, attrs) {
      scope.off = {};
      scope.off.$translateChangeSuccess = $rootScope.$on(
        "$translateChangeSuccess",
        translateAriaLabel
      );
      scope.off.$translateRefreshEnd = $rootScope.$on(
        "$translateRefreshEnd",
        translateAriaLabel
      );
      translateAriaLabel();
      function setAriaLabel(value) {
        attrs.$set("ariaLabel", value);
      }
      function translateAriaLabel() {
        var translationId = attrs.ariaTranslate;
        var translation = $translate.instant(translationId);
        setAriaLabel(translation || translationId);
        if (translation !== translationId) {
          scope.off.$translateRefreshEnd();
        }
      }
    }
  }
})(window.angular);
app.filter("toTrusted", function ($sce) {
  return function (htmlCode) {
    return $sce.trustAsHtml(htmlCode);
  };
});
app.filter("highlightArticle", function ($sce) {
  return function (origText, characterRanges) {
    if (
      !angular.isDefined(characterRanges) ||
      !angular.isDefined(characterRanges.length)
    ) {
      return $sce.trustAsHtml(origText);
    } else {
      var newSnippet = [];
      var currentCRIndex = 0;
      for (var i = 0; i < origText.length; i++) {
        var CR = characterRanges[currentCRIndex];
        if (angular.isDefined(CR)) {
          if (i === CR.firstPos)
            newSnippet.push('<span class="egain-highlighted-content">');
          newSnippet.push(origText.charAt(i));
          if (i === CR.lastPos - 1) {
            newSnippet.push("</span>");
            if (characterRanges.length > currentCRIndex + 1) {
              currentCRIndex++;
            }
          }
        }
      }
      var highlightedText = newSnippet.join("");
      return $sce.trustAsHtml(highlightedText);
    }
  };
});
app.filter("nospace", function () {
  return function (value) {
    return !value
      ? ""
      : value
          .replace(/<br ?\/?>/g, "")
          .replace(/&nbsp;/g, "")
          .trim();
  };
});
/*! egain-client-library 01-10-2019 */
(function (global, factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    module.exports = global.document
      ? factory(global, true)
      : function (w) {
          if (!w.document) {
            throw new Error("jQuery requires a window with a document");
          }
          return factory(w);
        };
  } else {
    factory(global);
  }
})(typeof window !== "undefined" ? window : this, function (window, noGlobal) {
  var arr = [];
  var slice = arr.slice;
  var concat = arr.concat;
  var push = arr.push;
  var indexOf = arr.indexOf;
  var class2type = {};
  var toString = class2type.toString;
  var hasOwn = class2type.hasOwnProperty;
  var support = {};
  var document = window.document,
    version = "2.1.3",
    jQuery = function (selector, context) {
      return new jQuery.fn.init(selector, context);
    },
    rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
    rmsPrefix = /^-ms-/,
    rdashAlpha = /-([\da-z])/gi,
    fcamelCase = function (all, letter) {
      return letter.toUpperCase();
    };
  jQuery.fn = jQuery.prototype = {
    jquery: version,
    constructor: jQuery,
    selector: "",
    length: 0,
    toArray: function () {
      return slice.call(this);
    },
    get: function (num) {
      return num != null
        ? num < 0
          ? this[num + this.length]
          : this[num]
        : slice.call(this);
    },
    pushStack: function (elems) {
      var ret = jQuery.merge(this.constructor(), elems);
      ret.prevObject = this;
      ret.context = this.context;
      return ret;
    },
    each: function (callback, args) {
      return jQuery.each(this, callback, args);
    },
    map: function (callback) {
      return this.pushStack(
        jQuery.map(this, function (elem, i) {
          return callback.call(elem, i, elem);
        })
      );
    },
    slice: function () {
      return this.pushStack(slice.apply(this, arguments));
    },
    first: function () {
      return this.eq(0);
    },
    last: function () {
      return this.eq(-1);
    },
    eq: function (i) {
      var len = this.length,
        j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    end: function () {
      return this.prevObject || this.constructor(null);
    },
    push: push,
    sort: arr.sort,
    splice: arr.splice,
  };
  jQuery.extend = jQuery.fn.extend = function () {
    var options,
      name,
      src,
      copy,
      copyIsArray,
      clone,
      target = arguments[0] || {},
      i = 1,
      length = arguments.length,
      deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[i] || {};
      i++;
    }
    if (typeof target !== "object" && !jQuery.isFunction(target)) {
      target = {};
    }
    if (i === length) {
      target = this;
      i--;
    }
    for (; i < length; i++) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if (
            deep &&
            copy &&
            (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))
          ) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && jQuery.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            }
            target[name] = jQuery.extend(deep, clone, copy);
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }
    return target;
  };
  jQuery.extend({
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
    isReady: true,
    error: function (msg) {
      throw new Error(msg);
    },
    noop: function () {},
    isFunction: function (obj) {
      return jQuery.type(obj) === "function";
    },
    isArray: Array.isArray,
    isWindow: function (obj) {
      return obj != null && obj === obj.window;
    },
    isNumeric: function (obj) {
      return !jQuery.isArray(obj) && obj - parseFloat(obj) + 1 >= 0;
    },
    isPlainObject: function (obj) {
      if (
        jQuery.type(obj) !== "object" ||
        obj.nodeType ||
        jQuery.isWindow(obj)
      ) {
        return false;
      }
      if (
        obj.constructor &&
        !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")
      ) {
        return false;
      }
      return true;
    },
    isEmptyObject: function (obj) {
      var name;
      for (name in obj) {
        return false;
      }
      return true;
    },
    type: function (obj) {
      if (obj == null) {
        return obj + "";
      }
      return typeof obj === "object" || typeof obj === "function"
        ? class2type[toString.call(obj)] || "object"
        : typeof obj;
    },
    globalEval: function (code) {
      var script,
        indirect = eval;
      code = jQuery.trim(code);
      if (code) {
        if (code.indexOf("use strict") === 1) {
          script = document.createElement("script");
          script.text = code;
          document.head.appendChild(script).parentNode.removeChild(script);
        } else {
          indirect(code);
        }
      }
    },
    camelCase: function (string) {
      return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    },
    nodeName: function (elem, name) {
      return (
        elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase()
      );
    },
    each: function (obj, callback, args) {
      var value,
        i = 0,
        length = obj.length,
        isArray = isArraylike(obj);
      if (args) {
        if (isArray) {
          for (; i < length; i++) {
            value = callback.apply(obj[i], args);
            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.apply(obj[i], args);
            if (value === false) {
              break;
            }
          }
        }
      } else {
        if (isArray) {
          for (; i < length; i++) {
            value = callback.call(obj[i], i, obj[i]);
            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.call(obj[i], i, obj[i]);
            if (value === false) {
              break;
            }
          }
        }
      }
      return obj;
    },
    trim: function (text) {
      return text == null ? "" : (text + "").replace(rtrim, "");
    },
    makeArray: function (arr, results) {
      var ret = results || [];
      if (arr != null) {
        if (isArraylike(Object(arr))) {
          jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
        } else {
          push.call(ret, arr);
        }
      }
      return ret;
    },
    inArray: function (elem, arr, i) {
      return arr == null ? -1 : indexOf.call(arr, elem, i);
    },
    merge: function (first, second) {
      var len = +second.length,
        j = 0,
        i = first.length;
      for (; j < len; j++) {
        first[i++] = second[j];
      }
      first.length = i;
      return first;
    },
    grep: function (elems, callback, invert) {
      var callbackInverse,
        matches = [],
        i = 0,
        length = elems.length,
        callbackExpect = !invert;
      for (; i < length; i++) {
        callbackInverse = !callback(elems[i], i);
        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }
      return matches;
    },
    map: function (elems, callback, arg) {
      var value,
        i = 0,
        length = elems.length,
        isArray = isArraylike(elems),
        ret = [];
      if (isArray) {
        for (; i < length; i++) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      }
      return concat.apply([], ret);
    },
    guid: 1,
    proxy: function (fn, context) {
      var tmp, args, proxy;
      if (typeof context === "string") {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }
      if (!jQuery.isFunction(fn)) {
        return undefined;
      }
      args = slice.call(arguments, 2);
      proxy = function () {
        return fn.apply(context || this, args.concat(slice.call(arguments)));
      };
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    },
    now: Date.now,
    support: support,
  });
  jQuery.each(
    "Boolean Number String Function Array Date RegExp Object Error".split(" "),
    function (i, name) {
      class2type["[object " + name + "]"] = name.toLowerCase();
    }
  );
  function isArraylike(obj) {
    var length = obj.length,
      type = jQuery.type(obj);
    if (type === "function" || jQuery.isWindow(obj)) {
      return false;
    }
    if (obj.nodeType === 1 && length) {
      return true;
    }
    return (
      type === "array" ||
      length === 0 ||
      (typeof length === "number" && length > 0 && length - 1 in obj)
    );
  }
  var Sizzle = (function (window) {
    var i,
      support,
      Expr,
      getText,
      isXML,
      tokenize,
      compile,
      select,
      outermostContext,
      sortInput,
      hasDuplicate,
      setDocument,
      document,
      docElem,
      documentIsHTML,
      rbuggyQSA,
      rbuggyMatches,
      matches,
      contains,
      expando = "sizzle" + 1 * new Date(),
      preferredDoc = window.document,
      dirruns = 0,
      done = 0,
      classCache = createCache(),
      tokenCache = createCache(),
      compilerCache = createCache(),
      sortOrder = function (a, b) {
        if (a === b) {
          hasDuplicate = true;
        }
        return 0;
      },
      MAX_NEGATIVE = 1 << 31,
      hasOwn = {}.hasOwnProperty,
      arr = [],
      pop = arr.pop,
      push_native = arr.push,
      push = arr.push,
      slice = arr.slice,
      indexOf = function (list, elem) {
        var i = 0,
          len = list.length;
        for (; i < len; i++) {
          if (list[i] === elem) {
            return i;
          }
        }
        return -1;
      },
      booleans =
        "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
      whitespace = "[\\x20\\t\\r\\n\\f]",
      characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
      identifier = characterEncoding.replace("w", "w#"),
      attributes =
        "\\[" +
        whitespace +
        "*(" +
        characterEncoding +
        ")(?:" +
        whitespace +
        "*([*^$|!~]?=)" +
        whitespace +
        "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" +
        identifier +
        "))|)" +
        whitespace +
        "*\\]",
      pseudos =
        ":(" +
        characterEncoding +
        ")(?:\\((" +
        "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
        "((?:\\\\.|[^\\\\()[\\]]|" +
        attributes +
        ")*)|" +
        ".*" +
        ")\\)|)",
      rwhitespace = new RegExp(whitespace + "+", "g"),
      rtrim = new RegExp(
        "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
        "g"
      ),
      rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
      rcombinators = new RegExp(
        "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"
      ),
      rattributeQuotes = new RegExp(
        "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]",
        "g"
      ),
      rpseudo = new RegExp(pseudos),
      ridentifier = new RegExp("^" + identifier + "$"),
      matchExpr = {
        ID: new RegExp("^#(" + characterEncoding + ")"),
        CLASS: new RegExp("^\\.(" + characterEncoding + ")"),
        TAG: new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
        ATTR: new RegExp("^" + attributes),
        PSEUDO: new RegExp("^" + pseudos),
        CHILD: new RegExp(
          "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
            whitespace +
            "*(even|odd|(([+-]|)(\\d*)n|)" +
            whitespace +
            "*(?:([+-]|)" +
            whitespace +
            "*(\\d+)|))" +
            whitespace +
            "*\\)|)",
          "i"
        ),
        bool: new RegExp("^(?:" + booleans + ")$", "i"),
        needsContext: new RegExp(
          "^" +
            whitespace +
            "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
            whitespace +
            "*((?:-\\d)?\\d*)" +
            whitespace +
            "*\\)|)(?=[^-]|$)",
          "i"
        ),
      },
      rinputs = /^(?:input|select|textarea|button)$/i,
      rheader = /^h\d$/i,
      rnative = /^[^{]+\{\s*\[native \w/,
      rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
      rsibling = /[+~]/,
      rescape = /'|\\/g,
      runescape = new RegExp(
        "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)",
        "ig"
      ),
      funescape = function (_, escaped, escapedWhitespace) {
        var high = "0x" + escaped - 65536;
        return high !== high || escapedWhitespace
          ? escaped
          : high < 0
          ? String.fromCharCode(high + 65536)
          : String.fromCharCode((high >> 10) | 55296, (high & 1023) | 56320);
      },
      unloadHandler = function () {
        setDocument();
      };
    try {
      push.apply(
        (arr = slice.call(preferredDoc.childNodes)),
        preferredDoc.childNodes
      );
      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {
        apply: arr.length
          ? function (target, els) {
              push_native.apply(target, slice.call(els));
            }
          : function (target, els) {
              var j = target.length,
                i = 0;
              while ((target[j++] = els[i++])) {}
              target.length = j - 1;
            },
      };
    }
    function Sizzle(selector, context, results, seed) {
      var match,
        elem,
        m,
        nodeType,
        i,
        groups,
        old,
        nid,
        newContext,
        newSelector;
      if (
        (context ? context.ownerDocument || context : preferredDoc) !== document
      ) {
        setDocument(context);
      }
      context = context || document;
      results = results || [];
      nodeType = context.nodeType;
      if (
        typeof selector !== "string" ||
        !selector ||
        (nodeType !== 1 && nodeType !== 9 && nodeType !== 11)
      ) {
        return results;
      }
      if (!seed && documentIsHTML) {
        if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
          if ((m = match[1])) {
            if (nodeType === 9) {
              elem = context.getElementById(m);
              if (elem && elem.parentNode) {
                if (elem.id === m) {
                  results.push(elem);
                  return results;
                }
              } else {
                return results;
              }
            } else {
              if (
                context.ownerDocument &&
                (elem = context.ownerDocument.getElementById(m)) &&
                contains(context, elem) &&
                elem.id === m
              ) {
                results.push(elem);
                return results;
              }
            }
          } else if (match[2]) {
            push.apply(results, context.getElementsByTagName(selector));
            return results;
          } else if ((m = match[3]) && support.getElementsByClassName) {
            push.apply(results, context.getElementsByClassName(m));
            return results;
          }
        }
        if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
          nid = old = expando;
          newContext = context;
          newSelector = nodeType !== 1 && selector;
          if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
            groups = tokenize(selector);
            if ((old = context.getAttribute("id"))) {
              nid = old.replace(rescape, "\\$&");
            } else {
              context.setAttribute("id", nid);
            }
            nid = "[id='" + nid + "'] ";
            i = groups.length;
            while (i--) {
              groups[i] = nid + toSelector(groups[i]);
            }
            newContext =
              (rsibling.test(selector) && testContext(context.parentNode)) ||
              context;
            newSelector = groups.join(",");
          }
          if (newSelector) {
            try {
              push.apply(results, newContext.querySelectorAll(newSelector));
              return results;
            } catch (qsaError) {
            } finally {
              if (!old) {
                context.removeAttribute("id");
              }
            }
          }
        }
      }
      return select(selector.replace(rtrim, "$1"), context, results, seed);
    }
    function createCache() {
      var keys = [];
      function cache(key, value) {
        if (keys.push(key + " ") > Expr.cacheLength) {
          delete cache[keys.shift()];
        }
        return (cache[key + " "] = value);
      }
      return cache;
    }
    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    function assert(fn) {
      var div = document.createElement("div");
      try {
        return !!fn(div);
      } catch (e) {
        return false;
      } finally {
        if (div.parentNode) {
          div.parentNode.removeChild(div);
        }
        div = null;
      }
    }
    function addHandle(attrs, handler) {
      var arr = attrs.split("|"),
        i = attrs.length;
      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    function siblingCheck(a, b) {
      var cur = b && a,
        diff =
          cur &&
          a.nodeType === 1 &&
          b.nodeType === 1 &&
          (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
      if (diff) {
        return diff;
      }
      if (cur) {
        while ((cur = cur.nextSibling)) {
          if (cur === b) {
            return -1;
          }
        }
      }
      return a ? 1 : -1;
    }
    function createInputPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === type;
      };
    }
    function createButtonPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === "input" || name === "button") && elem.type === type;
      };
    }
    function createPositionalPseudo(fn) {
      return markFunction(function (argument) {
        argument = +argument;
        return markFunction(function (seed, matches) {
          var j,
            matchIndexes = fn([], seed.length, argument),
            i = matchIndexes.length;
          while (i--) {
            if (seed[(j = matchIndexes[i])]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    function testContext(context) {
      return (
        context &&
        typeof context.getElementsByTagName !== "undefined" &&
        context
      );
    }
    support = Sizzle.support = {};
    isXML = Sizzle.isXML = function (elem) {
      var documentElement =
        elem && (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== "HTML" : false;
    };
    setDocument = Sizzle.setDocument = function (node) {
      var hasCompare,
        parent,
        doc = node ? node.ownerDocument || node : preferredDoc;
      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      }
      document = doc;
      docElem = doc.documentElement;
      parent = doc.defaultView;
      if (parent && parent !== parent.top) {
        if (parent.addEventListener) {
          parent.addEventListener("unload", unloadHandler, false);
        } else if (parent.attachEvent) {
          parent.attachEvent("onunload", unloadHandler);
        }
      }
      documentIsHTML = !isXML(doc);
      support.attributes = assert(function (div) {
        div.className = "i";
        return !div.getAttribute("className");
      });
      support.getElementsByTagName = assert(function (div) {
        div.appendChild(doc.createComment(""));
        return !div.getElementsByTagName("*").length;
      });
      support.getElementsByClassName = rnative.test(doc.getElementsByClassName);
      support.getById = assert(function (div) {
        docElem.appendChild(div).id = expando;
        return !doc.getElementsByName || !doc.getElementsByName(expando).length;
      });
      if (support.getById) {
        Expr.find["ID"] = function (id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var m = context.getElementById(id);
            return m && m.parentNode ? [m] : [];
          }
        };
        Expr.filter["ID"] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            return elem.getAttribute("id") === attrId;
          };
        };
      } else {
        delete Expr.find["ID"];
        Expr.filter["ID"] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            var node =
              typeof elem.getAttributeNode !== "undefined" &&
              elem.getAttributeNode("id");
            return node && node.value === attrId;
          };
        };
      }
      Expr.find["TAG"] = support.getElementsByTagName
        ? function (tag, context) {
            if (typeof context.getElementsByTagName !== "undefined") {
              return context.getElementsByTagName(tag);
            } else if (support.qsa) {
              return context.querySelectorAll(tag);
            }
          }
        : function (tag, context) {
            var elem,
              tmp = [],
              i = 0,
              results = context.getElementsByTagName(tag);
            if (tag === "*") {
              while ((elem = results[i++])) {
                if (elem.nodeType === 1) {
                  tmp.push(elem);
                }
              }
              return tmp;
            }
            return results;
          };
      Expr.find["CLASS"] =
        support.getElementsByClassName &&
        function (className, context) {
          if (documentIsHTML) {
            return context.getElementsByClassName(className);
          }
        };
      rbuggyMatches = [];
      rbuggyQSA = [];
      if ((support.qsa = rnative.test(doc.querySelectorAll))) {
        assert(function (div) {
          docElem.appendChild(div).innerHTML =
            "<a id='" +
            expando +
            "'></a>" +
            "<select id='" +
            expando +
            "-\f]' msallowcapture=''>" +
            "<option selected=''></option></select>";
          if (div.querySelectorAll("[msallowcapture^='']").length) {
            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
          }
          if (!div.querySelectorAll("[selected]").length) {
            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
          }
          if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
            rbuggyQSA.push("~=");
          }
          if (!div.querySelectorAll(":checked").length) {
            rbuggyQSA.push(":checked");
          }
          if (!div.querySelectorAll("a#" + expando + "+*").length) {
            rbuggyQSA.push(".#.+[+~]");
          }
        });
        assert(function (div) {
          var input = doc.createElement("input");
          input.setAttribute("type", "hidden");
          div.appendChild(input).setAttribute("name", "D");
          if (div.querySelectorAll("[name=d]").length) {
            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
          }
          if (!div.querySelectorAll(":enabled").length) {
            rbuggyQSA.push(":enabled", ":disabled");
          }
          div.querySelectorAll("*,:x");
          rbuggyQSA.push(",.*:");
        });
      }
      if (
        (support.matchesSelector = rnative.test(
          (matches =
            docElem.matches ||
            docElem.webkitMatchesSelector ||
            docElem.mozMatchesSelector ||
            docElem.oMatchesSelector ||
            docElem.msMatchesSelector)
        ))
      ) {
        assert(function (div) {
          support.disconnectedMatch = matches.call(div, "div");
          matches.call(div, "[s!='']:x");
          rbuggyMatches.push("!=", pseudos);
        });
      }
      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
      rbuggyMatches =
        rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
      hasCompare = rnative.test(docElem.compareDocumentPosition);
      contains =
        hasCompare || rnative.test(docElem.contains)
          ? function (a, b) {
              var adown = a.nodeType === 9 ? a.documentElement : a,
                bup = b && b.parentNode;
              return (
                a === bup ||
                !!(
                  bup &&
                  bup.nodeType === 1 &&
                  (adown.contains
                    ? adown.contains(bup)
                    : a.compareDocumentPosition &&
                      a.compareDocumentPosition(bup) & 16)
                )
              );
            }
          : function (a, b) {
              if (b) {
                while ((b = b.parentNode)) {
                  if (b === a) {
                    return true;
                  }
                }
              }
              return false;
            };
      sortOrder = hasCompare
        ? function (a, b) {
            if (a === b) {
              hasDuplicate = true;
              return 0;
            }
            var compare =
              !a.compareDocumentPosition - !b.compareDocumentPosition;
            if (compare) {
              return compare;
            }
            compare =
              (a.ownerDocument || a) === (b.ownerDocument || b)
                ? a.compareDocumentPosition(b)
                : 1;
            if (
              compare & 1 ||
              (!support.sortDetached &&
                b.compareDocumentPosition(a) === compare)
            ) {
              if (
                a === doc ||
                (a.ownerDocument === preferredDoc && contains(preferredDoc, a))
              ) {
                return -1;
              }
              if (
                b === doc ||
                (b.ownerDocument === preferredDoc && contains(preferredDoc, b))
              ) {
                return 1;
              }
              return sortInput
                ? indexOf(sortInput, a) - indexOf(sortInput, b)
                : 0;
            }
            return compare & 4 ? -1 : 1;
          }
        : function (a, b) {
            if (a === b) {
              hasDuplicate = true;
              return 0;
            }
            var cur,
              i = 0,
              aup = a.parentNode,
              bup = b.parentNode,
              ap = [a],
              bp = [b];
            if (!aup || !bup) {
              return a === doc
                ? -1
                : b === doc
                ? 1
                : aup
                ? -1
                : bup
                ? 1
                : sortInput
                ? indexOf(sortInput, a) - indexOf(sortInput, b)
                : 0;
            } else if (aup === bup) {
              return siblingCheck(a, b);
            }
            cur = a;
            while ((cur = cur.parentNode)) {
              ap.unshift(cur);
            }
            cur = b;
            while ((cur = cur.parentNode)) {
              bp.unshift(cur);
            }
            while (ap[i] === bp[i]) {
              i++;
            }
            return i
              ? siblingCheck(ap[i], bp[i])
              : ap[i] === preferredDoc
              ? -1
              : bp[i] === preferredDoc
              ? 1
              : 0;
          };
      return doc;
    };
    Sizzle.matches = function (expr, elements) {
      return Sizzle(expr, null, null, elements);
    };
    Sizzle.matchesSelector = function (elem, expr) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      expr = expr.replace(rattributeQuotes, "='$1']");
      if (
        support.matchesSelector &&
        documentIsHTML &&
        (!rbuggyMatches || !rbuggyMatches.test(expr)) &&
        (!rbuggyQSA || !rbuggyQSA.test(expr))
      ) {
        try {
          var ret = matches.call(elem, expr);
          if (
            ret ||
            support.disconnectedMatch ||
            (elem.document && elem.document.nodeType !== 11)
          ) {
            return ret;
          }
        } catch (e) {}
      }
      return Sizzle(expr, document, null, [elem]).length > 0;
    };
    Sizzle.contains = function (context, elem) {
      if ((context.ownerDocument || context) !== document) {
        setDocument(context);
      }
      return contains(context, elem);
    };
    Sizzle.attr = function (elem, name) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      var fn = Expr.attrHandle[name.toLowerCase()],
        val =
          fn && hasOwn.call(Expr.attrHandle, name.toLowerCase())
            ? fn(elem, name, !documentIsHTML)
            : undefined;
      return val !== undefined
        ? val
        : support.attributes || !documentIsHTML
        ? elem.getAttribute(name)
        : (val = elem.getAttributeNode(name)) && val.specified
        ? val.value
        : null;
    };
    Sizzle.error = function (msg) {
      throw new Error("Syntax error, unrecognized expression: " + msg);
    };
    Sizzle.uniqueSort = function (results) {
      var elem,
        duplicates = [],
        j = 0,
        i = 0;
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);
      if (hasDuplicate) {
        while ((elem = results[i++])) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }
      sortInput = null;
      return results;
    };
    getText = Sizzle.getText = function (elem) {
      var node,
        ret = "",
        i = 0,
        nodeType = elem.nodeType;
      if (!nodeType) {
        while ((node = elem[i++])) {
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        if (typeof elem.textContent === "string") {
          return elem.textContent;
        } else {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      }
      return ret;
    };
    Expr = Sizzle.selectors = {
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        ">": { dir: "parentNode", first: true },
        " ": { dir: "parentNode" },
        "+": { dir: "previousSibling", first: true },
        "~": { dir: "previousSibling" },
      },
      preFilter: {
        ATTR: function (match) {
          match[1] = match[1].replace(runescape, funescape);
          match[3] = (match[3] || match[4] || match[5] || "").replace(
            runescape,
            funescape
          );
          if (match[2] === "~=") {
            match[3] = " " + match[3] + " ";
          }
          return match.slice(0, 4);
        },
        CHILD: function (match) {
          match[1] = match[1].toLowerCase();
          if (match[1].slice(0, 3) === "nth") {
            if (!match[3]) {
              Sizzle.error(match[0]);
            }
            match[4] = +(match[4]
              ? match[5] + (match[6] || 1)
              : 2 * (match[3] === "even" || match[3] === "odd"));
            match[5] = +(match[7] + match[8] || match[3] === "odd");
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }
          return match;
        },
        PSEUDO: function (match) {
          var excess,
            unquoted = !match[6] && match[2];
          if (matchExpr["CHILD"].test(match[0])) {
            return null;
          }
          if (match[3]) {
            match[2] = match[4] || match[5] || "";
          } else if (
            unquoted &&
            rpseudo.test(unquoted) &&
            (excess = tokenize(unquoted, true)) &&
            (excess =
              unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)
          ) {
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          }
          return match.slice(0, 3);
        },
      },
      filter: {
        TAG: function (nodeNameSelector) {
          var nodeName = nodeNameSelector
            .replace(runescape, funescape)
            .toLowerCase();
          return nodeNameSelector === "*"
            ? function () {
                return true;
              }
            : function (elem) {
                return (
                  elem.nodeName && elem.nodeName.toLowerCase() === nodeName
                );
              };
        },
        CLASS: function (className) {
          var pattern = classCache[className + " "];
          return (
            pattern ||
            ((pattern = new RegExp(
              "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)"
            )) &&
              classCache(className, function (elem) {
                return pattern.test(
                  (typeof elem.className === "string" && elem.className) ||
                    (typeof elem.getAttribute !== "undefined" &&
                      elem.getAttribute("class")) ||
                    ""
                );
              }))
          );
        },
        ATTR: function (name, operator, check) {
          return function (elem) {
            var result = Sizzle.attr(elem, name);
            if (result == null) {
              return operator === "!=";
            }
            if (!operator) {
              return true;
            }
            result += "";
            return operator === "="
              ? result === check
              : operator === "!="
              ? result !== check
              : operator === "^="
              ? check && result.indexOf(check) === 0
              : operator === "*="
              ? check && result.indexOf(check) > -1
              : operator === "$="
              ? check && result.slice(-check.length) === check
              : operator === "~="
              ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) >
                -1
              : operator === "|="
              ? result === check ||
                result.slice(0, check.length + 1) === check + "-"
              : false;
          };
        },
        CHILD: function (type, what, argument, first, last) {
          var simple = type.slice(0, 3) !== "nth",
            forward = type.slice(-4) !== "last",
            ofType = what === "of-type";
          return first === 1 && last === 0
            ? function (elem) {
                return !!elem.parentNode;
              }
            : function (elem, context, xml) {
                var cache,
                  outerCache,
                  node,
                  diff,
                  nodeIndex,
                  start,
                  dir = simple !== forward ? "nextSibling" : "previousSibling",
                  parent = elem.parentNode,
                  name = ofType && elem.nodeName.toLowerCase(),
                  useCache = !xml && !ofType;
                if (parent) {
                  if (simple) {
                    while (dir) {
                      node = elem;
                      while ((node = node[dir])) {
                        if (
                          ofType
                            ? node.nodeName.toLowerCase() === name
                            : node.nodeType === 1
                        ) {
                          return false;
                        }
                      }
                      start = dir = type === "only" && !start && "nextSibling";
                    }
                    return true;
                  }
                  start = [forward ? parent.firstChild : parent.lastChild];
                  if (forward && useCache) {
                    outerCache = parent[expando] || (parent[expando] = {});
                    cache = outerCache[type] || [];
                    nodeIndex = cache[0] === dirruns && cache[1];
                    diff = cache[0] === dirruns && cache[2];
                    node = nodeIndex && parent.childNodes[nodeIndex];
                    while (
                      (node =
                        (++nodeIndex && node && node[dir]) ||
                        (diff = nodeIndex = 0) ||
                        start.pop())
                    ) {
                      if (node.nodeType === 1 && ++diff && node === elem) {
                        outerCache[type] = [dirruns, nodeIndex, diff];
                        break;
                      }
                    }
                  } else if (
                    useCache &&
                    (cache = (elem[expando] || (elem[expando] = {}))[type]) &&
                    cache[0] === dirruns
                  ) {
                    diff = cache[1];
                  } else {
                    while (
                      (node =
                        (++nodeIndex && node && node[dir]) ||
                        (diff = nodeIndex = 0) ||
                        start.pop())
                    ) {
                      if (
                        (ofType
                          ? node.nodeName.toLowerCase() === name
                          : node.nodeType === 1) &&
                        ++diff
                      ) {
                        if (useCache) {
                          (node[expando] || (node[expando] = {}))[type] = [
                            dirruns,
                            diff,
                          ];
                        }
                        if (node === elem) {
                          break;
                        }
                      }
                    }
                  }
                  diff -= last;
                  return (
                    diff === first || (diff % first === 0 && diff / first >= 0)
                  );
                }
              };
        },
        PSEUDO: function (pseudo, argument) {
          var args,
            fn =
              Expr.pseudos[pseudo] ||
              Expr.setFilters[pseudo.toLowerCase()] ||
              Sizzle.error("unsupported pseudo: " + pseudo);
          if (fn[expando]) {
            return fn(argument);
          }
          if (fn.length > 1) {
            args = [pseudo, pseudo, "", argument];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase())
              ? markFunction(function (seed, matches) {
                  var idx,
                    matched = fn(seed, argument),
                    i = matched.length;
                  while (i--) {
                    idx = indexOf(seed, matched[i]);
                    seed[idx] = !(matches[idx] = matched[i]);
                  }
                })
              : function (elem) {
                  return fn(elem, 0, args);
                };
          }
          return fn;
        },
      },
      pseudos: {
        not: markFunction(function (selector) {
          var input = [],
            results = [],
            matcher = compile(selector.replace(rtrim, "$1"));
          return matcher[expando]
            ? markFunction(function (seed, matches, context, xml) {
                var elem,
                  unmatched = matcher(seed, null, xml, []),
                  i = seed.length;
                while (i--) {
                  if ((elem = unmatched[i])) {
                    seed[i] = !(matches[i] = elem);
                  }
                }
              })
            : function (elem, context, xml) {
                input[0] = elem;
                matcher(input, null, xml, results);
                input[0] = null;
                return !results.pop();
              };
        }),
        has: markFunction(function (selector) {
          return function (elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        contains: markFunction(function (text) {
          text = text.replace(runescape, funescape);
          return function (elem) {
            return (
              (elem.textContent || elem.innerText || getText(elem)).indexOf(
                text
              ) > -1
            );
          };
        }),
        lang: markFunction(function (lang) {
          if (!ridentifier.test(lang || "")) {
            Sizzle.error("unsupported lang: " + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          return function (elem) {
            var elemLang;
            do {
              if (
                (elemLang = documentIsHTML
                  ? elem.lang
                  : elem.getAttribute("xml:lang") || elem.getAttribute("lang"))
              ) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);
            return false;
          };
        }),
        target: function (elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        root: function (elem) {
          return elem === docElem;
        },
        focus: function (elem) {
          return (
            elem === document.activeElement &&
            (!document.hasFocus || document.hasFocus()) &&
            !!(elem.type || elem.href || ~elem.tabIndex)
          );
        },
        enabled: function (elem) {
          return elem.disabled === false;
        },
        disabled: function (elem) {
          return elem.disabled === true;
        },
        checked: function (elem) {
          var nodeName = elem.nodeName.toLowerCase();
          return (
            (nodeName === "input" && !!elem.checked) ||
            (nodeName === "option" && !!elem.selected)
          );
        },
        selected: function (elem) {
          if (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }
          return elem.selected === true;
        },
        empty: function (elem) {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }
          return true;
        },
        parent: function (elem) {
          return !Expr.pseudos["empty"](elem);
        },
        header: function (elem) {
          return rheader.test(elem.nodeName);
        },
        input: function (elem) {
          return rinputs.test(elem.nodeName);
        },
        button: function (elem) {
          var name = elem.nodeName.toLowerCase();
          return (
            (name === "input" && elem.type === "button") || name === "button"
          );
        },
        text: function (elem) {
          var attr;
          return (
            elem.nodeName.toLowerCase() === "input" &&
            elem.type === "text" &&
            ((attr = elem.getAttribute("type")) == null ||
              attr.toLowerCase() === "text")
          );
        },
        first: createPositionalPseudo(function () {
          return [0];
        }),
        last: createPositionalPseudo(function (matchIndexes, length) {
          return [length - 1];
        }),
        eq: createPositionalPseudo(function (matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        even: createPositionalPseudo(function (matchIndexes, length) {
          var i = 0;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        odd: createPositionalPseudo(function (matchIndexes, length) {
          var i = 1;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        lt: createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; --i >= 0; ) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        gt: createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; ++i < length; ) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
      },
    };
    Expr.pseudos["nth"] = Expr.pseudos["eq"];
    for (i in {
      radio: true,
      checkbox: true,
      file: true,
      password: true,
      image: true,
    }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }
    for (i in { submit: true, reset: true }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    }
    function setFilters() {}
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();
    tokenize = Sizzle.tokenize = function (selector, parseOnly) {
      var matched,
        match,
        tokens,
        type,
        soFar,
        groups,
        preFilters,
        cached = tokenCache[selector + " "];
      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }
      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;
      while (soFar) {
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            soFar = soFar.slice(match[0].length) || soFar;
          }
          groups.push((tokens = []));
        }
        matched = false;
        if ((match = rcombinators.exec(soFar))) {
          matched = match.shift();
          tokens.push({ value: matched, type: match[0].replace(rtrim, " ") });
          soFar = soFar.slice(matched.length);
        }
        for (type in Expr.filter) {
          if (
            (match = matchExpr[type].exec(soFar)) &&
            (!preFilters[type] || (match = preFilters[type](match)))
          ) {
            matched = match.shift();
            tokens.push({ value: matched, type: type, matches: match });
            soFar = soFar.slice(matched.length);
          }
        }
        if (!matched) {
          break;
        }
      }
      return parseOnly
        ? soFar.length
        : soFar
        ? Sizzle.error(selector)
        : tokenCache(selector, groups).slice(0);
    };
    function toSelector(tokens) {
      var i = 0,
        len = tokens.length,
        selector = "";
      for (; i < len; i++) {
        selector += tokens[i].value;
      }
      return selector;
    }
    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir,
        checkNonElements = base && dir === "parentNode",
        doneName = done++;
      return combinator.first
        ? function (elem, context, xml) {
            while ((elem = elem[dir])) {
              if (elem.nodeType === 1 || checkNonElements) {
                return matcher(elem, context, xml);
              }
            }
          }
        : function (elem, context, xml) {
            var oldCache,
              outerCache,
              newCache = [dirruns, doneName];
            if (xml) {
              while ((elem = elem[dir])) {
                if (elem.nodeType === 1 || checkNonElements) {
                  if (matcher(elem, context, xml)) {
                    return true;
                  }
                }
              }
            } else {
              while ((elem = elem[dir])) {
                if (elem.nodeType === 1 || checkNonElements) {
                  outerCache = elem[expando] || (elem[expando] = {});
                  if (
                    (oldCache = outerCache[dir]) &&
                    oldCache[0] === dirruns &&
                    oldCache[1] === doneName
                  ) {
                    return (newCache[2] = oldCache[2]);
                  } else {
                    outerCache[dir] = newCache;
                    if ((newCache[2] = matcher(elem, context, xml))) {
                      return true;
                    }
                  }
                }
              }
            }
          };
    }
    function elementMatcher(matchers) {
      return matchers.length > 1
        ? function (elem, context, xml) {
            var i = matchers.length;
            while (i--) {
              if (!matchers[i](elem, context, xml)) {
                return false;
              }
            }
            return true;
          }
        : matchers[0];
    }
    function multipleContexts(selector, contexts, results) {
      var i = 0,
        len = contexts.length;
      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      return results;
    }
    function condense(unmatched, map, filter, context, xml) {
      var elem,
        newUnmatched = [],
        i = 0,
        len = unmatched.length,
        mapped = map != null;
      for (; i < len; i++) {
        if ((elem = unmatched[i])) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            if (mapped) {
              map.push(i);
            }
          }
        }
      }
      return newUnmatched;
    }
    function setMatcher(
      preFilter,
      selector,
      matcher,
      postFilter,
      postFinder,
      postSelector
    ) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function (seed, results, context, xml) {
        var temp,
          i,
          elem,
          preMap = [],
          postMap = [],
          preexisting = results.length,
          elems =
            seed ||
            multipleContexts(
              selector || "*",
              context.nodeType ? [context] : context,
              []
            ),
          matcherIn =
            preFilter && (seed || !selector)
              ? condense(elems, preMap, preFilter, context, xml)
              : elems,
          matcherOut = matcher
            ? postFinder || (seed ? preFilter : preexisting || postFilter)
              ? []
              : results
            : matcherIn;
        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        }
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);
          i = temp.length;
          while (i--) {
            if ((elem = temp[i])) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }
        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              temp = [];
              i = matcherOut.length;
              while (i--) {
                if ((elem = matcherOut[i])) {
                  temp.push((matcherIn[i] = elem));
                }
              }
              postFinder(null, (matcherOut = []), temp, xml);
            }
            i = matcherOut.length;
            while (i--) {
              if (
                (elem = matcherOut[i]) &&
                (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1
              ) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          }
        } else {
          matcherOut = condense(
            matcherOut === results
              ? matcherOut.splice(preexisting, matcherOut.length)
              : matcherOut
          );
          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }
    function matcherFromTokens(tokens) {
      var checkContext,
        matcher,
        j,
        len = tokens.length,
        leadingRelative = Expr.relative[tokens[0].type],
        implicitRelative = leadingRelative || Expr.relative[" "],
        i = leadingRelative ? 1 : 0,
        matchContext = addCombinator(
          function (elem) {
            return elem === checkContext;
          },
          implicitRelative,
          true
        ),
        matchAnyContext = addCombinator(
          function (elem) {
            return indexOf(checkContext, elem) > -1;
          },
          implicitRelative,
          true
        ),
        matchers = [
          function (elem, context, xml) {
            var ret =
              (!leadingRelative && (xml || context !== outermostContext)) ||
              ((checkContext = context).nodeType
                ? matchContext(elem, context, xml)
                : matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          },
        ];
      for (; i < len; i++) {
        if ((matcher = Expr.relative[tokens[i].type])) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
          if (matcher[expando]) {
            j = ++i;
            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(
              i > 1 && elementMatcher(matchers),
              i > 1 &&
                toSelector(
                  tokens
                    .slice(0, i - 1)
                    .concat({ value: tokens[i - 2].type === " " ? "*" : "" })
                ).replace(rtrim, "$1"),
              matcher,
              i < j && matcherFromTokens(tokens.slice(i, j)),
              j < len && matcherFromTokens((tokens = tokens.slice(j))),
              j < len && toSelector(tokens)
            );
          }
          matchers.push(matcher);
        }
      }
      return elementMatcher(matchers);
    }
    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0,
        byElement = elementMatchers.length > 0,
        superMatcher = function (seed, context, xml, results, outermost) {
          var elem,
            j,
            matcher,
            matchedCount = 0,
            i = "0",
            unmatched = seed && [],
            setMatched = [],
            contextBackup = outermostContext,
            elems = seed || (byElement && Expr.find["TAG"]("*", outermost)),
            dirrunsUnique = (dirruns +=
              contextBackup == null ? 1 : Math.random() || 0.1),
            len = elems.length;
          if (outermost) {
            outermostContext = context !== document && context;
          }
          for (; i !== len && (elem = elems[i]) != null; i++) {
            if (byElement && elem) {
              j = 0;
              while ((matcher = elementMatchers[j++])) {
                if (matcher(elem, context, xml)) {
                  results.push(elem);
                  break;
                }
              }
              if (outermost) {
                dirruns = dirrunsUnique;
              }
            }
            if (bySet) {
              if ((elem = !matcher && elem)) {
                matchedCount--;
              }
              if (seed) {
                unmatched.push(elem);
              }
            }
          }
          matchedCount += i;
          if (bySet && i !== matchedCount) {
            j = 0;
            while ((matcher = setMatchers[j++])) {
              matcher(unmatched, setMatched, context, xml);
            }
            if (seed) {
              if (matchedCount > 0) {
                while (i--) {
                  if (!(unmatched[i] || setMatched[i])) {
                    setMatched[i] = pop.call(results);
                  }
                }
              }
              setMatched = condense(setMatched);
            }
            push.apply(results, setMatched);
            if (
              outermost &&
              !seed &&
              setMatched.length > 0 &&
              matchedCount + setMatchers.length > 1
            ) {
              Sizzle.uniqueSort(results);
            }
          }
          if (outermost) {
            dirruns = dirrunsUnique;
            outermostContext = contextBackup;
          }
          return unmatched;
        };
      return bySet ? markFunction(superMatcher) : superMatcher;
    }
    compile = Sizzle.compile = function (selector, match) {
      var i,
        setMatchers = [],
        elementMatchers = [],
        cached = compilerCache[selector + " "];
      if (!cached) {
        if (!match) {
          match = tokenize(selector);
        }
        i = match.length;
        while (i--) {
          cached = matcherFromTokens(match[i]);
          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        }
        cached = compilerCache(
          selector,
          matcherFromGroupMatchers(elementMatchers, setMatchers)
        );
        cached.selector = selector;
      }
      return cached;
    };
    select = Sizzle.select = function (selector, context, results, seed) {
      var i,
        tokens,
        token,
        type,
        find,
        compiled = typeof selector === "function" && selector,
        match = !seed && tokenize((selector = compiled.selector || selector));
      results = results || [];
      if (match.length === 1) {
        tokens = match[0] = match[0].slice(0);
        if (
          tokens.length > 2 &&
          (token = tokens[0]).type === "ID" &&
          support.getById &&
          context.nodeType === 9 &&
          documentIsHTML &&
          Expr.relative[tokens[1].type]
        ) {
          context = (Expr.find["ID"](
            token.matches[0].replace(runescape, funescape),
            context
          ) || [])[0];
          if (!context) {
            return results;
          } else if (compiled) {
            context = context.parentNode;
          }
          selector = selector.slice(tokens.shift().value.length);
        }
        i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
        while (i--) {
          token = tokens[i];
          if (Expr.relative[(type = token.type)]) {
            break;
          }
          if ((find = Expr.find[type])) {
            if (
              (seed = find(
                token.matches[0].replace(runescape, funescape),
                (rsibling.test(tokens[0].type) &&
                  testContext(context.parentNode)) ||
                  context
              ))
            ) {
              tokens.splice(i, 1);
              selector = seed.length && toSelector(tokens);
              if (!selector) {
                push.apply(results, seed);
                return results;
              }
              break;
            }
          }
        }
      }
      (compiled || compile(selector, match))(
        seed,
        context,
        !documentIsHTML,
        results,
        (rsibling.test(selector) && testContext(context.parentNode)) || context
      );
      return results;
    };
    support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
    support.detectDuplicates = !!hasDuplicate;
    setDocument();
    support.sortDetached = assert(function (div1) {
      return div1.compareDocumentPosition(document.createElement("div")) & 1;
    });
    if (
      !assert(function (div) {
        div.innerHTML = "<a href='#'></a>";
        return div.firstChild.getAttribute("href") === "#";
      })
    ) {
      addHandle("type|href|height|width", function (elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
        }
      });
    }
    if (
      !support.attributes ||
      !assert(function (div) {
        div.innerHTML = "<input/>";
        div.firstChild.setAttribute("value", "");
        return div.firstChild.getAttribute("value") === "";
      })
    ) {
      addHandle("value", function (elem, name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === "input") {
          return elem.defaultValue;
        }
      });
    }
    if (
      !assert(function (div) {
        return div.getAttribute("disabled") == null;
      })
    ) {
      addHandle(booleans, function (elem, name, isXML) {
        var val;
        if (!isXML) {
          return elem[name] === true
            ? name.toLowerCase()
            : (val = elem.getAttributeNode(name)) && val.specified
            ? val.value
            : null;
        }
      });
    }
    return Sizzle;
  })(window);
  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors;
  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  var rneedsContext = jQuery.expr.match.needsContext;
  var rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
  var risSimple = /^.[^:#\[\.,]*$/;
  function winnow(elements, qualifier, not) {
    if (jQuery.isFunction(qualifier)) {
      return jQuery.grep(elements, function (elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    }
    if (qualifier.nodeType) {
      return jQuery.grep(elements, function (elem) {
        return (elem === qualifier) !== not;
      });
    }
    if (typeof qualifier === "string") {
      if (risSimple.test(qualifier)) {
        return jQuery.filter(qualifier, elements, not);
      }
      qualifier = jQuery.filter(qualifier, elements);
    }
    return jQuery.grep(elements, function (elem) {
      return indexOf.call(qualifier, elem) >= 0 !== not;
    });
  }
  jQuery.filter = function (expr, elems, not) {
    var elem = elems[0];
    if (not) {
      expr = ":not(" + expr + ")";
    }
    return elems.length === 1 && elem.nodeType === 1
      ? jQuery.find.matchesSelector(elem, expr)
        ? [elem]
        : []
      : jQuery.find.matches(
          expr,
          jQuery.grep(elems, function (elem) {
            return elem.nodeType === 1;
          })
        );
  };
  jQuery.fn.extend({
    find: function (selector) {
      var i,
        len = this.length,
        ret = [],
        self = this;
      if (typeof selector !== "string") {
        return this.pushStack(
          jQuery(selector).filter(function () {
            for (i = 0; i < len; i++) {
              if (jQuery.contains(self[i], this)) {
                return true;
              }
            }
          })
        );
      }
      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }
      ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
      ret.selector = this.selector ? this.selector + " " + selector : selector;
      return ret;
    },
    filter: function (selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function (selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function (selector) {
      return !!winnow(
        this,
        typeof selector === "string" && rneedsContext.test(selector)
          ? jQuery(selector)
          : selector || [],
        false
      ).length;
    },
  });
  var rootjQuery,
    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
    init = (jQuery.fn.init = function (selector, context) {
      var match, elem;
      if (!selector) {
        return this;
      }
      if (typeof selector === "string") {
        if (
          selector[0] === "<" &&
          selector[selector.length - 1] === ">" &&
          selector.length >= 3
        ) {
          match = [null, selector, null];
        } else {
          match = rquickExpr.exec(selector);
        }
        if (match && (match[1] || !context)) {
          if (match[1]) {
            context = context instanceof jQuery ? context[0] : context;
            jQuery.merge(
              this,
              jQuery.parseHTML(
                match[1],
                context && context.nodeType
                  ? context.ownerDocument || context
                  : document,
                true
              )
            );
            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
              for (match in context) {
                if (jQuery.isFunction(this[match])) {
                  this[match](context[match]);
                } else {
                  this.attr(match, context[match]);
                }
              }
            }
            return this;
          } else {
            elem = document.getElementById(match[2]);
            if (elem && elem.parentNode) {
              this.length = 1;
              this[0] = elem;
            }
            this.context = document;
            this.selector = selector;
            return this;
          }
        } else if (!context || context.jquery) {
          return (context || rootjQuery).find(selector);
        } else {
          return this.constructor(context).find(selector);
        }
      } else if (selector.nodeType) {
        this.context = this[0] = selector;
        this.length = 1;
        return this;
      } else if (jQuery.isFunction(selector)) {
        return typeof rootjQuery.ready !== "undefined"
          ? rootjQuery.ready(selector)
          : selector(jQuery);
      }
      if (selector.selector !== undefined) {
        this.selector = selector.selector;
        this.context = selector.context;
      }
      return jQuery.makeArray(selector, this);
    });
  init.prototype = jQuery.fn;
  rootjQuery = jQuery(document);
  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
    guaranteedUnique = {
      children: true,
      contents: true,
      next: true,
      prev: true,
    };
  jQuery.extend({
    dir: function (elem, dir, until) {
      var matched = [],
        truncate = until !== undefined;
      while ((elem = elem[dir]) && elem.nodeType !== 9) {
        if (elem.nodeType === 1) {
          if (truncate && jQuery(elem).is(until)) {
            break;
          }
          matched.push(elem);
        }
      }
      return matched;
    },
    sibling: function (n, elem) {
      var matched = [];
      for (; n; n = n.nextSibling) {
        if (n.nodeType === 1 && n !== elem) {
          matched.push(n);
        }
      }
      return matched;
    },
  });
  jQuery.fn.extend({
    has: function (target) {
      var targets = jQuery(target, this),
        l = targets.length;
      return this.filter(function () {
        var i = 0;
        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    closest: function (selectors, context) {
      var cur,
        i = 0,
        l = this.length,
        matched = [],
        pos =
          rneedsContext.test(selectors) || typeof selectors !== "string"
            ? jQuery(selectors, context || this.context)
            : 0;
      for (; i < l; i++) {
        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
          if (
            cur.nodeType < 11 &&
            (pos
              ? pos.index(cur) > -1
              : cur.nodeType === 1 &&
                jQuery.find.matchesSelector(cur, selectors))
          ) {
            matched.push(cur);
            break;
          }
        }
      }
      return this.pushStack(
        matched.length > 1 ? jQuery.unique(matched) : matched
      );
    },
    index: function (elem) {
      if (!elem) {
        return this[0] && this[0].parentNode
          ? this.first().prevAll().length
          : -1;
      }
      if (typeof elem === "string") {
        return indexOf.call(jQuery(elem), this[0]);
      }
      return indexOf.call(this, elem.jquery ? elem[0] : elem);
    },
    add: function (selector, context) {
      return this.pushStack(
        jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context)))
      );
    },
    addBack: function (selector) {
      return this.add(
        selector == null ? this.prevObject : this.prevObject.filter(selector)
      );
    },
  });
  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {}
    return cur;
  }
  jQuery.each(
    {
      parent: function (elem) {
        var parent = elem.parentNode;
        return parent && parent.nodeType !== 11 ? parent : null;
      },
      parents: function (elem) {
        return jQuery.dir(elem, "parentNode");
      },
      parentsUntil: function (elem, i, until) {
        return jQuery.dir(elem, "parentNode", until);
      },
      next: function (elem) {
        return sibling(elem, "nextSibling");
      },
      prev: function (elem) {
        return sibling(elem, "previousSibling");
      },
      nextAll: function (elem) {
        return jQuery.dir(elem, "nextSibling");
      },
      prevAll: function (elem) {
        return jQuery.dir(elem, "previousSibling");
      },
      nextUntil: function (elem, i, until) {
        return jQuery.dir(elem, "nextSibling", until);
      },
      prevUntil: function (elem, i, until) {
        return jQuery.dir(elem, "previousSibling", until);
      },
      siblings: function (elem) {
        return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
      },
      children: function (elem) {
        return jQuery.sibling(elem.firstChild);
      },
      contents: function (elem) {
        return elem.contentDocument || jQuery.merge([], elem.childNodes);
      },
    },
    function (name, fn) {
      jQuery.fn[name] = function (until, selector) {
        var matched = jQuery.map(this, fn, until);
        if (name.slice(-5) !== "Until") {
          selector = until;
        }
        if (selector && typeof selector === "string") {
          matched = jQuery.filter(selector, matched);
        }
        if (this.length > 1) {
          if (!guaranteedUnique[name]) {
            jQuery.unique(matched);
          }
          if (rparentsprev.test(name)) {
            matched.reverse();
          }
        }
        return this.pushStack(matched);
      };
    }
  );
  var rnotwhite = /\S+/g;
  var optionsCache = {};
  function createOptions(options) {
    var object = (optionsCache[options] = {});
    jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
      object[flag] = true;
    });
    return object;
  }
  jQuery.Callbacks = function (options) {
    options =
      typeof options === "string"
        ? optionsCache[options] || createOptions(options)
        : jQuery.extend({}, options);
    var memory,
      fired,
      firing,
      firingStart,
      firingLength,
      firingIndex,
      list = [],
      stack = !options.once && [],
      fire = function (data) {
        memory = options.memory && data;
        fired = true;
        firingIndex = firingStart || 0;
        firingStart = 0;
        firingLength = list.length;
        firing = true;
        for (; list && firingIndex < firingLength; firingIndex++) {
          if (
            list[firingIndex].apply(data[0], data[1]) === false &&
            options.stopOnFalse
          ) {
            memory = false;
            break;
          }
        }
        firing = false;
        if (list) {
          if (stack) {
            if (stack.length) {
              fire(stack.shift());
            }
          } else if (memory) {
            list = [];
          } else {
            self.disable();
          }
        }
      },
      self = {
        add: function () {
          if (list) {
            var start = list.length;
            (function add(args) {
              jQuery.each(args, function (_, arg) {
                var type = jQuery.type(arg);
                if (type === "function") {
                  if (!options.unique || !self.has(arg)) {
                    list.push(arg);
                  }
                } else if (arg && arg.length && type !== "string") {
                  add(arg);
                }
              });
            })(arguments);
            if (firing) {
              firingLength = list.length;
            } else if (memory) {
              firingStart = start;
              fire(memory);
            }
          }
          return this;
        },
        remove: function () {
          if (list) {
            jQuery.each(arguments, function (_, arg) {
              var index;
              while ((index = jQuery.inArray(arg, list, index)) > -1) {
                list.splice(index, 1);
                if (firing) {
                  if (index <= firingLength) {
                    firingLength--;
                  }
                  if (index <= firingIndex) {
                    firingIndex--;
                  }
                }
              }
            });
          }
          return this;
        },
        has: function (fn) {
          return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
        },
        empty: function () {
          list = [];
          firingLength = 0;
          return this;
        },
        disable: function () {
          list = stack = memory = undefined;
          return this;
        },
        disabled: function () {
          return !list;
        },
        lock: function () {
          stack = undefined;
          if (!memory) {
            self.disable();
          }
          return this;
        },
        locked: function () {
          return !stack;
        },
        fireWith: function (context, args) {
          if (list && (!fired || stack)) {
            args = args || [];
            args = [context, args.slice ? args.slice() : args];
            if (firing) {
              stack.push(args);
            } else {
              fire(args);
            }
          }
          return this;
        },
        fire: function () {
          self.fireWith(this, arguments);
          return this;
        },
        fired: function () {
          return !!fired;
        },
      };
    return self;
  };
  jQuery.extend({
    Deferred: function (func) {
      var tuples = [
          ["resolve", "done", jQuery.Callbacks("once memory"), "resolved"],
          ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"],
          ["notify", "progress", jQuery.Callbacks("memory")],
        ],
        state = "pending",
        promise = {
          state: function () {
            return state;
          },
          always: function () {
            deferred.done(arguments).fail(arguments);
            return this;
          },
          then: function () {
            var fns = arguments;
            return jQuery
              .Deferred(function (newDefer) {
                jQuery.each(tuples, function (i, tuple) {
                  var fn = jQuery.isFunction(fns[i]) && fns[i];
                  deferred[tuple[1]](function () {
                    var returned = fn && fn.apply(this, arguments);
                    if (returned && jQuery.isFunction(returned.promise)) {
                      returned
                        .promise()
                        .done(newDefer.resolve)
                        .fail(newDefer.reject)
                        .progress(newDefer.notify);
                    } else {
                      newDefer[tuple[0] + "With"](
                        this === promise ? newDefer.promise() : this,
                        fn ? [returned] : arguments
                      );
                    }
                  });
                });
                fns = null;
              })
              .promise();
          },
          promise: function (obj) {
            return obj != null ? jQuery.extend(obj, promise) : promise;
          },
        },
        deferred = {};
      promise.pipe = promise.then;
      jQuery.each(tuples, function (i, tuple) {
        var list = tuple[2],
          stateString = tuple[3];
        promise[tuple[1]] = list.add;
        if (stateString) {
          list.add(
            function () {
              state = stateString;
            },
            tuples[i ^ 1][2].disable,
            tuples[2][2].lock
          );
        }
        deferred[tuple[0]] = function () {
          deferred[tuple[0] + "With"](
            this === deferred ? promise : this,
            arguments
          );
          return this;
        };
        deferred[tuple[0] + "With"] = list.fireWith;
      });
      promise.promise(deferred);
      if (func) {
        func.call(deferred, deferred);
      }
      return deferred;
    },
    when: function (subordinate) {
      var i = 0,
        resolveValues = slice.call(arguments),
        length = resolveValues.length,
        remaining =
          length !== 1 ||
          (subordinate && jQuery.isFunction(subordinate.promise))
            ? length
            : 0,
        deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
        updateFunc = function (i, contexts, values) {
          return function (value) {
            contexts[i] = this;
            values[i] = arguments.length > 1 ? slice.call(arguments) : value;
            if (values === progressValues) {
              deferred.notifyWith(contexts, values);
            } else if (!--remaining) {
              deferred.resolveWith(contexts, values);
            }
          };
        },
        progressValues,
        progressContexts,
        resolveContexts;
      if (length > 1) {
        progressValues = new Array(length);
        progressContexts = new Array(length);
        resolveContexts = new Array(length);
        for (; i < length; i++) {
          if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
            resolveValues[i]
              .promise()
              .done(updateFunc(i, resolveContexts, resolveValues))
              .fail(deferred.reject)
              .progress(updateFunc(i, progressContexts, progressValues));
          } else {
            --remaining;
          }
        }
      }
      if (!remaining) {
        deferred.resolveWith(resolveContexts, resolveValues);
      }
      return deferred.promise();
    },
  });
  var readyList;
  jQuery.fn.ready = function (fn) {
    jQuery.ready.promise().done(fn);
    return this;
  };
  jQuery.extend({
    isReady: false,
    readyWait: 1,
    holdReady: function (hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    },
    ready: function (wait) {
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      }
      jQuery.isReady = true;
      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      }
      readyList.resolveWith(document, [jQuery]);
      if (jQuery.fn.triggerHandler) {
        jQuery(document).triggerHandler("ready");
        jQuery(document).off("ready");
      }
    },
  });
  function completed() {
    document.removeEventListener("DOMContentLoaded", completed, false);
    window.removeEventListener("load", completed, false);
    jQuery.ready();
  }
  jQuery.ready.promise = function (obj) {
    if (!readyList) {
      readyList = jQuery.Deferred();
      if (document.readyState === "complete") {
        setTimeout(jQuery.ready);
      } else {
        document.addEventListener("DOMContentLoaded", completed, false);
        window.addEventListener("load", completed, false);
      }
    }
    return readyList.promise(obj);
  };
  jQuery.ready.promise();
  var access = (jQuery.access = function (
    elems,
    fn,
    key,
    value,
    chainable,
    emptyGet,
    raw
  ) {
    var i = 0,
      len = elems.length,
      bulk = key == null;
    if (jQuery.type(key) === "object") {
      chainable = true;
      for (i in key) {
        jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
      }
    } else if (value !== undefined) {
      chainable = true;
      if (!jQuery.isFunction(value)) {
        raw = true;
      }
      if (bulk) {
        if (raw) {
          fn.call(elems, value);
          fn = null;
        } else {
          bulk = fn;
          fn = function (elem, key, value) {
            return bulk.call(jQuery(elem), value);
          };
        }
      }
      if (fn) {
        for (; i < len; i++) {
          fn(
            elems[i],
            key,
            raw ? value : value.call(elems[i], i, fn(elems[i], key))
          );
        }
      }
    }
    return chainable
      ? elems
      : bulk
      ? fn.call(elems)
      : len
      ? fn(elems[0], key)
      : emptyGet;
  });
  jQuery.acceptData = function (owner) {
    return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
  };
  function Data() {
    Object.defineProperty((this.cache = {}), 0, {
      get: function () {
        return {};
      },
    });
    this.expando = jQuery.expando + Data.uid++;
  }
  Data.uid = 1;
  Data.accepts = jQuery.acceptData;
  Data.prototype = {
    key: function (owner) {
      if (!Data.accepts(owner)) {
        return 0;
      }
      var descriptor = {},
        unlock = owner[this.expando];
      if (!unlock) {
        unlock = Data.uid++;
        try {
          descriptor[this.expando] = { value: unlock };
          Object.defineProperties(owner, descriptor);
        } catch (e) {
          descriptor[this.expando] = unlock;
          jQuery.extend(owner, descriptor);
        }
      }
      if (!this.cache[unlock]) {
        this.cache[unlock] = {};
      }
      return unlock;
    },
    set: function (owner, data, value) {
      var prop,
        unlock = this.key(owner),
        cache = this.cache[unlock];
      if (typeof data === "string") {
        cache[data] = value;
      } else {
        if (jQuery.isEmptyObject(cache)) {
          jQuery.extend(this.cache[unlock], data);
        } else {
          for (prop in data) {
            cache[prop] = data[prop];
          }
        }
      }
      return cache;
    },
    get: function (owner, key) {
      var cache = this.cache[this.key(owner)];
      return key === undefined ? cache : cache[key];
    },
    access: function (owner, key, value) {
      var stored;
      if (
        key === undefined ||
        (key && typeof key === "string" && value === undefined)
      ) {
        stored = this.get(owner, key);
        return stored !== undefined
          ? stored
          : this.get(owner, jQuery.camelCase(key));
      }
      this.set(owner, key, value);
      return value !== undefined ? value : key;
    },
    remove: function (owner, key) {
      var i,
        name,
        camel,
        unlock = this.key(owner),
        cache = this.cache[unlock];
      if (key === undefined) {
        this.cache[unlock] = {};
      } else {
        if (jQuery.isArray(key)) {
          name = key.concat(key.map(jQuery.camelCase));
        } else {
          camel = jQuery.camelCase(key);
          if (key in cache) {
            name = [key, camel];
          } else {
            name = camel;
            name = name in cache ? [name] : name.match(rnotwhite) || [];
          }
        }
        i = name.length;
        while (i--) {
          delete cache[name[i]];
        }
      }
    },
    hasData: function (owner) {
      return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});
    },
    discard: function (owner) {
      if (owner[this.expando]) {
        delete this.cache[owner[this.expando]];
      }
    },
  };
  var data_priv = new Data();
  var data_user = new Data();
  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
    rmultiDash = /([A-Z])/g;
  function dataAttr(elem, key, data) {
    var name;
    if (data === undefined && elem.nodeType === 1) {
      name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
      data = elem.getAttribute(name);
      if (typeof data === "string") {
        try {
          data =
            data === "true"
              ? true
              : data === "false"
              ? false
              : data === "null"
              ? null
              : +data + "" === data
              ? +data
              : rbrace.test(data)
              ? jQuery.parseJSON(data)
              : data;
        } catch (e) {}
        data_user.set(elem, key, data);
      } else {
        data = undefined;
      }
    }
    return data;
  }
  jQuery.extend({
    hasData: function (elem) {
      return data_user.hasData(elem) || data_priv.hasData(elem);
    },
    data: function (elem, name, data) {
      return data_user.access(elem, name, data);
    },
    removeData: function (elem, name) {
      data_user.remove(elem, name);
    },
    _data: function (elem, name, data) {
      return data_priv.access(elem, name, data);
    },
    _removeData: function (elem, name) {
      data_priv.remove(elem, name);
    },
  });
  jQuery.fn.extend({
    data: function (key, value) {
      var i,
        name,
        data,
        elem = this[0],
        attrs = elem && elem.attributes;
      if (key === undefined) {
        if (this.length) {
          data = data_user.get(elem);
          if (elem.nodeType === 1 && !data_priv.get(elem, "hasDataAttrs")) {
            i = attrs.length;
            while (i--) {
              if (attrs[i]) {
                name = attrs[i].name;
                if (name.indexOf("data-") === 0) {
                  name = jQuery.camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }
            data_priv.set(elem, "hasDataAttrs", true);
          }
        }
        return data;
      }
      if (typeof key === "object") {
        return this.each(function () {
          data_user.set(this, key);
        });
      }
      return access(
        this,
        function (value) {
          var data,
            camelKey = jQuery.camelCase(key);
          if (elem && value === undefined) {
            data = data_user.get(elem, key);
            if (data !== undefined) {
              return data;
            }
            data = data_user.get(elem, camelKey);
            if (data !== undefined) {
              return data;
            }
            data = dataAttr(elem, camelKey, undefined);
            if (data !== undefined) {
              return data;
            }
            return;
          }
          this.each(function () {
            var data = data_user.get(this, camelKey);
            data_user.set(this, camelKey, value);
            if (key.indexOf("-") !== -1 && data !== undefined) {
              data_user.set(this, key, value);
            }
          });
        },
        null,
        value,
        arguments.length > 1,
        null,
        true
      );
    },
    removeData: function (key) {
      return this.each(function () {
        data_user.remove(this, key);
      });
    },
  });
  jQuery.extend({
    queue: function (elem, type, data) {
      var queue;
      if (elem) {
        type = (type || "fx") + "queue";
        queue = data_priv.get(elem, type);
        if (data) {
          if (!queue || jQuery.isArray(data)) {
            queue = data_priv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }
        return queue || [];
      }
    },
    dequeue: function (elem, type) {
      type = type || "fx";
      var queue = jQuery.queue(elem, type),
        startLength = queue.length,
        fn = queue.shift(),
        hooks = jQuery._queueHooks(elem, type),
        next = function () {
          jQuery.dequeue(elem, type);
        };
      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }
      if (fn) {
        if (type === "fx") {
          queue.unshift("inprogress");
        }
        delete hooks.stop;
        fn.call(elem, next, hooks);
      }
      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    _queueHooks: function (elem, type) {
      var key = type + "queueHooks";
      return (
        data_priv.get(elem, key) ||
        data_priv.access(elem, key, {
          empty: jQuery.Callbacks("once memory").add(function () {
            data_priv.remove(elem, [type + "queue", key]);
          }),
        })
      );
    },
  });
  jQuery.fn.extend({
    queue: function (type, data) {
      var setter = 2;
      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }
      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }
      return data === undefined
        ? this
        : this.each(function () {
            var queue = jQuery.queue(this, type, data);
            jQuery._queueHooks(this, type);
            if (type === "fx" && queue[0] !== "inprogress") {
              jQuery.dequeue(this, type);
            }
          });
    },
    dequeue: function (type) {
      return this.each(function () {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function (type) {
      return this.queue(type || "fx", []);
    },
    promise: function (type, obj) {
      var tmp,
        count = 1,
        defer = jQuery.Deferred(),
        elements = this,
        i = this.length,
        resolve = function () {
          if (!--count) {
            defer.resolveWith(elements, [elements]);
          }
        };
      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }
      type = type || "fx";
      while (i--) {
        tmp = data_priv.get(elements[i], type + "queueHooks");
        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }
      resolve();
      return defer.promise(obj);
    },
  });
  var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
  var cssExpand = ["Top", "Right", "Bottom", "Left"];
  var isHidden = function (elem, el) {
    elem = el || elem;
    return (
      jQuery.css(elem, "display") === "none" ||
      !jQuery.contains(elem.ownerDocument, elem)
    );
  };
  var rcheckableType = /^(?:checkbox|radio)$/i;
  (function () {
    var fragment = document.createDocumentFragment(),
      div = fragment.appendChild(document.createElement("div")),
      input = document.createElement("input");
    input.setAttribute("type", "radio");
    input.setAttribute("checked", "checked");
    input.setAttribute("name", "t");
    div.appendChild(input);
    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
  })();
  var strundefined = typeof undefined;
  support.focusinBubbles = "onfocusin" in window;
  var rkeyEvent = /^key/,
    rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
    rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
    rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }
  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }
  jQuery.event = {
    global: {},
    add: function (elem, types, handler, data, selector) {
      var handleObjIn,
        eventHandle,
        tmp,
        events,
        t,
        handleObj,
        special,
        handlers,
        type,
        namespaces,
        origType,
        elemData = data_priv.get(elem);
      if (!elemData) {
        return;
      }
      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }
      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      }
      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }
      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function (e) {
          return typeof jQuery !== strundefined &&
            jQuery.event.triggered !== e.type
            ? jQuery.event.dispatch.apply(elem, arguments)
            : undefined;
        };
      }
      types = (types || "").match(rnotwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        special = jQuery.event.special[type] || {};
        handleObj = jQuery.extend(
          {
            type: type,
            origType: origType,
            data: data,
            handler: handler,
            guid: handler.guid,
            selector: selector,
            needsContext:
              selector && jQuery.expr.match.needsContext.test(selector),
            namespace: namespaces.join("."),
          },
          handleObjIn
        );
        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0;
          if (
            !special.setup ||
            special.setup.call(elem, data, namespaces, eventHandle) === false
          ) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle, false);
            }
          }
        }
        if (special.add) {
          special.add.call(elem, handleObj);
          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        }
        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        }
        jQuery.event.global[type] = true;
      }
    },
    remove: function (elem, types, handler, selector, mappedTypes) {
      var j,
        origCount,
        tmp,
        events,
        t,
        handleObj,
        special,
        handlers,
        type,
        namespaces,
        origType,
        elemData = data_priv.hasData(elem) && data_priv.get(elem);
      if (!elemData || !(events = elemData.events)) {
        return;
      }
      types = (types || "").match(rnotwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp =
          tmp[2] &&
          new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
        origCount = j = handlers.length;
        while (j--) {
          handleObj = handlers[j];
          if (
            (mappedTypes || origType === handleObj.origType) &&
            (!handler || handler.guid === handleObj.guid) &&
            (!tmp || tmp.test(handleObj.namespace)) &&
            (!selector ||
              selector === handleObj.selector ||
              (selector === "**" && handleObj.selector))
          ) {
            handlers.splice(j, 1);
            if (handleObj.selector) {
              handlers.delegateCount--;
            }
            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        }
        if (origCount && !handlers.length) {
          if (
            !special.teardown ||
            special.teardown.call(elem, namespaces, elemData.handle) === false
          ) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }
          delete events[type];
        }
      }
      if (jQuery.isEmptyObject(events)) {
        delete elemData.handle;
        data_priv.remove(elem, "events");
      }
    },
    trigger: function (event, data, elem, onlyHandlers) {
      var i,
        cur,
        tmp,
        bubbleType,
        ontype,
        handle,
        special,
        eventPath = [elem || document],
        type = hasOwn.call(event, "type") ? event.type : event,
        namespaces = hasOwn.call(event, "namespace")
          ? event.namespace.split(".")
          : [];
      cur = tmp = elem = elem || document;
      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      }
      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }
      if (type.indexOf(".") >= 0) {
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }
      ontype = type.indexOf(":") < 0 && "on" + type;
      event = event[jQuery.expando]
        ? event
        : new jQuery.Event(type, typeof event === "object" && event);
      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.namespace_re = event.namespace
        ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)")
        : null;
      event.result = undefined;
      if (!event.target) {
        event.target = elem;
      }
      data = data == null ? [event] : jQuery.makeArray(data, [event]);
      special = jQuery.event.special[type] || {};
      if (
        !onlyHandlers &&
        special.trigger &&
        special.trigger.apply(elem, data) === false
      ) {
        return;
      }
      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
        bubbleType = special.delegateType || type;
        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }
        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        }
        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      }
      i = 0;
      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        event.type = i > 1 ? bubbleType : special.bindType || type;
        handle =
          (data_priv.get(cur, "events") || {})[event.type] &&
          data_priv.get(cur, "handle");
        if (handle) {
          handle.apply(cur, data);
        }
        handle = ontype && cur[ontype];
        if (handle && handle.apply && jQuery.acceptData(cur)) {
          event.result = handle.apply(cur, data);
          if (event.result === false) {
            event.preventDefault();
          }
        }
      }
      event.type = type;
      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if (
          (!special._default ||
            special._default.apply(eventPath.pop(), data) === false) &&
          jQuery.acceptData(elem)
        ) {
          if (
            ontype &&
            jQuery.isFunction(elem[type]) &&
            !jQuery.isWindow(elem)
          ) {
            tmp = elem[ontype];
            if (tmp) {
              elem[ontype] = null;
            }
            jQuery.event.triggered = type;
            elem[type]();
            jQuery.event.triggered = undefined;
            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }
      return event.result;
    },
    dispatch: function (event) {
      event = jQuery.event.fix(event);
      var i,
        j,
        ret,
        matched,
        handleObj,
        handlerQueue = [],
        args = slice.call(arguments),
        handlers = (data_priv.get(this, "events") || {})[event.type] || [],
        special = jQuery.event.special[event.type] || {};
      args[0] = event;
      event.delegateTarget = this;
      if (
        special.preDispatch &&
        special.preDispatch.call(this, event) === false
      ) {
        return;
      }
      handlerQueue = jQuery.event.handlers.call(this, event, handlers);
      i = 0;
      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;
        while (
          (handleObj = matched.handlers[j++]) &&
          !event.isImmediatePropagationStopped()
        ) {
          if (
            !event.namespace_re ||
            event.namespace_re.test(handleObj.namespace)
          ) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = (
              (jQuery.event.special[handleObj.origType] || {}).handle ||
              handleObj.handler
            ).apply(matched.elem, args);
            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      }
      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }
      return event.result;
    },
    handlers: function (event, handlers) {
      var i,
        matches,
        sel,
        handleObj,
        handlerQueue = [],
        delegateCount = handlers.delegateCount,
        cur = event.target;
      if (
        delegateCount &&
        cur.nodeType &&
        (!event.button || event.type !== "click")
      ) {
        for (; cur !== this; cur = cur.parentNode || this) {
          if (cur.disabled !== true || event.type !== "click") {
            matches = [];
            for (i = 0; i < delegateCount; i++) {
              handleObj = handlers[i];
              sel = handleObj.selector + " ";
              if (matches[sel] === undefined) {
                matches[sel] = handleObj.needsContext
                  ? jQuery(sel, this).index(cur) >= 0
                  : jQuery.find(sel, this, null, [cur]).length;
              }
              if (matches[sel]) {
                matches.push(handleObj);
              }
            }
            if (matches.length) {
              handlerQueue.push({ elem: cur, handlers: matches });
            }
          }
        }
      }
      if (delegateCount < handlers.length) {
        handlerQueue.push({
          elem: this,
          handlers: handlers.slice(delegateCount),
        });
      }
      return handlerQueue;
    },
    props:
      "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(
        " "
      ),
    fixHooks: {},
    keyHooks: {
      props: "char charCode key keyCode".split(" "),
      filter: function (event, original) {
        if (event.which == null) {
          event.which =
            original.charCode != null ? original.charCode : original.keyCode;
        }
        return event;
      },
    },
    mouseHooks: {
      props:
        "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(
          " "
        ),
      filter: function (event, original) {
        var eventDoc,
          doc,
          body,
          button = original.button;
        if (event.pageX == null && original.clientX != null) {
          eventDoc = event.target.ownerDocument || document;
          doc = eventDoc.documentElement;
          body = eventDoc.body;
          event.pageX =
            original.clientX +
            ((doc && doc.scrollLeft) || (body && body.scrollLeft) || 0) -
            ((doc && doc.clientLeft) || (body && body.clientLeft) || 0);
          event.pageY =
            original.clientY +
            ((doc && doc.scrollTop) || (body && body.scrollTop) || 0) -
            ((doc && doc.clientTop) || (body && body.clientTop) || 0);
        }
        if (!event.which && button !== undefined) {
          event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
        }
        return event;
      },
    },
    fix: function (event) {
      if (event[jQuery.expando]) {
        return event;
      }
      var i,
        prop,
        copy,
        type = event.type,
        originalEvent = event,
        fixHook = this.fixHooks[type];
      if (!fixHook) {
        this.fixHooks[type] = fixHook = rmouseEvent.test(type)
          ? this.mouseHooks
          : rkeyEvent.test(type)
          ? this.keyHooks
          : {};
      }
      copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
      event = new jQuery.Event(originalEvent);
      i = copy.length;
      while (i--) {
        prop = copy[i];
        event[prop] = originalEvent[prop];
      }
      if (!event.target) {
        event.target = document;
      }
      if (event.target.nodeType === 3) {
        event.target = event.target.parentNode;
      }
      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
    },
    special: {
      load: { noBubble: true },
      focus: {
        trigger: function () {
          if (this !== safeActiveElement() && this.focus) {
            this.focus();
            return false;
          }
        },
        delegateType: "focusin",
      },
      blur: {
        trigger: function () {
          if (this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: "focusout",
      },
      click: {
        trigger: function () {
          if (
            this.type === "checkbox" &&
            this.click &&
            jQuery.nodeName(this, "input")
          ) {
            this.click();
            return false;
          }
        },
        _default: function (event) {
          return jQuery.nodeName(event.target, "a");
        },
      },
      beforeunload: {
        postDispatch: function (event) {
          if (event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        },
      },
    },
    simulate: function (type, elem, event, bubble) {
      var e = jQuery.extend(new jQuery.Event(), event, {
        type: type,
        isSimulated: true,
        originalEvent: {},
      });
      if (bubble) {
        jQuery.event.trigger(e, null, elem);
      } else {
        jQuery.event.dispatch.call(elem, e);
      }
      if (e.isDefaultPrevented()) {
        event.preventDefault();
      }
    },
  };
  jQuery.removeEvent = function (elem, type, handle) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle, false);
    }
  };
  jQuery.Event = function (src, props) {
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    }
    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type;
      this.isDefaultPrevented =
        src.defaultPrevented ||
        (src.defaultPrevented === undefined && src.returnValue === false)
          ? returnTrue
          : returnFalse;
    } else {
      this.type = src;
    }
    if (props) {
      jQuery.extend(this, props);
    }
    this.timeStamp = (src && src.timeStamp) || jQuery.now();
    this[jQuery.expando] = true;
  };
  jQuery.Event.prototype = {
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    preventDefault: function () {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;
      if (e && e.preventDefault) {
        e.preventDefault();
      }
    },
    stopPropagation: function () {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;
      if (e && e.stopPropagation) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function () {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = returnTrue;
      if (e && e.stopImmediatePropagation) {
        e.stopImmediatePropagation();
      }
      this.stopPropagation();
    },
  };
  jQuery.each(
    {
      mouseenter: "mouseover",
      mouseleave: "mouseout",
      pointerenter: "pointerover",
      pointerleave: "pointerout",
    },
    function (orig, fix) {
      jQuery.event.special[orig] = {
        delegateType: fix,
        bindType: fix,
        handle: function (event) {
          var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj;
          if (
            !related ||
            (related !== target && !jQuery.contains(target, related))
          ) {
            event.type = handleObj.origType;
            ret = handleObj.handler.apply(this, arguments);
            event.type = fix;
          }
          return ret;
        },
      };
    }
  );
  if (!support.focusinBubbles) {
    jQuery.each({ focus: "focusin", blur: "focusout" }, function (orig, fix) {
      var handler = function (event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
      };
      jQuery.event.special[fix] = {
        setup: function () {
          var doc = this.ownerDocument || this,
            attaches = data_priv.access(doc, fix);
          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }
          data_priv.access(doc, fix, (attaches || 0) + 1);
        },
        teardown: function () {
          var doc = this.ownerDocument || this,
            attaches = data_priv.access(doc, fix) - 1;
          if (!attaches) {
            doc.removeEventListener(orig, handler, true);
            data_priv.remove(doc, fix);
          } else {
            data_priv.access(doc, fix, attaches);
          }
        },
      };
    });
  }
  jQuery.fn.extend({
    on: function (types, selector, data, fn, one) {
      var origFn, type;
      if (typeof types === "object") {
        if (typeof selector !== "string") {
          data = data || selector;
          selector = undefined;
        }
        for (type in types) {
          this.on(type, selector, data, types[type], one);
        }
        return this;
      }
      if (data == null && fn == null) {
        fn = selector;
        data = selector = undefined;
      } else if (fn == null) {
        if (typeof selector === "string") {
          fn = data;
          data = undefined;
        } else {
          fn = data;
          data = selector;
          selector = undefined;
        }
      }
      if (fn === false) {
        fn = returnFalse;
      } else if (!fn) {
        return this;
      }
      if (one === 1) {
        origFn = fn;
        fn = function (event) {
          jQuery().off(event);
          return origFn.apply(this, arguments);
        };
        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
      }
      return this.each(function () {
        jQuery.event.add(this, types, fn, data, selector);
      });
    },
    one: function (types, selector, data, fn) {
      return this.on(types, selector, data, fn, 1);
    },
    off: function (types, selector, fn) {
      var handleObj, type;
      if (types && types.preventDefault && types.handleObj) {
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(
          handleObj.namespace
            ? handleObj.origType + "." + handleObj.namespace
            : handleObj.origType,
          handleObj.selector,
          handleObj.handler
        );
        return this;
      }
      if (typeof types === "object") {
        for (type in types) {
          this.off(type, selector, types[type]);
        }
        return this;
      }
      if (selector === false || typeof selector === "function") {
        fn = selector;
        selector = undefined;
      }
      if (fn === false) {
        fn = returnFalse;
      }
      return this.each(function () {
        jQuery.event.remove(this, types, fn, selector);
      });
    },
    trigger: function (type, data) {
      return this.each(function () {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function (type, data) {
      var elem = this[0];
      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    },
  });
  var rxhtmlTag =
      /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
    rtagName = /<([\w:]+)/,
    rhtml = /<|&#?\w+;/,
    rnoInnerhtml = /<(?:script|style|link)/i,
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
    rscriptType = /^$|\/(?:java|ecma)script/i,
    rscriptTypeMasked = /^true\/(.*)/,
    rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
    wrapMap = {
      option: [1, "<select multiple='multiple'>", "</select>"],
      thead: [1, "<table>", "</table>"],
      col: [2, "<table><colgroup>", "</colgroup></table>"],
      tr: [2, "<table><tbody>", "</tbody></table>"],
      td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
      _default: [0, "", ""],
    };
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody =
    wrapMap.tfoot =
    wrapMap.colgroup =
    wrapMap.caption =
      wrapMap.thead;
  wrapMap.th = wrapMap.td;
  function manipulationTarget(elem, content) {
    return jQuery.nodeName(elem, "table") &&
      jQuery.nodeName(
        content.nodeType !== 11 ? content : content.firstChild,
        "tr"
      )
      ? elem.getElementsByTagName("tbody")[0] ||
          elem.appendChild(elem.ownerDocument.createElement("tbody"))
      : elem;
  }
  function disableScript(elem) {
    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
    return elem;
  }
  function restoreScript(elem) {
    var match = rscriptTypeMasked.exec(elem.type);
    if (match) {
      elem.type = match[1];
    } else {
      elem.removeAttribute("type");
    }
    return elem;
  }
  function setGlobalEval(elems, refElements) {
    var i = 0,
      l = elems.length;
    for (; i < l; i++) {
      data_priv.set(
        elems[i],
        "globalEval",
        !refElements || data_priv.get(refElements[i], "globalEval")
      );
    }
  }
  function cloneCopyEvent(src, dest) {
    var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
    if (dest.nodeType !== 1) {
      return;
    }
    if (data_priv.hasData(src)) {
      pdataOld = data_priv.access(src);
      pdataCur = data_priv.set(dest, pdataOld);
      events = pdataOld.events;
      if (events) {
        delete pdataCur.handle;
        pdataCur.events = {};
        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    }
    if (data_user.hasData(src)) {
      udataOld = data_user.access(src);
      udataCur = jQuery.extend({}, udataOld);
      data_user.set(dest, udataCur);
    }
  }
  function getAll(context, tag) {
    var ret = context.getElementsByTagName
      ? context.getElementsByTagName(tag || "*")
      : context.querySelectorAll
      ? context.querySelectorAll(tag || "*")
      : [];
    return tag === undefined || (tag && jQuery.nodeName(context, tag))
      ? jQuery.merge([context], ret)
      : ret;
  }
  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase();
    if (nodeName === "input" && rcheckableType.test(src.type)) {
      dest.checked = src.checked;
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }
  jQuery.extend({
    clone: function (elem, dataAndEvents, deepDataAndEvents) {
      var i,
        l,
        srcElements,
        destElements,
        clone = elem.cloneNode(true),
        inPage = jQuery.contains(elem.ownerDocument, elem);
      if (
        !support.noCloneChecked &&
        (elem.nodeType === 1 || elem.nodeType === 11) &&
        !jQuery.isXMLDoc(elem)
      ) {
        destElements = getAll(clone);
        srcElements = getAll(elem);
        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      }
      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);
          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      }
      destElements = getAll(clone, "script");
      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
      }
      return clone;
    },
    buildFragment: function (elems, context, scripts, selection) {
      var elem,
        tmp,
        tag,
        wrap,
        contains,
        j,
        fragment = context.createDocumentFragment(),
        nodes = [],
        i = 0,
        l = elems.length;
      for (; i < l; i++) {
        elem = elems[i];
        if (elem || elem === 0) {
          if (jQuery.type(elem) === "object") {
            jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
          } else if (!rhtml.test(elem)) {
            nodes.push(context.createTextNode(elem));
          } else {
            tmp = tmp || fragment.appendChild(context.createElement("div"));
            tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML =
              wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];
            j = wrap[0];
            while (j--) {
              tmp = tmp.lastChild;
            }
            jQuery.merge(nodes, tmp.childNodes);
            tmp = fragment.firstChild;
            tmp.textContent = "";
          }
        }
      }
      fragment.textContent = "";
      i = 0;
      while ((elem = nodes[i++])) {
        if (selection && jQuery.inArray(elem, selection) !== -1) {
          continue;
        }
        contains = jQuery.contains(elem.ownerDocument, elem);
        tmp = getAll(fragment.appendChild(elem), "script");
        if (contains) {
          setGlobalEval(tmp);
        }
        if (scripts) {
          j = 0;
          while ((elem = tmp[j++])) {
            if (rscriptType.test(elem.type || "")) {
              scripts.push(elem);
            }
          }
        }
      }
      return fragment;
    },
    cleanData: function (elems) {
      var data,
        elem,
        type,
        key,
        special = jQuery.event.special,
        i = 0;
      for (; (elem = elems[i]) !== undefined; i++) {
        if (jQuery.acceptData(elem)) {
          key = elem[data_priv.expando];
          if (key && (data = data_priv.cache[key])) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type);
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            }
            if (data_priv.cache[key]) {
              delete data_priv.cache[key];
            }
          }
        }
        delete data_user.cache[elem[data_user.expando]];
      }
    },
  });
  jQuery.fn.extend({
    text: function (value) {
      return access(
        this,
        function (value) {
          return value === undefined
            ? jQuery.text(this)
            : this.empty().each(function () {
                if (
                  this.nodeType === 1 ||
                  this.nodeType === 11 ||
                  this.nodeType === 9
                ) {
                  this.textContent = value;
                }
              });
        },
        null,
        value,
        arguments.length
      );
    },
    append: function () {
      return this.domManip(arguments, function (elem) {
        if (
          this.nodeType === 1 ||
          this.nodeType === 11 ||
          this.nodeType === 9
        ) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function () {
      return this.domManip(arguments, function (elem) {
        if (
          this.nodeType === 1 ||
          this.nodeType === 11 ||
          this.nodeType === 9
        ) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function () {
      return this.domManip(arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function () {
      return this.domManip(arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    remove: function (selector, keepData) {
      var elem,
        elems = selector ? jQuery.filter(selector, this) : this,
        i = 0;
      for (; (elem = elems[i]) != null; i++) {
        if (!keepData && elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem));
        }
        if (elem.parentNode) {
          if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
            setGlobalEval(getAll(elem, "script"));
          }
          elem.parentNode.removeChild(elem);
        }
      }
      return this;
    },
    empty: function () {
      var elem,
        i = 0;
      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem, false));
          elem.textContent = "";
        }
      }
      return this;
    },
    clone: function (dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents =
        deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function () {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function (value) {
      return access(
        this,
        function (value) {
          var elem = this[0] || {},
            i = 0,
            l = this.length;
          if (value === undefined && elem.nodeType === 1) {
            return elem.innerHTML;
          }
          if (
            typeof value === "string" &&
            !rnoInnerhtml.test(value) &&
            !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]
          ) {
            value = value.replace(rxhtmlTag, "<$1></$2>");
            try {
              for (; i < l; i++) {
                elem = this[i] || {};
                if (elem.nodeType === 1) {
                  jQuery.cleanData(getAll(elem, false));
                  elem.innerHTML = value;
                }
              }
              elem = 0;
            } catch (e) {}
          }
          if (elem) {
            this.empty().append(value);
          }
        },
        null,
        value,
        arguments.length
      );
    },
    replaceWith: function () {
      var arg = arguments[0];
      this.domManip(arguments, function (elem) {
        arg = this.parentNode;
        jQuery.cleanData(getAll(this));
        if (arg) {
          arg.replaceChild(elem, this);
        }
      });
      return arg && (arg.length || arg.nodeType) ? this : this.remove();
    },
    detach: function (selector) {
      return this.remove(selector, true);
    },
    domManip: function (args, callback) {
      args = concat.apply([], args);
      var fragment,
        first,
        scripts,
        hasScripts,
        node,
        doc,
        i = 0,
        l = this.length,
        set = this,
        iNoClone = l - 1,
        value = args[0],
        isFunction = jQuery.isFunction(value);
      if (
        isFunction ||
        (l > 1 &&
          typeof value === "string" &&
          !support.checkClone &&
          rchecked.test(value))
      ) {
        return this.each(function (index) {
          var self = set.eq(index);
          if (isFunction) {
            args[0] = value.call(this, index, self.html());
          }
          self.domManip(args, callback);
        });
      }
      if (l) {
        fragment = jQuery.buildFragment(
          args,
          this[0].ownerDocument,
          false,
          this
        );
        first = fragment.firstChild;
        if (fragment.childNodes.length === 1) {
          fragment = first;
        }
        if (first) {
          scripts = jQuery.map(getAll(fragment, "script"), disableScript);
          hasScripts = scripts.length;
          for (; i < l; i++) {
            node = fragment;
            if (i !== iNoClone) {
              node = jQuery.clone(node, true, true);
              if (hasScripts) {
                jQuery.merge(scripts, getAll(node, "script"));
              }
            }
            callback.call(this[i], node, i);
          }
          if (hasScripts) {
            doc = scripts[scripts.length - 1].ownerDocument;
            jQuery.map(scripts, restoreScript);
            for (i = 0; i < hasScripts; i++) {
              node = scripts[i];
              if (
                rscriptType.test(node.type || "") &&
                !data_priv.access(node, "globalEval") &&
                jQuery.contains(doc, node)
              ) {
                if (node.src) {
                  if (jQuery._evalUrl) {
                    jQuery._evalUrl(node.src);
                  }
                } else {
                  jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
                }
              }
            }
          }
        }
      }
      return this;
    },
  });
  jQuery.each(
    {
      appendTo: "append",
      prependTo: "prepend",
      insertBefore: "before",
      insertAfter: "after",
      replaceAll: "replaceWith",
    },
    function (name, original) {
      jQuery.fn[name] = function (selector) {
        var elems,
          ret = [],
          insert = jQuery(selector),
          last = insert.length - 1,
          i = 0;
        for (; i <= last; i++) {
          elems = i === last ? this : this.clone(true);
          jQuery(insert[i])[original](elems);
          push.apply(ret, elems.get());
        }
        return this.pushStack(ret);
      };
    }
  );
  var iframe,
    elemdisplay = {};
  function actualDisplay(name, doc) {
    var style,
      elem = jQuery(doc.createElement(name)).appendTo(doc.body),
      display =
        window.getDefaultComputedStyle &&
        (style = window.getDefaultComputedStyle(elem[0]))
          ? style.display
          : jQuery.css(elem[0], "display");
    elem.detach();
    return display;
  }
  function defaultDisplay(nodeName) {
    var doc = document,
      display = elemdisplay[nodeName];
    if (!display) {
      display = actualDisplay(nodeName, doc);
      if (display === "none" || !display) {
        iframe = (
          iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")
        ).appendTo(doc.documentElement);
        doc = iframe[0].contentDocument;
        doc.write();
        doc.close();
        display = actualDisplay(nodeName, doc);
        iframe.detach();
      }
      elemdisplay[nodeName] = display;
    }
    return display;
  }
  var rmargin = /^margin/;
  var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
  var getStyles = function (elem) {
    if (elem.ownerDocument.defaultView.opener) {
      return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
    }
    return window.getComputedStyle(elem, null);
  };
  function curCSS(elem, name, computed) {
    var width,
      minWidth,
      maxWidth,
      ret,
      style = elem.style;
    computed = computed || getStyles(elem);
    if (computed) {
      ret = computed.getPropertyValue(name) || computed[name];
    }
    if (computed) {
      if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
        ret = jQuery.style(elem, name);
      }
      if (rnumnonpx.test(ret) && rmargin.test(name)) {
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth;
        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width;
        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }
    return ret !== undefined ? ret + "" : ret;
  }
  function addGetHookIf(conditionFn, hookFn) {
    return {
      get: function () {
        if (conditionFn()) {
          delete this.get;
          return;
        }
        return (this.get = hookFn).apply(this, arguments);
      },
    };
  }
  (function () {
    var pixelPositionVal,
      boxSizingReliableVal,
      docElem = document.documentElement,
      container = document.createElement("div"),
      div = document.createElement("div");
    if (!div.style) {
      return;
    }
    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";
    container.style.cssText =
      "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
      "position:absolute";
    container.appendChild(div);
    function computePixelPositionAndBoxSizingReliable() {
      div.style.cssText =
        "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
        "box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
        "border:1px;padding:1px;width:4px;position:absolute";
      div.innerHTML = "";
      docElem.appendChild(container);
      var divStyle = window.getComputedStyle(div, null);
      pixelPositionVal = divStyle.top !== "1%";
      boxSizingReliableVal = divStyle.width === "4px";
      docElem.removeChild(container);
    }
    if (window.getComputedStyle) {
      jQuery.extend(support, {
        pixelPosition: function () {
          computePixelPositionAndBoxSizingReliable();
          return pixelPositionVal;
        },
        boxSizingReliable: function () {
          if (boxSizingReliableVal == null) {
            computePixelPositionAndBoxSizingReliable();
          }
          return boxSizingReliableVal;
        },
        reliableMarginRight: function () {
          var ret,
            marginDiv = div.appendChild(document.createElement("div"));
          marginDiv.style.cssText = div.style.cssText =
            "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
            "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
          marginDiv.style.marginRight = marginDiv.style.width = "0";
          div.style.width = "1px";
          docElem.appendChild(container);
          ret = !parseFloat(
            window.getComputedStyle(marginDiv, null).marginRight
          );
          docElem.removeChild(container);
          div.removeChild(marginDiv);
          return ret;
        },
      });
    }
  })();
  jQuery.swap = function (elem, options, callback, args) {
    var ret,
      name,
      old = {};
    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }
    ret = callback.apply(elem, args || []);
    for (name in options) {
      elem.style[name] = old[name];
    }
    return ret;
  };
  var rdisplayswap = /^(none|table(?!-c[ea]).+)/,
    rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"),
    rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"),
    cssShow = { position: "absolute", visibility: "hidden", display: "block" },
    cssNormalTransform = { letterSpacing: "0", fontWeight: "400" },
    cssPrefixes = ["Webkit", "O", "Moz", "ms"];
  function vendorPropName(style, name) {
    if (name in style) {
      return name;
    }
    var capName = name[0].toUpperCase() + name.slice(1),
      origName = name,
      i = cssPrefixes.length;
    while (i--) {
      name = cssPrefixes[i] + capName;
      if (name in style) {
        return name;
      }
    }
    return origName;
  }
  function setPositiveNumber(elem, value, subtract) {
    var matches = rnumsplit.exec(value);
    return matches
      ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px")
      : value;
  }
  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
    var i =
        extra === (isBorderBox ? "border" : "content")
          ? 4
          : name === "width"
          ? 1
          : 0,
      val = 0;
    for (; i < 4; i += 2) {
      if (extra === "margin") {
        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
      }
      if (isBorderBox) {
        if (extra === "content") {
          val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        }
        if (extra !== "margin") {
          val -= jQuery.css(
            elem,
            "border" + cssExpand[i] + "Width",
            true,
            styles
          );
        }
      } else {
        val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        if (extra !== "padding") {
          val += jQuery.css(
            elem,
            "border" + cssExpand[i] + "Width",
            true,
            styles
          );
        }
      }
    }
    return val;
  }
  function getWidthOrHeight(elem, name, extra) {
    var valueIsBorderBox = true,
      val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
      styles = getStyles(elem),
      isBorderBox =
        jQuery.css(elem, "boxSizing", false, styles) === "border-box";
    if (val <= 0 || val == null) {
      val = curCSS(elem, name, styles);
      if (val < 0 || val == null) {
        val = elem.style[name];
      }
      if (rnumnonpx.test(val)) {
        return val;
      }
      valueIsBorderBox =
        isBorderBox &&
        (support.boxSizingReliable() || val === elem.style[name]);
      val = parseFloat(val) || 0;
    }
    return (
      val +
      augmentWidthOrHeight(
        elem,
        name,
        extra || (isBorderBox ? "border" : "content"),
        valueIsBorderBox,
        styles
      ) +
      "px"
    );
  }
  function showHide(elements, show) {
    var display,
      elem,
      hidden,
      values = [],
      index = 0,
      length = elements.length;
    for (; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      values[index] = data_priv.get(elem, "olddisplay");
      display = elem.style.display;
      if (show) {
        if (!values[index] && display === "none") {
          elem.style.display = "";
        }
        if (elem.style.display === "" && isHidden(elem)) {
          values[index] = data_priv.access(
            elem,
            "olddisplay",
            defaultDisplay(elem.nodeName)
          );
        }
      } else {
        hidden = isHidden(elem);
        if (display !== "none" || !hidden) {
          data_priv.set(
            elem,
            "olddisplay",
            hidden ? display : jQuery.css(elem, "display")
          );
        }
      }
    }
    for (index = 0; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      if (!show || elem.style.display === "none" || elem.style.display === "") {
        elem.style.display = show ? values[index] || "" : "none";
      }
    }
    return elements;
  }
  jQuery.extend({
    cssHooks: {
      opacity: {
        get: function (elem, computed) {
          if (computed) {
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        },
      },
    },
    cssNumber: {
      columnCount: true,
      fillOpacity: true,
      flexGrow: true,
      flexShrink: true,
      fontWeight: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      widows: true,
      zIndex: true,
      zoom: true,
    },
    cssProps: { float: "cssFloat" },
    style: function (elem, name, value, extra) {
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      }
      var ret,
        type,
        hooks,
        origName = jQuery.camelCase(name),
        style = elem.style;
      name =
        jQuery.cssProps[origName] ||
        (jQuery.cssProps[origName] = vendorPropName(style, origName));
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (value !== undefined) {
        type = typeof value;
        if (type === "string" && (ret = rrelNum.exec(value))) {
          value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
          type = "number";
        }
        if (value == null || value !== value) {
          return;
        }
        if (type === "number" && !jQuery.cssNumber[origName]) {
          value += "px";
        }
        if (
          !support.clearCloneStyle &&
          value === "" &&
          name.indexOf("background") === 0
        ) {
          style[name] = "inherit";
        }
        if (
          !hooks ||
          !("set" in hooks) ||
          (value = hooks.set(elem, value, extra)) !== undefined
        ) {
          style[name] = value;
        }
      } else {
        if (
          hooks &&
          "get" in hooks &&
          (ret = hooks.get(elem, false, extra)) !== undefined
        ) {
          return ret;
        }
        return style[name];
      }
    },
    css: function (elem, name, extra, styles) {
      var val,
        num,
        hooks,
        origName = jQuery.camelCase(name);
      name =
        jQuery.cssProps[origName] ||
        (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      }
      if (val === undefined) {
        val = curCSS(elem, name, styles);
      }
      if (val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      }
      if (extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
      }
      return val;
    },
  });
  jQuery.each(["height", "width"], function (i, name) {
    jQuery.cssHooks[name] = {
      get: function (elem, computed, extra) {
        if (computed) {
          return rdisplayswap.test(jQuery.css(elem, "display")) &&
            elem.offsetWidth === 0
            ? jQuery.swap(elem, cssShow, function () {
                return getWidthOrHeight(elem, name, extra);
              })
            : getWidthOrHeight(elem, name, extra);
        }
      },
      set: function (elem, value, extra) {
        var styles = extra && getStyles(elem);
        return setPositiveNumber(
          elem,
          value,
          extra
            ? augmentWidthOrHeight(
                elem,
                name,
                extra,
                jQuery.css(elem, "boxSizing", false, styles) === "border-box",
                styles
              )
            : 0
        );
      },
    };
  });
  jQuery.cssHooks.marginRight = addGetHookIf(
    support.reliableMarginRight,
    function (elem, computed) {
      if (computed) {
        return jQuery.swap(elem, { display: "inline-block" }, curCSS, [
          elem,
          "marginRight",
        ]);
      }
    }
  );
  jQuery.each(
    { margin: "", padding: "", border: "Width" },
    function (prefix, suffix) {
      jQuery.cssHooks[prefix + suffix] = {
        expand: function (value) {
          var i = 0,
            expanded = {},
            parts = typeof value === "string" ? value.split(" ") : [value];
          for (; i < 4; i++) {
            expanded[prefix + cssExpand[i] + suffix] =
              parts[i] || parts[i - 2] || parts[0];
          }
          return expanded;
        },
      };
      if (!rmargin.test(prefix)) {
        jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
      }
    }
  );
  jQuery.fn.extend({
    css: function (name, value) {
      return access(
        this,
        function (elem, name, value) {
          var styles,
            len,
            map = {},
            i = 0;
          if (jQuery.isArray(name)) {
            styles = getStyles(elem);
            len = name.length;
            for (; i < len; i++) {
              map[name[i]] = jQuery.css(elem, name[i], false, styles);
            }
            return map;
          }
          return value !== undefined
            ? jQuery.style(elem, name, value)
            : jQuery.css(elem, name);
        },
        name,
        value,
        arguments.length > 1
      );
    },
    show: function () {
      return showHide(this, true);
    },
    hide: function () {
      return showHide(this);
    },
    toggle: function (state) {
      if (typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }
      return this.each(function () {
        if (isHidden(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    },
  });
  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }
  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function (elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || "swing";
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function () {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get
        ? hooks.get(this)
        : Tween.propHooks._default.get(this);
    },
    run: function (percent) {
      var eased,
        hooks = Tween.propHooks[this.prop];
      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](
          percent,
          this.options.duration * percent,
          0,
          1,
          this.options.duration
        );
      } else {
        this.pos = eased = percent;
      }
      this.now = (this.end - this.start) * eased + this.start;
      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }
      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }
      return this;
    },
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {
    _default: {
      get: function (tween) {
        var result;
        if (
          tween.elem[tween.prop] != null &&
          (!tween.elem.style || tween.elem.style[tween.prop] == null)
        ) {
          return tween.elem[tween.prop];
        }
        result = jQuery.css(tween.elem, tween.prop, "");
        return !result || result === "auto" ? 0 : result;
      },
      set: function (tween) {
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (
          tween.elem.style &&
          (tween.elem.style[jQuery.cssProps[tween.prop]] != null ||
            jQuery.cssHooks[tween.prop])
        ) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      },
    },
  };
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function (tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    },
  };
  jQuery.easing = {
    linear: function (p) {
      return p;
    },
    swing: function (p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    },
  };
  jQuery.fx = Tween.prototype.init;
  jQuery.fx.step = {};
  var fxNow,
    timerId,
    rfxtypes = /^(?:toggle|show|hide)$/,
    rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"),
    rrun = /queueHooks$/,
    animationPrefilters = [defaultPrefilter],
    tweeners = {
      "*": [
        function (prop, value) {
          var tween = this.createTween(prop, value),
            target = tween.cur(),
            parts = rfxnum.exec(value),
            unit = (parts && parts[3]) || (jQuery.cssNumber[prop] ? "" : "px"),
            start =
              (jQuery.cssNumber[prop] || (unit !== "px" && +target)) &&
              rfxnum.exec(jQuery.css(tween.elem, prop)),
            scale = 1,
            maxIterations = 20;
          if (start && start[3] !== unit) {
            unit = unit || start[3];
            parts = parts || [];
            start = +target || 1;
            do {
              scale = scale || ".5";
              start = start / scale;
              jQuery.style(tween.elem, prop, start + unit);
            } while (
              scale !== (scale = tween.cur() / target) &&
              scale !== 1 &&
              --maxIterations
            );
          }
          if (parts) {
            start = tween.start = +start || +target || 0;
            tween.unit = unit;
            tween.end = parts[1]
              ? start + (parts[1] + 1) * parts[2]
              : +parts[2];
          }
          return tween;
        },
      ],
    };
  function createFxNow() {
    setTimeout(function () {
      fxNow = undefined;
    });
    return (fxNow = jQuery.now());
  }
  function genFx(type, includeWidth) {
    var which,
      i = 0,
      attrs = { height: type };
    includeWidth = includeWidth ? 1 : 0;
    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }
    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }
    return attrs;
  }
  function createTween(value, prop, animation) {
    var tween,
      collection = (tweeners[prop] || []).concat(tweeners["*"]),
      index = 0,
      length = collection.length;
    for (; index < length; index++) {
      if ((tween = collection[index].call(animation, prop, value))) {
        return tween;
      }
    }
  }
  function defaultPrefilter(elem, props, opts) {
    var prop,
      value,
      toggle,
      tween,
      hooks,
      oldfire,
      display,
      checkDisplay,
      anim = this,
      orig = {},
      style = elem.style,
      hidden = elem.nodeType && isHidden(elem),
      dataShow = data_priv.get(elem, "fxshow");
    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");
      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function () {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;
      anim.always(function () {
        anim.always(function () {
          hooks.unqueued--;
          if (!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    }
    if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
      opts.overflow = [style.overflow, style.overflowX, style.overflowY];
      display = jQuery.css(elem, "display");
      checkDisplay =
        display === "none"
          ? data_priv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName)
          : display;
      if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
        style.display = "inline-block";
      }
    }
    if (opts.overflow) {
      style.overflow = "hidden";
      anim.always(function () {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    }
    for (prop in props) {
      value = props[prop];
      if (rfxtypes.exec(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";
        if (value === (hidden ? "hide" : "show")) {
          if (value === "show" && dataShow && dataShow[prop] !== undefined) {
            hidden = true;
          } else {
            continue;
          }
        }
        orig[prop] = (dataShow && dataShow[prop]) || jQuery.style(elem, prop);
      } else {
        display = undefined;
      }
    }
    if (!jQuery.isEmptyObject(orig)) {
      if (dataShow) {
        if ("hidden" in dataShow) {
          hidden = dataShow.hidden;
        }
      } else {
        dataShow = data_priv.access(elem, "fxshow", {});
      }
      if (toggle) {
        dataShow.hidden = !hidden;
      }
      if (hidden) {
        jQuery(elem).show();
      } else {
        anim.done(function () {
          jQuery(elem).hide();
        });
      }
      anim.done(function () {
        var prop;
        data_priv.remove(elem, "fxshow");
        for (prop in orig) {
          jQuery.style(elem, prop, orig[prop]);
        }
      });
      for (prop in orig) {
        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
        if (!(prop in dataShow)) {
          dataShow[prop] = tween.start;
          if (hidden) {
            tween.end = tween.start;
            tween.start = prop === "width" || prop === "height" ? 1 : 0;
          }
        }
      }
    } else if (
      (display === "none" ? defaultDisplay(elem.nodeName) : display) ===
      "inline"
    ) {
      style.display = display;
    }
  }
  function propFilter(props, specialEasing) {
    var index, name, easing, value, hooks;
    for (index in props) {
      name = jQuery.camelCase(index);
      easing = specialEasing[name];
      value = props[index];
      if (jQuery.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }
      if (index !== name) {
        props[name] = value;
        delete props[index];
      }
      hooks = jQuery.cssHooks[name];
      if (hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name];
        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }
  function Animation(elem, properties, options) {
    var result,
      stopped,
      index = 0,
      length = animationPrefilters.length,
      deferred = jQuery.Deferred().always(function () {
        delete tick.elem;
      }),
      tick = function () {
        if (stopped) {
          return false;
        }
        var currentTime = fxNow || createFxNow(),
          remaining = Math.max(
            0,
            animation.startTime + animation.duration - currentTime
          ),
          temp = remaining / animation.duration || 0,
          percent = 1 - temp,
          index = 0,
          length = animation.tweens.length;
        for (; index < length; index++) {
          animation.tweens[index].run(percent);
        }
        deferred.notifyWith(elem, [animation, percent, remaining]);
        if (percent < 1 && length) {
          return remaining;
        } else {
          deferred.resolveWith(elem, [animation]);
          return false;
        }
      },
      animation = deferred.promise({
        elem: elem,
        props: jQuery.extend({}, properties),
        opts: jQuery.extend(true, { specialEasing: {} }, options),
        originalProperties: properties,
        originalOptions: options,
        startTime: fxNow || createFxNow(),
        duration: options.duration,
        tweens: [],
        createTween: function (prop, end) {
          var tween = jQuery.Tween(
            elem,
            animation.opts,
            prop,
            end,
            animation.opts.specialEasing[prop] || animation.opts.easing
          );
          animation.tweens.push(tween);
          return tween;
        },
        stop: function (gotoEnd) {
          var index = 0,
            length = gotoEnd ? animation.tweens.length : 0;
          if (stopped) {
            return this;
          }
          stopped = true;
          for (; index < length; index++) {
            animation.tweens[index].run(1);
          }
          if (gotoEnd) {
            deferred.resolveWith(elem, [animation, gotoEnd]);
          } else {
            deferred.rejectWith(elem, [animation, gotoEnd]);
          }
          return this;
        },
      }),
      props = animation.props;
    propFilter(props, animation.opts.specialEasing);
    for (; index < length; index++) {
      result = animationPrefilters[index].call(
        animation,
        elem,
        props,
        animation.opts
      );
      if (result) {
        return result;
      }
    }
    jQuery.map(props, createTween, animation);
    if (jQuery.isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }
    jQuery.fx.timer(
      jQuery.extend(tick, {
        elem: elem,
        anim: animation,
        queue: animation.opts.queue,
      })
    );
    return animation
      .progress(animation.opts.progress)
      .done(animation.opts.done, animation.opts.complete)
      .fail(animation.opts.fail)
      .always(animation.opts.always);
  }
  jQuery.Animation = jQuery.extend(Animation, {
    tweener: function (props, callback) {
      if (jQuery.isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.split(" ");
      }
      var prop,
        index = 0,
        length = props.length;
      for (; index < length; index++) {
        prop = props[index];
        tweeners[prop] = tweeners[prop] || [];
        tweeners[prop].unshift(callback);
      }
    },
    prefilter: function (callback, prepend) {
      if (prepend) {
        animationPrefilters.unshift(callback);
      } else {
        animationPrefilters.push(callback);
      }
    },
  });
  jQuery.speed = function (speed, easing, fn) {
    var opt =
      speed && typeof speed === "object"
        ? jQuery.extend({}, speed)
        : {
            complete:
              fn || (!fn && easing) || (jQuery.isFunction(speed) && speed),
            duration: speed,
            easing:
              (fn && easing) ||
              (easing && !jQuery.isFunction(easing) && easing),
          };
    opt.duration = jQuery.fx.off
      ? 0
      : typeof opt.duration === "number"
      ? opt.duration
      : opt.duration in jQuery.fx.speeds
      ? jQuery.fx.speeds[opt.duration]
      : jQuery.fx.speeds._default;
    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    }
    opt.old = opt.complete;
    opt.complete = function () {
      if (jQuery.isFunction(opt.old)) {
        opt.old.call(this);
      }
      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };
    return opt;
  };
  jQuery.fn.extend({
    fadeTo: function (speed, to, easing, callback) {
      return this.filter(isHidden)
        .css("opacity", 0)
        .show()
        .end()
        .animate({ opacity: to }, speed, easing, callback);
    },
    animate: function (prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
        optall = jQuery.speed(speed, easing, callback),
        doAnimation = function () {
          var anim = Animation(this, jQuery.extend({}, prop), optall);
          if (empty || data_priv.get(this, "finish")) {
            anim.stop(true);
          }
        };
      doAnimation.finish = doAnimation;
      return empty || optall.queue === false
        ? this.each(doAnimation)
        : this.queue(optall.queue, doAnimation);
    },
    stop: function (type, clearQueue, gotoEnd) {
      var stopQueue = function (hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };
      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }
      if (clearQueue && type !== false) {
        this.queue(type || "fx", []);
      }
      return this.each(function () {
        var dequeue = true,
          index = type != null && type + "queueHooks",
          timers = jQuery.timers,
          data = data_priv.get(this);
        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }
        for (index = timers.length; index--; ) {
          if (
            timers[index].elem === this &&
            (type == null || timers[index].queue === type)
          ) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        }
        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function (type) {
      if (type !== false) {
        type = type || "fx";
      }
      return this.each(function () {
        var index,
          data = data_priv.get(this),
          queue = data[type + "queue"],
          hooks = data[type + "queueHooks"],
          timers = jQuery.timers,
          length = queue ? queue.length : 0;
        data.finish = true;
        jQuery.queue(this, type, []);
        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        }
        for (index = timers.length; index--; ) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        }
        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        }
        delete data.finish;
      });
    },
  });
  jQuery.each(["toggle", "show", "hide"], function (i, name) {
    var cssFn = jQuery.fn[name];
    jQuery.fn[name] = function (speed, easing, callback) {
      return speed == null || typeof speed === "boolean"
        ? cssFn.apply(this, arguments)
        : this.animate(genFx(name, true), speed, easing, callback);
    };
  });
  jQuery.each(
    {
      slideDown: genFx("show"),
      slideUp: genFx("hide"),
      slideToggle: genFx("toggle"),
      fadeIn: { opacity: "show" },
      fadeOut: { opacity: "hide" },
      fadeToggle: { opacity: "toggle" },
    },
    function (name, props) {
      jQuery.fn[name] = function (speed, easing, callback) {
        return this.animate(props, speed, easing, callback);
      };
    }
  );
  jQuery.timers = [];
  jQuery.fx.tick = function () {
    var timer,
      i = 0,
      timers = jQuery.timers;
    fxNow = jQuery.now();
    for (; i < timers.length; i++) {
      timer = timers[i];
      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }
    if (!timers.length) {
      jQuery.fx.stop();
    }
    fxNow = undefined;
  };
  jQuery.fx.timer = function (timer) {
    jQuery.timers.push(timer);
    if (timer()) {
      jQuery.fx.start();
    } else {
      jQuery.timers.pop();
    }
  };
  jQuery.fx.interval = 13;
  jQuery.fx.start = function () {
    if (!timerId) {
      timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
    }
  };
  jQuery.fx.stop = function () {
    clearInterval(timerId);
    timerId = null;
  };
  jQuery.fx.speeds = { slow: 600, fast: 200, _default: 400 };
  jQuery.fn.delay = function (time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || "fx";
    return this.queue(type, function (next, hooks) {
      var timeout = setTimeout(next, time);
      hooks.stop = function () {
        clearTimeout(timeout);
      };
    });
  };
  (function () {
    var input = document.createElement("input"),
      select = document.createElement("select"),
      opt = select.appendChild(document.createElement("option"));
    input.type = "checkbox";
    support.checkOn = input.value !== "";
    support.optSelected = opt.selected;
    select.disabled = true;
    support.optDisabled = !opt.disabled;
    input = document.createElement("input");
    input.value = "t";
    input.type = "radio";
    support.radioValue = input.value === "t";
  })();
  var nodeHook,
    boolHook,
    attrHandle = jQuery.expr.attrHandle;
  jQuery.fn.extend({
    attr: function (name, value) {
      return access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function (name) {
      return this.each(function () {
        jQuery.removeAttr(this, name);
      });
    },
  });
  jQuery.extend({
    attr: function (elem, name, value) {
      var hooks,
        ret,
        nType = elem.nodeType;
      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (typeof elem.getAttribute === strundefined) {
        return jQuery.prop(elem, name, value);
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = name.toLowerCase();
        hooks =
          jQuery.attrHooks[name] ||
          (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
      }
      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
        } else if (
          hooks &&
          "set" in hooks &&
          (ret = hooks.set(elem, value, name)) !== undefined
        ) {
          return ret;
        } else {
          elem.setAttribute(name, value + "");
          return value;
        }
      } else if (
        hooks &&
        "get" in hooks &&
        (ret = hooks.get(elem, name)) !== null
      ) {
        return ret;
      } else {
        ret = jQuery.find.attr(elem, name);
        return ret == null ? undefined : ret;
      }
    },
    removeAttr: function (elem, value) {
      var name,
        propName,
        i = 0,
        attrNames = value && value.match(rnotwhite);
      if (attrNames && elem.nodeType === 1) {
        while ((name = attrNames[i++])) {
          propName = jQuery.propFix[name] || name;
          if (jQuery.expr.match.bool.test(name)) {
            elem[propName] = false;
          }
          elem.removeAttribute(name);
        }
      }
    },
    attrHooks: {
      type: {
        set: function (elem, value) {
          if (
            !support.radioValue &&
            value === "radio" &&
            jQuery.nodeName(elem, "input")
          ) {
            var val = elem.value;
            elem.setAttribute("type", value);
            if (val) {
              elem.value = val;
            }
            return value;
          }
        },
      },
    },
  });
  boolHook = {
    set: function (elem, value, name) {
      if (value === false) {
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }
      return name;
    },
  };
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;
    attrHandle[name] = function (elem, name, isXML) {
      var ret, handle;
      if (!isXML) {
        handle = attrHandle[name];
        attrHandle[name] = ret;
        ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
        attrHandle[name] = handle;
      }
      return ret;
    };
  });
  var rfocusable = /^(?:input|select|textarea|button)$/i;
  jQuery.fn.extend({
    prop: function (name, value) {
      return access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function (name) {
      return this.each(function () {
        delete this[jQuery.propFix[name] || name];
      });
    },
  });
  jQuery.extend({
    propFix: { for: "htmlFor", class: "className" },
    prop: function (elem, name, value) {
      var ret,
        hooks,
        notxml,
        nType = elem.nodeType;
      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
      if (notxml) {
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }
      if (value !== undefined) {
        return hooks &&
          "set" in hooks &&
          (ret = hooks.set(elem, value, name)) !== undefined
          ? ret
          : (elem[name] = value);
      } else {
        return hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null
          ? ret
          : elem[name];
      }
    },
    propHooks: {
      tabIndex: {
        get: function (elem) {
          return elem.hasAttribute("tabindex") ||
            rfocusable.test(elem.nodeName) ||
            elem.href
            ? elem.tabIndex
            : -1;
        },
      },
    },
  });
  if (!support.optSelected) {
    jQuery.propHooks.selected = {
      get: function (elem) {
        var parent = elem.parentNode;
        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }
        return null;
      },
    };
  }
  jQuery.each(
    [
      "tabIndex",
      "readOnly",
      "maxLength",
      "cellSpacing",
      "cellPadding",
      "rowSpan",
      "colSpan",
      "useMap",
      "frameBorder",
      "contentEditable",
    ],
    function () {
      jQuery.propFix[this.toLowerCase()] = this;
    }
  );
  var rclass = /[\t\r\n\f]/g;
  jQuery.fn.extend({
    addClass: function (value) {
      var classes,
        elem,
        cur,
        clazz,
        j,
        finalValue,
        proceed = typeof value === "string" && value,
        i = 0,
        len = this.length;
      if (jQuery.isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).addClass(value.call(this, j, this.className));
        });
      }
      if (proceed) {
        classes = (value || "").match(rnotwhite) || [];
        for (; i < len; i++) {
          elem = this[i];
          cur =
            elem.nodeType === 1 &&
            (elem.className
              ? (" " + elem.className + " ").replace(rclass, " ")
              : " ");
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              if (cur.indexOf(" " + clazz + " ") < 0) {
                cur += clazz + " ";
              }
            }
            finalValue = jQuery.trim(cur);
            if (elem.className !== finalValue) {
              elem.className = finalValue;
            }
          }
        }
      }
      return this;
    },
    removeClass: function (value) {
      var classes,
        elem,
        cur,
        clazz,
        j,
        finalValue,
        proceed =
          arguments.length === 0 || (typeof value === "string" && value),
        i = 0,
        len = this.length;
      if (jQuery.isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).removeClass(value.call(this, j, this.className));
        });
      }
      if (proceed) {
        classes = (value || "").match(rnotwhite) || [];
        for (; i < len; i++) {
          elem = this[i];
          cur =
            elem.nodeType === 1 &&
            (elem.className
              ? (" " + elem.className + " ").replace(rclass, " ")
              : "");
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              while (cur.indexOf(" " + clazz + " ") >= 0) {
                cur = cur.replace(" " + clazz + " ", " ");
              }
            }
            finalValue = value ? jQuery.trim(cur) : "";
            if (elem.className !== finalValue) {
              elem.className = finalValue;
            }
          }
        }
      }
      return this;
    },
    toggleClass: function (value, stateVal) {
      var type = typeof value;
      if (typeof stateVal === "boolean" && type === "string") {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }
      if (jQuery.isFunction(value)) {
        return this.each(function (i) {
          jQuery(this).toggleClass(
            value.call(this, i, this.className, stateVal),
            stateVal
          );
        });
      }
      return this.each(function () {
        if (type === "string") {
          var className,
            i = 0,
            self = jQuery(this),
            classNames = value.match(rnotwhite) || [];
          while ((className = classNames[i++])) {
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          }
        } else if (type === strundefined || type === "boolean") {
          if (this.className) {
            data_priv.set(this, "__className__", this.className);
          }
          this.className =
            this.className || value === false
              ? ""
              : data_priv.get(this, "__className__") || "";
        }
      });
    },
    hasClass: function (selector) {
      var className = " " + selector + " ",
        i = 0,
        l = this.length;
      for (; i < l; i++) {
        if (
          this[i].nodeType === 1 &&
          (" " + this[i].className + " ")
            .replace(rclass, " ")
            .indexOf(className) >= 0
        ) {
          return true;
        }
      }
      return false;
    },
  });
  var rreturn = /\r/g;
  jQuery.fn.extend({
    val: function (value) {
      var hooks,
        ret,
        isFunction,
        elem = this[0];
      if (!arguments.length) {
        if (elem) {
          hooks =
            jQuery.valHooks[elem.type] ||
            jQuery.valHooks[elem.nodeName.toLowerCase()];
          if (
            hooks &&
            "get" in hooks &&
            (ret = hooks.get(elem, "value")) !== undefined
          ) {
            return ret;
          }
          ret = elem.value;
          return typeof ret === "string"
            ? ret.replace(rreturn, "")
            : ret == null
            ? ""
            : ret;
        }
        return;
      }
      isFunction = jQuery.isFunction(value);
      return this.each(function (i) {
        var val;
        if (this.nodeType !== 1) {
          return;
        }
        if (isFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        }
        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (jQuery.isArray(val)) {
          val = jQuery.map(val, function (value) {
            return value == null ? "" : value + "";
          });
        }
        hooks =
          jQuery.valHooks[this.type] ||
          jQuery.valHooks[this.nodeName.toLowerCase()];
        if (
          !hooks ||
          !("set" in hooks) ||
          hooks.set(this, val, "value") === undefined
        ) {
          this.value = val;
        }
      });
    },
  });
  jQuery.extend({
    valHooks: {
      option: {
        get: function (elem) {
          var val = jQuery.find.attr(elem, "value");
          return val != null ? val : jQuery.trim(jQuery.text(elem));
        },
      },
      select: {
        get: function (elem) {
          var value,
            option,
            options = elem.options,
            index = elem.selectedIndex,
            one = elem.type === "select-one" || index < 0,
            values = one ? null : [],
            max = one ? index + 1 : options.length,
            i = index < 0 ? max : one ? index : 0;
          for (; i < max; i++) {
            option = options[i];
            if (
              (option.selected || i === index) &&
              (support.optDisabled
                ? !option.disabled
                : option.getAttribute("disabled") === null) &&
              (!option.parentNode.disabled ||
                !jQuery.nodeName(option.parentNode, "optgroup"))
            ) {
              value = jQuery(option).val();
              if (one) {
                return value;
              }
              values.push(value);
            }
          }
          return values;
        },
        set: function (elem, value) {
          var optionSet,
            option,
            options = elem.options,
            values = jQuery.makeArray(value),
            i = options.length;
          while (i--) {
            option = options[i];
            if ((option.selected = jQuery.inArray(option.value, values) >= 0)) {
              optionSet = true;
            }
          }
          if (!optionSet) {
            elem.selectedIndex = -1;
          }
          return values;
        },
      },
    },
  });
  jQuery.each(["radio", "checkbox"], function () {
    jQuery.valHooks[this] = {
      set: function (elem, value) {
        if (jQuery.isArray(value)) {
          return (elem.checked =
            jQuery.inArray(jQuery(elem).val(), value) >= 0);
        }
      },
    };
    if (!support.checkOn) {
      jQuery.valHooks[this].get = function (elem) {
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  });
  jQuery.each(
    (
      "blur focus focusin focusout load resize scroll unload click dblclick " +
      "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
      "change select submit keydown keypress keyup error contextmenu"
    ).split(" "),
    function (i, name) {
      jQuery.fn[name] = function (data, fn) {
        return arguments.length > 0
          ? this.on(name, null, data, fn)
          : this.trigger(name);
      };
    }
  );
  jQuery.fn.extend({
    hover: function (fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    },
    bind: function (types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function (types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function (selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function (selector, types, fn) {
      return arguments.length === 1
        ? this.off(selector, "**")
        : this.off(types, selector || "**", fn);
    },
  });
  var nonce = jQuery.now();
  var rquery = /\?/;
  jQuery.parseJSON = function (data) {
    return JSON.parse(data + "");
  };
  jQuery.parseXML = function (data) {
    var xml, tmp;
    if (!data || typeof data !== "string") {
      return null;
    }
    try {
      tmp = new DOMParser();
      xml = tmp.parseFromString(data, "text/xml");
    } catch (e) {
      xml = undefined;
    }
    if (!xml || xml.getElementsByTagName("parsererror").length) {
      jQuery.error("Invalid XML: " + data);
    }
    return xml;
  };
  var rhash = /#.*$/,
    rts = /([?&])_=[^&]*/,
    rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm,
    rlocalProtocol =
      /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
    rnoContent = /^(?:GET|HEAD)$/,
    rprotocol = /^\/\//,
    rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
    prefilters = {},
    transports = {},
    allTypes = "*/".concat("*"),
    ajaxLocation = window.location.href,
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
  function addToPrefiltersOrTransports(structure) {
    return function (dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }
      var dataType,
        i = 0,
        dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
      if (jQuery.isFunction(func)) {
        while ((dataType = dataTypes[i++])) {
          if (dataType[0] === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func);
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  }
  function inspectPrefiltersOrTransports(
    structure,
    options,
    originalOptions,
    jqXHR
  ) {
    var inspected = {},
      seekingTransport = structure === transports;
    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(
          options,
          originalOptions,
          jqXHR
        );
        if (
          typeof dataTypeOrTransport === "string" &&
          !seekingTransport &&
          !inspected[dataTypeOrTransport]
        ) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }
    return inspect(options.dataTypes[0]) || (!inspected["*"] && inspect("*"));
  }
  function ajaxExtend(target, src) {
    var key,
      deep,
      flatOptions = jQuery.ajaxSettings.flatOptions || {};
    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
      }
    }
    if (deep) {
      jQuery.extend(true, target, deep);
    }
    return target;
  }
  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct,
      type,
      finalDataType,
      firstDataType,
      contents = s.contents,
      dataTypes = s.dataTypes;
    while (dataTypes[0] === "*") {
      dataTypes.shift();
      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    }
    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    }
    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }
        if (!firstDataType) {
          firstDataType = type;
        }
      }
      finalDataType = finalDataType || firstDataType;
    }
    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }
      return responses[finalDataType];
    }
  }
  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2,
      current,
      conv,
      tmp,
      prev,
      converters = {},
      dataTypes = s.dataTypes.slice();
    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }
    current = dataTypes.shift();
    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      }
      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }
      prev = current;
      current = dataTypes.shift();
      if (current) {
        if (current === "*") {
          current = prev;
        } else if (prev !== "*" && prev !== current) {
          conv = converters[prev + " " + current] || converters["* " + current];
          if (!conv) {
            for (conv2 in converters) {
              tmp = conv2.split(" ");
              if (tmp[1] === current) {
                conv =
                  converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                if (conv) {
                  if (conv === true) {
                    conv = converters[conv2];
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }
                  break;
                }
              }
            }
          }
          if (conv !== true) {
            if (conv && s["throws"]) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv
                    ? e
                    : "No conversion from " + prev + " to " + current,
                };
              }
            }
          }
        }
      }
    }
    return { state: "success", data: response };
  }
  jQuery.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: ajaxLocation,
      type: "GET",
      isLocal: rlocalProtocol.test(ajaxLocParts[1]),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript",
      },
      contents: { xml: /xml/, html: /html/, json: /json/ },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON",
      },
      converters: {
        "* text": String,
        "text html": true,
        "text json": jQuery.parseJSON,
        "text xml": jQuery.parseXML,
      },
      flatOptions: { url: true, context: true },
    },
    ajaxSetup: function (target, settings) {
      return settings
        ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings)
        : ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    ajax: function (url, options) {
      if (typeof url === "object") {
        options = url;
        url = undefined;
      }
      options = options || {};
      var transport,
        cacheURL,
        responseHeadersString,
        responseHeaders,
        timeoutTimer,
        parts,
        fireGlobals,
        i,
        s = jQuery.ajaxSetup({}, options),
        callbackContext = s.context || s,
        globalEventContext =
          s.context && (callbackContext.nodeType || callbackContext.jquery)
            ? jQuery(callbackContext)
            : jQuery.event,
        deferred = jQuery.Deferred(),
        completeDeferred = jQuery.Callbacks("once memory"),
        statusCode = s.statusCode || {},
        requestHeaders = {},
        requestHeadersNames = {},
        state = 0,
        strAbort = "canceled",
        jqXHR = {
          readyState: 0,
          getResponseHeader: function (key) {
            var match;
            if (state === 2) {
              if (!responseHeaders) {
                responseHeaders = {};
                while ((match = rheaders.exec(responseHeadersString))) {
                  responseHeaders[match[1].toLowerCase()] = match[2];
                }
              }
              match = responseHeaders[key.toLowerCase()];
            }
            return match == null ? null : match;
          },
          getAllResponseHeaders: function () {
            return state === 2 ? responseHeadersString : null;
          },
          setRequestHeader: function (name, value) {
            var lname = name.toLowerCase();
            if (!state) {
              name = requestHeadersNames[lname] =
                requestHeadersNames[lname] || name;
              requestHeaders[name] = value;
            }
            return this;
          },
          overrideMimeType: function (type) {
            if (!state) {
              s.mimeType = type;
            }
            return this;
          },
          statusCode: function (map) {
            var code;
            if (map) {
              if (state < 2) {
                for (code in map) {
                  statusCode[code] = [statusCode[code], map[code]];
                }
              } else {
                jqXHR.always(map[jqXHR.status]);
              }
            }
            return this;
          },
          abort: function (statusText) {
            var finalText = statusText || strAbort;
            if (transport) {
              transport.abort(finalText);
            }
            done(0, finalText);
            return this;
          },
        };
      deferred.promise(jqXHR).complete = completeDeferred.add;
      jqXHR.success = jqXHR.done;
      jqXHR.error = jqXHR.fail;
      s.url = ((url || s.url || ajaxLocation) + "")
        .replace(rhash, "")
        .replace(rprotocol, ajaxLocParts[1] + "//");
      s.type = options.method || options.type || s.method || s.type;
      s.dataTypes = jQuery
        .trim(s.dataType || "*")
        .toLowerCase()
        .match(rnotwhite) || [""];
      if (s.crossDomain == null) {
        parts = rurl.exec(s.url.toLowerCase());
        s.crossDomain = !!(
          parts &&
          (parts[1] !== ajaxLocParts[1] ||
            parts[2] !== ajaxLocParts[2] ||
            (parts[3] || (parts[1] === "http:" ? "80" : "443")) !==
              (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443")))
        );
      }
      if (s.data && s.processData && typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      }
      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
      if (state === 2) {
        return jqXHR;
      }
      fireGlobals = jQuery.event && s.global;
      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      }
      s.type = s.type.toUpperCase();
      s.hasContent = !rnoContent.test(s.type);
      cacheURL = s.url;
      if (!s.hasContent) {
        if (s.data) {
          cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data;
          delete s.data;
        }
        if (s.cache === false) {
          s.url = rts.test(cacheURL)
            ? cacheURL.replace(rts, "$1_=" + nonce++)
            : cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
        }
      }
      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader(
            "If-Modified-Since",
            jQuery.lastModified[cacheURL]
          );
        }
        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
        }
      }
      if (
        (s.data && s.hasContent && s.contentType !== false) ||
        options.contentType
      ) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      }
      jqXHR.setRequestHeader(
        "Accept",
        s.dataTypes[0] && s.accepts[s.dataTypes[0]]
          ? s.accepts[s.dataTypes[0]] +
              (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "")
          : s.accepts["*"]
      );
      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      }
      if (
        s.beforeSend &&
        (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)
      ) {
        return jqXHR.abort();
      }
      strAbort = "abort";
      for (i in { success: 1, error: 1, complete: 1 }) {
        jqXHR[i](s[i]);
      }
      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1;
        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        }
        if (s.async && s.timeout > 0) {
          timeoutTimer = setTimeout(function () {
            jqXHR.abort("timeout");
          }, s.timeout);
        }
        try {
          state = 1;
          transport.send(requestHeaders, done);
        } catch (e) {
          if (state < 2) {
            done(-1, e);
          } else {
            throw e;
          }
        }
      }
      function done(status, nativeStatusText, responses, headers) {
        var isSuccess,
          success,
          error,
          response,
          modified,
          statusText = nativeStatusText;
        if (state === 2) {
          return;
        }
        state = 2;
        if (timeoutTimer) {
          clearTimeout(timeoutTimer);
        }
        transport = undefined;
        responseHeadersString = headers || "";
        jqXHR.readyState = status > 0 ? 4 : 0;
        isSuccess = (status >= 200 && status < 300) || status === 304;
        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        }
        response = ajaxConvert(s, response, jqXHR, isSuccess);
        if (isSuccess) {
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");
            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }
            modified = jqXHR.getResponseHeader("etag");
            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          }
          if (status === 204 || s.type === "HEAD") {
            statusText = "nocontent";
          } else if (status === 304) {
            statusText = "notmodified";
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          error = statusText;
          if (status || !statusText) {
            statusText = "error";
            if (status < 0) {
              status = 0;
            }
          }
        }
        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + "";
        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        }
        jqXHR.statusCode(statusCode);
        statusCode = undefined;
        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [
            jqXHR,
            s,
            isSuccess ? success : error,
          ]);
        }
        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
          if (!--jQuery.active) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      }
      return jqXHR;
    },
    getJSON: function (url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },
    getScript: function (url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    },
  });
  jQuery.each(["get", "post"], function (i, method) {
    jQuery[method] = function (url, data, callback, type) {
      if (jQuery.isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }
      return jQuery.ajax({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback,
      });
    };
  });
  jQuery._evalUrl = function (url) {
    return jQuery.ajax({
      url: url,
      type: "GET",
      dataType: "script",
      async: false,
      global: false,
      throws: true,
    });
  };
  jQuery.fn.extend({
    wrapAll: function (html) {
      var wrap;
      if (jQuery.isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapAll(html.call(this, i));
        });
      }
      if (this[0]) {
        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }
        wrap
          .map(function () {
            var elem = this;
            while (elem.firstElementChild) {
              elem = elem.firstElementChild;
            }
            return elem;
          })
          .append(this);
      }
      return this;
    },
    wrapInner: function (html) {
      if (jQuery.isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }
      return this.each(function () {
        var self = jQuery(this),
          contents = self.contents();
        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function (html) {
      var isFunction = jQuery.isFunction(html);
      return this.each(function (i) {
        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function () {
      return this.parent()
        .each(function () {
          if (!jQuery.nodeName(this, "body")) {
            jQuery(this).replaceWith(this.childNodes);
          }
        })
        .end();
    },
  });
  jQuery.expr.filters.hidden = function (elem) {
    return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
  };
  jQuery.expr.filters.visible = function (elem) {
    return !jQuery.expr.filters.hidden(elem);
  };
  var r20 = /%20/g,
    rbracket = /\[\]$/,
    rCRLF = /\r?\n/g,
    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
    rsubmittable = /^(?:input|select|textarea|keygen)/i;
  function buildParams(prefix, obj, traditional, add) {
    var name;
    if (jQuery.isArray(obj)) {
      jQuery.each(obj, function (i, v) {
        if (traditional || rbracket.test(prefix)) {
          add(prefix, v);
        } else {
          buildParams(
            prefix + "[" + (typeof v === "object" ? i : "") + "]",
            v,
            traditional,
            add
          );
        }
      });
    } else if (!traditional && jQuery.type(obj) === "object") {
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      add(prefix, obj);
    }
  }
  jQuery.param = function (a, traditional) {
    var prefix,
      s = [],
      add = function (key, value) {
        value = jQuery.isFunction(value) ? value() : value == null ? "" : value;
        s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
      };
    if (traditional === undefined) {
      traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    }
    if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
      jQuery.each(a, function () {
        add(this.name, this.value);
      });
    } else {
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    }
    return s.join("&").replace(r20, "+");
  };
  jQuery.fn.extend({
    serialize: function () {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function () {
      return this.map(function () {
        var elements = jQuery.prop(this, "elements");
        return elements ? jQuery.makeArray(elements) : this;
      })
        .filter(function () {
          var type = this.type;
          return (
            this.name &&
            !jQuery(this).is(":disabled") &&
            rsubmittable.test(this.nodeName) &&
            !rsubmitterTypes.test(type) &&
            (this.checked || !rcheckableType.test(type))
          );
        })
        .map(function (i, elem) {
          var val = jQuery(this).val();
          return val == null
            ? null
            : jQuery.isArray(val)
            ? jQuery.map(val, function (val) {
                return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
              })
            : { name: elem.name, value: val.replace(rCRLF, "\r\n") };
        })
        .get();
    },
  });
  jQuery.ajaxSettings.xhr = function () {
    try {
      return new XMLHttpRequest();
    } catch (e) {}
  };
  var xhrId = 0,
    xhrCallbacks = {},
    xhrSuccessStatus = { 0: 200, 1223: 204 },
    xhrSupported = jQuery.ajaxSettings.xhr();
  if (window.attachEvent) {
    window.attachEvent("onunload", function () {
      for (var key in xhrCallbacks) {
        xhrCallbacks[key]();
      }
    });
  }
  support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
  support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function (options) {
    var callback;
    if (support.cors || (xhrSupported && !options.crossDomain)) {
      return {
        send: function (headers, complete) {
          var i,
            xhr = options.xhr(),
            id = ++xhrId;
          xhr.open(
            options.type,
            options.url,
            options.async,
            options.username,
            options.password
          );
          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          }
          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          }
          if (!options.crossDomain && !headers["X-Requested-With"]) {
            headers["X-Requested-With"] = "XMLHttpRequest";
          }
          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          }
          callback = function (type) {
            return function () {
              if (callback) {
                delete xhrCallbacks[id];
                callback = xhr.onload = xhr.onerror = null;
                if (type === "abort") {
                  xhr.abort();
                } else if (type === "error") {
                  complete(xhr.status, xhr.statusText);
                } else {
                  complete(
                    xhrSuccessStatus[xhr.status] || xhr.status,
                    xhr.statusText,
                    typeof xhr.responseText === "string"
                      ? { text: xhr.responseText }
                      : undefined,
                    xhr.getAllResponseHeaders()
                  );
                }
              }
            };
          };
          xhr.onload = callback();
          xhr.onerror = callback("error");
          callback = xhrCallbacks[id] = callback("abort");
          try {
            xhr.send((options.hasContent && options.data) || null);
          } catch (e) {
            if (callback) {
              throw e;
            }
          }
        },
        abort: function () {
          if (callback) {
            callback();
          }
        },
      };
    }
  });
  jQuery.ajaxSetup({
    accepts: {
      script:
        "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript",
    },
    contents: { script: /(?:java|ecma)script/ },
    converters: {
      "text script": function (text) {
        jQuery.globalEval(text);
        return text;
      },
    },
  });
  jQuery.ajaxPrefilter("script", function (s) {
    if (s.cache === undefined) {
      s.cache = false;
    }
    if (s.crossDomain) {
      s.type = "GET";
    }
  });
  jQuery.ajaxTransport("script", function (s) {
    if (s.crossDomain) {
      var script, callback;
      return {
        send: function (_, complete) {
          script = jQuery("<script>")
            .prop({ async: true, charset: s.scriptCharset, src: s.url })
            .on(
              "load error",
              (callback = function (evt) {
                script.remove();
                callback = null;
                if (evt) {
                  complete(evt.type === "error" ? 404 : 200, evt.type);
                }
              })
            );
          document.head.appendChild(script[0]);
        },
        abort: function () {
          if (callback) {
            callback();
          }
        },
      };
    }
  });
  var oldCallbacks = [],
    rjsonp = /(=)\?(?=&|$)|\?\?/;
  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function () {
      var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
      this[callback] = true;
      return callback;
    },
  });
  jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
    var callbackName,
      overwritten,
      responseContainer,
      jsonProp =
        s.jsonp !== false &&
        (rjsonp.test(s.url)
          ? "url"
          : typeof s.data === "string" &&
            !(s.contentType || "").indexOf(
              "application/x-www-form-urlencoded"
            ) &&
            rjsonp.test(s.data) &&
            "data");
    if (jsonProp || s.dataTypes[0] === "jsonp") {
      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback)
        ? s.jsonpCallback()
        : s.jsonpCallback;
      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if (s.jsonp !== false) {
        s.url +=
          (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      }
      s.converters["script json"] = function () {
        if (!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }
        return responseContainer[0];
      };
      s.dataTypes[0] = "json";
      overwritten = window[callbackName];
      window[callbackName] = function () {
        responseContainer = arguments;
      };
      jqXHR.always(function () {
        window[callbackName] = overwritten;
        if (s[callbackName]) {
          s.jsonpCallback = originalSettings.jsonpCallback;
          oldCallbacks.push(callbackName);
        }
        if (responseContainer && jQuery.isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }
        responseContainer = overwritten = undefined;
      });
      return "script";
    }
  });
  jQuery.parseHTML = function (data, context, keepScripts) {
    if (!data || typeof data !== "string") {
      return null;
    }
    if (typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }
    context = context || document;
    var parsed = rsingleTag.exec(data),
      scripts = !keepScripts && [];
    if (parsed) {
      return [context.createElement(parsed[1])];
    }
    parsed = jQuery.buildFragment([data], context, scripts);
    if (scripts && scripts.length) {
      jQuery(scripts).remove();
    }
    return jQuery.merge([], parsed.childNodes);
  };
  var _load = jQuery.fn.load;
  jQuery.fn.load = function (url, params, callback) {
    if (typeof url !== "string" && _load) {
      return _load.apply(this, arguments);
    }
    var selector,
      type,
      response,
      self = this,
      off = url.indexOf(" ");
    if (off >= 0) {
      selector = jQuery.trim(url.slice(off));
      url = url.slice(0, off);
    }
    if (jQuery.isFunction(params)) {
      callback = params;
      params = undefined;
    } else if (params && typeof params === "object") {
      type = "POST";
    }
    if (self.length > 0) {
      jQuery
        .ajax({ url: url, type: type, dataType: "html", data: params })
        .done(function (responseText) {
          response = arguments;
          self.html(
            selector
              ? jQuery("<div>")
                  .append(jQuery.parseHTML(responseText))
                  .find(selector)
              : responseText
          );
        })
        .complete(
          callback &&
            function (jqXHR, status) {
              self.each(
                callback,
                response || [jqXHR.responseText, status, jqXHR]
              );
            }
        );
    }
    return this;
  };
  jQuery.each(
    [
      "ajaxStart",
      "ajaxStop",
      "ajaxComplete",
      "ajaxError",
      "ajaxSuccess",
      "ajaxSend",
    ],
    function (i, type) {
      jQuery.fn[type] = function (fn) {
        return this.on(type, fn);
      };
    }
  );
  jQuery.expr.filters.animated = function (elem) {
    return jQuery.grep(jQuery.timers, function (fn) {
      return elem === fn.elem;
    }).length;
  };
  var docElem = window.document.documentElement;
  function getWindow(elem) {
    return jQuery.isWindow(elem)
      ? elem
      : elem.nodeType === 9 && elem.defaultView;
  }
  jQuery.offset = {
    setOffset: function (elem, options, i) {
      var curPosition,
        curLeft,
        curCSSTop,
        curTop,
        curOffset,
        curCSSLeft,
        calculatePosition,
        position = jQuery.css(elem, "position"),
        curElem = jQuery(elem),
        props = {};
      if (position === "static") {
        elem.style.position = "relative";
      }
      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, "top");
      curCSSLeft = jQuery.css(elem, "left");
      calculatePosition =
        (position === "absolute" || position === "fixed") &&
        (curCSSTop + curCSSLeft).indexOf("auto") > -1;
      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }
      if (jQuery.isFunction(options)) {
        options = options.call(elem, i, curOffset);
      }
      if (options.top != null) {
        props.top = options.top - curOffset.top + curTop;
      }
      if (options.left != null) {
        props.left = options.left - curOffset.left + curLeft;
      }
      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    },
  };
  jQuery.fn.extend({
    offset: function (options) {
      if (arguments.length) {
        return options === undefined
          ? this
          : this.each(function (i) {
              jQuery.offset.setOffset(this, options, i);
            });
      }
      var docElem,
        win,
        elem = this[0],
        box = { top: 0, left: 0 },
        doc = elem && elem.ownerDocument;
      if (!doc) {
        return;
      }
      docElem = doc.documentElement;
      if (!jQuery.contains(docElem, elem)) {
        return box;
      }
      if (typeof elem.getBoundingClientRect !== strundefined) {
        box = elem.getBoundingClientRect();
      }
      win = getWindow(doc);
      return {
        top: box.top + win.pageYOffset - docElem.clientTop,
        left: box.left + win.pageXOffset - docElem.clientLeft,
      };
    },
    position: function () {
      if (!this[0]) {
        return;
      }
      var offsetParent,
        offset,
        elem = this[0],
        parentOffset = { top: 0, left: 0 };
      if (jQuery.css(elem, "position") === "fixed") {
        offset = elem.getBoundingClientRect();
      } else {
        offsetParent = this.offsetParent();
        offset = this.offset();
        if (!jQuery.nodeName(offsetParent[0], "html")) {
          parentOffset = offsetParent.offset();
        }
        parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
        parentOffset.left += jQuery.css(
          offsetParent[0],
          "borderLeftWidth",
          true
        );
      }
      return {
        top:
          offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
        left:
          offset.left -
          parentOffset.left -
          jQuery.css(elem, "marginLeft", true),
      };
    },
    offsetParent: function () {
      return this.map(function () {
        var offsetParent = this.offsetParent || docElem;
        while (
          offsetParent &&
          !jQuery.nodeName(offsetParent, "html") &&
          jQuery.css(offsetParent, "position") === "static"
        ) {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || docElem;
      });
    },
  });
  jQuery.each(
    { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" },
    function (method, prop) {
      var top = "pageYOffset" === prop;
      jQuery.fn[method] = function (val) {
        return access(
          this,
          function (elem, method, val) {
            var win = getWindow(elem);
            if (val === undefined) {
              return win ? win[prop] : elem[method];
            }
            if (win) {
              win.scrollTo(
                !top ? val : window.pageXOffset,
                top ? val : window.pageYOffset
              );
            } else {
              elem[method] = val;
            }
          },
          method,
          val,
          arguments.length,
          null
        );
      };
    }
  );
  jQuery.each(["top", "left"], function (i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(
      support.pixelPosition,
      function (elem, computed) {
        if (computed) {
          computed = curCSS(elem, prop);
          return rnumnonpx.test(computed)
            ? jQuery(elem).position()[prop] + "px"
            : computed;
        }
      }
    );
  });
  jQuery.each({ Height: "height", Width: "width" }, function (name, type) {
    jQuery.each(
      { padding: "inner" + name, content: type, "": "outer" + name },
      function (defaultExtra, funcName) {
        jQuery.fn[funcName] = function (margin, value) {
          var chainable =
              arguments.length && (defaultExtra || typeof margin !== "boolean"),
            extra =
              defaultExtra ||
              (margin === true || value === true ? "margin" : "border");
          return access(
            this,
            function (elem, type, value) {
              var doc;
              if (jQuery.isWindow(elem)) {
                return elem.document.documentElement["client" + name];
              }
              if (elem.nodeType === 9) {
                doc = elem.documentElement;
                return Math.max(
                  elem.body["scroll" + name],
                  doc["scroll" + name],
                  elem.body["offset" + name],
                  doc["offset" + name],
                  doc["client" + name]
                );
              }
              return value === undefined
                ? jQuery.css(elem, type, extra)
                : jQuery.style(elem, type, value, extra);
            },
            type,
            chainable ? margin : undefined,
            chainable,
            null
          );
        };
      }
    );
  });
  jQuery.fn.size = function () {
    return this.length;
  };
  jQuery.fn.andSelf = jQuery.fn.addBack;
  if (typeof define === "function" && define.amd) {
    define("jquery", [], function () {
      return jQuery;
    });
  }
  var _jQuery = window.jQuery,
    _$ = window.$;
  jQuery.noConflict = function (deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }
    if (deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }
    return jQuery;
  };
  if (typeof noGlobal === strundefined) {
    window.jQuery = window.$ = jQuery;
  }
  return jQuery;
});
(function ($) {
  var Base64 = (function () {
    var keyStr =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var obj = {
      encode: function (input) {
        var output = "";
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i = 0;
        do {
          chr1 = input.charCodeAt(i++);
          chr2 = input.charCodeAt(i++);
          chr3 = input.charCodeAt(i++);
          enc1 = chr1 >> 2;
          enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
          enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
          enc4 = chr3 & 63;
          if (isNaN(chr2)) {
            enc3 = enc4 = 64;
          } else if (isNaN(chr3)) {
            enc4 = 64;
          }
          output =
            output +
            keyStr.charAt(enc1) +
            keyStr.charAt(enc2) +
            keyStr.charAt(enc3) +
            keyStr.charAt(enc4);
        } while (i < input.length);
        return output;
      },
      decode: function (input) {
        var output = "";
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i = 0;
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        do {
          enc1 = keyStr.indexOf(input.charAt(i++));
          enc2 = keyStr.indexOf(input.charAt(i++));
          enc3 = keyStr.indexOf(input.charAt(i++));
          enc4 = keyStr.indexOf(input.charAt(i++));
          chr1 = (enc1 << 2) | (enc2 >> 4);
          chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
          chr3 = ((enc3 & 3) << 6) | enc4;
          output = output + String.fromCharCode(chr1);
          if (enc3 != 64) {
            output = output + String.fromCharCode(chr2);
          }
          if (enc4 != 64) {
            output = output + String.fromCharCode(chr3);
          }
        } while (i < input.length);
        return output;
      },
    };
    return obj;
  })();
  var MD5 = (function () {
    var hexcase = 0;
    var b64pad = "";
    var chrsz = 8;
    var safe_add = function (x, y) {
      var lsw = (x & 65535) + (y & 65535);
      var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
      return (msw << 16) | (lsw & 65535);
    };
    var bit_rol = function (num, cnt) {
      return (num << cnt) | (num >>> (32 - cnt));
    };
    var str2binl = function (str) {
      var bin = [];
      var mask = (1 << chrsz) - 1;
      for (var i = 0; i < str.length * chrsz; i += chrsz) {
        bin[i >> 5] |= (str.charCodeAt(i / chrsz) & mask) << i % 32;
      }
      return bin;
    };
    var binl2str = function (bin) {
      var str = "";
      var mask = (1 << chrsz) - 1;
      for (var i = 0; i < bin.length * 32; i += chrsz) {
        str += String.fromCharCode((bin[i >> 5] >>> i % 32) & mask);
      }
      return str;
    };
    var binl2hex = function (binarray) {
      var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
      var str = "";
      for (var i = 0; i < binarray.length * 4; i++) {
        str +=
          hex_tab.charAt((binarray[i >> 2] >> ((i % 4) * 8 + 4)) & 15) +
          hex_tab.charAt((binarray[i >> 2] >> ((i % 4) * 8)) & 15);
      }
      return str;
    };
    var binl2b64 = function (binarray) {
      var tab =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var str = "";
      var triplet, j;
      for (var i = 0; i < binarray.length * 4; i += 3) {
        triplet =
          (((binarray[i >> 2] >> (8 * (i % 4))) & 255) << 16) |
          (((binarray[(i + 1) >> 2] >> (8 * ((i + 1) % 4))) & 255) << 8) |
          ((binarray[(i + 2) >> 2] >> (8 * ((i + 2) % 4))) & 255);
        for (j = 0; j < 4; j++) {
          if (i * 8 + j * 6 > binarray.length * 32) {
            str += b64pad;
          } else {
            str += tab.charAt((triplet >> (6 * (3 - j))) & 63);
          }
        }
      }
      return str;
    };
    var md5_cmn = function (q, a, b, x, s, t) {
      return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
    };
    var md5_ff = function (a, b, c, d, x, s, t) {
      return md5_cmn((b & c) | (~b & d), a, b, x, s, t);
    };
    var md5_gg = function (a, b, c, d, x, s, t) {
      return md5_cmn((b & d) | (c & ~d), a, b, x, s, t);
    };
    var md5_hh = function (a, b, c, d, x, s, t) {
      return md5_cmn(b ^ c ^ d, a, b, x, s, t);
    };
    var md5_ii = function (a, b, c, d, x, s, t) {
      return md5_cmn(c ^ (b | ~d), a, b, x, s, t);
    };
    var core_md5 = function (x, len) {
      x[len >> 5] |= 128 << len % 32;
      x[(((len + 64) >>> 9) << 4) + 14] = len;
      var a = 1732584193;
      var b = -271733879;
      var c = -1732584194;
      var d = 271733878;
      var olda, oldb, oldc, oldd;
      for (var i = 0; i < x.length; i += 16) {
        olda = a;
        oldb = b;
        oldc = c;
        oldd = d;
        a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
        d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
        b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);
        a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
        a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);
        a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
        d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
        c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);
        a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
        d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);
        a = safe_add(a, olda);
        b = safe_add(b, oldb);
        c = safe_add(c, oldc);
        d = safe_add(d, oldd);
      }
      return [a, b, c, d];
    };
    var core_hmac_md5 = function (key, data) {
      var bkey = str2binl(key);
      if (bkey.length > 16) {
        bkey = core_md5(bkey, key.length * chrsz);
      }
      var ipad = new Array(16),
        opad = new Array(16);
      for (var i = 0; i < 16; i++) {
        ipad[i] = bkey[i] ^ 909522486;
        opad[i] = bkey[i] ^ 1549556828;
      }
      var hash = core_md5(
        ipad.concat(str2binl(data)),
        512 + data.length * chrsz
      );
      return core_md5(opad.concat(hash), 512 + 128);
    };
    var obj = {
      hexdigest: function (s) {
        return binl2hex(core_md5(str2binl(s), s.length * chrsz));
      },
      b64digest: function (s) {
        return binl2b64(core_md5(str2binl(s), s.length * chrsz));
      },
      hash: function (s) {
        return binl2str(core_md5(str2binl(s), s.length * chrsz));
      },
      hmac_hexdigest: function (key, data) {
        return binl2hex(core_hmac_md5(key, data));
      },
      hmac_b64digest: function (key, data) {
        return binl2b64(core_hmac_md5(key, data));
      },
      hmac_hash: function (key, data) {
        return binl2str(core_hmac_md5(key, data));
      },
      test: function () {
        return MD5.hexdigest("abc") === "900150983cd24fb0d6963f7d28e17f72";
      },
    };
    return obj;
  })();
  if (!Function.prototype.bind) {
    Function.prototype.bind = function (obj) {
      var func = this;
      return function () {
        return func.apply(obj, arguments);
      };
    };
  }
  if (!Function.prototype.prependArg) {
    Function.prototype.prependArg = function (arg) {
      var func = this;
      return function () {
        var newargs = [arg];
        for (var i = 0; i < arguments.length; i++) {
          newargs.push(arguments[i]);
        }
        return func.apply(this, newargs);
      };
    };
  }
  if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function (elt) {
      var len = this.length;
      var from = Number(arguments[1]) || 0;
      from = from < 0 ? Math.ceil(from) : Math.floor(from);
      if (from < 0) {
        from += len;
      }
      for (; from < len; from++) {
        if (from in this && this[from] === elt) {
          return from;
        }
      }
      return -1;
    };
  }
  (function (callback) {
    var Strophe;
    function $build(name, attrs) {
      return new Strophe.Builder(name, attrs);
    }
    function $msg(attrs) {
      return new Strophe.Builder("message", attrs);
    }
    function $iq(attrs) {
      return new Strophe.Builder("iq", attrs);
    }
    function $pres(attrs) {
      return new Strophe.Builder("presence", attrs);
    }
    Strophe = {
      VERSION: "1.0.1",
      NS: {
        HTTPBIND: "http://jabber.org/protocol/httpbind",
        BOSH: "urn:xmpp:xbosh",
        CLIENT: "jabber:client",
        AUTH: "jabber:iq:auth",
        ROSTER: "jabber:iq:roster",
        PROFILE: "jabber:iq:profile",
        DISCO_INFO: "http://jabber.org/protocol/disco#info",
        DISCO_ITEMS: "http://jabber.org/protocol/disco#items",
        MUC: "http://jabber.org/protocol/muc",
        SASL: "urn:ietf:params:xml:ns:xmpp-sasl",
        STREAM: "http://etherx.jabber.org/streams",
        BIND: "urn:ietf:params:xml:ns:xmpp-bind",
        SESSION: "urn:ietf:params:xml:ns:xmpp-session",
        VERSION: "jabber:iq:version",
        STANZAS: "urn:ietf:params:xml:ns:xmpp-stanzas",
      },
      addNamespace: function (name, value) {
        Strophe.NS[name] = value;
      },
      Status: {
        ERROR: 0,
        CONNECTING: 1,
        CONNFAIL: 2,
        AUTHENTICATING: 3,
        AUTHFAIL: 4,
        CONNECTED: 5,
        DISCONNECTED: 6,
        DISCONNECTING: 7,
        ATTACHED: 8,
      },
      LogLevel: { DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3, FATAL: 4 },
      ElementType: { NORMAL: 1, TEXT: 3 },
      TIMEOUT: 1.1,
      SECONDARY_TIMEOUT: 0.1,
      forEachChild: function (elem, elemName, func) {
        var i, childNode;
        for (i = 0; i < elem.childNodes.length; i++) {
          childNode = elem.childNodes[i];
          if (
            childNode.nodeType == Strophe.ElementType.NORMAL &&
            (!elemName || this.isTagEqual(childNode, elemName))
          ) {
            func(childNode);
          }
        }
      },
      isTagEqual: function (el, name) {
        return el.tagName.toLowerCase() == name.toLowerCase();
      },
      _xmlGenerator: null,
      _makeGenerator: function () {
        var doc;
        if (window.ActiveXObject) {
          doc = new ActiveXObject("Microsoft.XMLDOM");
          doc.appendChild(doc.createElement("strophe"));
        } else {
          doc = document.implementation.createDocument(
            "jabber:client",
            "strophe",
            null
          );
        }
        return doc;
      },
      xmlElement: function (name) {
        if (!name) {
          return null;
        }
        var node = null;
        if (!Strophe._xmlGenerator) {
          Strophe._xmlGenerator = Strophe._makeGenerator();
        }
        node = Strophe._xmlGenerator.createElement(name);
        var a, i, k;
        for (a = 1; a < arguments.length; a++) {
          if (!arguments[a]) {
            continue;
          }
          if (
            typeof arguments[a] == "string" ||
            typeof arguments[a] == "number"
          ) {
            node.appendChild(Strophe.xmlTextNode(arguments[a]));
          } else if (
            typeof arguments[a] == "object" &&
            typeof arguments[a].sort == "function"
          ) {
            for (i = 0; i < arguments[a].length; i++) {
              if (
                typeof arguments[a][i] == "object" &&
                typeof arguments[a][i].sort == "function"
              ) {
                node.setAttribute(arguments[a][i][0], arguments[a][i][1]);
              }
            }
          } else if (typeof arguments[a] == "object") {
            for (k in arguments[a]) {
              if (arguments[a].hasOwnProperty(k)) {
                node.setAttribute(k, arguments[a][k]);
              }
            }
          }
        }
        return node;
      },
      xmlescape: function (text) {
        if (!text) return "";
        if (text.constructor != Array) {
          text = text
            .replace(/\&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;");
        } else {
          for (var i = 0; i < text.length; i++) {
            text[i] = text[i]
              .replace(/\&/g, "&amp;")
              .replace(/</g, "&lt;")
              .replace(/>/g, "&gt;");
          }
        }
        return text;
      },
      xmlTextNode: function (text) {
        text = Strophe.xmlescape(text);
        if (!Strophe._xmlGenerator) {
          Strophe._xmlGenerator = Strophe._makeGenerator();
        }
        return Strophe._xmlGenerator.createTextNode(text);
      },
      getText: function (elem) {
        if (!elem) {
          return null;
        }
        var str = "";
        if (
          elem.childNodes.length === 0 &&
          elem.nodeType == Strophe.ElementType.TEXT
        ) {
          str += elem.nodeValue;
        }
        for (var i = 0; i < elem.childNodes.length; i++) {
          if (elem.childNodes[i].nodeType == Strophe.ElementType.TEXT) {
            str += elem.childNodes[i].nodeValue;
          }
        }
        return str;
      },
      copyElement: function (elem) {
        var i, el;
        if (elem.nodeType == Strophe.ElementType.NORMAL) {
          el = Strophe.xmlElement(elem.tagName);
          for (i = 0; i < elem.attributes.length; i++) {
            el.setAttribute(
              elem.attributes[i].nodeName.toLowerCase(),
              elem.attributes[i].value
            );
          }
          for (i = 0; i < elem.childNodes.length; i++) {
            el.appendChild(Strophe.copyElement(elem.childNodes[i]));
          }
        } else if (elem.nodeType == Strophe.ElementType.TEXT) {
          el = Strophe.xmlTextNode(elem.nodeValue);
        }
        return el;
      },
      escapeNode: function (node) {
        return node
          .replace(/^\s+|\s+$/g, "")
          .replace(/\\/g, "\\5c")
          .replace(/ /g, "\\20")
          .replace(/\"/g, "\\22")
          .replace(/\&/g, "\\26")
          .replace(/\'/g, "\\27")
          .replace(/\//g, "\\2f")
          .replace(/:/g, "\\3a")
          .replace(/</g, "\\3c")
          .replace(/>/g, "\\3e")
          .replace(/@/g, "\\40");
      },
      unescapeNode: function (node) {
        return node
          .replace(/\\20/g, " ")
          .replace(/\\22/g, '"')
          .replace(/\\26/g, "&")
          .replace(/\\27/g, "'")
          .replace(/\\2f/g, "/")
          .replace(/\\3a/g, ":")
          .replace(/\\3c/g, "<")
          .replace(/\\3e/g, ">")
          .replace(/\\40/g, "@")
          .replace(/\\5c/g, "\\");
      },
      getNodeFromJid: function (jid) {
        if (jid.indexOf("@") < 0) {
          return null;
        }
        return jid.split("@")[0];
      },
      getDomainFromJid: function (jid) {
        var bare = Strophe.getBareJidFromJid(jid);
        if (bare.indexOf("@") < 0) {
          return bare;
        } else {
          var parts = bare.split("@");
          parts.splice(0, 1);
          return parts.join("@");
        }
      },
      getResourceFromJid: function (jid) {
        var s = jid.split("/");
        if (s.length < 2) {
          return null;
        }
        s.splice(0, 1);
        return s.join("/");
      },
      getBareJidFromJid: function (jid) {
        return jid.split("/")[0];
      },
      log: function(){}